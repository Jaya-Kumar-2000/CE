(function (global, factory) {if (typeof define === "function" && define.amd) {define([], factory);} else if (typeof exports !== "undefined") {factory();} else {var mod = { exports: {} };factory();global.zc = mod.exports;}})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function () {"use strict";function _regeneratorRuntime() {"use strict";
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime = function _regeneratorRuntime() {return exports;};var exports = {},Op = Object.prototype,hasOwn = Op.hasOwnProperty,defineProperty = Object.defineProperty || function (obj, key, desc) {obj[key] = desc.value;},$Symbol = "function" == typeof Symbol ? Symbol : {},iteratorSymbol = $Symbol.iterator || "@@iterator",asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";function define(obj, key, value) {return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key];}try {define({}, "");} catch (err) {define = function define(obj, key, value) {return obj[key] = value;};}function wrap(innerFn, outerFn, self, tryLocsList) {var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,generator = Object.create(protoGenerator.prototype),context = new Context(tryLocsList || []);return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator;}function tryCatch(fn, obj, arg) {try {return { type: "normal", arg: fn.call(obj, arg) };} catch (err) {return { type: "throw", arg: err };}}exports.wrap = wrap;var ContinueSentinel = {};function Generator() {}function GeneratorFunction() {}function GeneratorFunctionPrototype() {}var IteratorPrototype = {};define(IteratorPrototype, iteratorSymbol, function () {return this;});var getProto = Object.getPrototypeOf,NativeIteratorPrototype = getProto && getProto(getProto(values([])));NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);function defineIteratorMethods(prototype) {["next", "throw", "return"].forEach(function (method) {define(prototype, method, function (arg) {return this._invoke(method, arg);});});}function AsyncIterator(generator, PromiseImpl) {function invoke(method, arg, resolve, reject) {var record = tryCatch(generator[method], generator, arg);if ("throw" !== record.type) {var result = record.arg,value = result.value;return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {invoke("next", value, resolve, reject);}, function (err) {invoke("throw", err, resolve, reject);}) : PromiseImpl.resolve(value).then(function (unwrapped) {result.value = unwrapped, resolve(result);}, function (error) {return invoke("throw", error, resolve, reject);});}reject(record.arg);}var previousPromise;defineProperty(this, "_invoke", { value: function value(method, arg) {function callInvokeWithMethodAndArg() {return new PromiseImpl(function (resolve, reject) {invoke(method, arg, resolve, reject);});}return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();} });}function makeInvokeMethod(innerFn, self, context) {var state = "suspendedStart";return function (method, arg) {if ("executing" === state) throw new Error("Generator is already running");if ("completed" === state) {if ("throw" === method) throw arg;return doneResult();}for (context.method = method, context.arg = arg;;) {var delegate = context.delegate;if (delegate) {var delegateResult = maybeInvokeDelegate(delegate, context);if (delegateResult) {if (delegateResult === ContinueSentinel) continue;return delegateResult;}}if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {if ("suspendedStart" === state) throw state = "completed", context.arg;context.dispatchException(context.arg);} else "return" === context.method && context.abrupt("return", context.arg);state = "executing";var record = tryCatch(innerFn, self, context);if ("normal" === record.type) {if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;return { value: record.arg, done: context.done };}"throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);}};}function maybeInvokeDelegate(delegate, context) {var methodName = context.method,method = delegate.iterator[methodName];if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;var record = tryCatch(method, delegate.iterator, context.arg);if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;var info = record.arg;return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);}function pushTryEntry(locs) {var entry = { tryLoc: locs[0] };1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);}function resetTryEntry(entry) {var record = entry.completion || {};record.type = "normal", delete record.arg, entry.completion = record;}function Context(tryLocsList) {this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);}function values(iterable) {if (iterable) {var iteratorMethod = iterable[iteratorSymbol];if (iteratorMethod) return iteratorMethod.call(iterable);if ("function" == typeof iterable.next) return iterable;if (!isNaN(iterable.length)) {var i = -1,next = function next() {for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;return next.value = undefined, next.done = !0, next;};return next.next = next;}}return { next: doneResult };}function doneResult() {return { value: undefined, done: !0 };}return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {var ctor = "function" == typeof genFun && genFun.constructor;return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));}, exports.mark = function (genFun) {return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;}, exports.awrap = function (arg) {return { __await: arg };}, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {return this;}), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {void 0 === PromiseImpl && (PromiseImpl = Promise);var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {return result.done ? result.value : iter.next();});}, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {return this;}), define(Gp, "toString", function () {return "[object Generator]";}), exports.keys = function (val) {var object = Object(val),keys = [];for (var key in object) keys.push(key);return keys.reverse(), function next() {for (; keys.length;) {var key = keys.pop();if (key in object) return next.value = key, next.done = !1, next;}return next.done = !0, next;};}, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) {if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);}, stop: function stop() {this.done = !0;var rootRecord = this.tryEntries[0].completion;if ("throw" === rootRecord.type) throw rootRecord.arg;return this.rval;}, dispatchException: function dispatchException(exception) {if (this.done) throw exception;var context = this;function handle(loc, caught) {return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;}for (var i = this.tryEntries.length - 1; i >= 0; --i) {var entry = this.tryEntries[i],record = entry.completion;if ("root" === entry.tryLoc) return handle("end");if (entry.tryLoc <= this.prev) {var hasCatch = hasOwn.call(entry, "catchLoc"),hasFinally = hasOwn.call(entry, "finallyLoc");if (hasCatch && hasFinally) {if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);} else if (hasCatch) {if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);} else {if (!hasFinally) throw new Error("try statement without catch or finally");if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);}}}}, abrupt: function abrupt(type, arg) {for (var i = this.tryEntries.length - 1; i >= 0; --i) {var entry = this.tryEntries[i];if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {var finallyEntry = entry;break;}}finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);var record = finallyEntry ? finallyEntry.completion : {};return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);}, complete: function complete(record, afterLoc) {if ("throw" === record.type) throw record.arg;return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;}, finish: function finish(finallyLoc) {for (var i = this.tryEntries.length - 1; i >= 0; --i) {var entry = this.tryEntries[i];if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;}}, "catch": function _catch(tryLoc) {for (var i = this.tryEntries.length - 1; i >= 0; --i) {var entry = this.tryEntries[i];if (entry.tryLoc === tryLoc) {var record = entry.completion;if ("throw" === record.type) {var thrown = record.arg;resetTryEntry(entry);}return thrown;}}throw new Error("illegal catch attempt");}, delegateYield: function delegateYield(iterable, resultName, nextLoc) {return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel;} }, exports;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _get() {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get.bind();} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(arguments.length < 3 ? target : receiver);}return desc.value;};}return _get.apply(this, arguments);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });Object.defineProperty(subClass, "prototype", { writable: false });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;} else if (call !== void 0) {throw new TypeError("Derived constructors may only return object or undefined");}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);Object.defineProperty(Constructor, "prototype", { writable: false });return Constructor;}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArrayLimit(arr, i) {var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];if (null != _i) {var _s,_e,_x,_r,_arr = [],_n = !0,_d = !1;try {if (_x = (_i = _i.call(arr)).next, 0 === i) {if (Object(_i) !== _i) return;_n = !1;} else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);} catch (err) {_d = !0, _e = err;} finally {try {if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;} finally {if (_d) throw _e;}}return _arr;}}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);enumerableOnly && (symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;})), keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = null != arguments[i] ? arguments[i] : {};i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {_defineProperty(target, key, source[key]);}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}return target;}function _defineProperty(obj, key, value) {key = _toPropertyKey(key);if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _toPropertyKey(arg) {var key = _toPrimitive(arg, "string");return _typeof(key) === "symbol" ? key : String(key);}function _toPrimitive(input, hint) {if (_typeof(input) !== "object" || input === null) return input;var prim = input[Symbol.toPrimitive];if (prim !== undefined) {var res = prim.call(input, hint || "default");if (_typeof(res) !== "object") return res;throw new TypeError("@@toPrimitive must return a primitive value.");}return (hint === "string" ? String : Number)(input);}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];return arr2;}function _typeof(obj) {"@babel/helpers - typeof";return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {return typeof obj;} : function (obj) {return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;}, _typeof(obj);}(function (global, factory) {(typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('@zohocharts/d3')) :
    typeof define === 'function' && define.amd ? define(['exports', '@zohocharts/d3'], factory) : (
    global = global || self, factory(global.$ZC = {}, global.d3));
  })(void 0, function (exports, d3$1) {var _LISTENER, _DATA_FINDER, _BEHAVIOUR;
    //d3-constants.js

    var d3_zc = d3$1, //export overall d3 object
      d3_select = d3$1.select,
      d3_selectAll = d3$1.selectAll,
      // de min-max

      d3_min = d3$1.min,
      d3_max = d3$1.max,
      d3_pairs = d3$1.pairs,
      /**
       * d3 axis axis with orients
       *
       * @type {Function}
       */
      d3_axis = function () {
        var d3AxisOrients = {
          top: d3$1.axisTop,
          bottom: d3$1.axisBottom,
          left: d3$1.axisLeft,
          right: d3$1.axisRight
        };

        return function (orient, scale) {
          return d3AxisOrients[orient](scale);
        };
      }(),
      /**
       * mapping d3 easing methods
       *
       * @type {Function}
       */
      d3_ease = function () {
        var easingTypes = {
          linear: d3$1.easeLinear,

          quad: d3$1.easeQuad,
          'quad-in-out': d3$1.easeQuadInOut,
          'quad-in': d3$1.easeQuadIn,
          'quad-out': d3$1.easeQuadOut,

          cubic: d3$1.easeCubic,
          'cubic-in-out': d3$1.easeCubicInOut,
          'cubic-in': d3$1.easeCubicIn,
          'cubic-out': d3$1.easeCubicOut,

          sin: d3$1.easeSin,
          'sin-in-out': d3$1.easeSinInOut,
          'sin-in': d3$1.easeSinIn,
          'sin-out': d3$1.easeSinOut,

          exp: d3$1.easeExp,
          'exp-in-out': d3$1.easeExpInOut,
          'exp-in': d3$1.easeExpIn,
          'exp-out': d3$1.easeExpOut,

          circle: d3$1.easeCircle,
          'circle-in-out': d3$1.easeCircleInOut,
          'circle-in': d3$1.easeCircleIn,
          'circle-out': d3$1.easeCircleOut,

          elastic: d3$1.easeElastic,
          'elastic-in-out': d3$1.easeElasticInOut,
          'elastic-in': d3$1.easeElasticIn,
          'elastic-out': d3$1.easeElasticOut,

          back: d3$1.easeBack,
          'back-in-out': d3$1.easeBackInOut,
          'back-in': d3$1.easeBackIn,
          'back-out': d3$1.easeBackOut,

          bounce: d3$1.easeBounce,
          'bounce-in-out': d3$1.easeBounceInOut,
          'bounce-in': d3$1.easeBounceIn,
          'bounce-out': d3$1.easeBounceOut
        };

        return function (type) {
          return easingTypes[type] || d3$1.easeLinear;
        };
      }(),
      d3_ease_linear = d3$1.easeLinear,
      /**
       *
       * @param interpolator
       * @param tension
       * @returns {*}
       */
      d3_curves = function () {
        var curves = {
          linear: d3$1.curveLinear,
          linearClosed: d3$1.curveLinearClosed,
          cardinal: d3$1.curveCardinal,
          cardinalClosed: d3$1.curveCardinalClosed,
          monotone: d3$1.curveMonotoneX,
          monotoneY: d3$1.curveMonotoneY,
          stepBefore: d3$1.curveStepBefore,
          stepAfter: d3$1.curveStepAfter,
          'linear-closed': d3$1.curveLinearClosed,
          'cardinal-closed': d3$1.curveCardinalClosed,
          'step-before': d3$1.curveStepBefore,
          'step-after': d3$1.curveStepAfter
        };

        // the above lines can be changed with below line.
        // curve = d3["curve" + interpolator[0].toUpperCase() + interpolator.slice(1)];

        return function (interpolator, rotated, tension) {
          var curve = curves[interpolator];

          if (interpolator == 'monotone' && rotated) {
            curve = curves.monotoneY;
          }

          if (tension !== undefined && tension !== null && curve.tension) {
            curve.tension(tension);
          }

          return curve;
        };
      }(),
      d3_tiles = function () {
        var defaultMode = 'squarify';
        var tiles = {
          squarify: d3$1.treemapSquarify,
          slice: d3$1.treemapSlice,
          dice: d3$1.treemapDice,
          sliceDice: d3$1.treemapSliceDice,
          resquarify: d3$1.treemapResquarify
        };

        return function (mode) {
          return tiles[mode] || tiles[defaultMode];
        };
      }(),
      // d3 scales

      d3_scaleLinear = function d3_scaleLinear() {
        var scale1 = d3$1.scaleLinear();
        scale1.ticks = function (count) {
          var d = this.domain();
          return d3$1.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
        };
        return scale1;
      },
      d3_scaleOrdinal = d3$1.scaleBand,
      d3_scaleTime = d3$1.scaleTime,
      d3_scalePoint = d3$1.scalePoint,
      d3_scaleOrdinalOrg = d3$1.scaleOrdinal, //change
      d3_scaleSqrt = d3$1.scaleSqrt,
      d3_scaleSymlog = d3$1.scaleSymlog,
      // bisector

      d3_bisector = d3$1.bisector,
      // sum

      d3_sum = d3$1.sum,
      // d3 colors

      d3_hsl = d3$1.hsl,
      d3_rgb = function d3_rgb() {
        var rgb = d3$1.rgb.apply(this, arguments);

        /**
         *
         * if the color is transparent, d3.rgb returns NaN, which throws error
         * in some browsers. eg: IE9
         *
         * So, if the color is NaN, we apply black color with 0 opacity.
         */
        if (isNaN(rgb.r) || isNaN(rgb.g) || isNaN(rgb.b)) {
          rgb = d3$1.rgb(0, 0, 0, rgb.opacity);
        }
        return rgb;
      },
      // d3 merge , map and ser

      d3_merge = d3$1.merge,
      d3_map = d3$1.map,
      d3_set = d3$1.set,
      // d3 behavior

      d3_zoom = d3$1.zoom,
      d3_zoomTransform = d3$1.zoomTransform,
      d3_zoomIdentity = d3$1.zoomIdentity,
      d3_drag = d3$1.drag,
      // d3 extent

      d3_extent = d3$1.extent,
      // event dispatch

      d3_dispatch = d3$1.dispatch,
      // d3 sort type

      d3_ascending = d3$1.ascending,
      d3_descending = d3$1.descending,
      // d3 shapes

      d3_line = d3$1.line,
      d3_lineRadial = d3$1.radialLine,
      d3_area = d3$1.area,
      d3_areaRadial = d3$1.radialArea,
      d3_arc = d3$1.arc,
      // layouts
      d3_hierarchy = d3$1.hierarchy,
      d3_pack = d3$1.pack,
      d3_pie = d3$1.pie,
      d3_partition = d3$1.partition,
      d3_treemap = d3$1.treemap,

      // d3 mouse
      // d3 interpolate

      d3_interpolate = d3$1.interpolate,
      d3_interpolateRgb = d3$1.interpolateRgb,
      d3_interpolateRound = d3$1.interpolateRound,
      // d3 range

      d3_range = d3$1.range,
      d3_tickStep = d3$1.tickStep,
      // d3 times

      // days
      d3_timeSunday = d3$1.timeSunday,
      d3_timeMonday = d3$1.timeMonday,
      d3_timeTuesday = d3$1.timeTuesday,
      d3_timeWednesday = d3$1.timeWednesday,
      d3_timeThursday = d3$1.timeThursday,
      d3_timeFriday = d3$1.timeFriday,
      d3_timeSaturday = d3$1.timeSaturday,
      // seconds, minute and hour
      d3_timeSeconds = d3$1.timeSeconds,
      d3_timeHours = d3$1.timeHours,
      d3_timeDays = d3$1.timeDays,
      d3_timeWeeks = d3$1.timeWeeks,
      d3_timeMonths = d3$1.timeMonths,
      d3_timeYears = d3$1.timeYears,
      // formatter
      d3_format = d3$1.format,
      d3_timeFormat = d3$1.timeFormat,
      d3_timeFormatUTC = d3$1.utcFormat,
      d3_timeParse = d3$1.timeParse,
      d3_formatLocale = d3$1.formatLocale,
      d3_timeFormatLocale = d3$1.timeFormatLocale,
      // brush
      d3_brush = d3$1.brush,
      d3_brushX = d3$1.brushX,
      d3_brushY = d3$1.brushY,
      d3_brushSelection = d3$1.brushSelection,
      // geo

      topojson = d3$1.topojson,
      versor = d3$1.versor,
      d3_geoPath = d3$1.geoPath,
      d3_geoGraticule = d3$1.geoGraticule,
      d3_geoCentroid = d3$1.geoCentroid,
      d3_polygonContains = d3$1.polygonContains,
      d3_geoDistance = d3$1.geoDistance,
      d3_geoContains = d3$1.geoContains,
      d3_quadtree = d3$1.quadtree,
      //Namespace
      d3_namespace = d3$1.namespace,
      d3_namespaces = d3$1.namespaces,
      d3_customEvent = d3$1.customEvent,
      //events
      d3_event = function d3_event(e) {
        if (e) {
          d3_zc.event = e;
        }

        return d3_zc.event;
      },
      // sankey variables
      d3_linkHorizontal = d3_zc.linkHorizontal,
      d3_polygonCentroid = d3_zc.polygonCentroid,
      d3_path = d3_zc.path;

    //$Id$

    var version = '2.25',
      versionName = 'Ortelius',
      d3Version = '4.12.0';
    /*
     * Initiate  functions
     */
    var axis = function axis() {},
      legend = function legend() {},
      scale = function scale() {},
      events = function events() {},
      plot = function plot() {};
    plot.canvas = function () {};

    var zmaps = function zmaps() {};
    /*
     * Constants
     */
    //Constants for analytics
    // this.put(MAPSCATTER,23);
    // this.put(MAPBUBBLE,22);
    // this.put(MAPAREA,25);
    // this.put(MAPPIE,28);
    // this.put(MAPPIEBUBBLE,29);
    // this.put(GEOHEATMAP,34);
    var charttype = {};
    var line = charttype.line = 11,
      pie = charttype.pie = 8,
      bar = charttype.bar = 9,
      stkdbar = charttype.stkdbar = 10,
      scatter = charttype.scatter = 12,
      area = charttype.area = 14,
      stkdarea = charttype.stkdarea = 15,
      bubble = charttype.bubble = 20,
      packedbubble = charttype.packedbubble = 19,
      funnel = charttype.funnel = 7,
      web = charttype.web = 16,
      sunburst = charttype.sunburst = 17,
      pyramid = charttype.pyramid = 13,
      dial = charttype.dial = 18,
      bullet = charttype.bullet = 6,
      arearange = charttype.arearange = 21,
      bubblepie = charttype.bubblepie = 5,
      gantt = charttype.gantt = 24,
      treemap = charttype.treemap = 4,
      heatmap = charttype.heatmap = 3,
      dotgrid = charttype.dotgrid = 26,
      waterfall = charttype.waterfall = 27,
      wordcloud = charttype.wordcloud = 2,
      geoheatmap = charttype.geoheatmap = 30,
      geoscatter = charttype.geoscatter = 31,
      geobubble = charttype.geobubble = 32,
      geobubblepie = charttype.geobubblepie = 33,
      boxplot = charttype.boxplot = 35,
      sankey = charttype.sankey = 36,
      barrange = charttype.barrange = 37;

    var charttypenames = d3_map();
    charttypenames.set(charttype.line, 'line');
    charttypenames.set(charttype.pie, 'pie');
    charttypenames.set(charttype.bar, 'bar');
    charttypenames.set(charttype.stkdbar, 'bar');
    charttypenames.set(charttype.scatter, 'scatter');
    charttypenames.set(charttype.area, 'area');
    charttypenames.set(charttype.funnel, 'funnel');
    charttypenames.set(charttype.web, 'web');
    charttypenames.set(charttype.stkdarea, 'area');
    charttypenames.set(charttype.sunburst, 'sunburst');
    charttypenames.set(charttype.pyramid, 'pyramid');
    charttypenames.set(charttype.bubble, 'bubble');
    charttypenames.set(charttype.dial, 'dial');
    charttypenames.set(charttype.packedbubble, 'packedbubble');
    charttypenames.set(charttype.bullet, 'bullet');
    charttypenames.set(charttype.arearange, 'arearange');
    charttypenames.set(charttype.gantt, 'gantt');
    charttypenames.set(charttype.bubblepie, 'bubblepie');
    charttypenames.set(charttype.treemap, 'treemap');
    charttypenames.set(charttype.heatmap, 'heatmap');
    charttypenames.set(charttype.dotgrid, 'dotgrid');
    charttypenames.set(charttype.waterfall, 'waterfall');
    charttypenames.set(charttype.wordcloud, 'wordcloud');
    charttypenames.set(charttype.geoheatmap, 'geoheatmap');
    charttypenames.set(charttype.geoscatter, 'geoscatter');
    charttypenames.set(charttype.geobubble, 'geobubble');
    charttypenames.set(charttype.geobubblepie, 'geobubblepie');
    charttypenames.set(charttype.boxplot, 'boxplot');
    charttypenames.set(charttype.sankey, 'sankey');
    charttypenames.set(charttype.barrange, 'barrange');

    //ALLOWED CHARTS
    var chartcategory = {};
    chartcategory.axis = [
    line,
    area,
    scatter,
    stkdarea,
    bar,
    stkdbar,
    bubble,
    bullet,
    arearange,
    bubblepie,
    gantt,
    heatmap,
    waterfall,
    boxplot,
    barrange];


    chartcategory.flow = [sankey];
    chartcategory.nonaxis = [pie, funnel, pyramid, dial, dotgrid];
    chartcategory.nonaxismultiseries = [web, sunburst, packedbubble, treemap, wordcloud];
    chartcategory.polarAxis = [web];
    chartcategory.hierarchy = [packedbubble, sunburst, treemap];
    chartcategory.continous = [line, area, scatter, stkdarea, bubble, arearange, bubblepie];
    chartcategory.discrete = [pie, bar, stkdbar, sunburst, funnel, pyramid, dial, bullet, gantt, heatmap, waterfall, boxplot, barrange];
    chartcategory.dotPlot = [scatter, bubble, geoscatter, geobubble];
    chartcategory.piePlot = [pie, bubblepie, geobubblepie];
    chartcategory.zaxis = [bubble, bubblepie, heatmap, geobubble, geobubblepie, sankey];
    chartcategory.svgOnly = [pie, funnel, pyramid, dial, sunburst, packedbubble, bubblepie, gantt, waterfall, geobubblepie, boxplot];
    chartcategory.geo = [geoheatmap, geoscatter, geobubble, geobubblepie];
    chartcategory.bubble = d3_set([bubble, geobubble]);
    chartcategory.bubblePie = d3_set([bubblepie, geobubblepie]);
    chartcategory.rangePlot = d3_set([arearange, gantt, boxplot, barrange]);
    chartcategory.barPlot = d3_set([bar, stkdbar, bullet, gantt, heatmap, waterfall, boxplot, barrange]);
    chartcategory.markerPlot = d3_set([scatter, bubble, line, area, arearange]);
    chartcategory.whiskerPlot = d3_set([bar, barrange, boxplot]);

    chartcategory.stacked = [bar, waterfall, bullet, line, area, web, barrange];
    chartcategory.stackedPercent = [bar, line, area, web, stkdbar, stkdarea]; //TODO: remove stkdbar, stkdarea chartTypes

    chartcategory.innerLabels = [pie, funnel, pyramid, sunburst, bubblepie, geobubblepie];
    chartcategory.datalabelsInside = [packedbubble, heatmap, treemap, geoheatmap];
    chartcategory.parentLabels = [treemap, sunburst];

    chartcategory.nonAxisSingleSourceEvent = [treemap, wordcloud];
    chartcategory.singleSourceEvent = [].concat(_toConsumableArray(
    chartcategory.axis), _toConsumableArray(
    chartcategory.polarAxis), _toConsumableArray(
    chartcategory.flow), _toConsumableArray(
    chartcategory.nonAxisSingleSourceEvent));


    //The main object can be renamed by calling this method by passing a customized object name.
    var rename = function rename(newObjName) {
      if (newObjName != null && newObjName != '' && typeof newObjName === 'string') {
        var window = getDocumentWindow();
        if (window && window.$ZC) {
          window[newObjName] = $ZC;
          window.$ZC = null;
          delete window.$ZC;
          return true; // renamed successfully
        }
      }
      return false; // rename failed.
    };

    var chartThemes = {};
    var setTheme = function setTheme(name, value) {
      var window = getDocumentWindow();
      if (window && window.$ZC) {
        window.$ZC[name] = value;
      }
      chartThemes[name] = value;
    };

    var getTheme = function getTheme(name) {
      return chartThemes[name] || window && window.$ZC && window.$ZC[name];
    };

    var viewCount;
    var addViewCount = function addViewCount() {
      viewCount = viewCount || 0;
      return ++viewCount;
    };

    /**
     * Common functions and variables
     */

    var svg_plot_renderer = {},
      renderer_helpers = {},
      dataLabel_handler = {},
      labelRenderer = function labelRenderer() {},
      datalabelsBoundBox_handler = {},
      GeoSeriesTypes = d3_map();

    // constants
    var CUSTOM_VALUE_PATTERN = /\{\{val\((\d+)\)\}\}|\{\{col\((\d+)\)\}\}|\{\{per\((\d+)\)\}\}|\{\{splitper\((\d+)\)\}\}|\{\{maxper\((\d+)\)\}\}|\{\{geo\(([a-z0-9\-\_]+)\)\}\}|\{\{clr\}\}|\{\{valatpos\((\d+)\)\[(\d+)\]\}\}/gi, // regxr
      RGBA_PATTERN = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/i,
      HIGHLIGHT_EFFECT_REGEX = /(illuminate|moody|flip|boxShadow|invert|ridge)/,
      UNHIGHLIGHT_EFFECT_REGEX = /(fadeOut|blur|grayscale|saturate)/,
      Console = window.console,
      tempCanvasContext = document.createElement('canvas').getContext('2d');

    var getDocumentWindow = function getDocumentWindow(node) {
      if (node && node.document) {
        return node.document;
      }
      return window;
    };

    //$Id$

    var UNDEFINED,
      math = Math,
      mathRound = math.round,
      mathFloor = math.floor,
      mathCeil = math.ceil,
      mathMax = math.max,
      mathMin = math.min,
      mathAbs = math.abs,
      mathPow = math.pow,
      mathSQRT = math.sqrt,
      mathCos = math.cos,
      mathSin = math.sin,
      mathLog = math.log,
      mathTan = math.tan,
      mathAtan2 = math.atan2,
      mathAtan = math.atan,
      mathLN10 = math.LN10,
      mathRandom = math.random,
      mathPI = math.PI,
      deg2rad = mathPI * 2 / 360,
      MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,
      EPSILON = Number.EPSILON || 2.220446049250313e-16,
      PX = 'px ',
      NONE = 'none',
      TRANSPARENT = 'transparent',
      POINTER = 'pointer',
      NULL$1 = null, //Below are not constants, need to change
      DOCUMENT_OBJECT_HOLDER = [],
      BASE_CONTAINER_POSITION = -9999,
      DEVICE_PIXEL_RATIO = getDocumentWindow().devicePixelRatio || 1,
      noOperation = function () {
        var func = function func() {};
        func._empty = true;
        return func;
      }();

    // var tempCanvasContext = document.createElement("canvas").getContext("2d");

    //zc-registry.js

    // Component registry
    var componentsRegistry = {};

    /**
     * [getComponent description]
     * @param  {String} componentName [description]
     * @return {Function}               [description]
     */
    function getComponent(componentName) {
      return componentsRegistry[componentName] || noOperation;
    }

    /**
     * [setComponent description]
     * @param {String} componentName [description]
     * @param {Function} module        [description]
     */
    function setComponent(componentName, module) {
      componentsRegistry[componentName] = module;
    }

    /**
     * [getComponentMethod description]
     * @param  {String} componentName [description]
     * @param  {String} methodName    [description]
     * @return {Function}               [description]
     */
    function getComponentMethod(componentName, methodName) {
      var component = getComponent(componentName) || noOperation;
      return component[methodName] || noOperation;
    }
    //$ZC.get, $ZC.set for non-components
    var get = getComponent,
      set = setComponent;

    var Registry = {
      getComponent: getComponent,
      setComponent: setComponent,
      getComponentMethod: getComponentMethod
    };

    //$Id$
    var _imageFilePath = "".concat(window.location.protocol, "//").concat(window.location.hostname, "/src/images/");
    var fontProperties = {
      minsize: 15,
      maxsize: 40,
      ratio: 0.038
    };

    /*If Xaxis data (numeric or time) is not sorted, plot rendering for continous charts will look odd.
     Because of the performance issue, we are giving this configuration as optional. Better make this parameter as false, and make sure the input data is sorted, if you are considering performance
     */
    var _requireXDataSorting = false;
    var _dataEncoded = false;

    /*
    Option for user to set the sort mode or to fetch the
    current sorting mode.
     */
    var requireXDataSorting = function requireXDataSorting(needSort) {
      if (!arguments.length) {
        return _requireXDataSorting;
      }
      _requireXDataSorting = needSort;
    };
    /*
    Option for user to set whether the given data is encoded
    or to get the current encoded mode.
     */
    var dataEncoded = function dataEncoded(isEncoded) {
      if (!arguments.length) {
        return _dataEncoded;
      }
      _dataEncoded = isEncoded;
    };
    Registry.setComponent('dataEncoded', dataEncoded);
    /*
    Option for user to customize the image file path or to
    get the current applied file path
     */
    var imageFilePath = function imageFilePath(filepath) {
      if (!arguments.length) {
        return _imageFilePath;
      }
      _imageFilePath = filepath;
    };

    var _modularized = {
      scaleCorrection: false,
      colorBandLegend: true
    };
    var modularized = function modularized(_) {
      if (!arguments.length) {
        return _modularized;
      }
      _modularized = _;
    };
    Registry.setComponent('modularized', modularized);

    //$Id$
    //polyfill.js

    var btoa =
    window.btoa ||
    function (input) {
      //window.btoa polyfill for IE9
      input = String(input);
      var B64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
      var position = 0,
        out = [],
        o1,
        o2,
        o3,
        e1,
        e2,
        e3,
        e4;

      if (/[^\x00-\xFF]/.test(input)) {
        throw Error('InvalidCharacterError');
      }

      while (position < input.length) {
        o1 = input.charCodeAt(position++);
        o2 = input.charCodeAt(position++);
        o3 = input.charCodeAt(position++);

        // 111111 112222 222233 333333
        e1 = o1 >> 2;
        e2 = (o1 & 0x3) << 4 | o2 >> 4;
        e3 = (o2 & 0xf) << 2 | o3 >> 6;
        e4 = o3 & 0x3f;

        if (position === input.length + 2) {
          e3 = 64;
          e4 = 64;
        } else if (position === input.length + 1) {
          e4 = 64;
        }

        out.push(B64_ALPHABET.charAt(e1), B64_ALPHABET.charAt(e2), B64_ALPHABET.charAt(e3), B64_ALPHABET.charAt(e4));
      }
      return out.join('');
    };

    /**
     * innerHTML property for SVGElement
     * Copyright(c) 2010, Jeff Schiller
     *
     * Licensed under the Apache License, Version 2
     *
     * Works in a SVG document in Chrome 6+, Safari 5+, Firefox 4+ and IE9+.
     * Works in a HTML5 document in Chrome 7+, Firefox 4+ and IE9+.
     * Does not work in Opera since it doesn't support the SVGElement interface yet.
     *
     * I haven't decided on the best name for this property - thus the duplication.
     */

    (function () {
      var serializeXML = function serializeXML(node, output) {
        var nodeType = node.nodeType;
        if (nodeType == 3) {
          // TEXT nodes.
          // Replace special XML characters with their entities.
          output.push(
          node.textContent.
          replace(/&/, '&amp;').
          replace(/</, '&lt;').
          replace('>', '&gt;'));

        } else if (nodeType == 1) {
          // ELEMENT nodes.
          // Serialize Element nodes.
          output.push('<', node.tagName);
          if (node.hasAttributes()) {
            var attrMap = node.attributes;
            for (var i = 0, len = attrMap.length; i < len; ++i) {
              var attrNode = attrMap.item(i);
              output.push(' ', attrNode.name, "='", attrNode.value, "'");
            }
          }
          if (node.hasChildNodes()) {
            output.push('>');
            var childNodes = node.childNodes;
            for (var i = 0, len = childNodes.length; i < len; ++i) {
              serializeXML(childNodes.item(i), output);
            }
            output.push('</', node.tagName, '>');
          } else {
            output.push('/>');
          }
        } else if (nodeType == 8) {
          // TODO(codedread): Replace special characters with XML entities?
          output.push('<!--', node.nodeValue, '-->');
        } else {
          // TODO: Handle CDATA nodes.
          // TODO: Handle ENTITY nodes.
          // TODO: Handle DOCUMENT nodes.
          throw "Error serializing XML. Unhandled node of type: ".concat(nodeType);
        }
      };

      // The innerHTML DOM property for SVGElement.
      Object.defineProperty(SVGElement.prototype, 'innerHTML', {
        configurable: true, // #ZC1789
        get: function get() {
          var output = [];
          var childNode = this.firstChild;
          while (childNode) {
            serializeXML(childNode, output);
            childNode = childNode.nextSibling;
          }
          return output.join('');
        },
        set: function set(markupText) {
          // Wipe out the current contents of the element.
          while (this.firstChild) {
            this.removeChild(this.firstChild);
          }

          try {
            // Parse the markup into valid nodes.
            var dXML = new DOMParser();
            dXML.async = false;
            // Wrap the markup into a SVG node to ensure parsing works.
            var sXML = "<svg xmlns='http://www.w3.org/2000/svg'>".concat(markupText, "</svg>");
            var svgDocElement = dXML.parseFromString(sXML, 'text/xml').documentElement;

            // Now take each node, import it and append to this element.
            var childNode = svgDocElement.firstChild;
            while (childNode) {
              this.appendChild(this.ownerDocument.importNode(childNode, true));
              childNode = childNode.nextSibling;
            }
          } catch (e) {
            throw new Error('Error parsing XML string');
          }
        }
      });

      // The outerHTML DOM property for SVGElement.
      Object.defineProperty(SVGElement.prototype, 'outerHTML', {
        get: function get() {
          var $node, $temp;
          $temp = document.createElement('div');
          $node = this.cloneNode(true);
          $temp.appendChild($node);
          return $temp.innerHTML;
        },
        enumerable: false,
        configurable: true
      });


      // The innerSVG DOM property for SVGElement.
      Object.defineProperty(SVGElement.prototype, 'innerSVG', {
        configurable: true, // #ZC1789
        get: function get() {
          return this.innerHTML;
        },
        set: function set(markupText) {
          this.innerHTML = markupText;
        }
      });

      if (!String.prototype.startsWith) {
        Object.defineProperty(String.prototype, 'startsWith', {
          value: function value(search, rawPos) {
            var pos = rawPos > 0 ? rawPos | 0 : 0;
            return this.substring(pos, pos + search.length) === search;
          }
        });
      }
    })();

    /**
     * IE9 throws error in style.setProperty if the value is a Number.
     * Previously it was done by d3 itself. But for some reason it has been removed in v4.
     * we adding this as a polyfill
     *
     */
    (function () {
      try {
        document.createElement('div').style.setProperty('opacity', 0, '');
      } catch (error) {
        var element_prototype = window.Element.prototype,
          element_setAttribute = element_prototype.setAttribute,
          element_setAttributeNS = element_prototype.setAttributeNS,
          style_setProperty = window.CSSStyleDeclaration.prototype.setProperty;

        element_prototype.setAttribute = function (name, value) {
          element_setAttribute.call(this, name, "".concat(value));
        };

        element_prototype.setAttributeNS = function (space, local, value) {
          element_setAttributeNS.call(this, space, local, "".concat(value));
        };

        window.CSSStyleDeclaration.prototype.setProperty = function (name, value, priority) {
          style_setProperty.call(this, name, "".concat(value), priority);
        };
      }
    })();

    // Set polyfill
    // https://unpkg.com/@ungap/set@0.1.1/index.js
    var Set = window.Set;
    if (!Set || !Set.prototype.values) {
      //IE11 has minimal support of Set. It doesn't has Set.prototype.values
      Set = function (i, dPs) {
        var proto = dPs(_Set.prototype, {
          size: {
            configurable: true,
            get: function get() {
              return this._v.length;
            }
          }
        });
        proto.add = function (value) {
          if (!has(this, value)) {
            this._v.push(value);
          }

          return this;
        };
        proto.clear = function () {
          var length = this._v.length;
          this._v.splice(0, length);
        };
        proto["delete"] = function (value) {
          return has(this, value) && !!this._v.splice(i, 1);
        };
        proto.entries = function () {
          return this._v.map(pair);
        };
        proto.forEach = function (callback, context) {
          this._v.forEach(function (value, i) {
            callback.call(context, value, value, this);
          }, this);
        };
        proto.has = function (key) {
          return has(this, key);
        };
        proto.keys = proto.values = function () {
          return this._v.slice(0);
        };

        function _Set(iterable) {
          dPs(this, {
            _v: {
              value: []
            }
          });
          if (iterable) {
            iterable.forEach(this.add, this);
          }
        }

        function has(self, value) {
          i = self._v.indexOf(value);
          return -1 < i;
        }

        function pair(value) {
          return [value, value];
        }

        return _Set;
      }(0, Object.defineProperties);
    }

    // FOR LOG SCALE
    Math.sign =
    Math.sign ||
    function (x) {
      return (x > 0) - (x < 0) || +x;
    };

    Math.log1p =
    Math.log1p ||
    function (x) {
      x = Number(x);
      if (x < -1 || x !== x) {
        return NaN;
      }
      if (x === 0 || x === Infinity) {
        return x;
      }

      var nearX = x + 1 - 1;

      return nearX === 0 ? x : x * (Math.log(x + 1) / nearX);
    };

    Math.expm1 =
    Math.expm1 ||
    function (x) {
      return Math.exp(x) - 1;
    };

    //$Id$

    var utils = function utils() {};

    /*
     * element - to which the bound box is drawn
     * component1 - node from which we start to draw the box
     * component2 - where to end the box
     * properties - outer box configuration
     */

    function drawBorderBox(element, properties) {
      element
      // .attr('x', properties.left)
      // .attr('y', properties.top)
      .attr('width', properties.width).
      attr('height', properties.height).
      style('fill-opacity', 0).
      style('stroke', TRANSPARENT);
    }
    utils.drawBorderBox = drawBorderBox;

    utils.getActualTextBounds = function (fontSize, width, rotation) {
      var width = width,
        height = fontSize,
        radian = rotation * (mathPI * 2 / 360);
      var bbox = {};
      bbox.width = mathAbs(height * mathSin(radian)) + mathAbs(width * mathCos(radian));
      bbox.height = mathAbs(height * mathCos(radian)) + mathAbs(width * mathSin(radian));
      return bbox;
    };
    var mergeJSON$1 = utils.mergeJSON = function (source1, source2, mergeConflicts, mergeIntoExists) {
      /*
       * Properties from the Souce2 object will be copied to Source1 Object.
       * Note: mergeIntoExists : true -- Here source 1 and source2 will get merged into source1.
       * mergeIntoExists : false -- This method will return a new merged object, Source1 and Source2 original values will not be replaced.
       * */
      source1 = source1 || {};
      source2 = source2 || {};

      var mergedJSON = mergeIntoExists != null && mergeIntoExists == true ? source1 : simpleClone(source1); // Cloning the source1
      for (var attrname in source2) {
        if (source2.hasOwnProperty(attrname)) {
          if (mergedJSON[attrname] != undefined) {
            if (source2[attrname] != null && (source2[attrname].constructor == Object || source2[attrname].constructor == Array)) {
              if (source2[attrname].constructor == Array && mergedJSON[attrname].constructor !== Array) {
                //check for source2 is array, but mergedJson is of string -> no need to recursive call, simply Merge the property from source 2 to source1
                if (mergeConflicts) {
                  mergedJSON[attrname] = source2[attrname];
                }
              } else {
                /*
                 * Recursive call if the property is an object,
                 * Iterate the object and set all properties of the inner object.
                 */
                mergedJSON[attrname] = mergeJSON$1(mergedJSON[attrname], source2[attrname], mergeConflicts, mergeIntoExists);
              }
            } else if (mergeConflicts == true && _typeof(mergedJSON) === 'object') {
              //Merge the property from source 2 to source1
              mergedJSON[attrname] = source2[attrname];
            }
          } else {
            //else Add the property from source 2 to source1
            mergedJSON[attrname] = source2[attrname];
          }

          if (mergedJSON[attrname] && mergedJSON[attrname]._zc) {
            // Removing internal properties - has circular reference ZC3271
            mergedJSON[attrname] = undefined;
          }
        }
      }

      return mergedJSON;
    };
    Registry.setComponent('utils.mergeJSON', mergeJSON$1);

    utils.getValueOfPlotOptions = function (obj1, obj2) {
      /*
       * obj1 -->high priority
       * obj2 -->Low priority
       */
      return function (key) {
        if (obj1 != null && obj1[key] != null) {
          return obj1[key];
        } else if (obj2 != null && obj2[key] != null) {
          return obj2[key];
        } else {
          return null;
        }
      };
    };

    function getVal(value, args) {var self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      /*
       * If the value is function, execute it and return the value
       */
      return typeof value === 'function' ? value.apply(self, args) : value;
    }
    utils.getVal = getVal;

    function generateIdByPropValue(properties, name) {
      if (properties == null || properties.constructor != Object) {
        if (name != null) {
          return name;
        }
        return;
      }
      var id = '',
        val;
      for (var prop in properties) {
        if (properties.hasOwnProperty(prop)) {
          val = properties[prop];
          if (val && val.constructor === Object) {
            //#ZC1142 on redraw
            val = jsonStringify(val);
          }

          id += val == null || val == '' ? '$$' : "".concat(val, "_");
        }
      }
      id = name + id;
      id = id.replace(/[.-]/g, '_');
      id = id.replace(/[`~!@#$%^&*( )|+\-=?;:'",.<>{}[\]\\/\s]/gi, '_');
      return id;
    }
    utils.generateIdByPropValue = generateIdByPropValue;

    function getMonochromeColor(baseClr, domain, range) {
      var hsl = d3_hsl(baseClr);

      var interpolateClr = d3_scaleLinear().
      domain([-1, 0, 1]).
      range([d3_hsl(hsl.h, hsl.s, 0.1), hsl, d3_hsl(hsl.h, hsl.s, 0.9)]).
      interpolate(d3_interpolateRgb);
      var clrScale = d3_scaleLinear().
      domain(domain).
      range(range);
      return function (clr) {
        return interpolateClr(clrScale(clr));
      };
    }
    utils.getMonochromeColor = getMonochromeColor;

    function bbox(ele) {
      //if element is removed from DOM, firefox will throw NS_ERROR_FAILURE on getBBox(). This function returns getBBox() of the given element if that element is present in DOM, else returns {x:0, y:0, height:0, width:0}
      if (ele) {
        if (ele.isD3Selection) {
          ele = ele.node();
        }

        if (isElementVisible(ele)) {
          return ele.getBBox();
        }
      }
      return {
        x: 0,
        y: 0,
        height: 0,
        width: 0
      };
    }
    Registry.setComponent('domUtils.getBBox', bbox);

    var simpleClone = utils.simpleClone = function (o) {
      var copy = o,
        k;

      if (o && _typeof(o) === 'object') {
        copy = isArray$1(o) ? [] : {};
        for (k in o) {
          // if(o.hasOwnProperty(k)){
          copy[k] = simpleClone(o[k]);
          // }
        }
      }

      return copy;
    };
    Registry.setComponent('utils.simpleClone', simpleClone);

    function decodeHTML(text) {
      if (!_dataEncoded || text == null) {
        return text;
      }
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = encodeURI(text);
      var decodedText = tempDiv.textContent;
      return decodeURI(decodedText);
    }
    Registry.setComponent('domUtils.decodeHTML', decodeHTML);

    function encodeHTML(text) {
      if (_dataEncoded || text == null) {
        return text;
      }
      var tempDiv = document.createElement('div');
      tempDiv.textContent = decodeHTML(text);
      var encodedText = tempDiv.innerHTML;
      return encodedText;
    }
    utils.encodeHTML = encodeHTML;
    Registry.setComponent('domUtils.encodeHTML', encodeHTML);

    function validateURL(url) {
      var exp_http = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g,
        exp_nonHttp = /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi;
      var regExp_http = new RegExp(exp_http),
        regExp_nonHttp = new RegExp(exp_nonHttp);
      return url.match(regExp_http) || url.match(regExp_nonHttp);
    }
    utils.validateURL = validateURL;

    function d3_values(map) {
      return map.slice(0);
    }
    utils.d3_values = d3_values;

    function getDefsLocation() {
      return d3_selectAll('base').node() ? location.href.split(location.search || location.hash || /[?#]/)[0] : '';
    }
    Registry.setComponent('domUtils.getDefsLocation', getDefsLocation);

    function isObjectPropDefined(obj, key, self) {
      var keySet = key.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
      keySet = keySet.replace(/^\./, ''); // strip a leading dot
      var keys = keySet.split('.');

      var childObj = keys.reduce(function (o, x) {
        return !defined(o) ? o : o[x];
      }, obj);
      return self ? childObj : defined(childObj);

      // return keys.every(function (x) {
      // 	if (typeof obj != "object" || obj === null || !x in obj)
      // 		return false;
      // 	obj = obj[x];
      // 	return true;
      // });
    }
    utils.isObjectPropDefined = isObjectPropDefined;

    /**
     *
     * @param {Object|*} variable
     * @return {boolean}
     */
    function isUndefined(variable) {
      return !defined(variable);
    }
    Registry.setComponent('utils.isUndefined', isUndefined);

    function toArray(objectLikeArray) {
      return Array.prototype.slice.call(objectLikeArray);
    }
    Registry.setComponent('utils.toArray', toArray);

    function objectToArray(data, rule, slice) {
      var array = [];
      for (var key in data) {
        if (data.hasOwnProperty(key) && isObject(data[key])) {
          if (!rule) {
            array.push(data[key]);
          } else if (rule(data[key])) {
            array.push(data[key]);
          }

          if (slice) {
            array = array.slice(slice[0], slice[1]);
          }
        }
      }
      return array;
    }
    utils.objectToArray = objectToArray;

    /**
     * It invokes a function with the given arguments.
     * If the first argument is true, then corresponding function will have
     * access to 'this' keyword with the value arguments[2]
     */

    function invokeFunction() {
      var args = toArray(arguments),
        advanced = args[0] === true && args.shift(),
        callback = args.shift();

      if (typeof callback === 'string') {
        var temp = getPropVal(window, callback);
        // callback = defined(temp) ? temp : callback; // for both global variable and global function support.
        callback = typeof temp === 'function' ? temp : callback; // for only global function support.
      }
      return typeof callback === 'function' ?
      advanced ?
      callback.apply(args[0], args.splice(1)) :
      callback.apply(undefined, args) :
      callback;
    }
    Registry.setComponent('utils.invokeFunction', invokeFunction);

    function getValue(key, args) {
      if (defined(key)) {
        if (typeof key == 'function') {
          return key.call(args);
        } else {
          return key;
        }
      }
      return null;
    }
    utils.getValue = getValue;

    function getValByPriority(array, attr) {
      var i = 0,
        len = array.length,
        val;
      for (; i < len && (val == null || val === ''); i++) {
        if (array[i]) {
          val = array[i][attr];
        }
      }
      return val;
    }
    utils.getValByPriority = getValByPriority;

    function validateNullVal(actualVal, defaultVal) {
      var val = actualVal == null || actualVal === '' ? defaultVal : actualVal;

      var parsedVal = JSON.parse(val);
      val = typeof parsedVal == 'number' ? parseFloat(parsedVal) : typeof parsedVal == 'boolean' ? JSON.parse(parsedVal) : parsedVal;
      return val;
    }
    Registry.setComponent('utils.validateNullValue', validateNullVal);

    function validateValWithinLimit(data, prop, minPercent, maxPercent, width, height) {
      var val;
      var refLevel = mathMin(width, height);
      var maxVal = maxPercent * refLevel / 100,
        minVal = minPercent * refLevel / 100;
      val = data[prop];
      val = val == null || val === '' ? null : val < minVal ? minVal : val > maxVal ? maxVal : parseFloat(val);
      return val;
    }
    utils.validateValWithinLimit = validateValWithinLimit;

    function isWithinRange$1(value, range) {
      var minVal = range[0],
        maxVal = range[1];
      return value < minVal || value > maxVal ? false : true;
    }
    utils.isWithinRange = isWithinRange$1;

    /**
     * Returns true if the object is not null or undefined.
     * @param {Object} obj
     */

    function defined(obj) {
      return obj !== undefined && obj !== null;
    }
    Registry.setComponent('utils.defined', defined);

    /**
     * Returns true if the number is positive or not.
     * @param {Object} obj
     */

    function isPositive(number) {
      return number > 0;
    }
    utils.isPositive = isPositive;

    /**
     * Returns true if the value is null object or null string
     * @param {Object} obj
     */

    function isNull(value) {
      return value == null || value == 'null';
    }
    utils.isNull = isNull;

    /**
     *
     * @param e
     * @returns {boolean}
     */

    function isTrue(e) {
      return e + ''.toLocaleLowerCase() === 'true';
    }
    utils.isTrue = isTrue;

    function shorthand_px(val) {
      /*
       * Input : 10 5 5 10
       * Output : 10px 5px 5px 10px
       */
      val += '';
      return "".concat(val.replace(/ /g, 'px '), "px");
    }
    utils.shorthand_px = shorthand_px;

    /**
     * Shortcut for parseInt
     * @param {Object} s
     * @param {Number} mag Magnitude
     */
    function pInt(s, mag) {
      return parseInt(s, mag || 10);
    }
    utils.pInt = pInt;

    /**
     * Check for string
     * @param {Object} s
     */
    function isString(s) {
      return typeof s === 'string';
    }
    utils.isString = isString;

    /**
     * Check for object
     * @param {Object} obj
     */
    function isObject(obj) {
      return obj && _typeof(obj) === 'object';
    }
    utils.isObject = isObject;

    /**
     * Check for array
     * @param {Object} obj
     */
    function isArray$1(obj) {
      if (Array.isArray) {
        return Array.isArray(obj);
      }
      return !!obj && obj.constructor === Array;
      // return Object.prototype.toString.call(obj) === '[object Array]';
    }
    Registry.setComponent('utils.isArray', isArray$1);

    /**
     * Check for number
     * @param {Object} n
     */
    function isNumber(n) {
      return typeof n === 'number' && !isNaN(n);
    }
    utils.isNumber = isNumber;

    function jsonStringify(obj, replacer) {
      if (defined(obj)) {
        return JSON.stringify(obj, replacer);
      }
      return UNDEFINED;
    }
    utils.jsonStringify = jsonStringify;

    /**
     *
     * @param {Object} obj
     * @param {String} key
     * @returns {*}
     */
    var getPropVal = utils.getPropVal = function (obj, key) {
      return isObjectPropDefined(obj, key, true);
    };
    /**
     *
     * @type {function(*=, *, *): *}
     */
    var setPropVal = utils.setPropVal = function (object, keySet, value) {
      keySet = keySet.replace(/\[(\w+)]/g, '.$1'); // convert indexes to properties
      keySet = keySet.replace(/^\./, ''); // strip a leading dot
      var keys = keySet.split('.');
      var add = function add(obj) {
        var key = keys.shift();
        if (key === null || keys.length === 0) {
          obj[key] = value;
          return false;
        } else if (obj[key] === null || _typeof(obj[key]) !== 'object') {
          obj[key] = !isNaN(parseInt(keys[0])) ? [] : {};
        }
        add(obj[key]);
      };
      add(object);
      return object;
    };

    function intersectObject(obj1, obj2) {
      if (!obj1 || !obj2) {
        return null;
      }
      var output = {},
        intersected;
      for (var prop in obj1) {
        if (obj1.hasOwnProperty(prop) && obj2.hasOwnProperty(prop)) {
          var val1 = obj1[prop],
            val2 = obj2[prop];
          if (val1 && (val1.constructor == Object || val1.constructor == Array)) {
            var i = intersectObject(val1, val2);
            if (i != null) {
              output[prop] = i;
              intersected = true;
            }
          } else if (val1 == val2) {
            output[prop] = val1;
            intersected = true;
          }
        }
      }
      return intersected ? output : null;
    }
    utils.intersectObject = intersectObject;

    /**
     *
     * @param {String} color
     * @returns {boolean}
     */

    function isDarkColor(color) {
      //TODO: consider alpha

      // http://stackoverflow.com/questions/2509443/check-if-uicolor-is-dark-or-bright/2509596#2509596
      // https://stackoverflow.com/questions/12043187/how-to-check-if-hex-color-is-too-black
      // https://stackoverflow.com/questions/24260853/check-if-color-is-dark-or-light-in-android
      // https://stackoverflow.com/questions/635022/calculating-contrasting-colours-in-javascript

      var rgb = d3_rgb(color);

      // return 1 - (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255 > 0.45;

      // return 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.r < 165; // zoho-reports version

      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000 < 128; // tiny color
    }
    utils.isDarkColor = isDarkColor;

    /**
     *
     * @param {String} color
     * @returns {boolean}
     */

    function isLightColor(color) {
      return !isDarkColor(color);
    }
    utils.isLightColor = isLightColor;

    /**
     *
     * @param {String} color
     * @returns {string}
     */

    function getContrastColor(color) {
      return isDarkColor(color) ? '#f8f8f8' : '#444444';
    }
    utils.getContrastColor = getContrastColor;

    /**
     *
     * @param {*} obj
     * @returns {boolean}
     */

    function isWindow(obj) {
      return obj != null && obj === obj.window;
    }
    utils.isWindow = isWindow;

    /**
     *
     * @param elem
     * @returns {boolean|DocumentView}
     */

    function getWindow(elem) {
      return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    utils.getWindow = getWindow;

    /**
     *
     * @param {Element} elem
     * @returns {{top: number, left: number}}
     */

    function offset(elem) {
      var box = elem.getBoundingClientRect(),
        doc = elem && elem.ownerDocument,
        docElem = doc.documentElement,
        win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    }
    utils.offset = offset;

    /**
     *
     * @param {String} str
     * @returns {Array}
     */
    function stringifiedArrayReverse(str) {
      if (!str) {
        return str;
      }

      return str.
      split(',').
      reverse().
      join();
    }
    utils.stringifiedArrayReverse = stringifiedArrayReverse;

    /**
     *
     * @returns {Boolean}
     */
    function isDocumentVisible() {
      return defined(document.visibilityState) && document.visibilityState !== 'visible'; //window blur state
    }
    utils.isDocumentVisible = isDocumentVisible;

    /**
     *
     * @param {Element} element
     * @param {Element} container
     * @param {Boolean|null} partial
     * @returns {boolean}
     */

    function elementIsVisible(element, container, partial) {
      var contHeight = container.offsetHeight,
        elemTop = offset(element).top - offset(container).top,
        elemBottom = elemTop + element.offsetHeight;
      return (
        elemTop >= 0 && elemBottom <= contHeight ||
        partial && (elemTop < 0 && elemBottom > 0 || elemTop > 0 && elemTop <= contHeight));

    }

    utils.elementIsVisible = elementIsVisible;

    /**
     * Return the first value that is defined.
     */

    var pick = function pick() {
      var args = arguments,
        i,
        arg,
        length = args.length;
      for (i = 0; i < length; i++) {
        arg = args[i];
        if (defined(arg)) {
          return arg;
        }
      }
      return args[length - 1];
    };
    utils.pick = pick;

    /**
     *
     * joins one or multiple arrays.
     * if the first argument is true, then remaining arrays will copied to the first array
     * else it copies all arrays to a new array.
     * @return {Array}
     */

    function arrayJoin() {
      // performance https://jsperf.com/array-prototype-push-apply-vs-concat/5
      // https://jsperf.com/arrayconcatvsarraypushapply
      // return target.concat(newObject)

      var args = toArray(arguments),
        copyToExisting = args[0] === true && args.shift(),
        target = copyToExisting ? args.shift() : [];

      if (copyToExisting && !args.length) {
        return target;
      }

      args.forEach(function (newObject) {
        var i = 0,
          c = newObject.length;
        for (; i < c; ++i) {
          target.push(newObject[i]);
        }
      });
      return target;
    }
    utils.arrayJoin = arrayJoin;

    function sortByLength(array) {
      return array.slice(0).sort(function (a, b) {
        // ASC  -> a.length - b.length
        // DESC -> b.length - a.length
        if (!defined(a)) {
          a = '';
        }
        if (!defined(b)) {
          b = '';
        }
        return b.length - a.length;
      });
    }
    utils.sortByLength = sortByLength;

    /*
    type - integer | string
     */
    function sortByIndices(array, type) {
      var len = array.length;
      var indices = new Array(len);
      for (var i = 0; i < len; ++i) {
        indices[i] = i;
      }
      indices.sort(function (i, j) {
        // ASC  -> a.length - b.length
        // DESC -> b.length - a.length
        var a = array[i],
          b = array[j];
        if (!defined(a)) {
          a = '';
        }
        if (!defined(b)) {
          b = '';
        }
        if (type == 'integer') {
          return b > a ? 1 : b < a ? -1 : 0;
        }
        return b.length > a.length ? 1 : b.length < a.length ? -1 : 0;
      });
      return indices;
    }
    utils.sortByIndices = sortByIndices;

    function isHidden(el) {
      return el.offsetParent === null;
    }
    utils.isHidden = isHidden;

    function each(obj, fn) {
      if (_typeof(obj) !== 'object') {
        return false;
      }

      if (isArray$1(obj) || typeof obj.length === 'number') {
        Array.prototype.forEach.call(obj, fn);
      } else {
        for (var attr in obj) {
          if (obj.hasOwnProperty(attr)) {
            fn(obj[attr], attr, obj);
          }
        }
      }
    }

    utils.each = each;

    /**
     * Extend one or more objects with the members of another
     * @param target
     * @returns {Object}
     */

    function extend(target) {
      if (!arguments[1]) {
        return;
      }
      for (var ii = 1, ll = arguments.length; ii < ll; ii++) {
        var source = arguments[ii];
        for (var prop in source) {
          if (!target[prop] && source.hasOwnProperty(prop)) {
            target[prop] = source[prop];
          }
        }
      }
      return target;
    }
    utils.extend = extend;

    /**
     * Inherits an Object
     * @param {Object|*} subClass
     * @param {Object|*} superClass
     */

    function inherit(subClass, superClass) {
      if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not ".concat(_typeof(superClass)));
      }
      var subClassProto = subClass.prototype;
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) {
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      // restore previous methods
      extend(subClass.prototype, subClassProto);
    }
    utils.inherit = inherit;

    /**
     *
     * @param {Array} array
     * @param {*} element
     * @returns {Array}
     */
    function removeElementFromArray(array, element) {
      var index = array.indexOf(element);
      if (index > -1) {
        array.splice(index, 1);
      }
      return array;
    }
    utils.removeElementFromArray = removeElementFromArray;

    /**
     *
     * Get the computed CSS value for given element and property, only for numerical
     * properties. For width and height, the dimension of the inner box (excluding
     * padding) is returned. Used for fitting the chart within the container.
     *
     * @param {HTMLElement} el - A HTML element.
     * @param {String} prop - The property name.
     * @param {Boolean} [convertToInt=true] - Parse to integer.
     * @returns {Number|*}
     */

    function getStyle(el, prop, convertToInt) {
      var style;

      if (el.isD3Selection) {
        el = el.node();
      }

      // For width and height, return the actual inner pixel size
      if (prop === 'width') {
        return mathMin(el.offsetWidth, el.scrollWidth) - getStyle(el, 'padding-left') - getStyle(el, 'padding-right');
      } else if (prop === 'height') {
        return mathMin(el.offsetHeight, el.scrollHeight) - getStyle(el, 'padding-top') - getStyle(el, 'padding-bottom');
      }

      // Otherwise, get the computed style
      style = window.getComputedStyle(el);

      if (style) {
        style = style.getPropertyValue(prop);
        if (pick(convertToInt, prop !== 'opacity')) {
          style = pInt(style);
        }
      }
      return style;
    }

    utils.getStyle = getStyle;

    /**
     *
     * @param element
     * @returns {boolean}
     */
    function isHTMLElement(element) {
      return element instanceof HTMLElement;
    }
    utils.isHTMLElement = isHTMLElement;

    /**
     * Check if an element is an array, and if not, make it into an array.
     */

    function splat(obj) {
      return isArray$1(obj) ? obj : [obj];
    }
    utils.splat = splat;

    function parseShortHandValue(value) {
      var t, r, b, l;
      if (defined(value)) {
        var parsedValue = value.toString().split(' ');

        t = pInt(priorityBasedValue([parsedValue[0], 0]));
        r = pInt(priorityBasedValue([parsedValue[1], parsedValue[0], 0]));
        b = pInt(priorityBasedValue([parsedValue[2], parsedValue[0], 0]));
        l = pInt(priorityBasedValue([parsedValue[3], parsedValue[1], parsedValue[0], 0]));
      } else {
        t = 0;
        r = 0;
        b = 0;
        l = 0;
      }

      return {
        top: t,
        right: r,
        bottom: b,
        left: l
      };
    }
    utils.parseShortHandValue = parseShortHandValue;

    function getBorderRadius(radius) {
      if (isObject(radius)) {
        return radius;
      }
      var parsedVal = {};
      var splittedStr = radius != null ? radius.toString().split('/') : null;
      var rx = splittedStr != null && splittedStr[0] != null ? splittedStr[0].split(' ') : [],
        ry = splittedStr != null && splittedStr[1] != null ? splittedStr[1].split(' ') : rx;

      /*
       * index 0-->topleft,  1-->topright,  2-->bottomright,  3-->bottomleft
       */
      parsedVal.tlx = pInt(priorityBasedValue([rx[0]]));
      parsedVal.tly = pInt(priorityBasedValue([ry[0], rx[0]]));

      parsedVal.trx = pInt(priorityBasedValue([rx[1], rx[0]]));
      parsedVal.trY = pInt(priorityBasedValue([ry[1], ry[0], rx[1], rx[0]]));

      parsedVal.brx = pInt(priorityBasedValue([rx[2], rx[0]]));
      parsedVal.bry = pInt(priorityBasedValue([ry[2], ry[0], rx[2], rx[0]]));

      parsedVal.blx = pInt(priorityBasedValue([rx[3], rx[1], rx[0]]));
      parsedVal.bly = pInt(priorityBasedValue([ry[3], ry[1], rx[3], rx[0]]));

      return parsedVal;
    }
    utils.getBorderRadius = getBorderRadius;

    /**
     *
     * @param priorities
     * @param defaultValue
     * @return {number|*}
     */

    function priorityBasedValue(priorities, defaultValue) {
      var value = null,
        size = priorities.length,
        i = 0;

      defaultValue = pick(defaultValue, 0);
      while (i < size && !defined(value)) {
        value = priorities[i] != null ? priorities[i] : null;
        i++;
      }
      return pick(value, defaultValue);
    }
    utils.priorityBasedValue = priorityBasedValue;

    /**
     *
     * @param {String} string
     * @return {String}
     */
    function toCapitalize(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    utils.toCapitalize = toCapitalize;

    /**
     *
     * @param {CanvasRenderingContext2D} context
     */
    function fixHDPI(context) {
      var canvas = context.canvas,
        pixelRatio = DEVICE_PIXEL_RATIO;
      canvas.style.width = "".concat(canvas.width, "px");
      canvas.style.height = "".concat(canvas.height, "px");

      canvas.setAttribute('width', canvas.width * pixelRatio);
      canvas.setAttribute('height', canvas.height * pixelRatio);
      context.scale(pixelRatio, pixelRatio);
      return context;
    }

    utils.fixHDPI = fixHDPI;

    /**
     *
     * @param {Array} array
     * @param {function} callback
     * @return {Array}
     */
    function arrayFind(array, callback) {
      if (Array.prototype.find) {
        return array.find(callback);
      } else {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
        var len = array.length >>> 0,
          i = 0;

        while (i < len) {
          var kValue = array[i];
          if (callback.call(callback, kValue, i, array)) {
            return kValue;
          }
          i++;
        }
        return undefined;
      }
    }

    utils.arrayFind = arrayFind;

    function moveArrayElement(array, from, to) {
      array.splice(to, 0, array.splice(from, 1)[0]);
    }

    utils.moveArrayElement = moveArrayElement;

    /**
     *
     * @param node
     * @return {*}
     */
    function getRootNode(node) {
      if (node.getRootNode) {
        return node.getRootNode();
      } else if (node.parentNode != null) {
        return getRootNode(node.parentNode);
      }
      return node;
    }
    utils.getRootNode = getRootNode;

    /**
     *
     * @param element
     * @return {boolean}
     */
    function isShadowElement(element) {
      return isShadowRoot(getRootNode(element));
    }

    utils.isShadowElement = isShadowElement;

    /**
     *
     * @param node
     * @return {boolean}
     */
    function isShadowRoot(node) {
      return node.nodeName === '#document-fragment' && node.constructor.name === 'ShadowRoot';
    }

    utils.isShadowRoot = isShadowRoot;

    /**
     *
     * @param element
     * @return {boolean}
     */
    function isElementOnDocument(element) {
      return isShadowElement(element) || document.body.contains(element);
      // if (isShadowElement(element)) {
      //     return d3.select(element).style("display") !== NONE;
      // } else {
      //     return document.body.contains(element)
      // }
    }
    utils.isElementOnDocument = isElementOnDocument;

    /**
     *
     * @param element
     * @return {boolean}
     */
    function isElementVisible(element) {
      return isElementOnDocument(element) && d3_select(element).style('display') !== NONE;
    }

    utils.isElementVisible = isElementVisible;

    /**
     *
     * @param node
     * @return {*}
     */
    function getRootBody(node) {
      var rootNode = getRootNode(node);
      if (isShadowRoot(rootNode)) {
        var fakeBodySelector = '_zc_fakeBody',
          fakeBody = rootNode.querySelector(".".concat(fakeBodySelector));

        if (!fakeBody) {
          fakeBody = document.createElement('div');
          fakeBody.className = fakeBodySelector;
          rootNode.appendChild(fakeBody);
        }
        return fakeBody;
      } else {
        return document.body;
      }
    }

    utils.getRootBody = getRootNode;

    /**
     *
     * @param element
     * @return {number}
     */
    function _getDocumentIndex(element) {
      return getRootNode(element).ZC_DOCUMENT_INDEX;
    }
    utils.getDocumentIndex = _getDocumentIndex;

    /**
     *
     * @param {d3.selection|HTMLElement}element
     * @return {*|ClientRect|DOMRect}
     */
    function getBoundingRect(element) {
      if (element.isD3Selection) {
        element = element.node();
      }

      if (defined(element) && isElementVisible(element)) {
        return element.getBoundingClientRect();
      }

      var t = {};
      t.x = t.y = t.width = t.height = t.top = t.left = t.right = t.bottom = 0;
      return t;
    }
    utils.getBoundingRect = getBoundingRect;

    function perToPx(val, dim, defaultVal) {
      return typeof val === 'string' && val.indexOf('%') > -1 ? dim * +val.replace(/%/g, '') * 0.01 : validateNullVal(val, defaultVal);
    }
    utils.perToPx = perToPx;

    /**
     *
     * @param obj
     * @return {any}
     */
    function _super(obj) {
      return Object.getPrototypeOf(obj.constructor.prototype);
    }
    utils._super = _super;

    /**
     *
     * @param {Array} array
     * @param {any} item
     * @return {boolean}
     */
    function arrayIncludes(array, item) {
      if (array.includes) {
        return array.includes(item);
      } else {
        return array.indexOf(item) > -1;
      }
    }
    utils.arrayIncludes = arrayIncludes;

    /**
     *
     * @type {arrayIncludes}
     */
    var stringIncludes = arrayIncludes;

    /**
     *
     * @param number
     * @param minMax
     * @return {boolean}
     */
    function numberIsBetween(number, minMax) {
      var min = Math.min.apply(Math, minMax),
        max = Math.max.apply(Math, minMax);
      return number >= min && number <= max;
    }
    utils.numberIsBetween = numberIsBetween;

    /**
     *
     * @param property
     * @return {boolean}
     */
    function isStylePropertySupported(property) {
      return property in document.documentElement.style;
    }
    utils.isStylePropertySupported = isStylePropertySupported;

    /**
     *
     * @param obj
     * @return {boolean}
     */
    function isEmptyObject(obj) {
      return !defined(obj) || Object.keys(obj).length === 0 && obj.constructor === Object;
    }
    utils.isEmptyObject = isEmptyObject;

    /**
     *
     * @param {[[number, number], [number, number]]} bound
     * @return {{x: *, width: number, y: *, height: number}}
     */
    function boundToRect(bound) {
      return {
        x: bound[0][0],
        y: bound[0][1],
        width: mathAbs(bound[1][0] - bound[0][0]),
        height: mathAbs(bound[1][1] - bound[0][1])
      };
    }
    utils.boundToRect = boundToRect;

    /**
     * returns distinct values in an array
     * @param {Array} array
     * @return {Array}
     */
    function getDistinct(array, accessor) {
      var values = _toConsumableArray(new Set(array).values());

      if (accessor) {
        values = values.map(accessor);
      }

      return values;
    }
    utils.getDistinct = getDistinct;

    /**
     * @param  {Object} obj [description]
     * @return {Array}     [description]
     */
    function objectValues(obj) {
      if (Object.values) {
        return Object.values(obj);
      }

      return Object.keys(obj).map(function (key) {return obj[key];});
    }
    utils.objectValues = objectValues;

    /**
     *
     * @return {number}
     */
    var getScrollbarWidth = function () {
      // Creating invisible container
      var scrollbarWidth = null;
      return function () {
        if (defined(scrollbarWidth)) {
          return scrollbarWidth;
        }

        var outer = d3_select(document.body || document.documentElement).
        append('div').
        styles({
          width: '100%',
          visibility: 'hidden',
          overflow: 'scroll',
          '-ms-overflow-style': 'scrollbar'
        });

        var inner = outer.append('div').styles({
          width: '100%'
        });

        // Calculating difference between container's full width and the child width
        scrollbarWidth = outer.node().offsetWidth - inner.node().offsetWidth;

        // Removing temporary elements from the DOM
        outer.remove();

        return scrollbarWidth;
      };
    }();

    utils.getScrollbarWidth = getScrollbarWidth;

    /**
     *
     * @param element
     * @return {boolean}
     */
    var elementIsScrollable = function elementIsScrollable(element) {var measureName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'height';
      if (element.isD3Selection) {
        element = element.node();
      }
      return measureName === 'width' ? element.scrollWidth > element.offsetWidth : element.scrollHeight > element.offsetHeight;
    };

    utils.elementIsScrollable = elementIsScrollable;

    /*
    accessor - callback function to acccess the key
    a - array of data
    x - search value
    returns array of indices where the search value present in the given array
     */
    function searchIndex(accessor) {
      return function (a, x) {
        var _i = [];
        a.map(function (d, i) {
          if (accessor(d) == x) {
            _i.push(i);
          }
        });
        return _i;
      };
    }
    utils.searchIndex = searchIndex;

    function objectEntries(obj) {
      if (Object.entries) {
        return Object.entries(obj);
      } else {
        // Polyfill
        var ownProps = Object.keys(obj),
          i = ownProps.length,
          resArray = new Array(i); // preallocate the Array

        while (i--) {
          resArray[i] = [ownProps[i], obj[ownProps[i]]];
        }

        return resArray;
      }
    }
    utils.objectEntries = objectEntries;

    function firstAndLastItem(array) {
      if (isArray$1(array)) {
        return [array[0], array[array.length - 1]];
      }
      return array;
    }
    utils.firstAndLastItem = firstAndLastItem;

    /**
     *
     * @param xs
     * @param key
     * @return {*}
     */
    function groupBy(xs, key) {
      return xs.reduce(function (rv, x) {
        (rv[x[key]] = rv[x[key]] || []).push(x);
        return rv;
      }, {});
    }

    utils.groupBy = groupBy;

    /**
     *
     * @param obj
     * @param except
     */
    function destroyObjectProperties(obj, except) {
      /**
       *
       * @param val
       * @param n
       */
      function fn(val, n) {
        // If the object is non-null and destroy is defined

        if (val && val !== except) {
          // Invoke the remove
          val.remove && val.remove();
          // Invoke the destroy
          val.destroy && val.destroy();
        }

        // remove the timeouts
        // if (isNumber(val)) {
        // clearTimeout(val);
        // clearInterval(val);
        // }

        // Delete the property from the object.
        obj[n] = null;
        delete obj[n];
      }

      for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
          fn.call(obj[key], obj[key], key, obj);
        }
      }
    }

    utils.destroyObjectProperties = destroyObjectProperties;

    /**
     *
     * @param partialValue
     * @param totalValue
     * @return {number}
     */
    function calculatePercentage(partialValue, totalValue) {
      return 100 * partialValue / totalValue;
    }

    //function-utils.js

    /**
     *
     * @param {Function|*}object
     * @returns {boolean}
     */
    function isFunction(object) {
      return !!(object && object.constructor && object.call && object.apply);
    }

    /**
     * @param  {Function} main [description]
     * @param  {Function} sub  function1, function2, function3...
     * @return {Function}      [description]
     */
    function extendFunction(main) {for (var _len = arguments.length, sub = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {sub[_key2 - 1] = arguments[_key2];}
      return function () {
        var self = this,
          arg = arguments;

        main.apply(self, arg);
        sub.forEach(function (func) {return func.apply(self, arg);});
      };
    }

    //$Id$
    //d3polyfill.js
    d3_zc.rebind = function (target, source) {
      var i = 1,
        n = arguments.length,
        method;
      while (++i < n) {
        target[method = arguments[i]] = rebindMethods(target, source, source[method]);
      }
      return target;
    };
    function rebindMethods(target, source, method) {
      return function () {
        var value = method.apply(source, arguments);
        return value === source ? target : value;
      };
    }

    // find all the points within radius
    (function (d3) {
      // the idea has taken from here https://bl.ocks.org/enjalot/778182a0cae1c2ff60186f7e7c1d350f
      d3.quadtree.prototype.findAll = function (x, y, radius, sizeOffset) {
        var tree = this,
          points = {
            points: [],
            visited: []
          };

        tree._size =
        tree._size ||
        function () {
          return 0;
        };

        // object is rectangle
        if (isObject(radius)) {
          // radius is extent [[x1 y1], [x2, y2]]
          tree.visit(withinRect(radius, points.points, points.visited, tree));
        } else {
          tree.visit(nearest({ x: x, y: y }, radius, sizeOffset, points.points, points.visited, tree));
        }

        return points;
      };

      /**
       *
       * @param radiusController
       * @return {d3.quadtree}
       */
      d3.quadtree.prototype.size = function (sizeController) {
        if (isFunction(sizeController)) {
          this._size = sizeController;
        }
        return this;
      };

      /**
       *
       * @param mouse
       * @param radius
       * @param hits
       * @param visits
       * @param tree
       * @return {function(*, *, *, *, *): boolean}
       */
      function nearest(mouse, radiusOffset, sizeOffset, hits, visits, tree) {
        var r = radiusOffset,
          nx1 = mouse.x - r,
          nx2 = mouse.x + r,
          ny1 = mouse.y - r,
          ny2 = mouse.y + r;

        return function (quad, x1, y1, x2, y2) {
          if (!quad.length) {
            visits.push(quad.data);
            do {
              if (quad.data) {
                var x = mouse.x - tree._x(quad.data),
                  y = mouse.y - tree._y(quad.data),
                  l = mathSQRT(x * x + y * y);

                if (l <= tree._size(quad.data) / 2 + sizeOffset) {
                  //offset 10
                  hits.push(quad.data);
                }
              }
            } while (quad = quad.next);
          }
          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        };
      }

      function withinRect(extent, points, visited, tree) {
        var x0 = extent[0][0],
          y0 = extent[0][1],
          x3 = extent[1][0],
          y3 = extent[1][1];

        return function (quad, x1, y1, x2, y2) {
          if (!quad.length) {
            do {
              var d = quad.data;
              var x = tree._x(d),
                y = tree._y(d);
              visited.push(d);
              if (x >= x0 && x < x3 && y >= y0 && y < y3) {
                points.push(d);
              }
            } while (quad = quad.next);
          }
          return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
        };
      }
    })(d3_zc);

    d3_zc.selection.prototype.first = function () {
      return d3_zc.select(this.nodes()[0]);
    };
    d3_zc.selection.prototype.last = function () {
      return d3_zc.select(this.nodes()[this.size() - 1]);
    };

    // remove all listeners
    d3_zc.selection.prototype.removeAllListeners = function () {var _this2 = this;
      var listeners;
      if (listeners = this.node() && this.node().__on) {
        listeners.forEach(function (listener) {return _this2.on(".".concat(listener.name), NULL$1);});
      }
      return this;
    };

    // for identifying d3 selection
    d3_zc.selection.prototype.isD3Selection = true;

    //$Id$
    //element-constants.js
    var TEXT_ELEMENT = 'text',
      TSPAN_ELEMENT = 'tspan',
      PATH_ELEMENT = 'path',
      CIRCLE_ELEMENT = 'circle',
      RECT_ELEMENT = 'rect',
      LINE_ELEMENT = 'line',
      DIV_ELEMENT = 'div',
      SVG_ELEMENT = 'svg';

    //$Id$

    var $ZCG = {};
    $ZCG.fontFamily = "'Roboto','Open Sans',sans-serif";
    $ZCG.fontColor = '#616161';
    $ZCG.fontStyle = null;
    $ZCG.fontWeight = null;
    $ZCG.fontL1Size = null;
    $ZCG.fontL2Size = null;
    $ZCG.fontL3Size = null;

    function calculateGlobalFontSize(userdata, globalFontSize, chartFontSize, denominator) {
      var props = toArray(arguments).slice(4),
        temp = null,
        fontSize;

      for (var i = 0, len = props.length; i < len + 1; i++) {
        fontSize = i === len ? null : getPropVal(userdata, props[i]);
        temp = calcfontSize(denominator, null, fontSize, globalFontSize, chartFontSize);
        if (isNumber(fontSize)) {
          break;
        }
      }
      return temp;
    }

    function setGlobalPropByUserdata(userdata, denominator, chartProp) {
      // denominator is an object. It contains {"width": chart_width, "height": chart_height}

      $ZCG.globalProp = {};

      //font size
      chartProp.fontL1Size = calculateGlobalFontSize(userdata, $ZCG.fontL1Size, chartProp.fontL1Size, denominator, 'canvas.fontSize');
      chartProp.fontL2Size = calculateGlobalFontSize(
      userdata,
      $ZCG.fontL2Size,
      chartProp.fontL2Size,
      denominator,
      'chart.fontSize',
      'canvas.fontSize');


      //font color
      $ZCG.globalProp.fontL1Color = null;
      $ZCG.globalProp.fontL2Color = null;

      //font family
      $ZCG.globalProp.fontL1Family = null;
      $ZCG.globalProp.fontL2Family = null;

      //font style
      $ZCG.globalProp.fontL1Style = null;
      $ZCG.globalProp.fontL2Style = null;

      //font weight
      $ZCG.globalProp.fontL1Weight = null;
      $ZCG.globalProp.fontL2Weight = null;

      //text shadow
      $ZCG.globalProp.textShadow = null;

      //animation
      var userAnimation = pick(getPropVal(userdata, 'chart.plot.animation'), {});

      $ZCG.globalProp.animation = {};
      $ZCG.globalProp.animation.enabled = userAnimation.enabled !== false;
      $ZCG.globalProp.animation.duration = userAnimation.duration || null;
      $ZCG.globalProp.animation.easingType = userAnimation.easingType || null;

      //datalabels
      $ZCG.globalProp.datalabels = {};
      chartProp.datalabels = chartProp.datalabels == null ? {} : chartProp.datalabels;
      $ZCG.globalProp.datalabels.enabled = null;
      chartProp.datalabels.fontSize = calculateGlobalFontSize(
      userdata,
      $ZCG.fontL3Size,
      chartProp.datalabels.fontSize,
      denominator,
      'chart.plot.datalabels.fontSize',
      'chart.fontSize',
      'canvas.fontSize');


      $ZCG.globalProp.datalabels.fontColor = null;
      $ZCG.globalProp.datalabels.fontFamily = null;
      $ZCG.globalProp.datalabels.fontStyle = null;
      $ZCG.globalProp.datalabels.fontWeight = null;

      //events
      $ZCG.globalProp.events = {};
      $ZCG.globalProp.events.mouseMove = null;
      $ZCG.globalProp.events.mouseOut = null;
      $ZCG.globalProp.events.click = null;
      $ZCG.globalProp.events.doubleClick = null;

      return chartProp;
    }

    /*
     * font size are calculated based on viewport of the chart placeholder.
     * L1 to L5 sizes are defined, based on the width and height which ever is minimum, the font-size is set.
     * */
    function calcfontSize(dimension, multiplier, customFontSize, globalFontSize, chartFontProp) {
      var denominator = mathMin(dimension.width, dimension.height);
      var globalMultiplier = isObjectPropDefined(fontProperties, 'ratio') && fontProperties.ratio;
      if (typeof globalMultiplier === 'function') {
        globalMultiplier = globalMultiplier(dimension);
      }
      multiplier = multiplier == null ? globalMultiplier && !isNaN(globalMultiplier) ? globalMultiplier : 0.038 : multiplier;

      var defaultSize = mathRound(denominator * multiplier);

      $ZCG.minL1Size = fontProperties.minsize;
      $ZCG.maxL1Size = fontProperties.maxsize;
      var min = $ZCG.minL1Size,
        max = $ZCG.maxL1Size;
      defaultSize = defaultSize < min ? min : defaultSize > max ? max : defaultSize;

      if (customFontSize != null) {
        multiplier = pInt(customFontSize) * multiplier / defaultSize;
        defaultSize = mathRound(denominator * multiplier);
        defaultSize = defaultSize < min ? min : defaultSize > max ? max : defaultSize;
      }
      var chartFontProp = globalFontSize == null ? chartFontProp == null ? {} : chartFontProp : globalFontSize;
      chartFontProp.size = defaultSize;
      chartFontProp.l1 = function () {
        return chartFontProp.size;
      };
      chartFontProp.l2 = function () {
        return chartFontProp.size - 2;
      };
      chartFontProp.l3 = function () {
        return chartFontProp.size - 3;
      };
      chartFontProp.l4 = function () {
        return chartFontProp.size - 4;
      };
      chartFontProp.l5 = function () {
        return chartFontProp.size - 5;
      };
      chartFontProp.l8 = function () {
        return chartFontProp.size - 8;
      };

      return chartFontProp;
    }

    /*Helpful for Developement
     * defining DOMBorder will show you the area division lines in the chart
     * */
    $ZCG.DOMBorder = 'none';

    //set Global patternSVG
    function setGlobalPatternSVG(patternSVG) {
      $ZCG.patternSVG = patternSVG;
    }

    //browser-detect.js

    var $Browser = new function () {
      this.NETSCAPE = 0;
      this.FIREFOX = 0;
      this.OPERA = 0;
      this.IE = 0;
      this.SAFARI = 0;
      this.MOZILA = 0;
      this.CHROME = 0;
      this.NONIE = 1;
      this.WEBKIT = 0;
      var agent = navigator.userAgent.toLowerCase();
      this.OSX = agent.indexOf('mac') != -1;
      this.WINDOWS = agent.indexOf('windows') != -1;
      this.LINUX = agent.indexOf('linux') != -1;
      this.IPHONE = agent.indexOf('iphone') != -1;
      this.IPAD = agent.indexOf('ipad') != -1;
      this.ANDROID = agent.indexOf('android') != -1;
      this.IS_IOS = this.IPHONE || this.IPAD;
      this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
      this.isMouseDevice = !(this.IS_IOS || this.ANDROID || agent.indexOf('mobile') != -1);
      this.uiwebview = this.IS_IOS && !/safari/.test(agent);
      this.PHANTOMJS = agent.indexOf('phantomjs') !== -1;
      this.WKWebView = this.uiwebview && agent.indexOf('wkwebview') != -1;
      var prefix = '';
      this.detect = function () {
        var agent = navigator.userAgent;
        var uaLen = agent.length;
        var vendor = navigator.vendor;
        var operaObject = window.opera;
        var versionSub = '';
        if (operaObject) {
          this.OPERA = 1;
          prefix = 'o';
        } else if (agent.indexOf('Chrome') > -1) {
          this.CHROME = 1;
          versionSub = 'Chrome/';
          prefix = 'webkit';
        } else if (agent.indexOf('Firefox') > -1) {
          this.FIREFOX = 1;
          versionSub = 'Firefox/';
          prefix = 'moz';
        } else if (agent.indexOf('MSIE ') > -1 || agent.indexOf('Trident/') > -1) {
          this.IE = 1;
          versionSub = 'MSIE ';
          prefix = 'ms';
        } else if (vendor.indexOf('Apple') > -1) {
          this.SAFARI = 1;
          versionSub = 'Version/';
          prefix = 'webkit';
        } else {
          versionSub = 'Unknown Browser';
        }
        this.VERSION = agent.substring(agent.indexOf(versionSub), uaLen).match(/[0-9\.]+/)[0];
      };
      this.detect();
      this.NONIE = !this.IE;
      this.WEBKIT = this.SAFARI || this.CHROME;
      this.prefix = {
        lowercase: prefix,
        css: prefix ? "-".concat(prefix, "-") : prefix, //prefix = "" if browser is unknown
        js: prefix ? prefix[0].toUpperCase() + prefix.substr(1) : prefix //prefix = "" if browser is unknown
      };
    }();

    Registry.setComponent('browser', $Browser);

    //$Id$

    var defaultTheme = function defaultTheme(userProp) {
      //userProp for getting fontSize wrt chartObj not globally
      var defaulttheme = {
        canvas: {
          fontFamily: $ZCG.globalProp.fontL1Family, //Note: import font to your application if it is not supported by the browser.
          fontColor: $ZCG.globalProp.fontL1Color,
          fontSize: userProp.fontL1Size.l3,
          fontWeight: $ZCG.globalProp.fontL1Weight, //normal || bold || bolder || lighter || 100 || 200 || 300 || 400 || 500 || 600 || 700 || 800 || 900
          fontStyle: $ZCG.globalProp.fontL1Style, //normal || italic || oblique

          title: {
            show: true,
            text: 'Title comes here',
            hAlign: 'left',
            vAlign: 'top',
            marginTop: 10,
            marginRight: 0,
            marginBottom: 0,
            marginLeft: 10,
            target: 'newtab',
            fontSize: userProp.fontL1Size.l1
          },
          subtitle: {
            show: true,
            text: 'Description comes here',
            hAlign: 'left',
            vAlign: 'top',
            marginTop: 0,
            marginRight: 0,
            marginBottom: 0,
            marginLeft: 10,
            target: 'newtab',
            fontSize: userProp.fontL1Size.l2
          },
          background: {
            alpha: 1,
            color: '#FFFFFF'
          },

          border: {
            show: true,
            size: 1,
            style: 'solid',
            radius: 1,
            color: '#cccccc'
          },

          shadow: {
            show: true,
            x: 1,
            y: 1,
            color: 'rgba(0,0,0,0.1)',
            blur: 2,
            inset: false
          },
          intelligence: {
            dimension: {
              title: 100, // 0 or null -> don't remove
              subtitle: 120, // 0 or null -> don't remove
              xaxis: 70, // 0 or null -> don't remove
              xaxislabel: 80,
              yaxis: 70, // 0 or null -> don't remove
              yaxislabel: 80,
              legend: 140, // 0 or null -> don't remove
              credits: 150, // 0 or null -> don't remove
              marker: 50
            },
            dataCount: {
              marker: 300, //null -> don't remove
              animation: 300, //null -> don't remove
              datalabels: 300 //null -> don't remove
            }
          }
        },
        legend: {
          enabled: true,
          colorPallete: {
            type: 'multicolor', //muticolor || monochrome
            options: {
              multicolor: 'countries',
              monochrome: {
                baseColor: 'red',
                count: 5,
                colorGamma: [0.3, 0.9]
              }
            }
          },
          hAlign: 'right', //left, right, center
          vAlign: 'top', //top, center, bottom.
          fontSize: userProp.fontL1Size.l5,
          textPadding: 5,
          itemMargin: 3,
          marginTop: 10,
          marginRight: 10,
          marginBottom: 10,
          marginLeft: 10,
          colorBox: {
            shape: 'square', //square,circle,diamond,bean,butterfly,clover,cloverFour,cross,ellipse,heart,triangle-up,triangle-down,arrow,rocket,malteseCross,asterisk,gear
            strokeWidth: 2
          },
          colorBand: {},
          title: {
            show: false,
            text: 'Legend',
            fontSize: userProp.fontL1Size.l4,
            keepAligned: false
          },
          background: {
            color: 'transparent',
            alpha: 0
          },
          border: {
            show: true,
            size: 1,
            style: 'solid',
            radius: 0,
            color: 'transparent'
          },
          itemDisabledStyle: {
            //css properties except margin alignment and visibility properties
            color: '#d1d1d1',
            patternColor: '#ffffff',
            strikeout: false
          },
          shadow: {
            show: false,
            color: 'rgba(0,0,0,0.3)',
            x: 2,
            y: 2,
            blur: 3,
            inset: false
          },
          filter: {
            enabled: true,
            slider: {
              tooltip: {
                fontSize: userProp.fontL1Size.l5
              }
            }
          },
          highlightEffect: {
            selectedSeries: null, //diagonalPattern,circlePattern,crossStripes,horizontalStripes,strokeEnlarge
            unselectedSeries: 'none' //fadeOut || blur || grayscale || saturate || none
          },
          expandable: {
            fontSize: userProp.fontL1Size.l5
          },
          size: {}
        },
        chart: {
          behaviour: {
            resetButton: {
              enabled: false,
              fillColor: '#3c3c3c',
              label: {
                marginTop: 6,
                marginRight: 10,
                marginBottom: 6,
                marginLeft: 10,
                fontSize: 14,
                fontColor: 'white',
                fontWeight: 500
              },
              border: {
                show: true,
                size: 1,
                radius: 2,
                color: 'transparent'
              }
            }
          },
          marginTop: 10,
          marginRight: 10,
          marginBottom: 10,
          marginLeft: 10,
          fontSize: userProp.fontL2Size.l3,
          zoom: {
            enabled: false,
            type: 'x'
          },
          brush: {
            enabled: false,
            type: 'x'
          },
          effects: {
            choice: 'auto', //Choices: auto, dropShadow, chalk, freehand
            options: {
              dropShadow: {
                dx: '5',
                dy: '5',
                blur: '3',
                color: 'rgba(0,0,0,0.6)'
              },
              freeHand: {
                scale: 7
              }
            }
          },
          plot: {
            renderer: {
              // this option is under development
              mode: window.rendererMode || 'svg',
              image: {
                source: 'auto', // auto | <any url>
                addDimensionInSource: false, // paramas are plotWidth & plotHeight
                exportUrl: ''
              }
            },
            morph: {
              enabled: false,
              duration: 1000,
              samplingDistance: 5
            },
            background: {
              alpha: 1,
              color: 'transparent',
              gradients: {
                show: false,
                type: 'radial'
              },
              image: {}
            },
            border: {
              show: false,
              size: 1,
              style: 'solid', //solid, shortdash, shortdot, shortdashdotdot, dotted, dashed, longdash, dashdot, longdashdot, longdashdotdot
              radius: 0,
              color: '#ececec'
            },
            animation: {
              enabled: $ZCG.globalProp.animation.enabled,
              easingType: $ZCG.globalProp.animation.easingType,
              duration: $ZCG.globalProp.animation.duration
            },
            datalabels: {
              renderOnInit: false,
              animation: {
                enabled: false
              },
              show: $ZCG.globalProp.datalabels.enabled,
              handleOverlapping: true,
              fontSize: userProp.datalabels.fontSize.l5,
              boundBox: {
                strokeColor: $ZCG.fontColor,
                fillColor: 'white'
              }
            },
            events: {
              cursor: null,
              click: $ZCG.globalProp.events.click, // On click on the plot, user function can be binded, el and event will be passed
              mousemove: $ZCG.globalProp.events.mouseMove, // on hovering the plot, user function can be binded, el and event will be passed
              mouseout: $ZCG.globalProp.events.mouseOut, //on mouseout the plot, user function can be binded, el and event will be passed
              doubleclick: $ZCG.globalProp.events.doubleClick, //on mouseout the plot, user function can be binded, el and event will be passed
              contextmenu: null, // right click event
              init: null,
              onload: null
            },
            plotoptions: {}
          },
          axes: defaultTheme.axes ? defaultTheme.axes(userProp) : {}
        },
        map: defaultTheme.map ? defaultTheme.map() : {},
        tooltip: {
          enabled: true,
          fontSize: userProp.fontL1Size.l5,
          opacity: 0.8,
          zindex: 2000,
          view: 'normal', //normal | column
          crosshair: {
            type: 'none',
            color: 'grey'
          },
          pointerEvents: 'none'
        },
        noDataHandler: {
          text: 'No Data',
          fontSize: userProp.fontL1Size.l1
        },
        loader: {
          type: 'none', //zBlocks, zBars, zCircle1, zCircle2, zCrossBars, wheel, snake
          fontSize: userProp.fontL1Size.l3
        }
      };
      return defaulttheme;
    };

    var getDefaultOptions = function getDefaultOptions(type, source, userProp) {
      var options;
      switch (type) {
        case 'zoom':
          options = defaultTheme.zoom(userProp);
          break;
        case 'brush':
          options = defaultTheme.brush(userProp);
          break;
        case 'scroll':
          //To implement NAVIGATOR later
          options = defaultTheme.scroll();
          break;
        case 'legend':
          options = {};
          break;

        case 'credits':
          options = defaultTheme.credits(userProp);
          break;

        case 'notes':
          options = defaultTheme.notes(userProp);
          break;

        case 'bar':
        case 'barrange':
          options = defaultTheme.bar();
          break;

        case 'line':
          options = defaultTheme.line();
          break;
        case 'area':
          options = defaultTheme.area();
          break;
        case 'arearange':
          options = defaultTheme.arearange();
          break;
        case 'scatter':
        case 'geoscatter':
          options = defaultTheme.scatter(type);
          break;
        case 'bubblepie':
        case 'geobubblepie':
          options = defaultTheme.pie(type);
          break;
        case 'pie':
          options = defaultTheme.pie(type);
          break;

        case 'funnel':
          options = defaultTheme.funnel();
          break;

        case 'web':
          options = defaultTheme.web();
          break;

        case 'pyramid':
          options = defaultTheme.pyramid();
          break;
        case 'sunburst':
          options = defaultTheme.sunburst();
          break;

        case 'dial':
          options = defaultTheme.dial(userProp);
          break;
        case 'bubble':
        case 'geobubble':
          options = defaultTheme.bubble();
          break;

        case 'packedbubble':
          options = defaultTheme.packedbubble();
          break;
        case 'bullet':
          options = defaultTheme.bullet(userProp);
          break;
        case 'gantt':
          options = defaultTheme.gantt();
          break;
        case 'treemap':
          options = defaultTheme.treemap();
          break;
        case 'heatmap':
          options = defaultTheme.heatmap();
          break;
        case 'geoheatmap':
          options = defaultTheme.geoheatmap();
          break;
        case 'dotgrid':
          options = defaultTheme.dotgrid();
          break;
        case 'waterfall':
          options = defaultTheme.waterfall();
          break;
        case 'wordcloud':
          options = defaultTheme.wordcloud();
          break;
        case 'size':
          options = defaultTheme.sizeLegend ? defaultTheme.sizeLegend(userProp) : {};
          break;
        case 'shape':
          options = defaultTheme.shapeLegend ? defaultTheme.shapeLegend(userProp) : {};
          break;
        case 'color':
          options = defaultTheme(userProp).legend;
          break;
        case 'boxplot':
          options = defaultTheme.boxplot();
          break;
        case 'sankey':
          options = defaultTheme.sankey();
          break;
        case 'metadata':
          options = {
            axes: {
              x: [0],
              y: [[1]],
              tooltip: [0, 1]
            },
            columns: [
            {
              dataindex: 0,
              columnname: '',
              datatype: 'numeric'
            },
            {
              dataindex: 1,
              columnname: '',
              datatype: 'numeric'
            }]

          };
          break;}

      return options;
    };

    var setDefaultOptions = function setDefaultOptions(type, source, userProp, options, dontFetchDefault) {
      if (!dontFetchDefault) {
        //or To fetch default options from above
        options = getDefaultOptions(type, source, userProp);
      }
      var dest = source[type] == null ? source[type] = {} : source[type];
      mergeJSON$1(options, dest, true, true);
      source[type] = options;
      return options;
    };

    //$Id$

    function Mark(mark, selector) {var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1];var options = arguments.length > 3 ? arguments[3] : undefined;
      return _objectSpread({
        mark: mark,
        selector: selector,
        data: data,
        children: [] },
      options);

    }

    Registry.setComponent('mark', Mark);

    //$Id$

    function MarkerParser(spec) {
      var selection = spec.selection,data = spec.data,event = spec.event;

      var mark = Mark('point', selection, data);
      mark.config = convertConfig(spec);
      mark.event = event;
      return mark;
    }

    function convertConfig(spec) {
      var config = spec.config,prefix = spec.prefix,_spec$defsPath = spec.defsPath,defsPath = _spec$defsPath === void 0 ? getDefsLocation() : _spec$defsPath,_spec$context = spec.context,context = _spec$context === void 0 ? d3_select(document.body).select('svg.svgPattern') : _spec$context,
        names = ['fillOpacity', 'strokeOpacity', 'strokeWidth', 'dashStyle', 'lineCap'],
        colors = ['fillColor', 'strokeColor'],
        _static = ['size', 'x', 'y', 'angle', 'imageUrl'],
        _config = {};

      names.forEach(function (_) {return _config[_] = prefix ? pick(config[prefix + toCapitalize(_)], config[_]) : config[_];});
      colors.forEach(function (_) {return _config[_] = (prefix ? config[prefix + toCapitalize(_)] : config[_]) || config.color;});
      _static.forEach(function (_) {return _config[_] = config[_];});
      _config.shape = config.shape || config.symbol;
      _config.dashStyle = _config.strokeWidth ? _config.dashStyle : null;

      var url = config.url || config.imageUrl;
      if (url) {
        var imageSize = splat(getVal(config.size))[0];
        _config.fillColor = {
          url: url,
          context: context,
          defsPath: defsPath,
          width: imageSize,
          height: imageSize,
          x: -imageSize / 2,
          y: -imageSize / 2,
          _type: 'image'
        };
      }

      return _config;
    }

    Registry.setComponent('marker.parser', MarkerParser);

    function getTspanBoundingClientRect(tspan) {var scaleFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      var range = document.createRange();
      range.selectNode(tspan);
      var rect = range.getClientRects(),
        actBoundBox = rect[1] || rect[0];

      range.detach(); // frees up memory in older browsers
      // if (actBoundBox && ($Browser.FIREFOX || $Browser.SAFARI)) {
      //     // TODO: check in phantomjs, firefox, safari - bar33 (remove if not necessary)
      //     (actBoundBox.width = actBoundBox.width * scaleFactor), (actBoundBox.height = actBoundBox.height * scaleFactor);
      // }
      return actBoundBox || { x: 0, y: 0, width: 0, height: 0 };
    }

    function getDefaultBoundingClientRect(text) {
      return text.getBoundingClientRect();
    }

    /**
     *
     * @param text
     * @param fontSize
     * @param fontFamily
     * @param {{fontFamily: string, fontSize: number, fontStyle: string}} styles
     * @returns {{width: *, height: *}}
     */

    function getTextBound(text, fontSize, fontFamily, styles, dontUseEmpirical, fontStyle, fontWeight) {
      var hasMultipleLines = isArray$1(text),
        w,
        h,
        y,
        dy,
        imageW,
        imageH,
        fontHeight = utils.fontUtils.getTextHeight(text, fontSize, fontFamily, fontStyle, fontWeight, dontUseEmpirical);

      if (hasMultipleLines) {
        text.forEach(function (d, i) {
          var hasCustomTick;
          if (defined(styles) && styles.length) {
            hasCustomTick = true;
            fontSize = styles[i].fontSize || fontSize;
            fontFamily = styles[i].fontFamily || fontFamily, y = styles[i].y, dy = styles[i].dy;
            imageW = text.width;
            imageH = text.height;
          }
          var tempWid = imageW || utils.fontUtils.getTextWidth(d, fontSize, fontFamily, fontStyle, fontWeight);
          fontHeight = imageH || utils.fontUtils.getTextHeight(d, fontSize, fontFamily, fontStyle, fontWeight);

          if (defined(w)) {
            if (hasCustomTick) {
              w = defined(y) || defined(dy) ? mathMax(w, tempWid) : w + tempWid;
            } else {
              w = mathMax(w, tempWid);
            }
          } else {
            w = tempWid;
          }
          // w = !defined(w) ? tempWid : mathMax(w, tempWid);
          if (defined(h)) {
            if (hasCustomTick) {
              h = defined(y) || defined(dy) ? h + 1.1 * fontHeight : h;
            } else {
              h = h + 1.1 * fontHeight;
            }
          } else {
            h = fontHeight;
          }

          // w = !defined(w) ? tempWid : mathMax(w, tempWid);
          // h = !defined(h) ? fontHeight : h + 1.1 * fontHeight;
        });
      } else {
        if (defined(styles)) {
          fontSize = styles.fontSize || fontSize;
          fontFamily = styles.fontFamily || fontFamily;
          imageW = text.width;
          imageH = text.height;
        } else if (text && text.type == 'group') {
          //for custom tick with 'g' tag
          imageW = text.width;
          imageH = text.height;
        }
        w = imageW || utils.fontUtils.getTextWidth(text, fontSize, fontFamily, fontStyle, fontWeight);
        h = imageH || utils.fontUtils.getTextHeight(text, fontSize, fontFamily, fontStyle, fontWeight, dontUseEmpirical);
      }

      return {
        width: w,
        height: h
      };
    }

    //$Id$
    var patternThemes = {};

    var addPattern = function addPattern(name, type, size, strokeWidth, strokeClr, bgClr, fillOpacity, strokeOpacity, translate) {
      patternThemes[name] = {
        type: type || 'diagonal-line-right',
        size: size || 5,
        strokeWidth: strokeWidth || 1,
        bgClr: bgClr,
        stroke: strokeClr,
        fillOpacity: fillOpacity || 1,
        strokeOpacity: strokeOpacity || 1,
        translate: translate
      };
    };
    var getPattern = function getPattern(name) {
      return {
        type: patternThemes[name].type,
        size: patternThemes[name].size,
        strokeWidth: patternThemes[name].strokeWidth,
        bgClr: patternThemes[name].bgClr,
        stroke: patternThemes[name].stroke,
        fillOpacity: patternThemes[name].fillOpacity,
        strokeOpacity: patternThemes[name].strokeOpacity,
        translate: patternThemes[name].translate
      };
    };
    Registry.setComponent('patterns.get', getPattern);

    function generateDefaultPatternTheme() {
      addPattern('hatch', 'diagonal-line-right', '5', '1', 'null', 'white', '1', '1');
      addPattern(
      'hatchDash',
      'square,diagonal-line-right',
      '5,5',
      '1',
      'transparent,{{brighter}}',
      'transparent,transparent',
      '1',
      '1',
      '0,3');

      addPattern(
      'thinThickHatch',
      'square,diagonal-line-right,diagonal-line-right',
      '10,10,10',
      '1,1,3',
      'transparent,null,null',
      TRANSPARENT,
      '1',
      '1',
      '0,2.5,0');

      addPattern(
      'thinThickHatchLeft',
      'square,diagonal-line-left,diagonal-line-left',
      '10,10,10',
      '1,1,3',
      'transparent,null,null',
      TRANSPARENT,
      '1',
      '1',
      '[0,[2.5,-2.5],0]');

      addPattern('thickHatch', 'diagonal-line-right', '5', '3', 'null', 'white', '1', '1');
      addPattern('thinHatch', 'diagonal-line-right', '2', '1', 'null', 'white', '1', '1');
      addPattern('hatchLeft', 'diagonal-line-left', '5', '1', 'null', 'white', '1', '1');
      addPattern('horizontalStripes', 'horizontal-line', '5', '1', 'null', 'white', '1', '1');
      addPattern('thinHorizontalStripes', 'horizontal-line', '2', '1', 'null', 'white', '1', '1');
      addPattern('verticalStripes', 'vertical-line', '5', '1', 'null', 'white', '1', '1');
      addPattern('thinVerticalStripes', 'vertical-line', '2', '1', 'null', 'white', '1', '1');
      addPattern('crossStripes', 'vertical-line,horizontal-line', '5', '1', 'null', 'white', '1', '1');

      addPattern('tinyHatchfill', 'square,diagonal-line-right', '5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern('hatchfill', 'square,diagonal-line-right', '10', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern('hatchLeftfill', 'square,diagonal-line-left', '10', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern('hatchDashfill', 'square,diagonal-line-right', '5,5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1', '0,3');
      addPattern('tinyHatchLeftfill', 'square,diagonal-line-left', '5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern('horizontalStripesfill', 'square,horizontal-line', '5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern('verticalStripesfill', 'square,vertical-line', '5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern('crossStripesfill', 'square,square', '5,5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern('checkerBoard', 'square,square,square', '10,5,5', '1', TRANSPARENT, 'transparent,null,{{brighter}}', '1', '1', '0,0,5');

      addPattern('circle', 'circle', '10', '1', 'null', 'white', '1', '1');
      addPattern('tinyCircle', 'circle', '5', '1', 'null', 'white', '1', '1');
      addPattern('crossCircle', 'square,circle,circle', '10,5,5', '1', 'transparent,null,{{brighter}}', TRANSPARENT, '1', '1', '0,0,5');
      addPattern('floatingCircle', 'square,circle', '10,5', '1', 'transparent,{{brighter}}', TRANSPARENT, '1', '1', '0,2.5');
      addPattern('dot', 'square,circle', '5,2.5', '1', 'transparent,{{brighter}}', 'transparent,transparent', '1', '1', '0,1.25');
      addPattern('dotSquare', 'square,circle', '10,2.5', '1', 'null,{{brighter}}', 'transparent,transparent', '1', '1', '0,3.75');

      addPattern('circlefill', 'square,circle', '10,10', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
      addPattern(
      'crossCirclefill',
      'square,circle,circle',
      '10,5,5',
      '1',
      'transparent,null,{{brighter}}',
      'null,{{brighter}},null',
      '1',
      '1',
      '0,0,5');

      addPattern('floatingCirclefill', 'square,circle', '10,5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1', '0,2.5');
      addPattern('dotfill', 'square,circle', '5,2.5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1', '0,1.25');

      addPattern('square', 'square', '5', '1', 'null', 'white', '1', '1');
      addPattern('squarefill', 'square', '5', '1', '{{brighter}}', 'null', '1', '1');

      addPattern('star', 'star', '10', '1', 'null', 'white', '1', '1');
      addPattern('starfill', 'square,star', '10,5', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');

      addPattern('wave', 'waves', '5', '1', 'null', 'white', '1', '1');
      addPattern('wavefill', 'square,waves', '10,10', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');

      addPattern('cap', 'caps', '5', '1', 'null', 'white', '1', '1');
      addPattern('capfill', 'square,caps', '10,10', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');

      addPattern('nylon', 'nylon', '5', '1', 'null', 'white', '1', '1');
      addPattern('nylonfill', 'square,nylon', '10,10', '1', 'transparent,{{brighter}}', 'null,transparent', '1', '1');
    }

    function addPatternThemeByEle(ele) {
      return { ele: ele };
    }

    //$Id$

    var effects = function effects() {};
    Registry.setComponent('effects', effects);

    effects.get = function (module, submodule, properties, args) {
      args = args || {};
      var offset = args.offset,
        dimension = args.dimension,
        returnSVGimage = args.returnSVGimage,
        base64 = args.base64,
        chartObj = args.chartObj,
        defaultModule = args.moduleType == 'svgPattern' ? effects.svg_patterns : null;
      module = module || defaultModule;
      if (!((submodule != null || submodule != '') && module[submodule])) {
        return;
      }

      var renderToSvg;

      if (chartObj && chartObj.getPatternSvg) {
        renderToSvg = chartObj.getPatternSvg();
      } else {
        renderToSvg = pick(args.renderTo, $ZCG.patternSVG);
        if (!renderToSvg.isD3Selection) {
          renderToSvg = d3_select(renderToSvg);
        }
      }

      /* Generate PatternID and check the pattern if already generated with the PatternID
       * If already exist return the patternID to apply
       * else create new pattern and return patternID.
       * */
      var effectID = "zp".concat(generateIdByPropValue(properties, submodule)),
        effectEle;

      if (effectID == null) {
        return;
      }

      var documentIndex = _getDocumentIndex(renderToSvg.node()),
        EFFECTS_STORE = DOCUMENT_OBJECT_HOLDER && documentIndex && DOCUMENT_OBJECT_HOLDER[documentIndex].EFFECTS;

      if (EFFECTS_STORE && defined(EFFECTS_STORE[effectID])) {
        effectEle = EFFECTS_STORE[effectID];
        if (returnSVGimage) {
          return effectEle;
        }
        return effectEle.id || effectEle;
      }

      effectEle = module[submodule](properties, effectID, offset, returnSVGimage, base64, chartObj, renderToSvg);
      if (effectEle) {
        if (EFFECTS_STORE) {
          EFFECTS_STORE[effectID] = effectEle;
        }
        if (returnSVGimage) {
          return effectEle;
        }
        return effectEle.id || effectEle; //for filters returns id, for patterns returns element. Need to make it common
      }
    };

    function getChartEffects(chartObj) {
      var systemconf = chartObj.systemConf,
        effectName = systemconf.chart.effects.choice;
      var effect = effects.svg_filters[effectName];
      if (!effect) {
        return;
      }
      if (chartObj.chartTypes[0].value === charttype.wordcloud) {
        return;
      }

      var properties = systemconf.chart.effects.options[effectName];
      if (effectName === 'dropShadow') {
        properties.blur = mathMax(0, properties.blur);
      }
      var effectID = effects.get(effects.svg_filters, effectName, properties, { chartObj: chartObj });
      return effectID;
    }

    function getGradientProp(gradient, dimension, color, opacity) {
      var type = gradient.type;
      if (!type || type === NONE) {
        return;
      }
      var options = gradient.options[type] || gradient.options;
      var prop = simpleClone(options);
      prop.color = color != null ? color : prop.color;
      prop.opacity = opacity != null ? opacity : prop.opacity;
      prop.dimension = dimension != null ? dimension : prop.dimension;
      prop.type = type;
      // prop.defsLocation = chartObj ? chartObj.defsLocation : "";
      return prop;
    }

    function getPatternProp(pattern, baseClr, opacity, customPatternDim, customClr) {
      var prop = patternThemes[pattern] ? getPattern(pattern) : addPatternThemeByEle(pattern);
      prop.bgClr_base = baseClr;
      prop.stroke_base = baseClr;
      prop.fillOpacity = prop.fillOpacity || opacity;
      prop.customStaticClr = customClr;
      if (customPatternDim) {
        prop.x = customPatternDim.x,
        prop.y = customPatternDim.y,
        prop.width = customPatternDim.width,
        prop.height = customPatternDim.height;
      }
      return prop;
    }
    function getPatternSize(properties, size) {
      var patternSize = size.map(function (d, i) {
        var s = parseInt(d);
        var rem = properties.width % s;
        var quo = parseInt(properties.width / s) || 1; //if pattern size is greater than properties.width
        var partial = rem / quo;
        return partial + s;
      });
      return patternSize;
    }
    function applyEffect(element, options) {
      var effect = options.effect,_options$config = options.config,config = _options$config === void 0 ? {} : _options$config,chartObj = options.chartObj;
      if (!effect && chartObj) {
        effect = getChartEffect(config, chartObj);
      }

      element.
      selectAll(
      '*:not(text):not(span):not(b):not(strong):not(i):not(em):not(mark):not(small):not(del):not(ins):not(sub):not(sup):not(.expandable):not(.minorTicks):not(.domain):not(.zc-connector-line)').

      filter(function () {
        return !this.childElementCount;
      }).
      style('filter', effect);
    }

    function getChartEffect(config, chartObj) {
      var effect = config.useChartEffect !== false && chartObj.filterEffectsID;
      return effect ? "url(".concat(chartObj.defsLocation, "#").concat(effect, ")") : null;
    }

    //$Id$

    var dashStyles = {
      solid: '',
      shortdash: '1.5,1.5',
      shortdot: '0.1,1.5',
      dashed: '2.5,2.5',
      longdash: '5,5',
      dotted: '0.1,2.5',
      shortdashdotdot: '1.5,2,0.1,2,0.1,2',
      dashdot: '2.5,2.5,0.1,2.5',
      longdashdot: '5,5,0.1,5',
      longdashdotdot: '5,2.5,0.1,2.5,0.1,2.5'
    };

    function getDashArray(dashStyleName, strokeWidth, scaleRatio) {
      var inList = defined(dashStyles[dashStyleName]),
        dashStyle = pick(dashStyles[dashStyleName], dashStyleName, null),
        _;

      if (!defined(dashStyle) || dashStyleName === 'solid') {
        return [];
      }

      strokeWidth = inList ? pick(strokeWidth, 1) : 1;
      if (scaleRatio) {
        strokeWidth *= scaleRatio;
      }

      if (isArray$1(dashStyle)) {
        _ = dashStyle;
      } else {
        _ = dashStyle.split(',');
      }
      return _.map(function (e) {
        return +e * strokeWidth;
      });
    }

    function getLineCap(lineCap, dashStyle) {
      return lineCap || (dashStyle && /dot/g.test(dashStyle) ? 'round' : null);
    }

    function applyMarquee(element, dur, strokeDashArray, chart) {
      var dashoffset = strokeDashArray.reduce(function (prev, current) {
        return current + prev;
      }, 0);

      element.
      attr('stroke-dasharray', strokeDashArray).
      attr('stroke-dashoffset', dashoffset).
      transition().
      duration(dur).
      ease(d3_ease_linear).
      attr('stroke-dashoffset', 0).
      on('end', function () {
        if (chart && chart.chartRendered) {
          applyMarquee(element, dur, strokeDashArray, chart);
        }
      });
    }

    //$Id$
    //align-constants.js
    var CENTER_ALIGN = 'center',
      LEFT_ALIGN = 'left',
      RIGHT_ALIGN = 'right',
      BOTTOM_ALIGN = 'bottom',
      TOP_ALIGN = 'top',
      FIXEDTOP_ALIGN = 'fixedTop',
      VERTICAL_ALIGN = 'vertical',
      HORIZONTAL_ALIGN = 'horizontal',
      INNER_ALIGN = 'inner',
      OUTER_ALIGN = 'outer',
      START_ALIGN = 'start',
      MIDDLE_ALIGN = 'middle',
      END_ALIGN = 'end';

    var TEXT_ANCHOR_MAP = {
      center: MIDDLE_ALIGN,
      right: END_ALIGN,
      left: START_ALIGN
    };

    //$Id$

    function getTspanTemplate(showAs) {
      var newShowAs = '';
      if (isArray$1(showAs)) {
        showAs.forEach(function (d, i) {
          newShowAs += "<tspan class='zcTspan'".concat(i ? " dy='1.1em'" : '', ">").concat(updateTspanTemplate(d), "</tspan>");
        });
      } else {
        var tagIndex = showAs.indexOf('<tspan');
        if (tagIndex != -1) {
          newShowAs = "<tspan class='zcTspan'>".concat(updateTspanTemplate(showAs), "</tspan>");
        } else {
          newShowAs = showAs;
        }
      }
      return newShowAs;
    }

    function updateTspanTemplate(showAs) {
      var str = '',
        lastIndex = 0,
        endTagLength = 8,
        t = {
          '<tspan': [],
          '</tspan>': []
        };

      showAs.replace(/<tspan|<\/tspan>/g, function () {
        t[arguments[0]].push(arguments[1]);
      });

      t['<tspan'].forEach(function (d, i) {
        if (lastIndex != d) {
          str += "<tspan>".concat(showAs.substring(lastIndex, d), "</tspan>");
        }
        str += showAs.substring(d, lastIndex = t['</tspan>'][i] + endTagLength);
      });

      if (lastIndex != showAs.length) {
        str += "<tspan>".concat(showAs.substring(lastIndex, showAs.length), "</tspan>");
      }

      return str;
    }

    function translateTspan(ele, x) {
      ele.selectAll('tspan.zcTspan').attr('x', x);
    }

    function trimAllTspan(labelText, chartObj, tranform, fontSize, edge, b, boundboxPadding, xy) {var preCalculation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};
      if (!b.length) {
        // ZC3001 Error: before chart rendering, tab switching may happen.
        return;
      }

      var dx = +tranform[0],
        dy = +tranform[1],
        plotarea = chartObj.plotarea,
        margin = {
          left: -fontSize,
          right: -fontSize,
          top: 0,
          bottom: 0
        },
        pattern = '..',
        orient = BOTTOM_ALIGN,
        useBBox = preCalculation.useBBox;
      boundboxPadding = boundboxPadding || 0;

      edge = edge || {
        left: -dx + boundboxPadding,
        top: -dy,
        right: plotarea.width - dx - boundboxPadding,
        bottom: plotarea.height - dy
      };

      labelText.each(function () {var _this3 = this;
        var children = this.childNodes,
          childCount = 0,
          parentWidth;

        if (!useBBox) {
          parentWidth = getParentWidth(this, edge, boundboxPadding, preCalculation);
        }var _loop = function _loop()

        {
          if (useBBox) {
            parentWidth = getParentWidth(_this3, edge, boundboxPadding, preCalculation);
          }

          node = children[i],
          c = node.childNodes,
          totalWidth = node.getComputedTextLength(),
          textContent = '';

          //collect all text contents
          for (j = 0; j < c.length; j++) {
            curTextContent = c[j].textContent;
            textContent += curTextContent;
            b[childCount + j].textLength = curTextContent.length;
          }

          // trim the text
          if (totalWidth - parentWidth > 1) {
            //#ZC1113
            bb = b[childCount].bbox;
            textBound = {
              left: bb.x + (xy ? xy[0] : 0),
              top: bb.y + (xy ? xy[1] : 0),
              width: totalWidth,
              height: bb.height
            };
            trimText(c[0], textContent, textBound, edge, orient, pattern, margin, null, null, false);

            // distribute the text contents to the respective tspan
            innerHTML = c[0].innerHTML;
            if (innerHTML === '..') {
              innerHTML = '';
            }

            if (useBBox) {
              var newB = getTspanBound(d3_select(_this3), fontSize, useBBox);
              b.forEach(function (_b, i) {return newB[i].textLength = _b.textLength;});
              b = newB;
            }

            for (j = 0, start = 0; j < c.length; j++) {
              curTextLength = b[childCount + j].textLength;
              c[j].innerHTML = innerHTML.substring(start, start + curTextLength);
              start += curTextLength;
            }
          }
          childCount += useBBox ? c.length : c.length - 1;
        };for (var i = 0; i < children.length; i++) {var node, c, totalWidth, textContent, j, curTextContent, bb, textBound, innerHTML, j, start, curTextLength;_loop();}
      });
    }

    function getParentWidth(node, edge, boundboxPadding, preCalculation) {
      var parentBBox = bbox(node),
        parentWidth = preCalculation.useBBox ? parentBBox.width : node.getComputedTextLength();

      if (parentBBox.x + parentWidth > edge.right) {
        parentWidth -= parentBBox.x + parentWidth - edge.right + boundboxPadding;
      }
      if (parentBBox.x < edge.left) {
        parentWidth -= edge.left - parentBBox.x + boundboxPadding;
      }
      return parentWidth;
    }

    function getTspanBound(label, fontSize, useBBox) {
      var c = label.selectAll(function () {
          return this.childNodes;
        }),
        anchor = label.attr('text-anchor'),
        X = +label.attr('x'),
        Y = +label.attr('y'),
        o = [],
        DY = 0;

      c.each(function (_, m) {
        if (!isVisibleTspan(this)) {
          if (useBBox) {
            o.push({});
          }

          return;
        }

        var ele = d3_select(this),
          nodeDY = parseFloat(ele.attr('dy') || 0),
          children = this.childNodes,
          totalWidth = this.getComputedTextLength(),
          oldRef = anchor === 'middle' ? -totalWidth / 2 : anchor == 'end' ? -totalWidth : 0;
        DY += nodeDY;

        for (var i = 0; i < children.length; i++) {
          var currentWidth = children[i].getComputedTextLength();
          var info = {
            dy: DY,
            dx: oldRef + (anchor === 'middle' ? currentWidth / 2 : 0),
            bbox: { x: X + oldRef, y: Y + DY * fontSize, width: children[i].getComputedTextLength(), height: fontSize },
            style: children[i].style,
            text: children[i].textContent,
            id: m + '_' + i
          };
          o.push(info);
          oldRef += currentWidth;
        }
      });
      return o;
    }

    function getCustomHTML(element, pool) {
      pool = pool || [];
      element.each(function (d, i) {
        var children = d3_select(this).selectAll('*');
        if (children.size()) {
          children.each(function () {
            getCustomHTML(d3_select(this), pool);
          });
        } else {
          var bb = bbox(this),
            nodeName = this.nodeName;
          if (nodeName === TSPAN_ELEMENT) {
            if (this.textContent === '') {
              //If tspan is trimmed and text content is nothing, getTspanBoundingClientRect(this) will return null
              return;
            }

            var parentNode = findParentTextNode(this),
              parentBCR = getTspanBoundingClientRect(parentNode),
              bcr = getTspanBoundingClientRect(this);
            bb.x += bcr.left - parentBCR.left;
            bb.y += bcr.top - parentBCR.top;
            bb.width = bcr.width;
            bb.height = bcr.height;
          }
          pool.push({
            node: this,
            nodeName: nodeName,
            bb: bb
          });
        }
      });
      return pool;
    }

    function findParentTextNode(node) {
      if (node.parentNode.nodeName !== TEXT_ELEMENT) {
        return findParentTextNode(node.parentNode);
      }
      return node.parentNode;
    }

    /**
     * Return all visible tspan
     * @param  {HTMLElement} ele
     * @return {Array}     Array of HTMLElement
     */
    function getVisibleTspan(ele) {
      var nodes = ele.selectAll('tspan.zcTspan').nodes();

      return Array.prototype.filter.call(nodes, isVisibleTspan);
    }

    /**
     * Return whether the tspan is visible or not
     * @param  {HTMLElement} ele
     * @return {Boolean}
     */
    function isVisibleTspan(node) {
      var minSize = $Browser.PHANTOMJS || $Browser.IE ? 1 : 0,
        bb = getTspanBoundingClientRect(node);

      return bb.width > minSize && bb.height > minSize; //why 1: in phantomjs eventhough tspan is empty getTspanBoundingClientRect returns {width: 1, height: 1} instead of {width: 0, height: 0}  FEATURES_DATALABEL_10
    }

    function getLeafAxisOrder(axisOrder, clusterCount, axisType, chartObj) {
      if (clusterCount == null) {
        var hierarchical = chartObj.dataObject.hierarchical,
          tag = axisType == 'y' ? 'row' : 'column',
          nodeList = hierarchical.pivotLayout.getRootNodeList(tag);
        clusterCount = nodeList.getClustersCount();
      }

      return axisOrder % clusterCount;
    }

    function getAxisDataIndex(axisType, axisOrder, chartObj) {
      var hierarchical = chartObj.dataObject.hierarchical,
        isCategoryHierarchy = chartObj.dataObject.categoryHierarchy,
        tag = axisType == 'y' ? 'row' : 'column';
      if (hierarchical) {
        var nodeList = hierarchical.pivotLayout.getRootNodeList(tag);
        if (nodeList.getCount() || nodeList.hasMultiCluster()) {
          var clustersCount = nodeList.getClustersCount(),
            leavesCount = nodeList.getLeavesCount(),
            isLeafAxisType = isLeafAxis(axisType, axisOrder, chartObj),
            leafAxisOrder = getLeafAxisOrder(axisOrder, clustersCount);
          if (isLeafAxisType) {
            return leafAxisOrder;
          } else {
            return 0;
          }
        }
        return axisOrder;
      }
      return axisOrder;
    }

    function isCategoryHierarchical(chartObj) {
      return chartObj.dataObject && chartObj.dataObject.hierarchical && chartObj.dataObject.hierarchical.categoryTree;
    }

    function hasBranchAxis(axisType, chartObj) {
      var tag = axisType == 'x' ? 'column' : 'row',
        nodeList = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList(tag);

      return nodeList.getCount();
    }

    function isBranchAxis(axisType, axisOrder, chartObj) {
      var tag = axisType == 'x' ? 'column' : 'row',
        nodeList = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList(tag),
        leavesCount = nodeList.getLeavesCount();

      return axisOrder > leavesCount - 1;
    }

    function isLeafAxis(axisType, axisOrder, chartObj) {
      var tag = axisType == 'x' ? 'column' : 'row',
        nodeList = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList(tag),
        leavesCount = nodeList.getLeavesCount();

      return axisOrder < leavesCount;
    }

    function getBranchDepth(axisType, axisOrder, chartObj) {
      var tag = axisType == 'x' ? 'column' : 'row',
        nodeList = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList(tag),
        leavesCount = nodeList.getLeavesCount();

      if (leavesCount > 1) {
        return axisOrder - leavesCount;
      }
      return axisOrder - 1;
    }
    function isRootBranchAxis(axisType, axisOrder, chartObj) {
      var axesCount = chartObj.getAxesCount(axisType);

      return axisOrder == axesCount - 1;
    }

    function showAxisLabelForTree(axisType, axisOrder, chartObj) {
      if (axisType == 'x') {
        return isRootBranchAxis(axisType, axisOrder, chartObj);
      } else {
        return isLeafAxis(axisType, axisOrder, chartObj) || isRootBranchAxis(axisType, axisOrder, chartObj);
      }
    }

    function getAxisAreaDim(axisType, axisOrder, orient, chartObj, plotarea) {
      var hierarchical = chartObj.dataObject.hierarchical;
      if (hierarchical && hierarchical.pivot) {
        if (axisType == 'y' && isLeafAxis(axisType, axisOrder, chartObj)) {
          var tag = axisType == 'x' ? 'column' : 'row',
            nodeList = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList(tag),
            dimension = orient == 'left' || orient == 'right' ? 'height' : 'width',
            obj = {};
          obj[dimension] = (nodeList.leafSize * axisOrder + nodeList.leafSize / 2) * 2; //To calculate the relative position to locate axislabel
          return obj;
        }
        return plotarea;
      } else {
        return plotarea;
      }
    }

    function isFacet(chartObj) {
      var dataObject = chartObj.dataObject;
      if (!dataObject) {
        return false;
      }

      var hierarchical = dataObject.hierarchical;
      return hierarchical && hierarchical.pivot;
    }

    //$Id$
    //datatype-constants.js
    var ORDINAL_DATATYPE = 'ordinal',
      TIME_DATATYPE = 'time',
      NUMERIC_DATATYPE = 'numeric',
      ORDINAL_NON_LINEAR_DATATYPE = 'ordinalNonLinear';

    //encode-helpers.js

    var encodeMethods = {};

    /**
     * @param  {String} type        [description]
     * @param  {Number} key         [description]
     * @param  {Number} seriesIndex [description]
     */
    encodeMethods.saveEncode = function (type, key, seriesIndex, seriesData) {
      var processor = this,
        encodes = processor.encodes[type] = processor.encodes[type] || {},
        encode = encodes[key];

      if (!encode) {
        encode = encodes[key] = {
          seriesData: [],
          seriesIndices: []
        };
      }

      var currentSeriesData = processor.processedseriesData[seriesIndex];
      encode.seriesData.push(seriesData || currentSeriesData);
      encode.seriesIndices.push(seriesIndex);
    };

    /**
     * @param  {String} type [description]
     * @param  {Number} key  [description]
     * @return {Object}      [description]
     */
    encodeMethods.getEncode = function (type, key) {
      var processor = this,
        encodes = processor.encodes[type] || {};

      if (arguments.length > 1) {
        key = key || 0;
        return encodes[key];
      }

      return encodes;
    };

    /**
     * @param  {String} type [description]
     * @param  {Number} key  [description]
     * @return {Object}      [description]
     */
    encodeMethods.filterEncode = function (type, accessor) {
      var processor = this,
        encodes = processor.encodes[type] || {};

      if (arguments.length > 1) {
        var keys = objectValues(encodes);
        return keys.filter(function (d) {
          return accessor(d);
        });
      }

      return encodes;
    };

    function getGridList(processor) {
      var pivotLayout = processor.hierarchical.pivotLayout,
        layers = pivotLayout.getRootNodeList('layer'),
        panes = layers.panes;

      return objectValues(panes);
    }

    function getCurrentRendererIndex(panes, paneIndex) {
      var rendererIdx = 0,
        arr = objectValues(panes);var _loop3 = function _loop3(i)

      {
        var currentPaneIndex = arr[i].index === i ? i : arr.filter(function (d) {return d.index === i;})[0];
        rendererIdx += arr[currentPaneIndex].data.length;
      };for (var i = 0; i < paneIndex; i++) {_loop3(i);}

      return rendererIdx;
    }

    //$Id$
    //labeltype-constants.js
    //labeltype-constants.js

    var DATALABELS_LABELTYPE = 'datalabels',
      STACKLABELS_LABELTYPE = 'stackLabels',
      INNERLABEL_LABELTYPE = 'innerLabel',
      PARENTLABELS_LABELTYPE = 'parentLabels';

    //

    var globalLocale,
      namedLocale = {};

    function setLocale() {
      if (arguments.length > 1) {
        var _arguments2 = Array.prototype.slice.call(arguments),name = _arguments2[0],locale = _arguments2[1];
        namedLocale[name] = locale;
      } else {
        globalLocale = arguments[0];
      }
    }

    function getLocale(name) {
      return name ? namedLocale[name] : globalLocale;
    }

    //$Id$

    function getFormattedValue(colInfo, value, dataType, chartObj, type, toDecode, arraySeperator, levelIndex) {
      if (!dataType) {
        return encodeOrDecode(value);
      }
      if (value == null || value.constructor == Array && value[0] === null) {
        return colInfo && colInfo.nullformatting != null ?
        encodeOrDecode(invokeFunction(colInfo.nullformatting, value, dataType, colInfo, type, chartObj)) :
        value;
      }
      var format = colInfo ? colInfo["".concat(type, "format")] || colInfo.format : null;
      if (!format || !Object.keys(format).length) {
        format = getDefaultFormat(dataType, colInfo);
      }
      return value.constructor == Array //For partition charts, array of values will come here to format
      ? value.
      map(function (d) {
        return applyFormat(d);
      }).
      join(defined(format.arraySeperator) ? format.arraySeperator : arraySeperator) :
      applyFormat(value);

      function applyFormat(value) {
        if (dataType === TIME_DATATYPE && !format.customFormat) {
          value = generateDateVal(value, format, colInfo);
        } else if (
        dataType === NUMERIC_DATATYPE && (
        type === 'axis' || type === STACKLABELS_LABELTYPE || type === DATALABELS_LABELTYPE && chartObj.dataObject.isHierarchy) &&
        typeof value === 'number')
        {
          if (countDecimals(value) > 12) {
            //Test_895.json
            value = parseFloat(value.toFixed(12)); //To avoid javascript floating point issue in axis ticks Test_559.json
          }
        }

        if (levelIndex && format.customFormat) {
          colInfo = simpleClone(colInfo);
          colInfo.levelindex = levelIndex;
        }
        var formattedValue =
        typeof format === 'function' ?
        format(value, dataType, colInfo) :
        format.customFormat ?
        invokeFunction(format.customFormat, value, dataType, colInfo, type, chartObj) :
        generateFormatSpecifier(format, value, colInfo, dataType, levelIndex, type, chartObj);
        return encodeOrDecode(formattedValue);
      }

      function encodeOrDecode(val) {
        return toDecode != false ? decodeHTML(val) : encodeHTML(val);
      }
    }

    function getDefaultFormat(type, colInfo) {
      var defaultFormat = {};
      switch (type) {
        case 'time':
          if (colInfo && colInfo.groupby) {
            defaultFormat = {};
          } else if (colInfo && colInfo.subfunction) {
            defaultFormat = getTimeSubfunctionFormatter(colInfo.subfunction, colInfo.useUTC, colInfo.locale);
          } else {
            defaultFormat.specifier = 'YYYY';
          }

          break;
        case 'numeric':
          defaultFormat.thousandSeperator = ',';
          break;
        case 'geo':{
            // nothing yet
            break;
          }
        case 'percent':
          defaultFormat.decimalPlaces = 1;
          defaultFormat.suffix = '%';
          defaultFormat.trailingZeros = false;}

      return defaultFormat;
    }

    function generateFormatSpecifier(format, value, colInfo, dataType, levelIndex, type, chartObj) {
      var _ref = colInfo || {},locale = _ref.locale;
      var formattedValue;
      switch (dataType) {
        case 'time':{
            // if useUTC is true use utc time formatter else use local time formatter
            var d3Format = colInfo && colInfo.useUTC === true ? getFormatter('time', locale, 'utcFormat') : getFormatter('time', locale);
            var specifier = format.specifier,
              groupOrder;

            if (defined(colInfo)) {
              groupOrder = isArray$1(colInfo.groupby) ? colInfo.groupby : colInfo.AUTO_GROUP_ORDER; //#ZC1015
            }

            if (isArray$1(specifier) || isArray$1(groupOrder)) {
              //For multiple line lables with the given array of specifier
              formattedValue = [];
              specifier = specifier || [null];
              if (defined(levelIndex)) {
                specifier = defined(specifier) ? [specifier[levelIndex]] : [null];
              }
              specifier = isArray$1(specifier) ? specifier : [specifier];
              // specifier = (defined(levelIndex)) ? [specifier[levelIndex]] : specifier; //for timegroupby with specifier index
              specifier.forEach(function (d, i) {
                var datetimespecifier = generated3TimeSpecifier(d),
                  formatter = generateTimeFormatter(d3Format, datetimespecifier, colInfo, levelIndex);
                formattedValue[i] = formatter ? formatter(value) : value;
              });
              if (type == DATALABELS_LABELTYPE) {
                formattedValue = formattedValue && formattedValue.toString();
              }
            } else if (!specifier) {
              var dateTimeSpecifier = getDefaultFormat(dataType, colInfo);
              formattedValue = dateTimeSpecifier(value);
            } else {
              var datetimespecifier = generated3TimeSpecifier(specifier);
              if (specifier === 'auto' || datetimespecifier == null) {
                formattedValue = value;
              } else {
                if (CUSTOM_SPECIFIER_REGEX.test(datetimespecifier)) {
                  var formatter = generateTimeFormatter(d3Format, datetimespecifier, colInfo, levelIndex);
                  formattedValue = formatter(value);
                } else {
                  formattedValue = d3Format(datetimespecifier)(value);
                }
              }
            }
            break;
          }
        case 'ordinal':{
            var lc = format.letterCase;
            value += ''; //toString
            formattedValue = lc ?
            lc === 'uppercase' ?
            value.toUpperCase() :
            lc === 'lowercase' ?
            value.toLowerCase() :
            toCapitalize(value) :
            value;
            break;
          }
        case 'geo':{
            var mapWith = format.mapBy,
              lc = format.letterCase;
            formattedValue = value;

            if (mapWith) {
              var feature = chartObj.dataObject.userMapFeatures.get(value);

              if (feature && feature.properties && feature.properties[mapWith]) {
                formattedValue = feature.properties[mapWith];
              }
            }
            formattedValue = lc ?
            lc === 'uppercase' ?
            formattedValue.toUpperCase() :
            lc === 'lowercase' ?
            formattedValue.toLowerCase() :
            formattedValue[0].toUpperCase() + formattedValue.substring(1).toLowerCase() :
            formattedValue;
            break;
          }
        default:{
            if (format.type == 'decimal' && pInt(value) != value) {
              return ''; // Test_558.json
            }

            var decimalPlaces = format.decimalPlaces;
            value = format.type == 'decimal' || decimalPlaces === 0 ? parseFloat(value) : value; //Decimal places = 0
            var currency = format.currency;
            var numericspecifier = generated3NumericSpecifier(format, null, locale, value),
              toRemoveTrailingZeros = false;
            formattedValue = numericspecifier(value);

            if (/(e|s)/gi.test(getd3NumericFormatterType(format))) {
              if (defined(decimalPlaces)) {
                formattedValue = formattedValue.replace(/[^a-z]+/i, function () {
                  return generated3NumericSpecifier(format, ".".concat(decimalPlaces, "f"), locale)(arguments[0]);
                });
              } else {
                toRemoveTrailingZeros = true;
              }
            } else if (defined(decimalPlaces) && decimalPlaces > 0) {
              formattedValue = formattedValue.replace(/[^a-z]+/i, function () {
                var number = +arguments[0].replace(/,/g, ''),
                  fixedNumber = toFixedNumber(number, decimalPlaces);

                return generated3NumericSpecifier(format, ".".concat(decimalPlaces, "f"), locale)(fixedNumber);
              });
            }

            if (format.signEnabled === false) {
              //1) null -> shows sign for -ve only 2) true -> shows sign for +ve and -ve 3) false -> no sign shown for both +ve and -ve
              formattedValue = formattedValue.substring(1, formattedValue.length);
            }

            if (!validateNullVal(format.trailingZeros, true) || toRemoveTrailingZeros) {
              // Remove trailing zeros
              var unitSuffix = '';
              formattedValue = formattedValue.replace(/[a-z]+(\+|-)*(\d)*$/i, function () {
                unitSuffix = arguments[0];
                return '';
              });

              formattedValue =
              formattedValue.replace(/\.(\d)*0*$/gi, function () {
                var matchedString = arguments[0];
                return !parseFloat(matchedString) ?
                '' : ".".concat(

                exponentialToDecimal(+matchedString).
                toString().
                split('.')[1]);
                //Test_822.json, ZC1418
              }) + unitSuffix;
            }

            formattedValue = applySeperators(format, formattedValue);

            if (currency != null) {
              //Add the currency symbol
              formattedValue = /(\+|\-)/.test(formattedValue[0]) ?
              formattedValue[0] + currency + formattedValue.slice(1) :
              currency + formattedValue;
            }
          }}


      //Add prefix or suffix
      formattedValue = addPrefixSuffix(format, formattedValue);

      if (format.breakSpace) {
        formattedValue = formattedValue.split(' ');
      }
      return formattedValue;
    }

    function getTimeSubfunctionFormatter(subfunctype, useUTC, locale) {
      useUTC = useUTC === true;
      var formatter = useUTC ? getFormatter('time', locale, 'utcFormat') : getFormatter('time', locale);
      switch (subfunctype) {
        case 'YEAR':
        case 'year':
          return formatter('%Y');
        case 'MONTH':
        case 'month':
          return formatter('%B');
        case 'ABSDAY':
          return formatter('%a');
        case 'DAY':
        case 'day':
          return formatter('%e');
        case 'WEEKDAY':
          return formatter('%A');
        case 'WEEK':
        case 'week':
          return formatter('Week %W');
        case 'ABSHOUR':
          return formatter('%I');
        case 'ABSSECOND':
          return formatter('%S');
        case 'ABSMINUTE':
        case 'MINUTE':
          return formatter('%M');
        case 'MILLISEC':
          return formatter('%L');
        case 'HOUR':
          return formatter('%H hrs');
        case 'DATETIME':
          return formatter('%d %b %Y %H:%M:%S');
        case 'DATE':
          return formatter('%x');
        case 'TIME':
          return formatter('%X');
        case 'TIMESTAMP':
          return formatter('%x %X hrs');
        case 'ABSMONTH':
          return formatter('%b %Y');
        case 'ABSWEEK':
          return formatter('W' + '%U' + ' ' + '%Y');
        case 'ABSQUARTER':
          return function (d) {
            var year = useUTC ? d.getUTCFullYear() : d.getFullYear();
            return formatter("Q".concat(getQuarter(d, useUTC), " ").concat(year));
          };
        case 'QUARTER':
          return function (d) {
            return formatter("Q".concat(getQuarter(d, useUTC)));
          };
        case 100:
          return formatter('%d %b %Y %H:%M:%S %L');
        default:
          throw "UNKNOWN TYPE 111: ".concat(subfunctype);}

    }

    function generateDateVal(value, format, colInfo, toProcess) {
      //var dateValue = (format != null && format.specifier != null)? d3_timeFormat(format.specifier).parse(value):new Date(value.toString());
      var inputformat = colInfo ? colInfo.inputformat : null;
      var dateValue = new Date(value.toString() === '0' ? +value : value.toString()); // For 1970, the timestamp will be 0. new Date("0") will return 1999
      var customFunc =
      typeof inputformat === 'function' ? inputformat : typeof window[inputformat] === 'function' ? window[inputformat] : null;
      if (!(value instanceof Date) && inputformat != null && (customFunc || inputformat.toLowerCase() != 'timestamp')) {
        value = !customFunc && !(_typeof(value) == String) ? value.toString() : value;
        var formatter = getFormatter('time', colInfo.locale, 'parse');
        var parsedVal = customFunc ? customFunc(value, colInfo) : formatter(generated3TimeSpecifier(inputformat))(value);
        dateValue = parsedVal == null ? dateValue : new Date(parsedVal);
      }
      if (isNaN(dateValue)) {
        dateValue = new Date(+value);
      }
      return dateValue;
    }

    function getFormattedValueByPercent(colInfo, value, dataType, chartObj, type) {
      colInfo = colInfo || {};
      type = "".concat(type && colInfo["".concat(type, "percentformat")] ? type : '', "percent");

      if (!colInfo["".concat(type, "format")]) {
        colInfo.percentformat = getDefaultFormat('percent');
      }

      return getFormattedValue(colInfo, value, dataType, chartObj, type);
    }

    //Format Utils
    var timeSpecifiers = {
        YYYY: '%Y',
        MMMM: '%B',
        EEEE: '%A',
        EEE: '%a',
        MMM: '%b',
        YY: '%y',
        MM: '%m',
        EE: '%U',
        dd: '%d',
        HH: '%H',
        hh: '%I',
        mm: '%M',
        ss: '%S',
        a: '%p',
        MILLI: '%L',
        z: '%Z',

        // ZC custom specifiers

        QT: '$Q'
      },
      numericSpecifiers = {
        decimal: 'd',
        exponent: 'e',
        "float": 'f',
        binary: 'b',
        octal: 'o',
        hexadecimal: 'x',
        SIprefix: 's'
      };

    /**
     * maps custom specifier with corresponding functions
     *
     * @type {{Q: getQuarter}}
     */
    var CUSTOM_SPECIFIER_MAPPER = {
        Q: getQuarter
      },
      tempArrayKeys = Object.keys(CUSTOM_SPECIFIER_MAPPER).map(function (key) {
        return "\\$".concat(key);
      }),
      CUSTOM_SPECIFIER_REGEX = new RegExp(tempArrayKeys.join('|'));

    function generated3TimeSpecifier(specifier) {
      if (specifier) {
        for (var spec in timeSpecifiers) {
          var index = specifier.indexOf(spec);
          if (index >= 0 && specifier[index - 1] !== '%') {
            specifier = specifier.replace(new RegExp(spec, 'g'), timeSpecifiers[spec]);
          }
        }
      }
      return specifier;
    }

    /**
     *
     * @param {Function} d3Format
     * @param {String} specifier
     * @param {Boolean} useUTC
     * @returns {Function}
     */
    function getSpecifierFormatter(d3Format, specifier, useUTC) {
      return function (date) {
        var val = d3Format(date); // calling d3 function

        var string = [],
          i = -1,
          j = 0,
          n = val.length,
          c;

        // search for custom specifier
        // below code taken from d3/d3-time-format

        while (++i < n) {
          if (val.charCodeAt(i) === 36) {
            // searches for zc custom specifier ($)
            string.push(val.slice(j, i));
            c = val.charAt(++i);
            c = defined(CUSTOM_SPECIFIER_MAPPER[c]) ? CUSTOM_SPECIFIER_MAPPER[c](date, useUTC) : c;
            string.push(c);
            j = i + 1;
          }
        }

        string.push(val.slice(j, i));
        return string.join('');
      };
    }

    function generateTimeFormatter(d3TimeFormat, specifier, colInfo, levelIndex) {
      var formatter;
      if (specifier) {
        formatter = getSpecifierFormatter(d3TimeFormat(specifier), specifier, colInfo.useUTC);
      } else if (colInfo.groupby) {
        //#ZC1015
        var groupOrder = isArray$1(colInfo.groupby) ? colInfo.groupby : colInfo.AUTO_GROUP_ORDER;
        var subFuncType = levelIndex === 0 || !defined(levelIndex) ? colInfo.subfunction : groupOrder[levelIndex - 1];
        formatter = getTimeSubfunctionFormatter(subFuncType, colInfo.useUTC, colInfo.locale);
      }
      return formatter;
    }

    function generated3NumericSpecifier(format, defaultSpecifier, locale, value) {
      var sign = defined(format.signEnabled) ? '+' : '',
        zeroPad = format.zeroPadding != null && format.zeroPadding.enabled ? "0".concat(format.zeroPadding.digits) : '',
        thousandSep = format.thousandSeperator != null ? ',' : '',
        type = getd3NumericFormatterType(format),
        isScientificFormat = /(e|s)/gi.test(type),
        decimalPlaces = format.decimalPlaces,
        decPlaces;

      if (decimalPlaces != null && decimalPlaces >= 0) {
        decPlaces = isScientificFormat ? $Browser.IE ? '.20' : '' : ".".concat(decimalPlaces === 0 ? decimalPlaces : decimalPlaces + 3); // #ZC898
      } else {
        decPlaces = isScientificFormat ? '' : ".".concat(countDecimals(value)); //Test_67.json
      }

      var formatSpecifier = sign + zeroPad + thousandSep + (defaultSpecifier || decPlaces + type);
      return getFormatter(undefined, locale)(formatSpecifier);
    }

    function getd3NumericFormatterType(format) {
      var decimalPlaces = format.decimalPlaces,
        type = format.type;

      return numericSpecifiers[type] || 'f';
    }

    function applySeperators(format, formattedValue) {
      var thSep = format.thousandSeperator,
        deSep = format.decimalSeperator,
        split = formattedValue.split(/\./);
      return (
        (thSep != null && thSep != ',' ? split[0].replace(/,/g, thSep) : split[0]) + (
        !split[1] ? '' : (deSep != null ? deSep : '.') + split[1]));

    }

    /**
     * Adds prefix and suffix
     * @param  {Object} format
     * @param  {String} formattedValue
     * @return {String}
     */
    function addPrefixSuffix(format, formattedValue) {
      if (isArray$1(formattedValue)) {
        return formattedValue;
      }

      var prefix = pick(format.prefix, ''),
        suffix = pick(format.suffix, '');

      return prefix + formattedValue + suffix;
    }

    function countDecimals(value) {
      if (isNaN(value)) {
        return 0;
      } else {
        value = +value; //Important: if value is string (e.g: "1.0000000455121E12") throws error
        if (Math.floor(value) == value) {
          return 0;
        }
      }

      var convertedNumber = exponentialToDecimal(value);
      return convertedNumber.toString().split('.')[1].length || 0;
    }

    function exponentialToDecimal(num) {
      //https://gist.github.com/jiggzson/b5f489af9ad931e3d186
      //if the number is in scientific notation remove it
      if (/\d+\.?\d*e[+-]*\d+/i.test(num)) {
        var zero = '0',
          parts = String(num).
          toLowerCase().
          split('e'), //split into coeff and exponent
          e = parts.pop(), //store the exponential part
          l = Math.abs(e), //get the number of zeros
          sign = e / l,
          coeff_array = parts[0].split('.');
        if (sign === -1) {
          num = "".concat(zero, ".").concat(new Array(l).join(zero)).concat(coeff_array.join(''));
        } else {
          var dec = coeff_array[1];
          if (dec) {
            l = l - dec.length;
          }
          num = coeff_array.join('') + new Array(l + 1).join(zero);
        }
      }
      return num;
    }

    /**
     * Returns absolute years, months, days till seconds from timestamp
     * @param {Number} ms date timestamp
     * @returns {{seconds: number, minute: number, hour: number, day: number, month: number, years: number}}
     */

    function millisecondToAbsoluteTime(ms) {
      var seconds = mathFloor(ms / 1000),
        minute = mathFloor(seconds / 60),
        hour = mathFloor(minute / 60),
        day = mathFloor(hour / 24),
        month = mathFloor(day / 30.436854166666667),
        years = mathFloor(day / 365.24225);

      return {
        seconds: seconds,
        minute: minute,
        hour: hour,
        day: day,
        month: month,
        years: years
      };
    }

    /**
     *
     * @param milliseconds
     * @returns {{subFunction: string, specifier: *}}
     */

    function getAutoTimeSubFunction(milliseconds) {
      var absoluteTime = millisecondToAbsoluteTime(milliseconds),
        subFunction = 'YEAR';

      if (absoluteTime.years > 1) {
        subFunction = 'YEAR';
      } else if (absoluteTime.month > 1) {
        subFunction = 'ABSMONTH';
      } else if (absoluteTime.day > 1) {
        subFunction = 'ABSDAY';
      } else if (absoluteTime.hour > 1) {
        subFunction = 'ABSHOUR';
      } else if (absoluteTime.minute > 1) {
        subFunction = 'ABSMINUTE';
      } else {
        subFunction = 'ABSSECOND';
      }

      return {
        subFunction: subFunction
      };
    }

    /**
     * (2.55).toFixed(1) returns 2.5 insteadof 2.6
     * stackoverflow.com/questions/49629597/js-decimal-precision-tofixed-not-returning-correct-value
     * stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-only-if-necessary
     * @param  {Number} number
     * @param  {Number} decimal
     * @return {Number}
     */
    function toFixedNumber(number, decimal) {
      var tenToD = Math.pow(10, decimal);
      return +(Math.round((number + EPSILON) * tenToD) / tenToD).toFixed(decimal);
    }

    /**
     * it returns the quarter of the given date
     *
     * @param {Date} date
     * @param {useUTC} useUTC
     * @returns {Number}
     */
    function getQuarter(date, useUTC) {
      return mathFloor((useUTC ? date.getUTCMonth() : date.getMonth()) / 3) + 1;
    }

    var timeApiMap = { format: d3_timeFormat, parse: d3_timeParse, utcFormat: d3_timeFormatUTC };
    function getFormatter() {var dataType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'numeric';var localeName = arguments.length > 1 ? arguments[1] : undefined;var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'format';
      var locale = getLocale(localeName);

      if (dataType === 'time') {
        return locale ? d3_timeFormatLocale(locale)[name] : timeApiMap[name];
      } else {
        return locale ? d3_formatLocale(locale)[name] : d3_format;
      }
    }

    /**
     * @param  {Array} array
     * @param  {[Array | Number | String]} keys
     * @return {Array}
     */
    function getDataByKeys(array, keys) {
      if (!isArray$1(keys)) {
        keys = [keys];
      }

      var readData = function readData(key) {return getDataByKey(array, key);};
      return d3_merge(keys.map(readData));
    }

    /**
     * @param  {Array} array
     * @param  {[Number | String]} key
     * @return {Array}
     */
    function getDataByKey(array, key) {
      var output = [];

      if (array && isArray$1(array) && array.every(isArray$1)) {
        //Hierarchy array
        array.forEach(function (_) {return collectRecursively(_, key, output);});
      } else {
        collectData.call(null, array, key, output);
      }

      return output;
    }

    function collectData(data, key, output) {
      var value = isFunction(key) ? key(data) : data[key];

      if (isArray$1(value)) {
        output.push.apply(output, _toConsumableArray(value));
      } else {
        output.push(value);
      }
    }

    function collectRecursively(subArray, key, output) {
      var subOutput = getDataByKey(subArray, key);
      output.push.apply(output, _toConsumableArray(subOutput));
    }

    /**
     * @param  {Array} array
     * @param  {[Array | Number | String]} keys
     * @return {Array}       [min, max]
     */
    function extent(array, keys) {
      var data = getDataByKeys(array, keys);
      return d3_extent(data);
    }

    //find-subfunction.js

    //data-processor.js

    Registry.setComponent('defaultDataProcessor', DataProcessor);
    function DataProcessor(data, dataSet, chartInstance) {
      this.data = data;
      this.dataset = dataSet;
      this.chartObj = chartInstance;

      this.allChartTypes = null;
      this.globalChartType = null;
      this.processedseriesData = chartInstance.seriesdata;

      this.initialize();
    }

    var DataProcessorProto = DataProcessor.prototype;

    /**
     *
     * @param state
     */

    DataProcessorProto.initialize = function (state) {
      var processor = this,
        data = processor.data,
        globalChartType = processor.globalChartType = data.seriesdata && data.seriesdata.type,
        metadata = data.metadata,
        dataset = processor.dataset,
        processedseriesData = processor.processedseriesData,
        helpers = DataProcessor.helpers,
        chartObj = processor.chartObj;

      dataset.setDataObj(processor);
      dataset.seriesTypes = d3_set();
      processor.totalnoofdatas = 0;
      processor.encodes = {};
      processor.markerSize = {};
      processor.annotation = [];

      chartObj.cache.data = {};
      chartObj.cache.search = {};
      chartObj.cache.customPoints = {};
      chartObj.cache.correction = {};

      if (isArray$1(processedseriesData)) {
        var groupbyDataIndices = helpers.groupByDataIndices(metadata, chartObj);
        processor.allChartTypes = processor.allChartTypes || helpers.getAllChartTypes(data);

        var gridlist = processor.pivot ? getGridList(processor) : [{ data: processedseriesData }];
        gridlist.forEach(function (grid) {
          grid.data.forEach(function (d) {
            var chartType_num = helpers.getChartType(d.node && d.node.type || d.type || globalChartType, NUMERIC_DATATYPE);

            // isAxisCategory, isPolarAxisCategory, isNonAxisMultiSeriesCategory should be here for totalDataCount (DEMOEVENTS_BUBBLEPIE_4)
            processor.isAxisCategory = processor.isAxisCategory || arrayIncludes(chartcategory.axis, chartType_num);
            processor.isPolarAxisCategory = processor.isPolarAxisCategory || arrayIncludes(chartcategory.polarAxis, chartType_num);
            processor.isNonAxisMultiSeriesCategory =
            processor.isNonAxisMultiSeriesCategory || arrayIncludes(chartcategory.nonaxismultiseries, chartType_num);

            processor.singleSourceEvent = processor.singleSourceEvent || arrayIncludes(chartcategory.singleSourceEvent, chartType_num);

            processor.hasLevelMarker = processor.hasLevelMarker || chartType_num == charttype.bullet || chartType_num == charttype.dial;

            // Initiate markerSize
            if (chartcategory.markerPlot.has(chartType_num)) {
              processor.markerSize[charttypenames.get(chartType_num)] = d3_set();
            }
          });
        });

        processedseriesData.forEach(function (d, i) {
          var disabled = d.disabled,
            curdata = d.data,
            is3DArray = helpers.is3D(curdata),
            chartType_num = helpers.getChartType(d.type || globalChartType, NUMERIC_DATATYPE);

          dataset.seriesTypes.add(chartType_num);

          // convert data to 3d array even it is disabled;
          if (state !== 'addorremoveseries' && !is3DArray && isArray$1(curdata)) {
            curdata = processor.convertTo3DArray(d, groupbyDataIndices, chartType_num);
          }

          if (!disabled && isArray$1(curdata)) {
            //totalNo of datas
            processor.totalDataCount(curdata);
          }
          saveAnnotation(curdata, chartObj, processor.annotation, i);
        });

        // findSubFunction(processor, processedseriesData);
      }
    };

    function saveAnnotation(curdata, chart, arr, seriesIndex) {
      var config = chart.systemConf.notes || {},
        dataIndex = config.dataIndex;

      if (isUndefined(dataIndex)) {
        return;
      }

      curdata.forEach(function (subgroup, subSeriesIndex) {
        if (isArray$1(subgroup)) {
          subgroup.forEach(function (d, itemIndex) {
            var data = d.data || d;
            if (data[dataIndex]) {
              arr.push({ data: d, subSeriesIndex: subSeriesIndex, itemIndex: itemIndex, seriesIndex: seriesIndex });
            }
          });
        }
      });
    }

    extend(DataProcessorProto, encodeMethods);

    //$Id$
    //chartname-constants.js

    var BAR_CHARTNAME = 'bar',
      BULLET_CHARTNAME = 'bullet',
      GANTT_CHARTNAME = 'gantt',
      WATERFALL_CHARTNAME = 'waterfall',
      AREA_CHARTNAME = 'area',
      AREARANGE_CHARTNAME = 'arearange',
      LINE_CHARTNAME = 'line',
      SCATTER_CHARTNAME = 'scatter',
      GEOSCATTER_CHARTNAME = 'geoscatter',
      BUBBLE_CHARTNAME = 'bubble',
      GEOBUBBLE_CHARTNAME = 'geobubble',
      BUBBLEPIE_CHARTNAME = 'bubblepie',
      GEOBUBBLEPIE_CHARTNAME = 'geobubblepie',
      PIE_CHARTNAME = 'pie',
      DIAL_CHARTNAME = 'dial',
      FUNNEL_CHARTNAME = 'funnel',
      PYRAMID_CHARTNAME = 'pyramid',
      WEB_CHARTNAME = 'web',
      HEATMAP_CHARTNAME = 'heatmap',
      SUNBURST_CHARTNAME = 'sunburst',
      PACKEDBUBBLE_CHARTNAME = 'packedbubble',
      TREEMAP_CHARTNAME = 'treemap',
      WORDCLOUD_CHARTNAME = 'wordcloud',
      BOXPLOT_CHARTNAME = 'boxplot',
      SANKEY_CHARTNAME = 'sankey',
      BARRANGE_CHARTNAME = 'barrange';

    //$Id$
    //colorscale-helpers.js
    var colorscale_helpers = {};

    colorscale_helpers.getProcessedColorRange = function (range, domain, config, chartObj) {
      var options = config.colorBand,
        userStops = options.stops,
        userRanges = options.ranges,
        processed_range = [],
        isOrdinal = chartObj.dataset.getDataType('clr') === ORDINAL_DATATYPE,
        legendType = getLegendType(config, chartObj),
        isContinousLegend = legendType !== 'discrete';

      if (userRanges && userRanges.length) {
        userRanges = getRawRanges(config, chartObj, true);
        var i = 0,
          check = function check(r, j) {
            if (
            r.length === 1 ?
            isOrdinal ?
            r[0] === domain[i] :
            r[0] === domain[i + 1] :
            r[0] === domain[i] && r[1] === domain[i + 1])
            {
              rangeIndex = j;
              return true;
            }
          };

        for (var len = domain.length; i < len; isOrdinal ? i++ : i += 2) {
          var rangeIndex = -1;
          userRanges.some(check);
          if (rangeIndex === -1 || !isContinousLegend && userRanges[rangeIndex].disabled) {
            processed_range.push(null);
          } else {
            processed_range.push(range[rangeIndex % range.length]);
          }
        }
      } else if (!isOrdinal && userStops && userStops.length) {
        var prevStopIndex = 0;
        domain.forEach(function (d, i) {
          var stopIndex = userStops.indexOf(d);
          if (stopIndex === -1) {
            stopIndex = prevStopIndex;
          }
          processed_range.push(range[stopIndex % range.length]);
          prevStopIndex = stopIndex;
        });
      } else {
        processed_range = range;
      }

      return processed_range;
    };

    colorscale_helpers.getColorDomain = function (chartObj) {
      var config = chartObj.systemConf.legend,
        options = config.colorBand,
        userStops = options.stops,
        userRanges = options.ranges,
        minmax = colorscale_helpers.getMinMax(chartObj),
        min = pick(options.minRange, minmax[0]) || 0, //min may be undefined|null //Test_695.json
        max = pick(options.maxRange, minmax[1]) || 0, //max may be undefined|null //Test_695.json
        isOrdinal = chartObj.dataset.getDataType('clr') === ORDINAL_DATATYPE;

      if (userRanges && userRanges.length) {
        var copy_userRanges = getRawRanges(config, chartObj),
          final_ranges = [];

        if (isOrdinal) {
          final_ranges = copy_userRanges;
        } else {
          if (copy_userRanges[0].length === 1) {
            var m = min;
            copy_userRanges = copy_userRanges.map(function (d) {
              var newRange = [m, d[0]];
              m = newRange[1];
              return newRange;
            });
          }
          final_ranges = copy_userRanges;
          final_ranges.splice(0, 0, [-Infinity, -MAX_SAFE_INTEGER]);
          final_ranges.splice(final_ranges.length, 0, [MAX_SAFE_INTEGER, Infinity]);
        }
        var merged_userRanges = d3_merge(final_ranges);
        return merged_userRanges;
      } else if (!isOrdinal && userStops && userStops.length) {
        var copy_userStops = d3_values(userStops);
        copy_userStops.sort(d3_ascending);
        var filteredStops = copy_userStops.filter(function (d) {
          var condition = true;
          if (defined(options.minRange)) {
            condition = condition && d >= options.minRange;
          }
          if (defined(options.maxRange)) {
            condition = condition && d <= options.maxRange;
          }
          return condition;
        });

        if (min < filteredStops[0] || !filteredStops.length) {
          filteredStops.splice(0, 0, min);
        }
        if (max > filteredStops[filteredStops.length - 1]) {
          filteredStops.splice(filteredStops.length, 0, max);
        }
        return filteredStops; //Add percentage support
      }

      return [min, max];
    };

    /*
     * @param {Object} chartObj
     * @returns {Array} minmax
     */
    colorscale_helpers.getMinMax = function (chartObj) {
      var colorData = colorscale_helpers.getAllColorData(chartObj);
      return d3_extent(colorData);
    };

    /*
     * @param {Object} chartObj
     * @returns {Array} distinct categories
     */
    colorscale_helpers.getCategories = function (chartObj) {
      var categories = colorscale_helpers.getAllColorData(chartObj);
      return getDistinct(categories);
    };

    /*
     * @param {Object} chartObj
     * @returns {Array} all color values
     */
    colorscale_helpers.getAllColorData = function (chartObj) {
      var seriesdata = chartObj.seriesdata,
        colorData = [];

      seriesdata.forEach(function (series) {
        if (!series.disabled) {
          var curSeriesdata = series.data || series;
          colorscale_helpers.pushColorData(chartObj, curSeriesdata, colorData);
        }
      });
      return colorData;
    };

    /*
     * @param {Object} chartObj
     * @param {Object} root
     * @param {Array} colorData
     */
    colorscale_helpers.pushColorData = function (chartObj, root, colorData) {
      if (root && isArray$1(root) && root.every(isArray$1)) {
        root.forEach(function (child) {
          colorscale_helpers.pushColorData(chartObj, child, colorData);
        });
      } else {
        var clrValue = chartObj.dataset.getClr(root);
        colorData.push(clrValue);
      }
    };

    colorscale_helpers.isQuantileColorScale = function (chartObj) {
      if (chartObj.axes.clr) {
        return chartObj.axes.clr.scaleType === 'quantile';
      } else {
        //check for hierarchy chart
        return (
          defined(chartObj.dataset.clridx) &&
          !chartObj.dataObject.isPolarAxisCategory &&
          chartObj.systemConf.legend.colorBand.type !== NONE);

      }
    };

    /*
     * @param {Object} chartObj
     * @param {Scale} colorIndexScale
     * @param {Array} d
     * @param {Number} i
     * @returns {Number} color index
     */
    colorscale_helpers.getItemIndex = function (chartObj, indexScale, d, i) {
      var clrValue = d && chartObj.dataset.getClr(d);
      if (indexScale) {
        return indexScale(clrValue);
      } else {
        return i;
      }
    };

    /*
     * @param {Object} chartObj
     * @returns {Scale} index scale
     */
    colorscale_helpers.getIndexScale = function (chartObj) {
      var hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
        config = chartObj.systemConf.legend,
        user_ranges = config.colorBand.ranges,
        scaleObj;

      if (hasColorScale && user_ranges && user_ranges.length) {
        //color index scale is only for user ranges
        var colorScale = chartObj.axes.clr.scale,
          colorScale_domain = colorScale.domain(),
          patternPallete = chartObj.patternPallete,
          imagePallete = chartObj.imagePallete,
          pallete;

        if (imagePallete && imagePallete.length) {
          pallete = imagePallete;
        } else if (patternPallete && patternPallete.length) {
          pallete = patternPallete;
        }
        if (pallete) {
          scaleObj = colorScale.copy();
          scaleObj.range(colorscale_helpers.getProcessedColorRange(d3_range(pallete.length), colorScale_domain, config, chartObj));
        }
      }
      return scaleObj;
      // var hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
      //     user_ranges = chartObj.systemConf.legend.colorBand.ranges,
      //     patternPallete = chartObj.patternPallete,
      //     imagePallete = chartObj.imagePallete;

      // if (hasColorScale && user_ranges && user_ranges.length) { //color index scale is only for user ranges
      //     if ((imagePallete && imagePallete.length) || (patternPallete && patternPallete.length)) {
      //     	return chartObj.axes.clr.indexScale;
      //     }
      // }
    };

    function getRawRanges(config, chartObj, dont) {
      var dataType = chartObj.dataset.getDataType('clr');
      return getLegendRanges(config.colorBand, dataType, dont);
    }

    function getLegendRanges(config, dataType, dont) {var clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var userRanges = config.ranges;

      var copy_userRanges = clone ? simpleClone(userRanges) : userRanges,
        isOrdinal = dataType === ORDINAL_DATATYPE;

      //make it as array of ranges if single value is given like [10, 20, 30] => [[10],[20],[30]]
      if (!isArray$1(copy_userRanges[0])) {
        copy_userRanges = copy_userRanges.map(function (d) {
          return [d];
        });
      }

      //sort
      if (!isOrdinal && !dont) {
        copy_userRanges.sort(function (a, b) {
          return d3_ascending(a[0], b[0]);
        });
      }
      return copy_userRanges;
    }

    /*
     * Returns legend type
     * @param {Object} config
     * @param {Object} chartObj
     * @returns {String} view type
     */
    function getLegendType(config, dataType) {
      var colorBandConfig = config.colorBand;

      if (dataType && dataType.dataset) {
        // TODO: enhance
        dataType = dataType.dataset.getDataType('clr');
      }

      if (colorBandConfig.type) {
        return colorBandConfig.type;
      }

      return colorBandConfig.ranges || dataType === ORDINAL_DATATYPE ? 'discrete' : 'continuous';
    }

    /*
    Legend data config
     */
    // export function
    Registry.setComponent('colorscale_helpers', colorscale_helpers);

    //charttype-helpers.js

    function isAreaChartType(type) {
      // return [$ZC.charttype.area, $ZC.charttype.stkdarea, $ZC.charttype.arearange].indexOf(type) > -1;
      return type === charttype.area || type === charttype.stkdarea || type === charttype.arearange;
    }

    /**
     *
     * @param {Number} type chart type
     * @return {boolean}
     */

    function isBubbleChartType(type) {
      return chartcategory.bubble.has(type) || chartcategory.bubblePie.has(type);
    }

    function getChartTypeByIndex(chart, paneid, index, series) {
      if (chart.dataObject.categoryHierarchy && chart.dataObject.hierarchical.pivot) {
        if (!paneid) {
          if (series) {
            paneid = "".concat(series.row, "_").concat(series.column);
          } else {
            paneid = '0_0';
          }
        }
        var gridOptions = chart.dataObject.hierarchical.gridOptions;
        return gridOptions[paneid].chartTypes[index] || gridOptions[paneid].chartTypes[0];
      } else {
        return chart.chartTypes[index] || chart.chartTypes[0];
      }
    }

    function getUniqueChartTypes(chart) {
      return d3_set(chart.distinctChartTypes);
    }

    function isCategoryOf(chartObj, chartType, categoryType) {
      if (isFacet(chartObj)) {
        var categoryKeys = { axis: 'axis', polarAxis: 'polarAxis', nonAxisMultiSeries: 'nonaxismultiseries', hierarchy: 'hierarchy' };
        return arrayIncludes(chartcategory[categoryKeys[categoryType]], chartType);
      }

      var savedKeys = {
        axis: 'isAxisCategory',
        polarAxis: 'isPolarAxisCategory',
        nonAxisMultiSeries: 'isNonAxisMultiSeriesCategory',
        hierarchy: 'isHierarchy'
      };
      return chartObj.dataObject[savedKeys[categoryType]];
    }

    function isMultiColorChart(chartName, chartObj) {
      var multiColoring =
        /(bar|scatter|bubble$|bullet|gantt|wordcloud|waterfall|boxplot|barrange)/.test(chartName) &&
        isMultiColoring(chartObj.systemConf.chart.plot.plotoptions[chartName], chartObj),
        defaultMultiColoring = /(^pie|funnel|pyramid|sankey|dial)/.test(chartName);
      return multiColoring || defaultMultiColoring;
    }

    Registry.setComponent('utils.isCategoryOf', isCategoryOf);
    Registry.setComponent('utils.getChartTypeByIndex', getChartTypeByIndex);

    //$Id$
    //legend-type-constants.js
    var SLIDER_LEGEND_TYPE = 'slider',
      NESTED_LEGEND_TYPE = 'nested',
      LIST_LEGEND_TYPE = 'list',
      BAND_LEGEND_TYPE = 'band';

    //

    function isSupported(name) {
      return function (chart) {var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'z-0';
        return getLegendView(chart.legends, id) === name;
      };
    }

    function indexOfRange(d, ranges) {
      var index;

      ranges.some(function (_, i) {
        var reversedIndex = ranges.length - 1 - i,
          range = ranges[reversedIndex];

        if (d >= range[0] && d <= range[1]) {
          index = reversedIndex;
          return true;
        }
      });

      return index;
    }

    function getLegendView(legends, id) {
      var sizeLegend = legends.get(id);

      return sizeLegend && sizeLegend.meta.view;
    }

    function getHoverOptions(config) {var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'z';var byView = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var view = getViewByConfig(config, encode),
        hoverOptions = config.hoverOptions,itemHoverStyle = config.itemHoverStyle,_itemHoverStyle = config._itemHoverStyle,
        _options = (encode === 'clr' ? _itemHoverStyle || itemHoverStyle : hoverOptions) || {};

      return (byView ? _options[view] : null) || _options;
    }

    function getDisabledOptions(config) {var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'z';
      var view = getViewByConfig(config, encode),
        filter = config.filter,itemDisabledStyle = config.itemDisabledStyle,
        _options = (encode === 'clr' ? itemDisabledStyle : filter) || {};

      return _options[view] || _options;
    }

    function getViewByConfig(config, encode) {
      var ranges = config.ranges,type = config.type,
        defaultView = ranges ? LIST_LEGEND_TYPE : encode === 'z' ? NESTED_LEGEND_TYPE : BAND_LEGEND_TYPE;

      return type || defaultView;
    }

    function convertNull(val, options) {
      var config = options.config,scale = options.scale,columnKey = options.columnKey,
        nullAs = config.nullAs;

      if (val === UNDEFINED) {
        val = NULL$1;
      }

      if (isUndefined(val) && defined(nullAs)) {
        if (nullAs === "{{min(".concat(columnKey, ")}}")) {
          if (scale) {
            val = scale.domain()[0];
          }
        } else {
          val = nullAs;
        }
      }

      return val;
    }

    function isDataActive(dt, chartObj, _seriesIndex) {
      if (!dt) {
        return false;
      }

      var d = dt.data || dt;

      var clr = chartObj.dataset.getClr(d),
        isWithinColorRange = Registry.getComponent('color.isWithinColorRange'),
        //
        seriesIndex = pick(d.seriesIndex, dt.index, _seriesIndex);
      if (chartObj.seriesAddRemoveDetails && chartObj.seriesAddRemoveDetails.seriesAddRemovePhase) {
        if (chartObj.seriesAddRemoveDetails.seriesAdded === true || chartObj.seriesAddRemoveDetails.seriesRemoved === true) {
          seriesIndex = _seriesIndex;
        }
      }
      var getChartType = DataProcessor.helpers.getChartType,
        isBubbleChart = defined(seriesIndex) && isBubbleChartType(getChartType(null, NUMERIC_DATATYPE, seriesIndex, chartObj.userdata));

      var _index = pick(
      d.seriesIndex,
      d.seriesPos,
      dt._seriesIndex,
      !chartObj.dataObject.isHierarchy && !chartObj.dataObject.pivot ? dt.index : null,
      _seriesIndex);
      //FEATURES_PIVOT_42 TODO check with remi
      if (defined(_index) && isSeriesFiltered(chartObj, d && d.paneid, _index)) {
        return false;
      }

      if (!isWithinColorRange(clr, chartObj)) {
        return false;
      }

      if (chartObj.dataObject.hasZaxis && isBubbleChart) {
        var _isWithinSizeEncode = Registry.getComponent('size.isWithinSizeEncode');
        if (!_isWithinSizeEncode(d, chartObj)) {
          return false;
        }
      }

      // related to #ZC2643 & #2654
      if (chartObj.dataObject.isFlowChartCategory) {
        var renderer = chartObj.renderer[0];
        if (renderer && renderer.highlighter) {
          return renderer.highlighter.isVisible(d.point || d);
        }
      }

      return true;
    }

    function isWithinEncode(val, encode, chartObj, scale, config) {var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
      var range = options.range,_options$condition = options.condition,userCondition = _options$condition === void 0 ? function () {return true;} : _options$condition,
        ranges = config.ranges;

      if (!scale) {
        return true; // If clr index is not specified
      }

      var nullAsOptions = { config: config, scale: scale, columnKey: chartObj.dataset.getColumnIdx(encode) };
      val = convertNull(val, nullAsOptions);

      var filterRange = range || config.filter.range,
        dataType = chartObj.dataset.getDataType(encode),
        scale_domain = scale.domain(),
        //
        _isWithinFilterRange = function _isWithinFilterRange() {
          if (!filterRange) {
            return true;
          } else {
            if (dataType === ORDINAL_DATATYPE) {
              return arrayIncludes(filterRange, val);
            } else if (ranges && ranges.length && isArray$1(filterRange[0])) {
              var legendIndex = indexOfRange(val, ranges);
              return !(defined(legendIndex) && ranges[legendIndex].disabled);
            } else {
              return isWithinRange$2(val, filterRange);
            }
          }
        },
        //
        isWithinFilterRange = _isWithinFilterRange(),
        isWithinScale =
        dataType === ORDINAL_DATATYPE ?
        arrayIncludes(scale_domain, val) :
        isWithinRange$2(val, [scale_domain[0], scale_domain[scale_domain.length - 1]]);

      return isWithinScale && isWithinFilterRange && scale(val) !== null && userCondition(val);
    }

    function isWithinRange$2(val, range) {
      return val >= range[0] && val <= range[1];
    }

    function getChartSeriesColor(chart, paneid, index) {
      var hierarchical = chart.dataObject.hierarchical;
      if (chart.dataObject.categoryHierarchy && hierarchical.pivot && paneid) {
        paneid = paneid || '0_0';
        var gridOptions = chart.dataObject.hierarchical.gridOptions;
        var gridColors = gridOptions[paneid].colors,
          // gridIdx = gridColors[index] ? index : 0,
          gridIdx = index;

        return gridColors[gridIdx % gridColors.length];
      } else {
        return chart.seriesColor[index % chart.seriesColor.length];
      }
    }

    function getImageByIndex(chartObj, index, paneid) {
      var imagePallete = chartObj.imagePallete;

      if (!imagePallete) {
        return;
      }

      var hierarchical = chartObj.dataObject.hierarchical;
      if (chartObj.dataObject.categoryHierarchy && hierarchical && hierarchical.pivot && paneid) {
        paneid = paneid || '0_0';
        var gridOptions = hierarchical.gridOptions;
        var renderer = gridOptions[paneid].renderer[index],
          legendIndex = renderer.commonRendererProp().params.legendIndex;

        return imagePallete[legendIndex % imagePallete.length];
      } else {
        return imagePallete[index % imagePallete.length];
      }
    }

    function euclideanDistance(point1, point2) {
      var x = point2.x - point1.x,
        y = point2.y - point1.y;

      return mathSQRT(mathPow(x, 2) + mathPow(y, 2));
    }

    function isCircleWithinCircle(circle1, circle2) {
      var dist = euclideanDistance(circle1, circle2),
        r1 = circle1.r,
        r2 = circle2.r;

      return dist + r2 == r1 || dist + r2 < r1;
    }

    function closestToCircle(circle, point) {
      var _circle = _slicedToArray(circle, 3),cx = _circle[0],cy = _circle[1],r = _circle[2],_point = _slicedToArray(
        point, 2),x = _point[0],y = _point[1],
        distance = euclideanDistance({ x: cx, y: cy }, { x: x, y: y }),
        closest;

      if (distance >= r) {
        closest = distance - r;
      } else {
        closest = r - distance;
      }

      return closest;
    }

    Registry.setComponent('geometryUtils.circle.closestToCircle', closestToCircle);
    Registry.setComponent('geometryUtils.circle.isCircleWithinCircle', isCircleWithinCircle);

    // TODO:  check this //stackoverflow.com/questions/12034019/as3-draw-a-line-along-the-common-tangents-of-two-circles/12037737#12037737
    function outerTangentPoints$Circle(circle1, circle2) {
      //www.ambrsoft.com/TrigoCalc/Circles2/Circles2Tangent_.htm
      var x1 = circle1.x,
        y1 = circle1.y,
        r1 = circle1.r,
        x2 = circle2.x,
        y2 = circle2.y,
        r2 = circle2.r;

      if (isCircleWithinCircle(circle1, circle2) || isCircleWithinCircle(circle2, circle1)) {
        return [];
      }

      if (r1 === r2) {
        var theta = mathAtan((y2 - y1) / (x2 - x1)),
          _t1_x = x1 + r1 * mathSin(theta),
          _t1_y = y1 - r1 * mathCos(theta),
          _t1_x2 = x2 + r1 * mathSin(theta),
          _t1_y2 = y2 - r1 * mathCos(theta),
          //
          _t2_x = x1 - r1 * mathSin(theta),
          _t2_y = y1 + r1 * mathCos(theta),
          _t2_x2 = x2 - r1 * mathSin(theta),
          _t2_y2 = y2 + r1 * mathCos(theta);

        return [[_t1_x, _t1_y], [_t1_x2, _t1_y2], [_t2_x, _t2_y], [_t2_x2, _t2_y2]];
      }

      var xp = (x2 * r1 - x1 * r2) / (r1 - r2),
        yp = (y2 * r1 - y1 * r2) / (r1 - r2);

      var lower1 = mathPow(xp - x1, 2) + mathPow(yp - y1, 2),
        upperSqrt1 = mathPow(xp - x1, 2) + mathPow(yp - y1, 2) - mathPow(r1, 2),
        upper1X = mathPow(r1, 2) * (xp - x1),
        upper2X = r1 * (yp - y1) * mathSQRT(upperSqrt1),
        upper1Y = mathPow(r1, 2) * (yp - y1),
        upper2Y = r1 * (xp - x1) * mathSQRT(upperSqrt1),
        //
        lower2 = mathPow(xp - x2, 2) + mathPow(yp - y2, 2),
        upperSqrt2 = mathPow(xp - x2, 2) + mathPow(yp - y2, 2) - mathPow(r2, 2),
        upper3X = mathPow(r2, 2) * (xp - x2),
        upper4X = r2 * (yp - y2) * mathSQRT(upperSqrt2),
        upper3Y = mathPow(r2, 2) * (yp - y2),
        upper4Y = r2 * (xp - x2) * mathSQRT(upperSqrt2);

      var t1_x1 = x1 + (upper1X + upper2X) / lower1,
        t1_y1 = y1 + (upper1Y - upper2Y) / lower1,
        t1_x2 = x2 + (upper3X + upper4X) / lower2,
        t2_x2 = x2 + (upper3X - upper4X) / lower2,
        //
        t2_x1 = x1 + (upper1X - upper2X) / lower1,
        t2_y1 = y1 + (upper1Y + upper2Y) / lower1,
        t1_y2 = y2 + (upper3Y - upper4Y) / lower2,
        t2_y2 = y2 + (upper3Y + upper4Y) / lower2;
      return [[t1_x1, t1_y1], [t1_x2, t1_y2], [t2_x1, t2_y1], [t2_x2, t2_y2]];
    }

    Registry.setComponent('geometryUtils.circle.outerTangentPoints', outerTangentPoints$Circle);

    function tangentPoints$Polygon(polygonPoints, isHorizontal) {var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [{ x: 0, y: 0 }, { x: 0, y: 0 }];
      //TODO: ninja|clover|butterfly
      //TODO: Overlapping polygons
      //http://geomalgorithms.com/a15-_tangents.html
      //https://arxiv.org/pdf/1601.01816.pdf
      //https://www.geeksforgeeks.org/tangents-two-convex-polygons/?ref=rp

      var tangent = polygonPoints.map(function (points, i) {
        var q1, q2, q3, q4;
        each(points, function (p) {
          if (isHorizontal) {
            if (p[0] < 0 && p[1] < 0) {
              if (!q1 || q1[1] > p[1]) {
                q1 = p;
              }
            } else if (p[0] >= 0 && p[1] < 0) {
              if (!q2 || q2[1] > p[1]) {
                q2 = p;
              }
            } else if (p[0] >= 0 && p[1] >= 0) {
              if (!q3 || q3[1] < p[1]) {
                q3 = p;
              }
            } else {
              if (!q4 || q4[1] < p[1]) {
                q4 = p;
              }
            }
          } else {
            if (p[0] < 0 && p[1] < 0) {
              if (!q1 || q1[0] > p[0]) {
                q1 = p;
              }
            } else if (p[0] >= 0 && p[1] < 0) {
              if (!q2 || q2[0] < p[0]) {
                q2 = p;
              }
            } else if (p[0] >= 0 && p[1] >= 0) {
              if (!q3 || q3[0] < p[0]) {
                q3 = p;
              }
            } else {
              if (!q4 || q4[0] > p[0]) {
                q4 = p;
              }
            }
          }
        });

        var point = isHorizontal ? i == 0 ? [q2, q3] : [q1, q4] : i == 0 ? [q3, q4] : [q2, q1];
        each(point, function (d) {
          if (d) {
            d[0] += position[i].x;
            d[1] += position[i].y;
          }
        });

        return point;
      });

      return [tangent[0][0], tangent[1][0], tangent[0][1], tangent[1][1]];
    }

    Registry.setComponent('geometryUtils.polygon.outerTangentPoints', tangentPoints$Polygon);

    //$Id$

    var geometryUtils = function () {
      var rotatePoint = function rotatePoint(point, theta) {var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { x: 0, y: 0 };
          /* If you rotate point (px, py) around point (ox, oy) by angle theta you'll get:
          p'x = (px-ox) * cos(theta) + (py-oy) * sin(theta) + ox
          p'y = (px-ox) * sin(theta) - (py-oy) * cos(theta) + oy */

          var px = point.x,
            py = point.y,
            ox = origin.x,
            oy = origin.y;

          return {
            x: (px - ox) * mathCos(theta) + (py - oy) * mathSin(theta) + ox,
            y: (px - ox) * mathSin(theta) - (py - oy) * mathCos(theta) + oy
          };
        },
        pointInRectangle = function pointInRectangle(point, rectangle) {
          var x1 = rectangle.x || 0,
            y1 = rectangle.y || 0,
            x2 = x1 + rectangle.width,
            y2 = y1 + rectangle.height,
            x,
            y;

          if (isArray$1(point)) {
            x = point[0];
            y = point[1];
          } else {
            x = point.x;
            y = point.y;
          }

          return x1 <= x && x <= x2 && y1 <= y && y <= y2;
        },
        degreeToRadian = function degreeToRadian(degree) {
          return degree / 180 * mathPI;
        },
        areaOfEllipse = function areaOfEllipse(a, b) {
          return mathPI * a * b;
        },
        areaOfCircle = function areaOfCircle(r) {
          return mathPI * r * r;
        },
        areaOfRect = function areaOfRect(w, h) {
          return w * h;
        };

      return {
        rotatePoint: rotatePoint,
        pointInRectangle: pointInRectangle,
        degreeToRadian: degreeToRadian,
        areaOfEllipse: areaOfEllipse,
        areaOfCircle: areaOfCircle,
        areaOfRect: areaOfRect,
        dist: euclideanDistance,
        outerTangentPoints$Circle: outerTangentPoints$Circle,
        tangentPoints$Polygon: tangentPoints$Polygon
      };
    }();

    // Returns true if two rectangles rect1 and rect2 overlap
    function doOverlap(rect1, rect2) {
      return !(rect1.x1 > rect2.x2 || rect2.x1 > rect1.x2 || rect1.y1 > rect2.y2 || rect2.y1 > rect1.y2);
    }
    Registry.setComponent('geometryUtils.doOverlapRect', doOverlap);

    //$Id$

    var tooltip_helpers = {};

    tooltip_helpers.getSize = function (config, availableDimension, defaultDimension, defaultMaxDimension) {
      defaultMaxDimension = defaultMaxDimension || [];
      var availableWidth = availableDimension[0],
        availableHeight = availableDimension[1],
        defaultWidth = defaultDimension[0],
        defaultHeight = defaultDimension[1],
        defaultMaxWidth = defaultMaxDimension[0],
        defaultMaxHeight = defaultMaxDimension[1],
        w = perToPx(config.width, availableWidth, perToPx(defaultWidth, availableWidth)),
        h = perToPx(config.height, availableHeight, perToPx(defaultHeight, availableHeight)),
        maxw = perToPx(config.maxWidth, availableWidth, defaultMaxWidth || w),
        maxh = perToPx(config.maxHeight, availableHeight, defaultMaxHeight || h);

      return {
        w: mathMin(maxw, w),
        h: mathMin(maxh, h),
        maxw: maxw,
        maxh: maxh
      };
    };

    tooltip_helpers.getPieColumnIndex = function (chartObj) {
      var piedataindex = validateNullVal(chartObj.systemConf.chart.plot.plotoptions.bubblepie.dataindex, 3);
      var pieIdx;
      chartObj.systemConf.metadata.columns.some(function (c, i) {
        if (c.dataindex === piedataindex) {
          pieIdx = i;
          return true;
        }
      });
      return defined(pieIdx) ? pieIdx : chartObj.dataset.getColumnIdx('y', 0);
    };

    tooltip_helpers.hasSharedSeries = function (chartObj) {
      return chartObj.systemConf.tooltip.sharedSeriesInfo && chartObj.isAxisCategory && !isHeatMapChartType(chartObj.chartTypes[0].value);
    };

    /**
     *
     * @param {Number} type chart type
     * @return {boolean}
     */

    function getEventConf(plotOptions, commonPlotOptions, chartObj, eventType, bulletRect) {
      var events_spo = defined(plotOptions) && defined(plotOptions.events) && plotOptions.events, //spo - seriesplotoptions
        events_cpo = commonPlotOptions.events, //cpo - commonplotoptions
        events_plot = chartObj.systemConf.chart.plot.events;

      if (defined(bulletRect)) {
        events_cpo = commonPlotOptions[bulletRect.type] && commonPlotOptions[bulletRect.type].events;
      }

      var eventFn =
      defined(events_spo) && defined(events_spo[eventType]) ?
      events_spo[eventType] :
      defined(events_cpo) && defined(events_cpo[eventType]) ?
      events_cpo[eventType] :
      events_plot != null ?
      events_plot[eventType] :
      null;

      if (eventFn === undefined && events_plot) {
        eventFn = events_plot[eventType];
      }

      return eventFn;
    }
    Registry.setComponent('events.getConfig', getEventConf);

    function getEventObject(e) {
      return e.changedTouches ? e.changedTouches[0] : e;
    }

    /**
     *
     * @param {Number} type chart type
     * @return {boolean}
     */

    function isBarChartType(type) {
      return (
        type === charttype.bar ||
        type === charttype.stkdbar ||
        type === charttype.bullet ||
        type === charttype.gantt ||
        isHeatMapChartType(type) && type !== charttype.geoheatmap ||
        type === charttype.waterfall ||
        type === charttype.boxplot ||
        type === charttype.barrange);

    }

    /**
     *
     * @param {Number} type chart type
     * @return {boolean}
     */

    function isScatterChartType(type) {
      return chartcategory.dotPlot.indexOf(type) != -1;
    }

    /**
     *
     * @param {Number} type chart type
     * @return {boolean}
     */

    function isBubbleChartType$1(type) {
      return chartcategory.bubble.has(type) || chartcategory.bubblePie.has(type);
    }

    /**
     *
     * @param {Number} type chart type
     * @return {boolean}
     */

    function isWaterfallChartType(type) {
      return seriesIs(type, WATERFALL_CHARTNAME);
    }

    /**
     *
     * @param {Number} type chart type
     * @return {boolean}
     */

    function isPointChartType(type) {
      return isScatterChartType(type) || type === charttype.bubblepie;
    }

    function isSunburstChartType(type) {
      return type === charttype.sunburst;
    }

    function isHeatMapChartType(type) {
      return type === charttype.heatmap || type === charttype.geoheatmap;
    }

    function isPieChartType(type) {
      return chartcategory.piePlot.indexOf(type) != -1;
    }

    function isMultiPieChartType(type) {
      return isPieChartType(type) && type !== charttype.pie;
    }

    /**
     *
     * @param type
     * @return {boolean}
     */
    function isGeoHeatMapChartType(type) {
      return type === charttype.geoheatmap;
    }

    function seriesIs(type, condition) {
      var chartName = isNumber(type) ? charttypenames.get(type) : type;
      return chartName === condition;
    }

    /**
     *
     * @param {Object} chartObj
     * @param {Array} dataPoint
     * @param {Scale} xscale
     * @param {Scale} yscale
     * @param {Number} yaxiscolumnorder
     * @return {{x, y, width, height}}
     */

    function getHeatCellPosition(chartObj, dataPoint, xscale, yscale, yaxiscolumnorder) {
      var dataset = chartObj.dataset,
        commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions.heatmap,
        symbolPath = commonPlotOptions.symbol && getSVGsymbol(commonPlotOptions.symbol),
        xValue = dataset.getX(dataPoint),
        yValue = dataset.getY(dataPoint, yaxiscolumnorder),
        zValue = chartObj.dataObject.hasZaxis ? chartObj.dataObject.getXYvalue(null, null, null, null, null, dataPoint, 'z') : 1,
        xBand = xscale.bandwidth(),
        yBand = yscale.bandwidth(),
        padding = commonPlotOptions.padding || 0,
        maxPaddingPercent = 0.4,
        xBandWithPadding = xBand - 2 * mathMin(padding, xBand * maxPaddingPercent),
        yBandWithPadding = yBand - 2 * mathMin(padding, yBand * maxPaddingPercent),
        x,
        y,
        w,
        h;

      if (chartObj.axes.rotated) {
        w = yBandWithPadding * zValue;
        h = xBandWithPadding * zValue;

        if (symbolPath) {
          w = h = mathMin(w, h);
        }

        y = xscale(xValue) + (xBand - h) / 2;
        x = yscale(yValue) + (yBand - w) / 2;
      } else {
        w = xBandWithPadding * zValue;
        h = yBandWithPadding * zValue;

        if (symbolPath) {
          w = h = mathMin(w, h);
        }

        x = xscale(xValue) + (xBand - w) / 2;
        y = yscale(yValue) + (yBand - h) / 2;
      }

      return {
        x: x,
        y: y,
        width: w,
        height: h
      };
    }

    /**
     *
     * @param {Array} dataPoint
     * @return {{x, y, width, height}}
     */

    function getPackedbubblePosition(dataPoint) {
      var w = 2 * dataPoint.r;
      var h = 2 * dataPoint.r;
      return {
        x: (dataPoint.x || 0) - w / 2,
        y: (dataPoint.y || 0) - h / 2,
        width: w,
        height: h
      };
    }

    function crosshair_enabled(chartObj) {
      return chartObj.systemConf.tooltip.crosshair.type != NONE;
    }

    /**
     *
     * @param {Object} chartObj
     * @param {d3 selection} element
     * @param {Boolean} disabled
     */
    function setPointerEvents(chartObj, element, disabled, paneid) {
      if (!colorscale_helpers.isQuantileColorScale(chartObj) && !isFacet(chartObj)) {
        return;
      }

      var isPyramid = getChartTypeByIndex(chartObj, paneid, 0).value === charttype.pyramid,
        seriesdata_0 = hasColorColumnInNonAxis(chartObj) ?
        chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList('layer').panes[paneid].data :
        isFacet(chartObj) ?
        DataProcessor.helpers.getSeriesdata(chartObj, paneid, 0).data[0] :
        isPyramid ?
        chartObj.seriesdata[0].data[0] :
        NULL$1,
        indexScale = colorscale_helpers.getIndexScale(chartObj);

      element.style('pointer-events', function (d, i) {
        var _ii = isPyramid ? seriesdata_0.length - 1 - i : pick(d && d.seriesIndex, i),
          dt = isPyramid && seriesdata_0 ? seriesdata_0[_ii] : d.data || d, //Pyramid hack
          isDisabled = utils.getVal(disabled, arguments),
          isFiltered;

        if (isFacet(chartObj)) {
          var _i = chartObj.dataObject.isHierarchy ?
          d && d.seriesIndex || dt && dt.seriesIndex || dt && dt.seriesPos || dt && dt._seriesIndex || 0 //TODO: check
          : hasColorColumnInNonAxis(chartObj) ?
          _ii :
          colorscale_helpers.getItemIndex(chartObj, indexScale, dt, _ii);

          isFiltered = isSeriesFiltered(chartObj, paneid, _i);
        }

        if (isDisabled || !isDataActive(isPyramid ? dt : d, chartObj) || isFiltered) {
          return NONE;
        }
      });
    }

    // get tooltip position for both ordinal and continuous scale
    // TODO revamp continuous scale tooltip position.
    function getTooltipPosition(
    event,
    coordinates,
    x,
    y,
    chartObj,
    point,
    axisrotated,
    sharedTooltip,
    sharedTooltipInfo,
    isOrdinalChart,
    isPolar,
    fillColorFunc)
    {
      var tooltipPos = null,
        plotarea = chartObj.plotarea,
        plotarea_approx = chartObj.plotarea_approx,
        // isSingleSourceEvent = chartObj.isAxisCategory || chartObj.dataObject.isPolarAxisCategory || chartObj.isGeoMap;
        isSingleSourceEvent = chartObj.eventHandler.isSingleSource(),
        yaxisorder = point && point.yaxisOrder || 0,
        axisreversed = isObjectPropDefined(chartObj.systemConf, "chart.axes.yaxis[".concat(yaxisorder, "].reversed"), true);

      point = point || {};

      if (sharedTooltip && crosshair_enabled(chartObj)) {
        if (axisrotated) {
          tooltipPos = {
            actLeft: x + plotarea.left,
            actTop: coordinates.y + plotarea.top,
            top: coordinates.y,
            left: isOrdinalChart ? plotarea.width : coordinates.x
          };
        } else {
          // common for both
          tooltipPos = {
            top: 0,
            actTop: plotarea.top + y
          };

          if (isOrdinalChart) {
            tooltipPos.left = coordinates.x;
            tooltipPos.actLeft = coordinates.x + plotarea.left;
          } else {
            tooltipPos.left = x;
            tooltipPos.actLeft = plotarea.left + x;
          }
        }
      } else {
        if (isOrdinalChart || !isSingleSourceEvent) {
          // common for both
          tooltipPos = {
            left: coordinates.x,
            top: coordinates.y
          };

          if (axisrotated) {
            var widthToAdd = axisreversed ? 0 : point && point._width || 0; //ZC2746 for bar chart with axisrotated x value with width should get add
            tooltipPos.actLeft = x + widthToAdd + plotarea.left;
            tooltipPos.actTop = coordinates.y + plotarea.top;
          } else {
            var heightToAdd = axisreversed ? point && point._height || 0 : 0; //ZC2746 for bar chart with axisrotated x value with width should get add
            tooltipPos.actLeft = coordinates.x + plotarea.left;
            tooltipPos.actTop = y + heightToAdd + plotarea.top;
          }
        } else {
          var chartType = getChartTypeByIndex(chartObj, point.paneid, point.seriesIndex || 0).value;

          if (chartObj.dataObject.isFlowChartCategory || arrayIncludes(chartcategory.nonAxisSingleSourceEvent, chartType)) {
            x = coordinates.x;y = coordinates.y;
          }
          tooltipPos = {
            left: x,
            top: y,
            actLeft: plotarea.left + x,
            actTop: plotarea.top + y
          };
        }
      }
      var dLeft = coordinates.x - event.clientX,
        dTop = coordinates.y - event.clientY;

      tooltipPos.dLeft = dLeft + plotarea.left;
      tooltipPos.dTop = dTop + plotarea.top;
      tooltipPos.left -= dLeft;
      tooltipPos.top -= dTop;
      tooltipPos.distance = chartObj.dataObject.isBubbleEnabled && !isOrdinalChart && point._size ? point._size / 2 : 0; //DOUBT
      // tooltipPos.distance = chartObj.dataObject.getXYvalue(axisrotated, stacked(type), xscale, ysc, yscindex, point, 'z', chartObj.zscale) / 2;
      if (!isSingleSourceEvent) {
        tooltipPos.dLeft = dLeft;
        tooltipPos.dTop = dTop;
      }
      // tooltipPos.dLeft = dLeft + plotarea.left;
      // tooltipPos.dTop = dTop + plotarea.top;

      // add dependencies in helper variable

      tooltipPos.helpers = {
        seriesindex: point.seriesIndex,
        subseriespos: isArray$1(point.subSeriesIndex) ? point.subSeriesIndex[point.seriesIndex] : point.subSeriesIndex,
        subseriesLength: isArray$1(point.subseriesLength) ? point.subseriesLength[point.seriesIndex] : point.subseriesLength,
        itempos: pick(point.categoryIndex, point.sortedItemIndex, point.itemIndex),
        paneid: point.paneid,
        itemposShared: point.itemPosShared,
        color: chartObj.seriesColor,
        tooltipSharedInfo: sharedTooltipInfo,
        tooltipShared: sharedTooltip,
        svgFillFunc: fillColorFunc || chartObj.renderer[point.seriesIndex] && chartObj.renderer[point.seriesIndex].fillColorFunc,
        inheritColors: chartObj.dataObject.isWaterfallEnabled,
        d: chartObj.dataObject.isHierarchy || !isSingleSourceEvent ? point.data && point.data.data || point.data || point : point,
        renderTo: 'plot',
        isWithinPlot:
        isOrdinalChart || !isSingleSourceEvent || chartObj.dataObject.isPolarAxisCategory ?
        true :
        pointInRectangle(chartObj.plotarea.left + x, chartObj.plotarea.top + y, {
          x: chartObj.plotarea.left + (chartObj.scrolledX || 0),
          y: chartObj.plotarea.top + (chartObj.scrolledY || 0),
          width: chartObj.plotarea.width,
          height: chartObj.plotarea.height
        })
      };

      if (isPolar) {
        tooltipPos.dLeft += plotarea_approx.x;
        tooltipPos.dTop += plotarea_approx.y;
      }

      return tooltipPos;
    }

    function getColumnIdxBasedOnDataindex(chartObj, options) {
      //check for multi yaxis
      var columns = chartObj.userdata.metadata.columns,
        columnidx = columns.filter(function (d) {
          return d.dataindex === options.dataindex;
        });
      return columnidx[0];
    }

    /**
     *
     * @param {Number} x
     * @param {Number} y
     * @param {Object} rectangle
     * @returns {boolean}
     */

    function pointInRectangle(x, y, rectangle) {
      return geometryUtils.pointInRectangle({ x: x, y: y }, rectangle);
    }

    /**
     * returns distance between point and rectangle
     *
     * @param {{x:Number, y: Number, width: Number, height:Number}} rect
     * @param {{x:Number, y:Number}} point
     */
    function distanceBetweenRectFromPoint(rect, point) {
      var dx = mathMax(rect.x - point.x, 0, point.x - (rect.x + rect.width));
      var dy = mathMax(rect.y - point.y, 0, point.y - (rect.y + rect.height));
      return mathSQRT(dx * dx + dy * dy);
    }

    /**
     *
     * @param {Chart} chartInstance
     * @param {Number} chartType
     * @param {Number} bubbleTriggerOffset
     * @return {Number|null}
     */
    function getTriggeringOffset(chartInstance, cType, bubbleTriggerOffset, subtype) {
      var triggerOffset = null,
        commonPlotOptions = chartInstance.systemConf.chart.plot.plotoptions[charttypenames.get(cType)],
        isContinuousPointType = isPointChartType(cType) || cType === charttype.line, //without area,as area should have no mindist
        filledChartType = !isContinuousPointType,
        customTriggerOffset = commonPlotOptions && commonPlotOptions.events && commonPlotOptions.events.triggerOffset;

      if (defined(customTriggerOffset)) {
        triggerOffset = customTriggerOffset;
      } else if (isBubbleChartType$1(cType) || cType == 'bubble') {
        if (arguments.length === 3) {
          triggerOffset = arguments[2]; // assign as it is
        } else {
          var r = chartInstance.zscale ? chartInstance.zscale.range()[1] / 2 : 10,
            offset = chartInstance.dataObject.isCombinationalChart ? 10 : 50;
          triggerOffset = r + offset; // for bubble charts
        }
      } else if (filledChartType || chartInstance.systemConf.tooltip.sharedSeriesInfo) {
        triggerOffset = null; //for area charts and tooltip shared
      } else if (chartInstance.dataObject.isCombinationalChart && isContinuousPointType || subtype == 'segment') {
        //for whsiker segment
        triggerOffset = 10; // for combo chart with line
      } else {
        triggerOffset = 50; //for line charts
      }
      return triggerOffset;
    }

    function isPointVisible(chart, point) {
      var isWithinClrRange = isDataActive(point, chart),
        isValidData = !isNullData(chart, point),
        isWithinCategories = !point._filter;
      return isWithinClrRange && isValidData && isWithinCategories;
    }

    function isWithinPlotarea(point, chartObj) {
      var x1 = chartObj.plotarea.left + (chartObj.scrolledX || 0),
        y1 = chartObj.plotarea.top + (chartObj.scrolledY || 0),
        x2 = x1 + chartObj.plotarea.width,
        y2 = y1 + chartObj.plotarea.height,
        pointX = point._x + chartObj.plotarea.left,
        pointY = point._y + chartObj.plotarea.top;

      var condition = x1 <= pointX && pointX <= x2 && y1 <= pointY && pointY <= y2;
      if (condition) {
        return 1;
      } else {
        return null;
      }
    }

    function isNullData(chart, point) {
      var dataset = chart.dataset,
        dataProcessorHelpers = DataProcessor.helpers,
        isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
        isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', point.yaxisOrder);
      if (chart.seriesdata[0].type == charttype.stkdarea) {
        return false;
      }
      if (point) {
        // FEATURES_PIVOT_2 treemap null data hover
        var chartType = getChartTypeByIndex(chart, point.paneid, point.seriesindex).value;
        if (arrayIncludes(chartcategory.nonAxisSingleSourceEvent, chartType)) {
          return false;
        }
      }

      return point == null || isCatNullX(dataset.getX(point)) || isCatNullY(dataset.getY(point, point.yaxisOrder));
    }

    function XY(axisrotated) {
      var X = 'x',
        Y = 'y';
      if (axisrotated) {
        X = 'y';
        Y = 'x';
      }
      return [X, Y];
    }

    /**
     *
     * @param {Chart|GeoMap} chart
     * @return {boolean}
     */
    function isDependentPointHighlightType(chart) {
      return chart.chartTypes[0].name === SANKEY_CHARTNAME;
    }

    //$Id$
    //intelligence-utils.js

    function dimension_based_intelligence(chartObj, factor, dimension) {
      var intelligenceInfo = +chartObj.systemConf.canvas.intelligence.dimension[factor];
      return dimension >= intelligenceInfo;
    }

    function datacount_based_intelligence(chartObj, factor) {
      var intelligenceInfo = +chartObj.systemConf.canvas.intelligence.dataCount[factor];
      return intelligenceInfo >= chartObj.dataObject.totalnoofdatas;
    }

    //$Id$
    var ZC_LEGEND_maxHeightVertRatio = '80%',
      ZC_LEGEND_maxHeightHoriRatio = '20%',
      ZC_LEGEND_maxWidthVertRatio = '20%',
      ZC_LEGEND_maxWidthHoriRatio = '100%',
      ZC_LEGEND_maxCenterWidth = '30%',
      ZC_LEGEND_maxCenterHeight = '30%',
      LEGEND_TITLE_MAX_WIDTH_HORIZONTAL = '50%',
      LEGEND_TITLE_MAX_WIDTH_VERTICAL = '100%';

    // Class name
    var LEGSERIES_LEGEND_CLASSNAME = 'zc-legend-legseries',
      SERIES_LEGEND_CLASSNAME = 'zc-legend-series',
      LEGSERIES_HEADER_CLASSNAME = 'zc-header-legseries',
      //
      TRACK_FLASH_CLASSNAME = 'zc-track-flash',
      TRACK_SYMBOL_CLASSNAME = 'zc-track-symbol',
      TRACK_LEGEND_CLASSNAME = 'zc-legend-track',
      //
      NESTED_AXIS_CLASSNAME = 'zc-nested-axis',
      NESTED_AXIS_TICKMARK_CLASSNAME = 'zc-nested-axis-tickmark',
      NESTED_AXIS_TICKLABEL_CLASSNAME = 'zc-nested-axis-ticklabel',
      //
      SLIDER_VIEW_CLASSNAME = 'zc-slider-view',
      SLIDER_AXIS_CLASSNAME = 'zc-slider-axis',
      //
      CONNECTOR_LEGEND_CLASSNAME = 'zc-legend-connector',
      CONNECTOR_LINE_CLASSNAME = 'zc-connector-line',
      //
      EXPANDABLE_CLASSNAME = 'zc-expandable',
      HIGHLIGHT_LEGEND_CLASSNAME = 'zc-legend-highlight',
      // minmax labels
      MINMAXLABEL_LEGEND_CLASSNAME = 'zc-legend-minmaxlabels',
      // Slider events
      SLIDER_HANDLE_TRACK_CLASSNAME = 'custom-handle-path-track',
      CUSTOM_HANDLE_PATH_CLASSNAME = 'custom-handle-path';

    function getPlotBound(chartObj) {
      var l = -chartObj.scrolledX || 0,
        t = -chartObj.scrolledY || 0;
      return {
        left: l,
        top: t,
        right: getPlotSize(chartObj, 'width'),
        bottom: getPlotSize(chartObj, 'height')
      };
    }

    function getPlotSize(chartObj, type, plotarea, gridSize, customPlotSize) {
      plotarea = plotarea || chartObj && chartObj.plotarea;
      var plotareaSize = gridSize || plotarea[type];
      var customSize = customPlotSize || chartObj && chartObj.systemConf.chart[type];
      if (customSize == null || isNaN(customSize)) {
        return plotareaSize;
      }
      return mathMax(plotareaSize, +customSize);
    }

    function fadeOnSelectAll(enable, chartObj, opacity, forceEnable, order) {
      var hasMultipleColorLegend = isObjectPropDefined(chartObj.dataObject, 'hierarchical.pivotLayout.layers.groups.length', true) > 1,
        _enable = isEnabled(chartObj, forceEnable, order),
        _color = 'white';

      if (isFacet(chartObj) && hasMultipleColorLegend) {
        var overLaySVG = createElement('svg', '.zc-fade-overlay-svg', [1], chartObj.container.selectAll('.canvas-component')),
          overLayClipHolder = createElement('g', '.zc-fade-overlay-clip-holder', [1], overLaySVG),
          overLay = createElement('rect', '.zc-fade-overlay', [1], overLayClipHolder);

        overLaySVG.
        attrs({
          version: '1.1',
          xmlns: d3_namespaces.svg
        }).
        styles({
          position: 'absolute',
          left: 0,
          top: 0,
          width: chartObj.getChartDimension('width'),
          height: chartObj.getChartDimension('height'),
          'box-sizing': 'border-box',
          'pointer-events': 'none'
        });

        if (!_enable) {
          fadeAll(false, chartObj, opacity);
          fadeAxis(chartObj, false);
          overLay.style('visibility', 'hidden');
          return;
        }
        fadeAll(true, chartObj, opacity);

        var clipPathID,
          desc = '',
          gridList = getGridList(chartObj.dataObject),
          count = 0;

        gridList.forEach(function (grid) {
          var _chartObj$rendererCon = chartObj.rendererConf[count].params,bound = _chartObj$rendererCon.bound,yaxiscolumnorder = _chartObj$rendererCon.yaxiscolumnorder,
            row = grid.row,layer = grid.layer,data = grid.data,
            state = chartObj.legend.state["clr-".concat(layer)],
            allSelected = defined(forceEnable) && "clr-".concat(layer) === "clr-".concat(order) ? forceEnable : state.allSelected;

          fadeAxis(chartObj, !allSelected, opacity, "y-axis-".concat(row));
          desc += !allSelected ? getGridBound(chartObj, bound) : '';
          count += data.length;
        });

        var properties = { d: desc, name: 'zc-legend-selectAll', id: chartObj.id };
        clipPathID = desc ? effects.get(effects.svg_clips, 'polygon', properties, { chartObj: chartObj }) : null;

        overLay.
        attrs({
          x: chartObj.plotarea.left,
          y: chartObj.plotarea.top,
          width: getPlotSize(chartObj, 'width'),
          height: getPlotSize(chartObj, 'height'),
          transform: "translate(".concat(-chartObj.scrolledX || 0, ",").concat(-chartObj.scrolledY || 0, ")"),
          'clip-path': clipPathID ? "url(".concat(chartObj.defsLocation, "#").concat(clipPathID, ")") : null
        }).
        styles({
          fill: _color,
          opacity: 1 - opacity,
          visibility: clipPathID ? null : 'hidden'
        });
      } else {
        fadeAll(_enable, chartObj, opacity);
      }
    }

    function fadeAll(enable, chartObj, opacity) {
      var ele = chartObj.container.selectAll('g.chartgroup,svg.static,canvas.zc-canvas,canvas.zc-labelholder-canvas,div.zcnotes');
      ele.style('opacity', enable ? NULL$1 : opacity);
      elementPriority(ele, enable ? NULL$1 : ['opacity']);
    }

    function isEnabled(chartObj, forceEnable, order) {
      if (isFacet(chartObj)) {
        var _enable = false;
        chartObj.legends.forEach(function (legend) {
          if (legend.meta.encode === 'clr') {
            var state = chartObj.legend.state && chartObj.legend.state[legend.id] || { allSelected: true };
            _enable =
            _enable || (
            defined(forceEnable) && legend.id === "clr-".concat(order) ? forceEnable : legend.enabled ? state.allSelected : true);
          }
        });

        return _enable;
      } else {
        var state = chartObj.legend.states || {};
        return pick(forceEnable, state.allSelected);
      }
    }

    function fadeAxis(chartObj, fade, opacity, id) {
      var axisWrap;
      if (id) {
        axisWrap = chartObj.container.selectAll("g.".concat(id));
      } else {
        axisWrap = chartObj.container.selectAll('g.y-axis').selectAll(function () {
          return this.childNodes;
        });
      }

      axisWrap.style('opacity', fade ? opacity : null);
    }

    function getGridBound(chartObj, bound) {
      var x = bound.x,y = bound.y,width = bound.width,height = bound.height,_chartObj$plotarea =
        chartObj.plotarea,plotarea_left = _chartObj$plotarea.left,plotarea_top = _chartObj$plotarea.top;

      return "M".concat(plotarea_left + x, " ").concat(plotarea_top + y, " L").concat(plotarea_left + x + width, " ").concat(plotarea_top + y, " L").concat(plotarea_left +
      x +
      width, " ").concat(plotarea_top + y + height, " L").concat(plotarea_left + x + width, " ").concat(plotarea_top + y + height, " L").concat(plotarea_left +
      x, " ").concat(plotarea_top + y + height, " Z");
    }

    //$Id$

    var legend_helpers = {};
    legend_helpers.getLegendData = function (chartObj, order) {
      // Continuous color - ranges
      if (colorscale_helpers.isQuantileColorScale(chartObj)) {
        var userRanges = chartObj.systemConf.legend.colorBand.ranges;
        if (userRanges && userRanges.length) {
          return userRanges;
        }
      }

      //Pivot - non axis chart
      var dataObject = chartObj.dataObject;
      if (
      chartObj._isAxisCategory() &&
      !dataObject.isAxisCategory &&
      !dataObject.isPolarAxisCategory &&
      !dataObject.isNonAxisMultiSeriesCategory &&
      !hasColorColumnInNonAxis(chartObj))
      {
        var gridList = getGridList(dataObject);
        return gridList[order || 0].data[0].data[0]; //TODO: check for missing data in the first grid
      }

      var categoryHierarchy = chartObj.dataObject.categoryHierarchy;
      if (categoryHierarchy) {
        var hierarchical = chartObj.dataObject.hierarchical,
          pivotLayout = hierarchical.pivotLayout,
          rowList = pivotLayout.getRootNodeList('row'),
          layers = pivotLayout.layers,
          isLayerNode = layers.isLayerNode,
          hasMultiClusterRows = rowList.hasMultiCluster(),
          hasMultiLayers = layers.groups.length > 1,
          panes = layers.panes,
          gridlist = objectValues(panes);
        if (hasMultiLayers || hasMultiClusterRows && isLayerNode) {
          return gridlist[order || 0].data;
        }

        if (hasColorColumnInNonAxis(chartObj)) {
          return chartObj.seriesdata;
        }
      }
      if (chartObj.isAxisCategory || chartObj.isNonAxisMultiSeriesCategory || chartObj.isGeoMap) {
        return chartObj.seriesdata;
      } else if (chartObj.dataObject.isFlowChartCategory) {
        return chartObj.cache.sankey.legend;
      } else {
        return chartObj.seriesdata[0].data[0];
      }
    };

    legend_helpers.getLegendDataLength = function (chartObj, legData) {
      if (chartObj.isAxisCategory || chartObj.isNonAxisMultiSeriesCategory) {
        return legData.filter(function (d) {
          return !legend_helpers.isHiddenItem(d);
        }).length;
      } else {
        return legData.length;
      }
    };

    legend_helpers.isHiddenItem = function (d) {
      return d && d.hideInLegend;
    };

    legend_helpers.getClr = function (disabled, defaultClr, disabledOptions) {
      return disabled ? disabledOptions.color || defaultClr : defaultClr;
    };

    legend_helpers.updateBubblePieData = function (d, i, chartObj) {
      if (chartObj.dataObject.pieWithAxis) {
        d.data.forEach(function (subseries) {
          var isBubblePie = isMultiPieChartType(chartObj.chartTypes[i].value);
          subseries.forEach(function (dataPoint) {
            dataPoint.disabled = d.disabled || !isBubblePie || dataPoint.dummy;
          });
        });
      }
    };

    legend_helpers.updateHierarchyData = function (d, i, chartObj) {
      if (chartObj.dataObject.isHierarchy) {
        chartObj.systemConf.seriesdata.chartdata[i].disabled = d.disabled;
      }
    };

    legend_helpers.toggleChartEvents = function (chartObj, enable) {
      var hasMultipleColorLegend = isObjectPropDefined(chartObj.dataObject, 'hierarchical.pivotLayout.layers.groups.length', true) > 1;

      if (isFacet(chartObj) && hasMultipleColorLegend) {
        chartObj.container.selectAll('rect.zc-fade-overlay').style('pointer-events', enable ? NONE : 'all');
        return;
      }

      var val = enable ? null : NONE,
        elements = [];
      if (!chartObj.svg) {
        elements.push(chartObj.container);
      } else {
        elements.push(chartObj.eventHandler.trackerElement);
        elements.push(chartObj.svg);
      }
      elements.forEach(function (d) {
        d.style('pointer-events', val);
      });
    };

    legend_helpers.fadeChart = function (enable, chartObj, opacity, forceEnable, order) {
      fadeOnSelectAll(enable, chartObj, opacity, forceEnable, order);
    };

    legend_helpers.isDisabled = function (d, allSelected, isFirstClickAfterDeselection) {
      return !allSelected && !isFirstClickAfterDeselection ? !allSelected : legend_helpers.isItemDisabled(d);
    };

    legend_helpers.isItemDisabled = function (d) {
      var dt = d.node || d;
      return dt.disabled || dt.filtered || d.disabled || d.filtered;
    };

    legend_helpers.isAllEnabled = function (legData, allSelected) {
      if (!allSelected) {
        return allSelected;
      }
      var disabledEle = legData.filter(legend_helpers.isItemDisabled);
      return !disabledEle.length;
    };

    legend_helpers.getFilterBoxSize = function (config, _default) {
      var size = pick(config.size, _default),
        width = pick(config.width, size),
        height = pick(config.height, size);

      return [width, height];
    };

    legend_helpers.updateData = function (d, i, chartObj) {
      if (colorscale_helpers.isQuantileColorScale(chartObj)) {
        chartObj.axes.clr.scale = scale.getScale(chartObj, chartObj.dataObject, null, null, null, chartObj.dataset, 'clr');
      } else if (!isFacet(chartObj)) {
        legend_helpers.updateBubblePieData(d, i, chartObj); //For bubblepie chart, it is mandatory to mark every data point to be disabled if the series is disabled
        legend_helpers.updateHierarchyData(d, i, chartObj); //For hierarchy chart, chartObj.seriesdata reference is not equal to chartObj.systemConf.seriesdata.chartdata reference as the chartObj.seriesdata is simplecloned. So, storing disable information at systemconf is mandatory
        chartObj.dataObject.data = chartObj.systemConf;
      }
    };

    legend_helpers.isContinousLegend = function (chartObj) {
      if (colorscale_helpers.isQuantileColorScale(chartObj)) {
        var _config2 = chartObj.systemConf.legend,
          type = getLegendType(_config2, chartObj);

        return type === 'continuousDiscrete' || type === 'continuous';
      }

      return false;
    };

    legend_helpers.getColorBandDimension = function (config, bound, chartObj) {
      var chartarea = chartObj.chartarea || chartObj,
        legendOptions = config,
        legendAlignment = getLegendAlignment(legendOptions),
        colorbandOptions = legendOptions.colorBand,
        isHorizontal = legendAlignment.layout === 'horizontal',
        maxWidth = bound.maxWidth,maxHeight = bound.maxHeight,
        w = colorbandOptions.width,
        h = colorbandOptions.height;

      if (isHorizontal) {
        w = w || '40%';
        h = h || 14;
      } else {
        w = w || 14;
        h = h || '70%';
      }

      //Remove---
      // Adopting old
      if (!bound.adjust) {
        var legendMaxDimension = getDefaultLegendMaxDimension(legendOptions);
        maxWidth = legendMaxDimension.width;
        maxHeight = legendMaxDimension.height;
      }
      //---Remove

      maxWidth = perToPx(maxWidth, chartarea.width);
      maxHeight = perToPx(maxHeight, chartarea.height);

      if (bound.adjust) {
        var percent = 0.8;
        if (isHorizontal) {
          maxWidth *= percent;
        } else {
          maxHeight *= percent;
        }
      }

      w = perToPx(w, chartarea.width);
      h = perToPx(h, chartarea.height);

      w = mathMin(w, maxWidth);
      h = mathMin(h, maxHeight);

      return [w, h];
    };

    legend_helpers.getOrient = function (legendOptions) {
      var align = getLegendAlignment(legendOptions),
        hAlign = align.hAlign,
        vAlign = align.vAlign,
        floating = align.floating,
        isHorizontal = align.layout === HORIZONTAL_ALIGN,
        orient,
        columnViewOrients = {
          top: 'top',
          center: 'bottom',
          bottom: 'bottom'
        },
        rowViewOrients = {
          left: 'left',
          center: 'right',
          right: 'right'
        };

      if (floating) {
        orient = isHorizontal ? BOTTOM_ALIGN : RIGHT_ALIGN;
      } else if (isHorizontal) {
        // -->
        orient = columnViewOrients[vAlign];
      } else {
        orient = rowViewOrients[hAlign];
      }

      return orient;
    };

    legend_helpers.getLabelIndex = function (value, colorbandOptions, dataType) {
      var userStops = colorbandOptions.stops,
        userRanges = colorbandOptions.ranges,
        labelIndex;

      if (userRanges && userRanges.length) {
        userRanges.some(function (d, i) {
          var condition;
          if (isArray$1(d)) {
            if (isArray$1(value)) {
              condition = d[0] === value[0] && d[1] === value[1];
            } else {
              condition = d[0] === value;
            }
          } else {
            condition = d === value;
          }
          if (condition) {
            labelIndex = i;
            return true;
          }
        });
      } else if (dataType !== ORDINAL_DATATYPE && userStops && userStops.length) {
        userStops.some(function (d, i) {
          var condition = d === value;
          if (condition) {
            labelIndex = i;
            return true;
          }
        });
      }

      return labelIndex;
    };

    legend_helpers.hexToRGB = function (color) {
      //Converting hex colors to rgb
      if (color && color.toString().indexOf('#') == -1) {
        return color;
      }
      var bigint = pInt(rgb2hex(color).replace(/#/g, ''), 16);
      return "rgb(".concat(bigint >> 16 & 255, ",").concat(bigint >> 8 & 255, ",").concat(bigint & 255, ")");
    };

    legend_helpers.filterSelectionByColor = function (selection, selectedSeries, filterIndex, chartObj) {var encode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'clr';
      var options;

      if (encode === 'clr') {
        var _config3 = chartObj.systemConf.legend;
        options = {
          encode: encode,
          config: _config3,
          userRanges: _config3.colorBand.ranges,
          scale: chartObj.axes.clr.scale,
          dataType: chartObj.dataset.getDataType('clr'),
          dataAccessor: function dataAccessor(d) {return chartObj.dataset.getClr(d);},
          valueByIdex: function valueByIdex(i) {return getColorByIndex(chartObj, i);}
        };
      } else if (encode === 'z') {
        var scaleComp = arrayFind(chartObj.scales, function (_) {return _.id === 'z-0';}),
          _scale2 = scaleComp.getScale(),
          scale_range = _scale2.range(),
          legendConfig = chartObj.systemConf.legend,
          _config4 = legendConfig.size[scaleComp.key] || legendConfig.size;

        options = {
          encode: encode,
          config: _config4,
          scale: _scale2,
          userRanges: _config4.ranges,
          dataType: chartObj.dataset.getDataType('z'),
          dataAccessor: function dataAccessor(d) {
            var val = chartObj.dataset.getZ(d),
              nullAsOptions = { config: _config4, scale: _scale2, columnKey: chartObj.dataset.getColumnIdx(encode) };
            val = convertNull(val, nullAsOptions);
            return val;
          },
          valueByIdex: function valueByIdex(i) {return scale_range[i];}
        };
      }

      return filterSelection(selection, selectedSeries, filterIndex, chartObj, options);
    };

    function filterSelection(selection, selectedSeries, filterIndex, chartObj, options) {
      if (defined(filterIndex)) {
        var _config5 = options.config,_scale3 = options.scale,dataType = options.dataType,dataAccessor = options.dataAccessor,_userRanges = options.userRanges,encode = options.encode,valueByIdex = options.valueByIdex,
          _getValue = function _getValue(d) {return dataAccessor(d._acutalData && d._acutalData() || d.data || d);}; // ZC2729 _actualData is only for Pyramid chart as data is reversed for Pyramid

        if (_userRanges && _userRanges.length) {
          var filterValue = splat(_userRanges[filterIndex]),
            isOrdinal = dataType === ORDINAL_DATATYPE;

          if (filterValue.length === 1 && !isOrdinal) {
            var domain = d3_values(_scale3.domain());
            domain.splice(0, 2);
            filterValue = [domain[filterIndex * 2], domain[filterIndex * 2 + 1]];
          }

          return selection.filter(function (d) {
            var val = _getValue(d),
              condition = isDataActive(d, chartObj) && isWithinEncode(val, encode, chartObj, _scale3, _config5, { range: filterValue });

            if (isOrdinal) {
              condition = condition && val === filterValue[0];
            } else {
              condition = condition && val >= filterValue[0] && val <= filterValue[1];
              if (val === filterValue[0]) {
                condition = condition && valueByIdex(filterIndex) === _scale3(val);
              }
              if (val === filterValue[1]) {
                condition = condition && valueByIdex(filterIndex) === _scale3(val);
              }
            }
            return selectedSeries ? condition : !condition;
          });
        } else {
          return selection.filter(function (d) {
            var val = _getValue(d),
              condition = isDataActive(d, chartObj) && isWithinEncode(val, encode, chartObj, _scale3, _config5, { range: filterIndex });

            return selectedSeries ? condition : !condition;
          });
        }
      } else {
        return selection.filter(function (d) {return isDataActive(d, chartObj);});
      }
    }

    legend_helpers.isReversedColorAxis = function (config) {
      return config.colorAxis && config.colorAxis.reversed;
    };

    legend_helpers.hasPatternPallete = function (chartObj) {
      var patternPallete = chartObj.patternPallete;
      return patternPallete && patternPallete.length;
    };

    /**
     *
     * @param legendOptions
     * @return {{width: number, height: number}}
     */
    function getDefaultLegendMaxDimension(legendOptions) {
      var legendAlign = getLegendAlignment(legendOptions),
        vAlign = legendAlign.vAlign,
        hAlign = legendAlign.hAlign,
        isHorizontalLayout = legendAlign.layout === 'horizontal',
        widthRatio = 0,
        heightRatio = 0;

      if (isHorizontalLayout) {
        if (vAlign === 'top' || vAlign === 'bottom') {
          widthRatio = ZC_LEGEND_maxWidthHoriRatio;
          heightRatio = ZC_LEGEND_maxHeightHoriRatio;
        } else if (vAlign === 'center') {
          widthRatio = ZC_LEGEND_maxCenterWidth;
          heightRatio = ZC_LEGEND_maxHeightVertRatio;
        }
      } else {
        if (hAlign === 'left' || hAlign === 'right') {
          widthRatio = ZC_LEGEND_maxWidthVertRatio;
          heightRatio = ZC_LEGEND_maxHeightVertRatio;
        } else if (hAlign === 'center') {
          widthRatio = ZC_LEGEND_maxWidthHoriRatio;
          heightRatio = ZC_LEGEND_maxCenterHeight;
        }
      }

      return {
        width: widthRatio,
        height: heightRatio
      };
    }

    /**
     *
     * @param legendConfig
     * @returns {{hAlign: *, vAlign: *, layout: *}}
     */
    function getLegendAlignment(config) {
      // fix center top
      var hAlign = config.hAlign,vAlign = config.vAlign,view = config.layout,x = config.x,y = config.y,
        floating = defined(x) && defined(y);

      // keep existing support
      if (hAlign === 'center' && vAlign === 'center') {
        hAlign = 'right';
      }

      if (floating) {
        hAlign = LEFT_ALIGN;
        vAlign = TOP_ALIGN;
      }

      if (!defined(view)) {
        if (floating) {
          view = 'vertical';
        } else if (vAlign === 'top' || vAlign === 'bottom') {
          view = 'horizontal';
        } else {
          view = 'vertical';
        }
      }

      return {
        hAlign: hAlign,
        vAlign: vAlign,
        layout: view,
        floating: floating
      };
    }

    function elementPriority(element) {var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var className = 'zc-priority';
      if (arguments.length === 1) {
        return JSON.parse(element.attr(className)) || [];
      } else {
        element.attr(className, jsonStringify(properties));
      }
    }

    function isLegendEnabled(config, chartObj) {var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'color';
      var _getLegendAlignment = getLegendAlignment(config),vAlign = _getLegendAlignment.vAlign,floating = _getLegendAlignment.floating,
        dim = chartObj.canvasarea[vAlign === TOP_ALIGN || vAlign === BOTTOM_ALIGN ? 'height' : 'width'],
        intelligence = dimension_based_intelligence(chartObj, 'legend', dim);

      if ((floating || intelligence) && _encodingBased(encoding, chartObj)) {
        // #ZC2582
        if (chartObj.dataObject.isFlowChartCategory && config.enabled) {
          return chartObj.dataObject.sankeyLayout.nodeLength > 0;
        }

        return config.enabled;
      }

      return false;
    }

    function hasAssociatedLegendData(chartObj) {
      var nonAxisSingleSeries =
      isFacet(chartObj) &&
      arrayIncludes([PIE_CHARTNAME, FUNNEL_CHARTNAME, PYRAMID_CHARTNAME], chartObj.chartTypes[0].name) &&
      !chartObj.userdata.facets.color.length;

      return isFacet(chartObj) && !nonAxisSingleSeries;
    }

    function getLegendContainer(chartObj) {var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'clr-0';
      if (isFacet(chartObj)) {
        var legendObj = chartObj.legends.get(id);
        return legendObj && legendObj.element || chartObj.legendarea.element;
      }

      return chartObj.legendarea.element;
    }

    function getLegendConfig(encodeType, key, chart) {
      var encode = encodeType === 'z' ? 'size' : encodeType === 'clr' ? 'color' : encodeType,
        baseConfig = chart.systemConf.legend;

      return baseConfig[encode][key] || baseConfig[encode];
    }

    function _encodingBased(encoding, chartObj) {
      switch (encoding) {
        case 'color':{
            if (colorscale_helpers.isQuantileColorScale(chartObj)) {
              return true;
            }

            var multiSeries = chartObj.isAxisCategory || chartObj.isNonAxisMultiSeriesCategory || chartObj.isGeoMap, // #ZC1859
              accessor = function accessor(d) {return !legend_helpers.isHiddenItem(d) && d.seriesname !== UNDEFINED;},
              hasPivotLayerNode = true;

            if (chartObj.dataObject.pivot) {
              var layers = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList('layer');
              hasPivotLayerNode = !layers.noLayers;
            }
            return multiSeries ?
            chartObj.seriesdata.some(accessor) && hasPivotLayerNode :
            chartObj.chartTypes[0].value === charttype.dial ?
            chartObj.seriesdata[0].data[0].length > 1 && !isFacet(chartObj) :
            true;
          }
        default:
          return true;}

    }

    //dataImage.js

    function getSVGImage(patternEle, base64) {
      var xml =
      "<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='".concat(patternEle.w, "' height='").concat(
      patternEle.h, "'>").concat(
      new XMLSerializer().serializeToString(patternEle.node.node()), "<path d='") + "M-5,-5 L5,-5 L5,5 L-5,5 Z" + "' transform='translate(".concat(

      patternEle.w / 2, ",").concat(patternEle.h / 2, ")' style='fill: ") + "url(#".concat(
      patternEle.id, ")'></path> </svg>");
      return {
        url: $Browser.FIREFOX || base64 ? "data:image/svg+xml;base64,".concat(btoa(xml)) : "data:image/svg+xml;utf8,".concat(xml),
        width: patternEle.w,
        height: patternEle.h
      };
    }

    //

    function getPattern$1(_, applied) {
      var context = _.context,_$defsPath = _.defsPath,defsPath = _$defsPath === void 0 ? '' : _$defsPath,_$rendererMode = _.rendererMode,rendererMode = _$rendererMode === void 0 ? 'svg' : _$rendererMode,
        color = applied.color,pattern = applied.pattern,opacity = applied.opacity,size = applied.size,staticColor = applied.staticColor,
        _rendererMode = rendererMode === 'base64' ? 'svg' : rendererMode;

      return function (d, i) {
        var _pattern = getVal(pattern, [d, i]),
          _color = getVal(color, [d, i]),
          _opacity = getVal(opacity, [d, i]),
          //
          prop = getPatternProp(_pattern, _color, _opacity, size, staticColor), // TODO: size
          args = { renderTo: context, returnSVGimage: rendererMode === 'base64' },
          patternEle = effects.get(effects["".concat(_rendererMode, "_patterns")], "".concat(_rendererMode, "PatternFill"), prop, args);

        return rendererMode === 'base64' ? "url(".concat(
        getSVGImage(patternEle, true).url, ")") :
        rendererMode === 'svg' ? "url(".concat(
        defsPath, "#").concat(patternEle, ")") :
        patternEle;
      };
    }

    //

    function getByEncode(_) {
      var scale = _.scale,field = _.field,accessor = _.accessor,value = _.value;

      if (!accessor) {
        if (field) {
          accessor = function accessor(d) {return d[field.dataindex];};
        } else {
          accessor = function accessor(d) {return d;};
        }
      }

      if (!value) {
        value = function value(_) {
          var scale = _.scale,field = _.field,config = _.config;
          return function (d, i) {
            return scale(accessor(d));
          };
        };
      }

      return value(_);
    }

    // let sample = {
    //     _type: 'encode',
    //     encode: {
    //         scale: d => d,
    //         field: {
    //             dataindex: 1
    //         }
    //     }
    //     // accessor: d => d[1],
    //     // value: function(_) {
    //     //     let { scale, field, config } = _;
    //     //     return function(d, i) {
    //     //         return scale(d) + _spec.padding;
    //     //     };
    //     // }
    // };
    //
    // let samplePattern = {
    //     _type: 'pattern',
    //     color: 'red',
    //     color: {
    //         _type: 'encode',
    //         encode: 'color-0'
    //     },
    //     pattern: 'hatchfill',
    //     pattern: {
    //         _type: 'encode',
    //         encode: 'pattern-0'
    //     }
    // };
    //
    // let sampleGradient = {
    //     _type: 'gradient',
    //     color: 'red',
    //     color: {
    //         _type: 'encode',
    //         encode: 'color-0'
    //     },
    //     gradient: {
    //         _type: 'gradient',
    //         config: {
    //             x1: '',
    //             x2: '',
    //             y1: '',
    //             y2: '',
    //             x: '',
    //             y: '',
    //             radius: '',
    //             stops: [
    //                 {
    //                     offset: 0,
    //                     color: 'red',
    //                     color: {
    //                         _type: 'encode',
    //                         encode: 'color-0'
    //                     },
    //                     opacity: 1
    //                 }
    //             ]
    //         }
    //     }
    // };
    // let sampleImage = {
    //     _type: 'imagePattern',
    //     image: 'url()',
    //     image: {
    //         _type: 'encode',
    //         encode: 'image-0'
    //     }
    // };

    //

    function getByGradient(_, applied) {
      var context = _.context,_$defsPath2 = _.defsPath,defsPath = _$defsPath2 === void 0 ? '' : _$defsPath2,_$rendererMode2 = _.rendererMode,rendererMode = _$rendererMode2 === void 0 ? 'svg' : _$rendererMode2,_$dimension = _.dimension,dimension = _$dimension === void 0 ? [0, 300] : _$dimension,
        color = applied.color;

      return function (d, i) {
        var _color = getVal(color, [d, i]),
          fillOpacity = 0,
          prop = getGradientProp$1(applied, dimension, _color, fillOpacity),
          gradientEle = effects.get(effects["".concat(rendererMode, "_gradients")], "".concat(rendererMode, "GradientFill"), prop, { renderTo: context });

        return rendererMode === 'svg' ? "url(".concat(defsPath, "#").concat(gradientEle, ")") : gradientEle;
      };
    }

    function getGradientProp$1(applied, dimension, color, opacity) {
      var type = applied.gradient;
      var options = applied;
      var prop = simpleClone(_objectSpread(_objectSpread({}, options), {}, { chart: undefined, context: undefined })); // TODO: context
      // let stopColor = [],
      //     stopOpacity = [],
      //     stopOffset = [];

      // let { stops = [] } = prop;
      // stops.forEach((_, i) => {
      //     if (_.color) {
      //         stopColor[i] = _.color;
      //     }
      //     if (_.opacity) {
      //         stopOpacity[i] = _.opacity;
      //     }
      //     if (_.offset) {
      //         stopOffset[i] = _.offset;
      //     }
      // });

      prop.color = color != null ? color : prop.color;
      prop.opacity = opacity != null ? opacity : prop.opacity;
      prop.dimension = dimension != null ? dimension : prop.dimension;
      prop.type = type;

      return _objectSpread({},
      prop);




    }

    //

    function getImage(_, applied) {
      var context = _.context,_$defsPath3 = _.defsPath,defsPath = _$defsPath3 === void 0 ? '' : _$defsPath3,_$rendererMode3 = _.rendererMode,rendererMode = _$rendererMode3 === void 0 ? 'svg' : _$rendererMode3;
      var url = applied.url,width = applied.width,height = applied.height,_applied$x = applied.x,x = _applied$x === void 0 ? 0 : _applied$x,_applied$y = applied.y,y = _applied$y === void 0 ? 0 : _applied$y,
        _rendererMode = rendererMode === 'base64' ? 'svg' : rendererMode;

      return function (d, i) {
        var prop = {
            name: getVal(url, [d, i]),
            width: getVal(width, [d, i]),
            height: getVal(height, [d, i]),
            x: getVal(x, [d, i]),
            y: getVal(y, [d, i]),
            mode: _rendererMode,
            context: context
          },
          imageEle = effects.get(effects["".concat(_rendererMode, "_patterns")], 'imageFill', prop, { renderTo: context });

        return rendererMode === 'svg' ? "url(".concat(defsPath, "#").concat(imageEle, ")") : imageEle;
      };
    }

    //

    function findBestParser(name, as, _) {
      var cache = _.cache,parser = _.parser;

      var saved = cache.as[pick(name, 'zcUnNamed')];
      if (saved.length === 1) {
        return saved[0];
      }

      var filteredParser = saved.filter(
      function (_) {return (
          _._as &&
          objectEntries(_._as).
          map(function (_) {return _[0];}).
          indexOf(as) !== -1);});

      if (filteredParser.length === 1) {
        return filteredParser[0];
      }

      return findByLevel(filteredParser, parser._level);
    }

    function findByLevel(parser, level) {
      if (!level) {
        return parser[0];
      }

      var has = parser.filter(function (_) {return _._level.indexOf(level) === 0;});
      if (has.length) {
        return has[0];
      }

      return findByLevel(parser, level.substr(0, level.length - 2));
    }

    //

    function exportAs(_, applied) {
      var name = _.name,as = _.as,_$onEnd = _.onEnd,onEnd = _$onEnd === void 0 ? function (d) {return d;} : _$onEnd;

      var val = findBestParser(name, as, this)._as[as];

      return function (d, i) {return onEnd(val[i]);};
    }

    //

    var ALLOWED_CONFIG_OPERATORS = d3_map();
    ALLOWED_CONFIG_OPERATORS.set('pattern', getPattern$1);
    ALLOWED_CONFIG_OPERATORS.set('encode', getByEncode);
    ALLOWED_CONFIG_OPERATORS.set('gradient', getByGradient);
    ALLOWED_CONFIG_OPERATORS.set('image', getImage);
    ALLOWED_CONFIG_OPERATORS.set('as', exportAs);

    //$Id$

    function rgb2hex(color) {
      var rgb = color.match(RGBA_PATTERN);
      return rgb && rgb.length === 5 ? "#".concat(
      "0".concat(parseInt(rgb[1], 10).toString(16)).slice(-2)).concat("0".concat(parseInt(rgb[2], 10).toString(16)).slice(-2)).concat("0".concat(parseInt(
      rgb[3],
      10).
      toString(16)).slice(-2)) :
      color;
    }
    Registry.setComponent('color.rgb2hex', rgb2hex);

    function toRGBA(color, opacity) {
      var rgba = d3_rgb(color);
      rgba.opacity = isUndefined(opacity) ? 1 : opacity;
      return rgba.toString();
    }

    function rgba_canvas(color, opacity) {
      opacity = pick(opacity, 1);
      var rgb = d3_rgb(color);
      return "rgba(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ",").concat(opacity * rgb.opacity, ")");
    }

    //NEED TO CHANGE FUNCTION NAME
    function getColorCopy(color, k, copyType, colorMode) {
      if (color === TRANSPARENT) {
        return color;
      }

      copyType = pick(copyType, 'darker');
      var d3Color = pick(colorMode, d3_rgb)(color);
      return d3Color[copyType](k).toString();
    }
    Registry.setComponent('color.toneColor', getColorCopy);

    /**
     * @param {Boolean} customRendererMode - Canvas mode: the highlight element which is SVG for wordcloud
     */
    function getFillColor(chartObj, seriesIndex, paneid, gradientDim, dontUsePatternPallete, customRendererMode, gradientOptions, rp) {
      var defsLocation = chartObj.defsLocation,
        cType_Obj = getChartTypeByIndex(chartObj, paneid, seriesIndex),
        chartName = cType_Obj.name,
        cType = cType_Obj.value,
        commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[chartName],
        plotoptions = (chartObj.seriesdata[seriesIndex] || chartObj.seriesdata[0]).plotoptions,
        gradientOptions =
        gradientOptions || (
        plotoptions && plotoptions.gradients ?
        mergeJSON$1(commonPlotOptions.gradients, plotoptions.gradients, true) :
        commonPlotOptions.gradients),
        patternPallete = chartObj.patternPallete,
        imagePallete = chartObj.imagePallete,
        imagePalleteLength = imagePallete && imagePallete.length,
        patternPalleteLength = !dontUsePatternPallete && patternPallete && patternPallete.length,
        rendererMode = customRendererMode || chartObj.plot.renderer.mode,
        indexScale = colorscale_helpers.getIndexScale(chartObj),
        rendererIdx = rp ? rp.rendererIndex : null;

      var func = function func(i, d, colorGamma, customColor, fillOpacity, customGradientDim, customPatternDim, returnSVGimage, subseriesIndex) {
        var clrValue = d && chartObj.dataset.getClr(d),
          baseClr,
          gradientsEnabled = gradientOptions && gradientOptions.type;

        gradientDim = customGradientDim || gradientDim;
        i = Math.max(i, 0) || 0; // check packed bubble and sunburst

        if (customColor) {
          //if (customColor && (!chartObj.dataObject.isAxisCategory || !rp || rp.thresholdType)) {
          baseClr = customColor;
        } else if (rp && rp.paneColor && !rp.colorOverlay) {
          baseClr = rp.paneColor;
        } else {
          baseClr = getRawColor(chartObj, i, d, seriesIndex, paneid, rendererIdx);
          i = colorscale_helpers.getItemIndex(chartObj, indexScale, d, i);
          if (indexScale && (!isWithinColorRange(clrValue, chartObj) || isUndefined(i)) && d3_rgb(baseClr).opacity === 0) {
            return baseClr;
          }
        }

        baseClr = getColorByFilter(chartObj, paneid, seriesIndex, baseClr);

        // opacity
        if (rendererMode == 'canvas' && !gradientsEnabled && !(baseClr instanceof Object)) {
          baseClr = rgba_canvas(baseClr, fillOpacity);
        }

        if (patternPalleteLength && /(url|data)/.test(baseClr)) {
          return baseClr;
        }

        if (defined(colorGamma)) {
          baseClr = getColorCopy(baseClr, colorGamma).toString();
        }
        if (imagePallete && imagePallete.length && isWithinColorRange(clrValue, chartObj)) {
          // TODO: isDataActive
          var imageParser = {
            _type: 'image',
            url: getImageByIndex(chartObj, i, paneid),
            width: customPatternDim && customPatternDim.width || chartObj.patternImageSizes[i % imagePalleteLength][0],
            height: customPatternDim && customPatternDim.height || chartObj.patternImageSizes[i % imagePalleteLength][1],
            context: customPatternDim && customPatternDim.context || chartObj.getPatternSvg(),
            defsPath: chartObj.defsLocation,
            rendererMode: rendererMode
          };
          return ALLOWED_CONFIG_OPERATORS.get(imageParser._type)(imageParser, imageParser)();
        }

        if (patternPalleteLength) {
          var _chartObj$userdata$le2 = chartObj.userdata.legend,useCustomPatternDimension = _chartObj$userdata$le2.useCustomPatternDimension,customPatternColor = _chartObj$userdata$le2.customPatternColor;
          customPatternDim =
          defined(useCustomPatternDimension) && !useCustomPatternDimension ? useCustomPatternDimension : customPatternDim;

          var patternParser = {
            _type: 'pattern',
            color: baseClr,
            pattern: patternPallete[i % patternPalleteLength],
            opacity: fillOpacity,
            size: customPatternDim,
            staticColor: customPatternColor,
            context: chartObj.getPatternSvg(),
            defsPath: chartObj.defsLocation,
            rendererMode: returnSVGimage ? 'base64' : rendererMode
          };
          return ALLOWED_CONFIG_OPERATORS.get(patternParser._type)(patternParser, patternParser)();
        }

        if (
        colorscale_helpers.isQuantileColorScale(chartObj) &&
        defined(subseriesIndex) &&
        isAreaChartType(cType) &&
        !(plotoptions && plotoptions.fillColor || commonPlotOptions.fillColor))
        {
          var rendererIndex = rp ? rp.rendererIndex : seriesIndex;
          gradientOptions = getGradient4ColorBand(
          chartObj,
          chartObj.renderer[rendererIndex].seriesdataAfterUpdate[subseriesIndex],
          seriesIndex);

        }

        if (gradientDim && gradientOptions && gradientOptions.type) {
          return getGradients(gradientOptions, gradientDim, baseClr, rendererMode, fillOpacity, chartName, returnSVGimage, chartObj);
        }

        return baseClr;
      };

      func.gradientOptions = gradientOptions;
      return func;
    }

    // let _map = {
    //     customColor: function(operator, applied) {
    //         let { paneColor, custom } = operator;
    //         return custom || paneColor;
    //     },
    //     image: function(operator, applied) {
    //         let { paneColor, custom } = operator;
    //         return custom || paneColor;
    //     }
    // };
    //
    // let defaultOperators = d3_set(['image', 'pattern', 'gradient']);
    // function fillParser() {
    //     let fillOperatos = {};
    //     if (defaultOperators.has('customColor')) {
    //         fillOperatos.customColor = {
    //             custom: null, //TODO
    //             paneColor: rp && rp.paneColor
    //         };
    //     }
    //
    //     if (defaultOperators.has('image')) {
    //         fillOperatos.image = {
    //             _type: 'image',
    //             image: (d, i) => getImageByIndex(chartObj, i, paneid),
    //             width: (d, i) => (customPatternDim && customPatternDim.width) || chartObj.patternImageSizes[i % imagePalleteLength][0],
    //             height: (d, i) => (customPatternDim && customPatternDim.width) || chartObj.patternImageSizes[i % imagePalleteLength][0]
    //         };
    //     }
    //
    //     // if (defaultOperators.has('pattern')) {
    //     //     fillOperatos.baseColor = {
    //     //         color: (d, i) => getRawColor(chartObj, i, d, seriesIndex, paneid)
    //     //     };
    //     // }
    //     //
    //     // if (defaultOperators.has('gradient')) {
    //     //     fillOperatos.baseColor = {
    //     //         color: (d, i) => getRawColor(chartObj, i, d, seriesIndex, paneid)
    //     //     };
    //     // }
    //
    //     return fillOperatos;
    // }
    //
    // function evalFill() {}

    /**
     *
     * @param gradientOptions
     * @param dimension
     * @param baseColor
     * @param type
     * @param fillOpacity
     * @param chartName
     * @param svgImage
     * @param chartInstance
     * @return {*}
     */
    function getGradients(gradientOptions, dimension, baseColor, type, fillOpacity, chartName, svgImage, chartInstance) {
      var prop = getGradientProp(gradientOptions, dimension, baseColor, fillOpacity),
        args = { offset: chartName, chartObj: chartInstance },
        gradient;

      if (type === 'svg') {
        gradient = effects.get(effects.svg_gradients, 'svgGradientFill', prop, args);
      } else {
        gradient = effects.get(effects.canvas_gradients, 'canvasGradientFill', prop, {
          offset: chartName,
          chartObj: chartInstance,
          returnSVGimage: svgImage
        });
      }

      if (svgImage || type === 'canvas') {
        return gradient;
      }

      return "url(".concat(chartInstance.defsLocation, "#").concat(gradient, ")");
    }

    /*
     * @param {Object} chartObj
     * @param {Number} seriesIndex
     * @returns {Color}
     */
    function getStrokeColor(chartObj, seriesIndex, paneid, gradientDim, rp) {
      var defsLocation = chartObj.defsLocation,
        cType_Obj = getChartTypeByIndex(chartObj, paneid, seriesIndex),
        cType = cType_Obj.value,
        chartName = cType_Obj.name,
        isAreaChart = isAreaChartType(cType),
        isLineChart = cType === charttype.line,
        plotoptions = (chartObj.seriesdata[seriesIndex] || chartObj.seriesdata[0]).plotoptions,
        commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[chartName],
        gradientOptions =
        isLineChart && plotoptions && plotoptions.gradients ?
        mergeJSON$1(commonPlotOptions.gradients, plotoptions.gradients, true) :
        commonPlotOptions.gradients,
        hasQuantileScale = colorscale_helpers.isQuantileColorScale(chartObj),
        rendererMode = chartObj.plot.renderer.mode,
        rendererIndex = rp ? rp.rendererIndex : seriesIndex,
        clr;

      return function (i, d, customColor, colorGamma, opacity, subseriesIndex) {
        var hasColorBand =
          hasQuantileScale &&
          defined(subseriesIndex) && (
          isLineChart || isAreaChart) &&
          !(plotoptions && plotoptions.strokeColor || commonPlotOptions.strokeColor),
          hasGradient = isLineChart && gradientOptions.type;

        if (hasColorBand) {

          gradientOptions = getGradient4ColorBand(
          chartObj,
          chartObj.renderer[rendererIndex].seriesdataAfterUpdate[subseriesIndex],
          seriesIndex);

        }

        if (gradientDim && (hasColorBand || hasGradient)) {
          var baseClr = customColor || getColorByIndex(chartObj, seriesIndex, paneid),
            prop = getGradientProp(gradientOptions, gradientDim, baseClr, opacity),
            args = { offset: chartName, chartObj: chartObj },
            gradientEle =
            rendererMode == 'svg' ?
            effects.get(effects.svg_gradients, 'svgGradientFill', prop, args) :
            effects.get(effects.canvas_gradients, 'canvasGradientFill', prop, { offset: chartName, chartObj: chartObj });

          if (rendererMode == 'canvas') {
            return gradientEle || baseClr;
          }

          return "url(".concat(defsLocation, "#").concat(gradientEle, ")");
        }

        if (customColor) {
          //if (customColor && (!rp || rp.thresholdType)) {
          clr = customColor;
        } else {
          i = Math.max(i, 0) || 0; // check packed bubble and sunburst
          var baseClr = getRawColor(chartObj, i, d, seriesIndex, paneid, rendererIndex);
          if (defined(colorGamma)) {
            baseClr = getColorCopy(baseClr, colorGamma).toString();
          }
          clr = baseClr;
        }

        clr = getColorByFilter(chartObj, paneid, seriesIndex, clr);

        if (rendererMode == 'canvas' && !(clr instanceof Object)) {
          clr = rgba_canvas(clr, opacity);
        }
        return clr;
      };
    }

    /*
     * @param {Number} clr
     * @param {Object} chartObj
     * @param {Scale} colorScale
     * @param {Array} colorScale_domain
     * @returns {Boolean}
     */
    function isWithinColorRange(clr, chartObj, colorScale, colorScale_domain, range) {
      if (!colorScale) {
        colorScale = isObjectPropDefined(chartObj, 'axes.clr.scale', true);
      }

      var config = chartObj.systemConf.legend,
        nullAsCondition = function nullAsCondition(val) {return !(isUndefined(config.colorBand.nullAs) && val == null);};

      return isWithinEncode(clr, 'clr', chartObj, colorScale, config, { condition: nullAsCondition, range: range });
    }
    Registry.setComponent('color.isWithinColorRange', isWithinColorRange);

    function getDisabledColor(d, color, chartObj) {
      if (!d || !d.dummy && d.disabled) {
        return color;
      }

      var legendOptions = chartObj.systemConf.legend;
      var clr = chartObj.dataset.getClr(d);
      if (!isWithinColorRange(clr, chartObj)) {
        return _disabledColor(color, legendOptions.filter.track);
      }

      if (chartObj.dataObject.hasZaxis) {
        var scaleComponent = arrayFind(chartObj.scales, function (_) {return _.id === 'z-0';}),
          _config6 = getLegendConfig(scaleComponent.encode, scaleComponent.key, chartObj),
          _isWithinSizeEncode2 = Registry.getComponent('size.isWithinSizeEncode');

        if (!_isWithinSizeEncode2(d, chartObj)) {
          return _disabledColor(color, getDisabledOptions(_config6).track);
        }
      }

      return true;
    }

    function _disabledColor(color) {var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var excludeOpacity = validateNullVal(config.fillOpacity, 1),
        hiddenColor = config.fillColor || TRANSPARENT;

      var rgba = d3_rgb(hiddenColor);
      excludeOpacity = rgba.opacity * excludeOpacity;

      if (excludeOpacity === 0) {
        return TRANSPARENT;
      } else {
        var interpolateClr = d3_scaleLinear().
        domain([0, 1]).
        range([color, rgb2hex(hiddenColor)]).
        interpolate(d3_interpolateRgb);
        return interpolateClr(excludeOpacity);
      }
    }

    /*
     * @param {Object} chartObj
     * @param {Number} i
     * @param {Array} d
     * @param {Number} seriesIndex
     * @returns {Color} 1)Threshold 2)Color scale 3)Index based
     */
    function getRawColor(chartObj, i, d, seriesIndex, paneid, rendererIdx) {
      paneid = paneid || d && d.paneid;
      var renderedIdx = pick(rendererIdx, seriesIndex);
      var baseClr = getColorByIndex(chartObj, i, paneid),
        chartType = getChartTypeByIndex(chartObj, paneid, 0).value,
        isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
        rp = isAxisCategory && defined(renderedIdx) && chartObj.rendererConf && chartObj.rendererConf[renderedIdx].params; // TODO: PIVOT

      var colorFinder = (chartObj.seriesdata[pick(seriesIndex, i)] || chartObj.seriesdata[0]).colorFinder,
        color;

      if (defined(colorFinder)) {
        color = invokeFunction(colorFinder, chartObj, i, d, seriesIndex);
        if (defined(color)) {
          return color;
        }
      }

      if (rp && rp.categoryColorConfig) {
        color = colorscale_helpers.getWaterfallColor(d, rp.categoryColorConfig, baseClr);
      } else if (rp && rp.colorOverlay) {
        color = getColorBythreshold(chartObj, rp, d, baseClr);
      } else if (d && colorscale_helpers.isQuantileColorScale(chartObj)) {
        color = getColorByScale(chartObj, d);
      } else {
        if (d && d.arcColor) {
          color = isArray$1(d.arcColor) ? d.arcColor[0] : d.arcColor;
        } else {
          color = baseClr;
        }
      }

      if (!isDataActive(d, chartObj, seriesIndex)) {
        color = getDisabledColor(d, color, chartObj);
      }

      color = getColorByFilter(chartObj, paneid, seriesIndex, color);

      return color;
    }
    Registry.setComponent('color.getRawColor', getRawColor);

    /*
     * @param {Object} chartObj
     * @param {Number} i
     * @returns {Color} based on index
     */
    function getColorByIndex(chartObj, i, paneid, legendOrder) {
      if (chartObj.imagePallete) {
        return getImageByIndex(chartObj, i, paneid);
      }

      if (chartObj.dataObject && chartObj.dataObject.categoryHierarchy && legendOrder) {
        var legendOptions = chartObj.dataObject.hierarchical.legendOptions[legendOrder];
        var colors = chartObj.imagePallete || legendOptions.colors;
        return colors[i % colors.length];
      }
      var seriesColor = getChartSeriesColor(chartObj, paneid, i);

      return seriesColor;
    }
    Registry.setComponent('color.getColorByIndex', getColorByIndex);

    /*
     * @param {Object} chartObj
     * @param {Object} rp
     * @param {Array} d
     * @param {Color} baseClr
     * @returns {Color} color overlay
     */
    function getColorBythreshold(chartObj, rp, d, baseClr) {
      var yaxiscolumnorder = rp.yaxiscolumnorder,
        threshold = rp.threshold,
        thresholdType = rp.thresholdType,
        dataset = chartObj.dataset;

      var thresholdValue = thresholdType == 'x' ? dataset.getX(d) : dataset.getY(d, yaxiscolumnorder);
      return rp.colorOverlay(threshold, thresholdType, thresholdValue, baseClr);
    }

    /*
     * @param {Object} chartObj
     * @param {Array} d
     * @returns {Color} based on color scale
     */
    function getColorByScale(chartObj, d) {
      var clrValue = chartObj.dataset.getClr(d),
        colorScale = chartObj.axes.clr.scale;

      if (clrValue === UNDEFINED) {
        clrValue = null;
      }

      return colorScale(clrValue);
    }

    /*
     * @param {Color} color
     * @returns {Color} grayscale color
     * Source: www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/
     */
    function getGrayScaleColor(color) {
      var rgba = d3_rgb(color);
      var gray = pInt((rgba.r + rgba.g + rgba.b) / 3); // Method 2: Gray = (Red * 0.2126 + Green * 0.7152 + Blue * 0.0722), Method 3: (Red * 0.299 + Green * 0.587 + Blue * 0.114)
      return "rgba(".concat(gray, ",").concat(gray, ",").concat(gray, ",").concat(rgba.opacity, ")");
    }

    function isMultiColoring(commonPlotOptions, chartObj) {
      return commonPlotOptions.multiColoring && !chartObj.legendarea.show;
    }

    function getGradient4ColorBand(chartObj, serData, seriesIndex) {
      var rotated = chartObj.axes.rotated,
        reversed = chartObj.systemConf.chart.axes.xaxis.reversed,
        xscale = chartObj.axes.x.scale,
        ordinalRange = xscale.range(),
        hiddenColor = 'rgba(255,255,255,0)',
        isDiscrete = chartObj.systemConf.legend.colorBand.colorModeOnPlot === 'discrete',
        bandWidthBy2 = xscale.bandwidth ? xscale.bandwidth() / 2 : 0,
        sc = d3_scaleLinear().
        domain([ordinalRange[0] + bandWidthBy2, ordinalRange[ordinalRange.length - 1] - bandWidthBy2]).
        range([0, 100]);

      var processedColors = [],
        processedOffsets = [],
        prevOffset,
        prevColor,
        prevHidden,
        curOffset,
        curColor,
        curHidden;

      serData.forEach(function (d) {
        curOffset = +sc(xscale(chartObj.dataset.getX(d)) + bandWidthBy2).toFixed(2);
        curColor = getColorByScale(chartObj, d);

        if (!isDataActive(d, chartObj, seriesIndex)) {
          curColor = getDisabledColor(d, curColor, chartObj);
        }

        curHidden = curColor === TRANSPARENT;
        if (curHidden) {
          curColor = hiddenColor;
        }

        if (!isDiscrete && (prevHidden || curHidden)) {
          if (defined(prevOffset)) {
            processedOffsets.push("".concat(mathMin(100, prevOffset + 0.1), "%")); // #ZC1328: Offset should be within 0 and 100 for CANVAS
            processedColors.push(hiddenColor);
          }

          processedOffsets.push("".concat(mathMax(0, curOffset - 0.1), "%")); // #ZC1328: Offset should be within 0 and 100 for CANVAS
          processedColors.push(hiddenColor);
        }

        // For discrete
        if (isDiscrete && prevColor) {
          if (prevHidden) {
            processedOffsets.push("".concat(mathMax(0, curOffset - 0.1), "%"));
            processedColors.push(prevColor);
          } else if (curHidden) {
            processedOffsets.push("".concat(mathMin(100, prevOffset + 0.1), "%"));
            processedColors.push(curColor);
          } else {
            var by2 = (curOffset + prevOffset) / 2;
            processedOffsets.push("".concat(by2, "%"));
            processedColors.push(prevColor);

            processedOffsets.push("".concat(by2, "%"));
            processedColors.push(curColor);
          }
        }

        processedOffsets.push("".concat(curOffset, "%"));
        processedColors.push(curColor);

        prevOffset = curOffset;
        prevColor = curColor;
        prevHidden = curHidden;
      });

      var options = {
        type: 'linear',
        options: {
          linear: {
            gradientUnits: 'userSpaceOnUse',
            x1: 0,
            x2: 0,
            y1: 0,
            y2: 0,
            stopColor: processedColors,
            stopOffset: processedOffsets
          }
        }
      };

      var key = rotated ? reversed ? 'y2' : 'y1' : reversed ? 'x1' : 'x2';
      options.options.linear[key] = 100;
      return options;
    }

    function getIndexForItemColor(itemIndex, seriesIndex, extraProps, chartObj) {
      /**data - actual subseries data
       * itemIndex - renderingOrder index
       * seriesIndex - series index
       * extraProps: {
       *     multiColoring
       *     reverseColor
       *     dataUpdate
       * }
       * chartObj
       *
       */
      var data_length = extraProps.dataCount,
        actualItemIndex = extraProps.reverseColor ?
        data_length - 1 - itemIndex :
        (chartObj.isAxisCategory ||
        chartObj.isNonAxisMultiSeriesCategory ||
        chartObj.dataObject.isPolarAxisCategory ||
        chartObj.isGeoMap) &&
        !extraProps.multiColoring ?
        seriesIndex :
        itemIndex;
      return actualItemIndex;
    }
    Registry.setComponent('color.getIndexForItem', getIndexForItemColor);

    function hasColorColumnInNonAxis(chartObj, paneid) {
      if (chartObj.isGeoMap) {
        return false;
      }

      if (!isFacet(chartObj)) {
        return false;
      }

      var chartNames = defined(paneid) ?
      chartObj.dataObject.hierarchical.gridOptions[paneid].chartTypes.map(function (_) {return _.name;}) :
      getUniqueChartTypes(chartObj).values();

      return (
        chartObj.userdata.facets.color.length &&
        chartNames.some(function (chartName) {return arrayIncludes([PIE_CHARTNAME, FUNNEL_CHARTNAME, PYRAMID_CHARTNAME], chartName);}));

    }

    function getColorByFilter(chartObj, paneid, seriesIndex, baseClr) {
      if (isSeriesFiltered(chartObj, paneid, seriesIndex)) {
        var legendOrder = chartObj.dataObject.hierarchical.gridOptions[paneid].legendOrder || 0,
          legendConfig = chartObj.legends.get("clr-".concat(legendOrder)).meta.config;

        return _disabledColor(baseClr, legendConfig.filter.track);
      }

      return baseClr;
    }

    function isSeriesFiltered(chartObj, paneid, seriesIndex) {
      var chartName = getChartTypeByIndex(chartObj, paneid, 0).name;

      if (
      isFacet(chartObj) &&
      paneid &&
      !(arrayIncludes([PIE_CHARTNAME, FUNNEL_CHARTNAME, PYRAMID_CHARTNAME], chartName) && !chartObj.userdata.facets.color.length))
      {
        var currentSeriesData = DataProcessor.helpers.getSeriesdata(chartObj, paneid, seriesIndex);
        return currentSeriesData.filtered;
      }
    }

    // function() {
    //     if (imagePallete) {
    //         add {}
    //     }
    //     if (patternPallete) {
    //         add {}
    //     }
    //     if (gradient) {
    //         add {}
    //     }
    //     default color {}
    // }

    function ViewFlow(spec, oldSpec) {
      this.spec = spec;
      this.data = spec.data || oldSpec.seriesdata.chartdata;
      this.encoding = {};
      this.columns = new Array(0);
      this.scales = {};
      this.axes = {
        vertical: new Array(0),
        horizontal: new Array(0)
      };
      this.marks = {
        _default: {},
        _custom: new Array(0)
      };
      this.marks._default = {
        chart: new Array(0),
        label: new Array(0)
      };
    }

    ViewFlow.prototype = {
      init: function init() {var _this4 = this;
        if (this.spec.encoding) {
          this.addEncode(this.spec.encoding);
        }
        if (this.spec.scales) {
          this.spec.scales.map(function (scale) {return _this4.addScale(scale);});
        }
        if (this.spec.axes) {
          this.spec.axes.map(function (axis) {return _this4.addAxis(axis);});
        }
        if (this.spec.marks) {
          this.spec.marks.map(function (mark) {return _this4.addMarks(mark);});
        }
      },
      addEncode: function addEncode(_encodes) {var _this5 = this;
        //encode x
        if (_encodes.x) {
          this.encoding.x = [];
          if (_encodes.x.constructor == Array) {
            _encodes.x.map(function (d) {
              _this5.encoding.x.push({
                column: d
              });
            });
          } else {
            _encodes.x.map(function (d) {
              _this5.encoding.x.push({
                column: d
              });
            });
          }
        }

        //encode y
        if (_encodes.y) {
          this.encoding.y = [];
          _encodes.y.map(function (d) {
            _this5.encoding.x.push({
              column: d
            });
          });
        }
      },
      addScale: function addScale(_scale) {
        this.scales[_scale.id] = {
          conf: _scale
        };
      },
      addAxis: function addAxis(_axis) {
        if (_axis.orient == 'left' || _axis.orient == 'right') {
          this.axes.vertical.push({
            conf: _axis,
            scale: this.scales[_axis.scale]
          });
        } else {
          this.axes.horizontal.push({
            conf: _axis,
            scale: this.scales[_axis.scale]
          });
        }
      },
      addMarks: function addMarks(_mark) {var _this6 = this;
        if (_mark.type == 'DEFAULT') {
          var _data = invokeFunction(_mark.data, this.data),
            renderer = _data.map(function (d, i) {return invokeFunction(_mark.renderer, d, i);}),
            markOperator,
            markSpec;

          if (_mark.operator) {
            markOperator = _data.map(function (d, i) {return _mark.operator(d, i);});
          }

          if (_mark.spec) {
            markSpec = _data.map(function (d, i) {
              if (typeof _mark.spec == 'function') {
                return _mark.spec(d, i);
              } else {
                return _mark.spec;
              }
            });
          }
          _data.map(function (d, i) {
            if (renderer[i].isDataLabel) {
              _this6.marks._default.label.push({
                data: d,
                operator: markOperator && markOperator[i],
                type: renderer[i].type,
                spec: markSpec && markSpec[i]
              });
            } else {
              _this6.marks._default.chart.push({
                data: d,
                operator: markOperator && markOperator[i],
                type: renderer[i].type,
                datasetIndex: renderer[i].datasetIndex,
                spec: markSpec && markSpec[i],
                x: renderer[i].x && _this6.scales[renderer[i].x].component,
                y: renderer[i].y && _this6.scales[renderer[i].y].component
                // spec:
              });
            }
          });
        } else {
          this.marks._custom.push({
            mark: _mark
          });
        }
      }
    };

    Registry.setComponent('viewParser', ViewFlow);

    //$Id$

    function merged_axis_column_intersect(axisorder, chartObj) {
      var metaData = chartObj.systemConf.metadata;
      var indices = metaData.axes.y[axisorder];
      var start = 1,
        end = indices.length - 1;

      var col1 = metaData.columns[indices[start - 1]];
      var output = col1[col1.datatype];

      for (; start <= end; start++) {
        var col2 = metaData.columns[indices[start]];
        var formatConf2 = col2[col2.datatype];

        output = intersectObject(output, formatConf2);
      }
      return output;
    }

    function hasMergedAxis(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,
        dataObject = chart.dataObject,systemConf = chart.systemConf,
        dataSplicer = chart.dataSplicer,
        metadata_axes = dataSplicer.getEncode();
      return !dataObject.hierarchical && metadata_axes[type][order].length > 1;
    }

    function getOppositeOrient(orient) {
      switch (orient) {
        case 'left':
          return 'right';
        case 'right':
          return 'left';
        case 'top':
          return 'bottom';
        case 'bottom':
          return 'top';}

    }

    /**
     *
     * @param {Object} obj
     * @param {number} defaultMargin
     * @returns {{top, right, bottom, left}}
     */

    function getMargin(obj, defaultMargin) {
      return {
        top: pick(obj.marginTop, defaultMargin, 5),
        right: pick(obj.marginRight, defaultMargin, 5),
        bottom: pick(obj.marginBottom, defaultMargin, 5),
        left: pick(obj.marginLeft, defaultMargin, 5)
      };
    }

    function getTickPadding(orient, ticklabelMargin, invert) {
      if (!invert) {
        orient = getOppositeOrient(orient);
      }
      return ticklabelMargin[orient];
    }

    function isRotatedChart(type, axisRotated) {
      return type == 'x' && axisRotated || type == 'y' && !axisRotated;
    }

    function getAxisType(orient, rotated) {
      if ((orient == 'bottom' || orient == 'top') && !rotated || (orient == 'left' || orient == 'right') && rotated) {
        return 'x';
      } else {
        return 'y';
      }
    }
    function getAxisObject(chartObj, type, index) {
      var obj;
      if (type == 'x') {
        var hierarchical = chartObj.dataObject.hierarchical;
        if (hierarchical) {
          var nodeList = hierarchical.pivotLayout.getRootNodeList('column'),
            nodeListCount = nodeList.getCount(),
            leavesCount = nodeList.getLeavesCount();

          if (nodeListCount && index > leavesCount - 1) {
            chartObj.axes.x.levels[index - leavesCount] = chartObj.axes.x.levels[index - leavesCount] || {};
            obj = chartObj.axes.x.levels[index - leavesCount];
          } else if (leavesCount > 1) {
            chartObj.axes.x.leaves[index] = chartObj.axes.x.leaves[index] || {};
            obj = chartObj.axes.x.leaves[index];
          } else {
            obj = chartObj.axes.x;
          }
        } else {
          obj = chartObj.axes.x;
        }
      } else if (type === 'clr') {
        obj = chartObj.axes.clr;
      } else {
        var _hierarchical2 = chartObj.dataObject.hierarchical,
          _nodeListCount,
          _hasMultiCluster,
          _leavesCount;
        if (_hierarchical2) {
          var _nodeList = _hierarchical2.pivotLayout.getRootNodeList('row');
          _nodeListCount = _nodeList.getCount();
          _hasMultiCluster = _nodeList.hasMultiCluster();
          _leavesCount = _nodeList.getLeavesCount();
        }
        if (_hasMultiCluster || _nodeListCount) {
          // if(defined(chartObj.dataObject.hierarchical) && (chartObj.dataObject.hierarchical.rows.count || chartObj.dataObject.hierarchical.leafRows.hasMulti)){
          if (_nodeListCount && index > _leavesCount - 1) {
            chartObj.axes.y.branches[index - _leavesCount] = chartObj.axes.y.branches[index - _leavesCount] || {};
            obj = chartObj.axes.y.branches[index - _leavesCount];
          } else {
            chartObj.axes.y.leaves[index] = chartObj.axes.y.leaves[index] || {};
            obj = chartObj.axes.y.leaves[index];
          }
        } else {
          chartObj.axes.y.groups[index] = chartObj.axes.y.groups[index] || {};
          obj = chartObj.axes.y.groups[index];
        }
      }
      return obj;
    }

    function getAxisData(chartObj, type, index, needMerge) {
      var systemconf = chartObj.systemConf,
        axisConfig_new = chartObj.dataSplicer.getAxisConfig(type),
        axisconf = type == 'y' ? systemconf.chart.axes.yaxis : systemconf.chart.axes.xaxis,
        axisconf_levels = type == 'y' ? systemconf.chart.axes.yaxisLevels : systemconf.chart.axes.xaxisLevels,
        processor = chartObj.dataObject,
        hierarchical = type == 'y' ? processor.categoryHierarchy : processor.hierarchical,
        categoryHierarchical = hierarchical && hierarchical.categoryTree,
        axisdata;

      if (hierarchical) {
        var isBranchAxisType = isBranchAxis(type, index, chartObj),
          leafAxisOrder = getLeafAxisOrder(index, null, type, chartObj);
        if (isBranchAxisType) {
          var branchDepth = getBranchDepth(type, index, chartObj);
          axisdata = axisconf_levels[branchDepth] || {};
          if (needMerge) {
            var basedata = type == 'y' ? axisconf[0] : axisconf;
            axisdata = axisconf_levels[branchDepth] = mergeJSON$1(axisconf_levels[branchDepth], basedata, false);
          }
        } else {
          axisdata = type == 'x' ? axisconf : axisconf[leafAxisOrder];
          if (needMerge && type == 'y' && leafAxisOrder > 0) {
            axisdata = mergeJSON$1(axisconf[leafAxisOrder], axisconf[0], false);
          }
        }
      } else {
        axisdata = chartObj.dataSplicer.getAxisConfig(type, index);
        if (needMerge && type == 'y' && index > 0) {
          axisdata = mergeJSON$1(axisconf[index], axisconf[0], false);
        }
      }
      return axisdata;
    }

    function getAxesCount(chart, type, orient) {
      if (chart.viewFlow) {
        var layout = getAxisLayout(orient);
        return chart.viewFlow.axes[layout].length || chart.axes[type].count;
      } else {
        return chart.axes[type].count;
      }
    }

    function getAxisViewModel(chart, type, orient, idx) {
      var layout = getAxisLayout(orient);

      if (chart.viewFlow) {
        var axisView = chart.viewFlow.axes[layout];
        return axisView[idx];
      } else {
        return null;
      }
    }

    function getAxisLayout(orient, type, rotated) {
      if (orient) {
        return orient == 'left' || orient == 'right' ? 'vertical' : 'horizontal';
      } else {
        if (rotated) {
          return type == 'x' ? 'vertical' : 'horizontal';
        } else {
          return type == 'y' ? 'vertical' : 'horizontal';
        }
      }
    }
    function isTickAutoRotate(chartObj, type, order, rotationConfig) {
      var isBranchAxisType;
      if (chartObj.dataObject.categoryHierarchy && type == 'x') {
        isBranchAxisType = isBranchAxis(type, order, chartObj);
      }
      return rotationConfig == 'auto' && !isBranchAxisType;
    }

    function isTickInnerOrient(obj, type, chart) {
      if (obj.tickOrient == 'inner') {
        return type == 'x' && chart.ismultix ? false : true;
      }
    }

    function checkTickInlineAlignWithInPlot(type, orient, systemConf) {
      var yaxisReversed = systemConf.chart.axes.yaxis[0].reversed;
      if (type == 'x') {
        if (
        orient == 'bottom' && !yaxisReversed ||
        orient == 'left' && !yaxisReversed ||
        orient == 'top' && yaxisReversed ||
        orient == 'right' && yaxisReversed)
        {
          return true;
        }
      }
    }

    /**
     * Returns if the axis rotated
     * @returns {boolean}
     */
    function _getAxisRotated(systemConf) {
      if (systemConf._viewParser) {
        return systemConf.rotated;
      } else {
        var axes = systemConf.chart.axes;
        return axes && axes.rotated === true;
      }

    }

    function getAxisAreaForLowerOrder(axisType, axisOrder, chartObj) {
      var hierachyObj = chartObj.dataObject.hierarchical,
        plotarea = chartObj.plotarea,
        axesCount = chartObj.axes[axisType].count;
      var axisLen = 0;
      if (hierachyObj) {
        var tag = axisType == 'x' ? 'column' : 'row',
          nodeList = hierachyObj.pivotLayout.getRootNodeList(tag),
          leavesCount = nodeList.getLeavesCount(),
          branchCount = nodeList.getCount(),
          _hasMultiCluster2 = nodeList.hasMultiCluster(),
          hasMultiLeaves = chartObj.dataObject.hierarchical && (_hasMultiCluster2 || branchCount);
        for (var i = 0; i < axisOrder; i++) {
          // eslint-disable-next-line no-empty
          if (hasMultiLeaves && i < leavesCount - 1) ;else {
            var axisData = getAxisData(chartObj, axisType, i);
            if (isAxisEnabled(axisData, axisType, i, chartObj)) {
              var axisObj = getAxisObject(chartObj, axisType, i);
              axisLen +=
              axisType === 'y' && i === leavesCount - 1 && hasMultiLeaves ?
              chartObj.axes[axisType].maxLeafAxisArea :
              axisObj.component.tickLabelWidth();
            }
          }
        }
      }
      return axisLen;
    }

    function isAxisEnabled(config, axisType, i, chartObj) {
      var show = config.show;
      if (chartObj._isAxisCategory() && !chartObj.isAxisCategory) {
        var isPivot = chartObj.dataObject.hierarchical && chartObj.dataObject.hierarchical.pivot;
        if (isPivot) {
          if (isLeafAxis(axisType, i, chartObj) && (axisType === 'y' || !(axisType === 'x' && hasColorColumnInNonAxis(chartObj)))) {
            return false;
          }
        } else {
          return show;
        }
      }

      return show;
    }

    function getAxisOrient(type, rotated, chartObj) {
      if (type == 'y') {
        return rotated ? BOTTOM_ALIGN : LEFT_ALIGN;
      } else {
        return rotated ? LEFT_ALIGN : BOTTOM_ALIGN;
      }
    }

    function copyDefaultTickAttrs(source, target) {
      var customAnchor = target.attr('textAnchor');
      target.attrs({
        x: source.attr('x'),
        y: source.attr('y'),
        dy: source.attr('dy'),
        transform: source.attr('transform'),
        'text-anchor': source.attr('text-anchor'),
        "class": source.attr('class'),
        style: source.attr('style')
      });
      if (customAnchor) {
        target.style('text-anchor', customAnchor);
      }
    }

    //$Id$

    function appendEle(parentNode, nodeName, data, selector, selectorAttr, selectorVal, styleObj, dataKeyFunc) {var options = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};
      var enter_update_exit = options.enter_update_exit,insertBefore = options.insertBefore,_options$remove = options.remove,remove = _options$remove === void 0 ? true : _options$remove;
      selector = selector || '';
      selectorVal = selectorVal || '';

      var node = parentNode.selectAll(nodeName + selector + selectorVal).data(data, dataKeyFunc),
        nodeEnter = insertBefore ? node.enter().insert(nodeName, insertBefore) : node.enter().append(nodeName),
        nodeUpdate = nodeEnter.merge(node),
        nodeExit = node.exit();

      if (selectorAttr) {
        nodeUpdate.attr(selectorAttr, selectorVal);
      }

      if (styleObj) {
        nodeUpdate.styles(styleObj);
      }

      if (remove) {
        nodeExit.remove();
      }

      return enter_update_exit ? { enter: nodeEnter, update: nodeUpdate, exit: nodeExit } : nodeUpdate;
    }
    Registry.setComponent('domUtils.appendElement', appendEle);

    function trimText(textObj, text, textBounds, edge, orient, pattern, marginValue, max, parent, deepTrim) {
      if (text == null || !text.trim() || !textObj) {
        //#ZC676
        return text;
      }
      var maxWidth, maxHeight;
      parent = parent || textObj;
      if (max) {
        maxWidth = max.width;
        maxHeight = max.height;
      } else {
        maxWidth = edge.right - edge.left;
        maxHeight = edge.bottom - edge.top;
      }
      // var textBounds = textObj.getBoundingClientRect()
      var overflowLength = 0;

      if (orient == 'left' || orient == 'right') {
        if (textBounds.top + textBounds.height - marginValue.bottom > edge.bottom) {
          overflowLength += (textBounds.top + textBounds.height - marginValue.bottom - edge.bottom) / textBounds.height;
        }
        if (textBounds.top + marginValue.top < edge.top) {
          overflowLength += (edge.top - (textBounds.top + marginValue.top)) / textBounds.height;
        }
        maxHeight =
        textBounds.height -
        mathMax(0, textBounds.top + textBounds.height - marginValue.bottom - edge.bottom) -
        mathMax(0, edge.top - (textBounds.top + marginValue.top));
      } else if (orient == 'bottom' || orient == 'top') {
        if (textBounds.left + textBounds.width - marginValue.right > edge.right) {
          overflowLength += (textBounds.left + textBounds.width - marginValue.right - edge.right) / textBounds.width;
        }
        if (textBounds.left + marginValue.left < edge.left) {
          overflowLength += (edge.left - (textBounds.left + marginValue.left)) / textBounds.width;
        }
        maxWidth =
        textBounds.width -
        mathMax(0, textBounds.left + textBounds.width - marginValue.right - edge.right) -
        mathMax(0, edge.left - (textBounds.left + marginValue.left));
      }

      overflowLength = parseFloat(overflowLength.toFixed(2));
      if (overflowLength > 0) {
        var croppedTextLength = mathCeil((1 - overflowLength) * text.length);
        textObj.textContent = text.substring(0, croppedTextLength - 1) + pattern;

        var clientRect = parent.nodeName == 'tspan' ? getTspanBoundingClientRect : getDefaultBoundingClientRect;
        var newTextBounds = clientRect(parent);
        deepTrim = textObj.nodeName == 'tspan' ? false : deepTrim; //TODO
        if (deepTrim !== false && (newTextBounds.width != textBounds.width || newTextBounds.height != textBounds.height)) {
          naiveEllipsis(textObj, parent, text, maxWidth, maxHeight, newTextBounds, pattern);
        }
      }
    }

    function wordWrap(text, maxWidth, maxHeight, fontHeight) {
      var words = text.split(/\s+/).reverse(),
        word,
        testLines = [],
        wrappedLines = [],
        totalHeight = fontHeight,
        maxWidth = maxWidth; //hack for setting maxwidth
      while (word = words.pop()) {
        testLines.push(word);
        var curWordWidth = utils.fontUtils.getTextWidth(testLines.join(' '));

        if (curWordWidth > maxWidth) {
          if (testLines.length > 1) {
            testLines.pop();
            wrappedLines.pop();
            wrappedLines.push(testLines.join(' '));
          }
          if (totalHeight > maxHeight) {
            return wrappedLines;
          }
          totalHeight += fontHeight;
          testLines = [word];
          wrappedLines.push(word);
        } else {
          wrappedLines.pop();
          wrappedLines.push(testLines.join(' '));
        }
      }
      return wrappedLines;
    }

    function getCorrectedRectParams(x, y, w, h, r, yReversed, axisrotated) {
      return {
        x1: yReversed && axisrotated ? x - w : x,
        y1: yReversed && !axisrotated ? y - h : y, //x1,y1 should be at top left . x2,y2 should be at bottom right .
        x2: yReversed && axisrotated ? x : x + w,
        y2: yReversed && !axisrotated ? y : y + h
      };
    }
    function roundedRect(x, y, w, h, r, yReversed, axisrotated, correctionApplied) {
      var x1 = x,y1 = y,x2 = w,y2 = h;
      if (!correctionApplied) {var _getCorrectedRectPara =
        getCorrectedRectParams.apply(this, toArray(arguments));x1 = _getCorrectedRectPara.x1;y1 = _getCorrectedRectPara.y1;x2 = _getCorrectedRectPara.x2;y2 = _getCorrectedRectPara.y2;
        r = checkRadiusWithinBoundary(r, w, h);
      }

      return "M".concat(x1, ",").concat(y2 - r.bly, "L").concat(x1, ",").concat(y1 + r.tly, "A").concat(r.tlx, ",").concat(r.tly, " 0 0 1 ").concat(x1 + r.tlx, ",").concat(y1, "L").concat(x2 - r.trx, ",").concat(y1, "A").concat(r.trx, ",").concat(
      r.trY, " 0 0 1 ").concat(
      x2, ",").concat(y1 + r.trY, "L").concat(x2, ",").concat(y2 - r.bry, "A").concat(r.brx, ",").concat(r.bry, " 0 0 1 ").concat(x2 - r.brx, ",").concat(y2, "L").concat(x1 + r.blx, ",").concat(y2, "A").concat(r.blx, ",").concat(
      r.bly, " 0 0 1 ").concat(
      x1, ",").concat(y2 - r.bly, "Z");
    }
    Registry.setComponent('utils.roundedRect', roundedRect);

    function checkRadiusWithinBoundary(r, width, height, isCanvasMode) {
      var radius = Object.create(r);
      var top = radius.tlx + radius.trx,
        right = radius.trY + radius.bry,
        bottom = radius.brx + radius.blx,
        left = radius.tly + radius.bly;

      var z;

      if (height < left) {
        z = left / (left - height);
        radius.tly = radius.tly - radius.tly / z, radius.bly = radius.bly - radius.bly / z;
      }
      if (width < top) {
        z = top / (top - width);
        radius.tlx = radius.tlx - radius.tlx / z, radius.trx = radius.trx - radius.trx / z;
      }
      if (height < right) {
        z = right / (right - height);
        radius.trY = radius.trY - radius.trY / z, radius.bry = radius.bry - radius.bry / z;
      }
      if (width < bottom) {
        z = bottom / (bottom - width);
        radius.brx = radius.brx - radius.brx / z, radius.blx = radius.blx - radius.blx / z;
      }

      if (isCanvasMode) {
        radius.tlx = radius.tly = Math.min(radius.tlx, radius.tly);
        radius.trx = radius.trY = Math.min(radius.trx, radius.trY);
        radius.blx = radius.bly = Math.min(radius.blx, radius.bly);
        radius.brx = radius.bry = Math.min(radius.brx, radius.bry);
      }
      return radius;
    }

    function applyFont(ele, hierarchy, html) {
      var fSize = utils.getVal(getValByPriority(hierarchy, 'fontSize')),
        fFamily = getValByPriority(hierarchy, 'fontFamily'),
        fWeight = getValByPriority(hierarchy, 'fontWeight'),
        fStyle = getValByPriority(hierarchy, 'fontStyle'),
        fShadow = getValByPriority(hierarchy, 'textShadow'),
        fColor = getValByPriority(hierarchy, 'fontColor'),
        txtDec = getValByPriority(hierarchy, 'textDecoration'),
        strokeColor = getValByPriority(hierarchy, 'strokeColor'),
        fontOpacity = getValByPriority(hierarchy, 'fontOpacity');

      var styleObj = _defineProperty({
        'font-size': defined(fSize) ? "".concat(fSize, "px") : null,
        'font-family': fFamily,
        'font-weight': fWeight,
        'font-style': fStyle,
        'text-shadow': fShadow,
        'text-decoration': txtDec,
        'fill-opacity': fontOpacity },
      html ? 'color' : 'fill', fColor);


      if (!html && strokeColor) {
        styleObj.stroke = strokeColor;
        styleObj['stroke-width'] = getValByPriority(hierarchy, 'strokeWidth') || 3;
        styleObj['paint-order'] = 'stroke';
      }

      if (defined(ele)) {
        if (strokeColor === 'contrast') {
          styleObj.stroke = null; // phantomjs trows error to wrong color values.
        }

        ele.styles(styleObj);
      } else {
        styleObj.color = fColor;
      }

      return styleObj;
    }
    Registry.setComponent('domUtils.applyFont', applyFont);

    function addSVGtitleEle(textEle, data) {
      textEle.append('title').text(function () {
        return data || this.parentNode.textContent;
      });
    }

    function naiveEllipsis(textNode, parent, origTextContent, maxWidth, maxHeight, textBounds, pattern) {
      /*
       * If bound is less than the max, traverse from current length to original length and update the textContent
       * Else traverse from current length to 0 and update the textContent
       */
      var index = textNode.textContent.length - 1,
        pattern_length = pattern.length;
      if (textBounds.width > maxWidth || textBounds.height > maxHeight) {
        var end = 0;
        while (index >= end) {
          changeTextContent(true);
          if (textBounds.width <= maxWidth && textBounds.height <= maxHeight) {
            return;
          }
          index--;
        }
      } else {
        var end = origTextContent.length;
        while (index < end) {
          // changeTextContent();
          if (textBounds.width >= maxWidth || textBounds.height >= maxHeight) {
            index--;
            changeTextContent(false);
            return;
          }
          index++;
        }
      }

      function changeTextContent(updateBound) {
        /*
         * This will change the textContent based on 'index' value
         * And update 'textBound' with new text bound if 'dontUpdateBound' is not true
         */
        var clientRect = textNode.nodeName == 'tspan' ? getTspanBoundingClientRect : getDefaultBoundingClientRect;
        textNode.textContent = origTextContent.substring(0, index - pattern_length) + pattern;
        if (updateBound) {
          textBounds = clientRect(parent);
        }
      }
    }

    function parseSVGPath(path) {
      //#ZC1741
      var arr = path.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/gi);
      return arr.map(function (d) {
        d = d.trim(); // remove white space
        var func = d.match(/[a-z]/gi).shift();
        var moves = d.match(/-?[0-9]\d*(\.\d+(e-\d+)?)?/g); // exponent is really important in arcs
        if (moves) {
          moves = moves.map(function (m) {
            return parseFloat(m);
          });
        }
        return {
          "function": func,
          moves: moves
        };
      });
    }

    function wrapTextContent(node, text, prop, useHTML) {
      var isMultiLine = isArray$1(text) && text.length > 1,
        printProperty = useHTML ? 'html' : 'text',
        parentGroup = d3_select(node.node().parentNode);

      if (isMultiLine) {
        node.text(null);
        var x = node.attr('x') || 0,
          y = node.attr('y') || 0,
          dy = node.attr('dy') ? parseFloat(node.attr('dy')) : 0.71;
        var lineNumber = 0,
          lineHeight = defined(prop) && defined(prop.lineHeight) ? prop.lineHeight : dy,
          orient = defined(prop) && prop.orient;

        lineHeight =
        orient == 'top' ?
        -(text.length - 1 + lineHeight) :
        orient == 'left' || orient == 'right' ?
        -(text.length - 2 + lineHeight) / 2 :
        lineHeight; //Adjust initial lineheight for left or top aligned axis

        text.forEach(function (el, i) {
          if (useHTML) {
            insertSVGEle(parentGroup, node, el, i);
          } else {
            var tspan = node.append('tspan');
            tspan.
            attr('x', x).
            attr('y', y).
            attr('dy', function (d, i) {
              return "".concat(lineNumber++ + lineHeight, "em");
            });

            tspan[printProperty](function () {
              return el;
            });
          }
        });
      } else {
        if (useHTML) {
          node.text(null);
          insertSVGEle(parentGroup, node, text);
        } else {
          // wordWrap(node,100);
          node[printProperty](text);
        }
      }
      return node;
    }

    function insertSVGEle(parent, textNode, child, order) {
      var imageRegex = /^<image.+<\/image>/i,
        tspanRegex = /^<tspan.+<\/tspan>/i,
        groupRegex = /^<g.+<\/g>/i;

      if (groupRegex.test(child)) {
        var doc = new DOMParser().parseFromString("<svg xmlns=\"".concat(d3_namespaces.svg, "\">").concat(child, "</svg>"), 'application/xml'),
          textElements = doc.querySelectorAll('text');
        for (var i = 0; i < textElements.length; i++) {
          var node = d3_select(textElements[i]);
          if (node.attr('position') == 'auto') {
            copyDefaultTickAttrs(textNode, node);
          }
        }

        parent.node().appendChild(doc.querySelector('g'));
      } else if (imageRegex.test(child)) {
        if (parent.selectAll('g.image').nodes().length) {
          var doc = new DOMParser().parseFromString("<svg xmlns=\"".concat(d3_namespaces.svg, "\">").concat(child, "</svg>"), 'application/xml');
          parent.
          selectAll('g.image').
          node().
          appendChild(doc.querySelector('image'));
        } else {
          createElement('g', '.image', [textNode.data()[0]], parent, order == 0 ? 'text' : null).html(child);
        }
      } else if (tspanRegex.test(child)) {
        var doc = new DOMParser().parseFromString("<svg xmlns=\"".concat(d3_namespaces.svg, "\">").concat(child, "</svg>"), 'application/xml');
        textNode.node().appendChild(doc.querySelector('tspan'));
      } else {
        textNode.append('tspan').text(child);
      }
    }

    function getTextContent(textNode) {
      var tspan = textNode.selectAll('tspan').nodes();
      if (tspan && tspan.length) {
        var arr = [];
        tspan.forEach(function (d) {
          arr.push(d.textContent);
        });
        return arr;
      } else {
        return textNode.node().textContent;
      }
    }

    /**
     *
     * @param {d3.selection} element
     * @param {String} query
     * @param {Array} data
     * @param {d3.selection} parent
     * @param {selector} insertBefore
     * @param {function} dataAccessor
     */
    function createElement(element, query, data, parent, insertBefore, dataAccessor) {var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
      if (!parent) {
        parent = d3_select('body');
      }

      var selectorAttribute,
        selectorValue,
        selector,
        selectorHash = {
          '.': 'class',
          '#': 'id'
        };

      if (/^[.#]/.test(query)) {
        selector = query[0];
        selectorValue = query.slice(1);
        selectorAttribute = selectorHash[selector];
      }

      // #ZC1527
      // insertBefore - code has been moved to appendEle api

      return appendEle(parent, element, data, selector, selectorAttribute, selectorValue, null, dataAccessor, _objectSpread(_objectSpread({}, options), {}, { insertBefore: insertBefore }));
    }

    function isSvgElement(element) {
      if (element.isD3Selection) {
        element = element.node();
      }

      return !!element.ownerSVGElement;
    }

    var fontUtils = utils.fontUtils = {
      /**
       *
       * @param text
       * @param fontSize
       * @param fontFamily
       * @param fontStyle
       * @param fontWeight
       * @return {number}
       */
      getTextWidth: function getTextWidth(text, fontSize, fontFamily, fontStyle, fontWeight) {
        fontStyle = fontStyle || 'normal';
        fontWeight = fontWeight || 'normal';

        tempCanvasContext.save();
        tempCanvasContext.font = "".concat(fontStyle, " ").concat(fontWeight, " ").concat(fontSize || 12, "px ").concat(fontFamily || $ZCG.fontFamily);
        var t = tempCanvasContext.measureText(text).width;
        tempCanvasContext.restore();
        return t;
      },

      /**
       *
       * @param fontSize
       * @param dontUseEmpirical
       * @return {*}
       */
      getTextHeight: function getTextHeight(text, fontSize, fontFamily, fontStyle, fontWeight, dontUseEmpirical) {
        // Empirical values found by comparing font size and bounding box height.
        // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
        if (dontUseEmpirical) {
          return fontSize;
        }
        return fontSize < 24 ? fontSize + 3 : ~~(fontSize * 1.195);
      }
    };

    utils.createElement = createElement;

    /**
     *
     * @param element
     * @param styles
     * @param customStyleMap
     */
    function setStyles(element, styles) {var customStyleMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var customAttrMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      // common maps

      var selectionAttrMap = _objectSpread({
        transform: 'transform',
        filter: 'filter',
        dashStyle: 'stroke-dasharray' },
      customAttrMap);


      var selectionStyleMap = _objectSpread({
        fillColor: 'fill',
        innerFillColor: 'fill',
        outerFillColor: 'fill',
        fillOpacity: 'fill-opacity',
        innerFillOpacity: 'fill-opacity',
        outerFillOpacity: 'fill-opacity',
        strokeColor: 'stroke',
        innerStrokeColor: 'stroke',
        outerStrokeColor: 'stroke',
        strokeOpacity: 'stroke-opacity',
        innerStrokeOpacity: 'stroke-opacity',
        outerStrokeOpacity: 'stroke-opacity',
        strokeWidth: 'stroke-width',
        innerStrokeWidth: 'stroke-width',
        outerStrokeWidth: 'stroke-width',
        fontWeight: 'font-weight',
        fontStyle: 'font-style',
        textShadow: 'text-shadow' },
      customStyleMap);


      // apply style
      each(styles, function (value, prop) {
        if (selectionAttrMap[prop]) {
          // #ZC2125
          if (prop === 'dashStyle') {
            value = getDashArray(value, styles.strokeWidth);
          }
          element.attr(selectionAttrMap[prop], value);
        } else {
          element.style(selectionStyleMap[prop] || prop, value);
        }
      });
      return element;
    }

    utils.setStyles = setStyles;

    /**
     *
     * @param shadow
     * @param chart
     * @return {string}
     */
    function svgBoxShadow(shadow, chart) {
      if (shadow) {
        var parsedShadowOptions = shadow.split(' '),
          shadowOptions = {
            dx: parseFloat(parsedShadowOptions[0]),
            dy: parseFloat(parsedShadowOptions[1]),
            color: parsedShadowOptions[3],
            blur: parseFloat(parsedShadowOptions[2]),
            x: '-50%',
            y: '-50%',
            width: '200%',
            height: '200%'
          };

        var id = effects.get(effects.svg_filters, 'dropShadow', shadowOptions, { chartObj: chart });

        return "url(".concat(chart.defsLocation, "#").concat(id, ")");
      }
    }

    utils.svgBoxShadow = utils.setStyles;

    function elementToPolygonPoints(ele) {
      if (ele.isD3Selection) {
        ele = ele.node();
      }

      var len = ele.getTotalLength(),
        points = [];

      for (var k = 0; k < len; k++) {
        var p = ele.getPointAtLength(k);
        points.push([p.x, p.y]);
      }

      return points;
    }

    /**
     *
     * @param pathNode
     * @param precision
     * @param offset
     * @return {[]}
     */
    function pathToPolygon(pathNode, precision) {var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
      var pathLength = pathNode.getTotalLength(),
        samples = [],_offset = _slicedToArray(
        offset, 2),offsetX = _offset[0],offsetY = _offset[1];

      for (var sample, sampleLength = 0; sampleLength <= pathLength; sampleLength += precision) {
        sample = pathNode.getPointAtLength(sampleLength);
        samples.push([sample.x + offsetX, sample.y + offsetY]);
      }
      samples.push(samples[0].slice(0));
      return samples;
    }

    function SVGDOMParser(input) {
      var domAsString = "<zc-temp>".concat(input, "</zc-temp>"),
        sandBox = new DOMParser().parseFromString("<svg xmlns=\"".concat(d3_namespaces.svg, "\">").concat(domAsString, "</svg>"), 'application/xml');
      return sandBox;
    }
    function parseSVGElementsToArray(element, tag) {
      var selectedElements = toArray(element.querySelectorAll(tag));

      return selectedElements;
      // parseSVGElementsToArray(element, tag, styleProps, attrProps, isTextNode)
      //     var styleValues,
      //     attrValues,
      //     textContents = new Array(0);
      //
      // if (selectedElements.length) {
      //     selectedElements.forEach(function(t) {
      //         if (isTextNode) {
      //             textContents.push(t.textContent.trim());
      //         }
      //
      //         if (styleProps) {
      //             let style = t.style || {};
      //             styleValues = iterateObject(style, styleProps);
      //         }
      //         if (attrProps) {
      //             let style = t.style || {};
      //             attrValues = iterateObject(style, attrProps);
      //         }
      //     });
      // } else if (isTextNode) {
      //     textContents.push(element.textContent);
      // }
      // return {
      //     nodes: selectedElements,
      //     styles: styleValues,
      //     attrs: attrValues,
      //     textNodes: textContents
      // };
    }

    function getTextBoundByDOM(node, content, contentType, isMultiLine) {
      var contentType = contentType || 'text',
        isMultiLine = contentType === 'html' && isMultiLine;

      node[contentType](content);
      if (isMultiLine) {
        translateTspan(node, 0);
      }

      var bound = bbox(node.node());
      return bound;
    }

    //$Id$
    //animation-constants.js
    var FADEALL_ANIMATION = 'fadeAll',
      FADEONEBYONE_ANIMATION = 'fadeOneByOne',
      FADERANDOM_ANIMATION = 'fadeRandom',
      FADE_ANIMATION = 'fade',
      SIZING_ANIMATION = 'sizing',
      SIZINGRANDOM_ANIMATION = 'sizingRandom',
      RANDOMOUT_ANIMATION = 'randomOut',
      VERTICAL_ANIMATION = 'vertical',
      VERTICALALL_ANIMATION = 'verticalAll',
      VERTPATHTWEEN_ANIMATION = 'vertPathTween',
      VERTPATHTWEENALL_ANIMATION = 'vertPathTweenAll',
      HORIZONTALALL_ANIMATION = 'horizontalAll',
      HORIPATHTWEEN_ANIMATION = 'horiPathTween',
      STROKETWEEN_ANIMATION = 'strokeTween',
      POINTTWEEN_ANIMATION = 'pointTween',
      POINTBYPOINT_ANIMATION = 'pointbypoint',
      ALLSERIES_ANIMATION = 'allseries',
      ONEBYONE_ANIMATION = 'onebyone',
      FANONEBYONE_ANIMATION = 'fanonebyone',
      FANALL_ANIMATION = 'fanAll',
      FAN_ANIMATION = 'fan',
      WHEEL_ANIMATION = 'wheel',
      INNER_ANIMATION = 'inner';

    //

    var LOCATION_MARKERS = d3_set([
    'geo-location-1',
    'geo-location-2',
    'geo-location-3',
    'geo-flag-1',
    'geo-flag-2',
    'geo-flag-3',
    'geo-pin-1',
    'geo-pin-2',
    'geo-pin-3']);


    function getGeoSVGSymbol(type, size, side) {
      side = pick(side, 'outer');

      var symbols = {
        'geo-location-1': {
          outer:
          "".concat('M' + ' ', 0, " ").concat(size * -0.9956, "C") + " ".concat(
          size * -0.1506, " ").concat(size * -0.9956, " ").concat(size * -0.2845, " ").concat(size * -0.8718, " ").concat(size * -0.2845, " ").concat(size * -0.7279, "C") + " ".concat(
          size * -0.2845, " ").concat(size * -0.7179, " ").concat(size * -0.2845, " ").concat(size * -0.7078, " ").concat(size * -0.2811, " ").concat(size * -0.6978, "C") + " ".concat(
          size * -0.2744, " ").concat(size * -0.594, " ").concat(size * -0.2209, " ").concat(size * -0.5204, " ").concat(size * -0.1673, " ").concat(size * -0.4401, "C") + " ".concat(
          size * -0.0971, " ").concat(size * -0.3363, " ").concat(size * -0.0167, " ").concat(size * -0.2159, " ").concat(size * -0.0167, " ").concat(size * -0.0084, "C") + " ".concat(
          size * -0.0167, " ").concat(size * 0.0017, " ").concat(size * -0.01, " ").concat(size * 0.0084, " ", 0, " ").concat(size * 0.0084, "S") + " ".concat(
          size * 0.0167, " ").concat(size * 0.0017, " ").concat(size * 0.0167, " ").concat(size * -0.0084, "C") + " ".concat(
          size * 0.0167, " ").concat(size * -0.2192, " ").concat(size * 0.0971, " ").concat(size * -0.3363, " ").concat(size * 0.1673, " ").concat(size * -0.4401, "C") + " ".concat(
          size * 0.2209, " ").concat(size * -0.5204, " ").concat(size * 0.2744, " ").concat(size * -0.594, " ").concat(size * 0.2811, " ").concat(size * -0.6944, "C") + " ".concat(
          size * 0.2811, " ").concat(size * -0.7045, " ").concat(size * 0.2845, " ").concat(size * -0.7145, " ").concat(size * 0.2845, " ").concat(size * -0.7246, "C") + " ".concat(
          size * 0.2845, " ").concat(size * -0.8718, " ").concat(size * 0.1506, " ").concat(size * -0.9956, " ", 0, " ").concat(size * -0.9956, "z"),
          inner:
          "".concat('M' + ' ', 0, " ").concat(size * -1.7333, "C") + " ".concat(
          size * 0.1267, " ").concat(size * -1.7333, " ").concat(size * 0.2333, " ").concat(size * -1.6267, " ").concat(size * 0.2333, " ").concat(size * -1.5, "S") + " ".concat(
          size * 0.1267, " ").concat(size * -1.2667, " ", 0, " ").concat(size * -1.2667, "S") + " ".concat(
          size * -0.2333, " ").concat(size * -1.3733, " ").concat(size * -0.2333, " ").concat(size * -1.5, "S") + " ".concat(
          size * -0.1267, " ").concat(size * -1.7333, " ", 0, " ").concat(size * -1.7333, "z")
        },
        'geo-location-2': {
          outer:
          "".concat('M' + ' ', 0, " ").concat(size * -1, "C") + " ".concat(
          size * -0.1933, " ").concat(size * -1, " ").concat(size * -0.35, " ").concat(size * -0.8433, " ").concat(size * -0.35, " ").concat(size * -0.65, "C") + " ".concat(
          size * -0.35, " ").concat(size * -0.31, " ").concat(size * -0.0233, " ").concat(size * -0.0167, " ").concat(size * -0.01, " ").concat(size * -0.0033, "C") + " ".concat(
          size * -0.0067, " ", 0, " ").concat(size * -0.0033, " ", 0, " ", 0, " ", 0, "S") + " ".concat(
          size * 0.0067, " ", 0, " ").concat(size * 0.01, " ").concat(size * -0.0033, "C") + " ".concat(
          size * 0.0233, " ").concat(size * -0.0167, " ").concat(size * 0.35, " ").concat(size * -0.31, " ").concat(size * 0.35, " ").concat(size * -0.65, "C") + " ".concat(
          size * 0.35, " ").concat(size * -0.8433, " ").concat(size * 0.1933, " ").concat(size * -1, " ", 0, " ").concat(size * -1, "z"),
          inner:
          "".concat('M' + ' ', 0, " ").concat(size * -1.6667, "C") + " ".concat(
          size * 0.2, " ").concat(size * -1.6667, " ").concat(size * 0.3667, " ").concat(size * -1.5, " ").concat(size * 0.3667, " ").concat(size * -1.3, "S") + " ".concat(
          size * 0.2, " ").concat(size * -0.9333, " ", 0, " ").concat(size * -0.9333, "S") + " ".concat(
          size * -0.3667, " ").concat(size * -1.1, " ").concat(size * -0.3667, " ").concat(size * -1.3, "S") + " ".concat(
          size * -0.2, " ").concat(size * -1.6667, " ", 0, " ").concat(size * -1.6667, "z")
        },
        'geo-pin-1': {
          outer:
          "".concat('M' + ' ').concat(size * 0.2167, " ").concat(size * -0.7833, "C") + " ".concat(
          size * 0.2167, " ").concat(size * -0.9033, " ").concat(size * 0.12, " ").concat(size * -1, " ", 0, " ").concat(size * -1, "S") + " ".concat(
          size * -0.2167, " ").concat(size * -0.9033, " ").concat(size * -0.2167, " ").concat(size * -0.7833, "C") + " ".concat(
          size * -0.2167, " ").concat(size * -0.67, " ").concat(size * -0.1267, " ").concat(size * -0.5767, " ").concat(size * -0.0167, " ").concat(size * -0.5667, "L") + " ".concat(
          size * -0.0167, " ").concat(size * -0.0167, "C") + " ".concat(
          size * -0.0167, " ").concat(size * -0.0067, " ").concat(size * -0.01, " ", 0, " ", 0, " ", 0, "S") + " ".concat(
          size * 0.0167, " ").concat(size * -0.0067, " ").concat(size * 0.0167, " ").concat(size * -0.0167, "L") + " ".concat(
          size * 0.0167, " ").concat(size * -0.5667, "C") + " ".concat(
          size * 0.1267, " ").concat(size * -0.5767, " ").concat(size * 0.2167, " ").concat(size * -0.67, " ").concat(size * 0.2167, " ").concat(size * -0.7833, "z"),
          inner:
          "".concat('M' + ' ', 0, " ").concat(size * -1.8, "C") + " ".concat(
          size * -0.1267, " ").concat(size * -1.8, " ").concat(size * -0.2333, " ").concat(size * -1.6933, " ").concat(size * -0.2333, " ").concat(size * -1.5667, "C") + " ".concat(
          size * -0.2333, " ").concat(size * -1.5467, " ").concat(size * -0.2467, " ").concat(size * -1.5333, " ").concat(size * -0.2667, " ").concat(size * -1.5333, "S") + " ".concat(
          size * -0.3, " ").concat(size * -1.5467, " ").concat(size * -0.3, " ").concat(size * -1.5667, "C") + " ".concat(
          size * -0.3, " ").concat(size * -1.7333, " ").concat(size * -0.1667, " ").concat(size * -1.8667, " ", 0, " ").concat(size * -1.8667, "C") + " ".concat(
          size * 0.02, " ").concat(size * -1.8667, " ").concat(size * 0.0333, " ").concat(size * -1.8533, " ").concat(size * 0.0333, " ").concat(size * -1.8333, "S") + " ".concat(
          size * 0.02, " ").concat(size * -1.8, " ", 0, " ").concat(size * -1.8, "z")
        },
        'geo-pin-2': {
          outer:
          "".concat('M' + ' ').concat(size * 0.304, " ").concat(size * -0.6935, "C") + " ".concat(
          size * 0.304, " ").concat(size * -0.8607, " ").concat(size * 0.1672, " ").concat(size * -0.9975, " ", 0, " ").concat(size * -0.9975, "S") + " ".concat(
          size * -0.304, " ").concat(size * -0.8607, " ").concat(size * -0.304, " ").concat(size * -0.6935, "C") + " ".concat(
          size * -0.304, " ").concat(size * -0.532, " ").concat(size * -0.1786, " ").concat(size * -0.4009, " ").concat(size * -0.019, " ").concat(size * -0.3914, "L") + " ".concat(
          size * -0.019, " ").concat(size * -0.019, "C") + " ".concat(
          size * -0.019, " ").concat(size * -0.0076, " ").concat(size * -0.0114, " ", 0, " ", 0, " ", 0, "S") + " ".concat(
          size * 0.019, " ").concat(size * -0.0076, " ").concat(size * 0.019, " ").concat(size * -0.019, "L") + " ".concat(
          size * 0.019, " ").concat(size * -0.3914, "C") + " ".concat(
          size * 0.1786, " ").concat(size * -0.4009, " ").concat(size * 0.304, " ").concat(size * -0.532, " ").concat(size * 0.304, " ").concat(size * -0.6935, "z"),
          inner:
          "".concat('M' + ' ').concat(size * -0.038, " ").concat(size * -1.767, "C") + " ".concat(
          size * -0.228, " ").concat(size * -1.767, " ").concat(size * -0.38, " ").concat(size * -1.615, " ").concat(size * -0.38, " ").concat(size * -1.425, "C") + " ".concat(
          size * -0.38, " ").concat(size * -1.4022, " ").concat(size * -0.3648, " ").concat(size * -1.387, " ").concat(size * -0.342, " ").concat(size * -1.387, "S") + " ".concat(
          size * -0.304, " ").concat(size * -1.4022, " ").concat(size * -0.304, " ").concat(size * -1.425, "C") + " ".concat(
          size * -0.304, " ").concat(size * -1.5732, " ").concat(size * -0.1862, " ").concat(size * -1.691, " ").concat(size * -0.038, " ").concat(size * -1.691, "C") + " ".concat(
          size * -0.0152, " ").concat(size * -1.691, " ", 0, " ").concat(size * -1.7062, " ", 0, " ").concat(size * -1.729, "S") + " ".concat(
          size * -0.0152, " ").concat(size * -1.767, " ").concat(size * -0.038, " ").concat(size * -1.767, "z")
        },
        'geo-pin-3': {
          outer:
          "".concat('M' + ' ').concat(size * 0.9442, " ").concat(size * -0.5854, "L") + " ".concat(
          size * 0.5451, " ").concat(size * -0.9826, "C") + " ".concat(
          size * 0.5376, " ").concat(size * -0.9901, " ").concat(size * 0.5264, " ").concat(size * -0.9901, " ").concat(size * 0.5189, " ").concat(size * -0.9826, "L") + " ".concat(
          size * 0.4196, " ").concat(size * -0.8833, "C") + " ".concat(
          size * 0.4159, " ").concat(size * -0.8795, " ").concat(size * 0.414, " ").concat(size * -0.8758, " ").concat(size * 0.414, " ").concat(size * -0.8702, "S") + " ".concat(
          size * 0.4159, " ").concat(size * -0.8608, " ").concat(size * 0.4196, " ").concat(size * -0.857, "L") + " ".concat(
          size * 0.4721, " ").concat(size * -0.8046, "L") + " ".concat(
          size * 0.2248, " ").concat(size * -0.5554, "L") + " ".concat(
          size * 0.1161, " ").concat(size * -0.5236, "C") + " ".concat(
          size * 0.1105, " ").concat(size * -0.5217, " ").concat(size * 0.1049, " ").concat(size * -0.5161, " ").concat(size * 0.103, " ").concat(size * -0.5105, "C") + " ".concat(
          size * 0.1012, " ").concat(size * -0.5049, " ").concat(size * 0.103, " ").concat(size * -0.4974, " ").concat(size * 0.1087, " ").concat(size * -0.4917, "L") + " ".concat(
          size * 0.2473, " ").concat(size * -0.3531, "L") + " ".concat(
          size * -0.0244, " ").concat(size * -0.0815, "C") + " ".concat(
          size * -0.0431, " ").concat(size * -0.0628, " ").concat(size * -0.0431, " ").concat(size * -0.0328, " ").concat(size * -0.0244, " ").concat(size * -0.0159, "C") + " ".concat(
          size * -0.015, " ").concat(size * -0.0066, " ").concat(size * -0.0037, " ").concat(size * -0.0028, " ").concat(size * 0.0094, " ").concat(size * -0.0028, "S") + " ".concat(
          size * 0.0337, " ").concat(size * -0.0084, " ").concat(size * 0.0431, " ").concat(size * -0.0159, "L") + " ".concat(
          size * 0.3147, " ").concat(size * -0.2876, "L") + " ".concat(
          size * 0.4533, " ").concat(size * -0.1489, "C") + " ".concat(
          size * 0.4571, " ").concat(size * -0.1452, " ").concat(size * 0.4608, " ").concat(size * -0.1433, " ").concat(size * 0.4665, " ").concat(size * -0.1433, "L") + " ".concat(
          size * 0.4702, " ").concat(size * -0.1433, "C") + " ".concat(
          size * 0.4758, " ").concat(size * -0.1452, " ").concat(size * 0.4814, " ").concat(size * -0.1489, " ").concat(size * 0.4833, " ").concat(size * -0.1564, "L") + " ".concat(
          size * 0.5152, " ").concat(size * -0.2651, "L") + " ".concat(
          size * 0.7643, " ").concat(size * -0.5142, "L") + " ".concat(
          size * 0.8168, " ").concat(size * -0.4618, "C") + " ".concat(
          size * 0.8243, " ").concat(size * -0.4543, " ").concat(size * 0.8355, " ").concat(size * -0.4543, " ").concat(size * 0.843, " ").concat(size * -0.4618, "L") + " ".concat(
          size * 0.9423, " ").concat(size * -0.5611, "C") + " ".concat(
          size * 0.9498, " ").concat(size * -0.5667, " ").concat(size * 0.9498, " ").concat(size * -0.5779, " ").concat(size * 0.9442, " ").concat(size * -0.5854, "z"),
          inner:
          "".concat('M' + ' ').concat(size * 0.0336, " ").concat(size * -0.0747, "C") + " ".concat(
          size * 0.0299, " ").concat(size * -0.0709, " ").concat(size * 0.0224, " ").concat(size * -0.0709, " ").concat(size * 0.0187, " ").concat(size * -0.0709, "C") + " ".concat(
          size * 0.0149, " ").concat(size * -0.0709, " ").concat(size * 0.0112, " ").concat(size * -0.0709, " ").concat(size * 0.0037, " ").concat(size * -0.0747, "C") + " ".concat(
          size * -0.0037, " ").concat(size * -0.0821, " ").concat(size * -0.0037, " ").concat(size * -0.0933, " ").concat(size * 0.0037, " ").concat(size * -0.1008, "L") + " ".concat(
          size * 0.5451, " ").concat(size * -0.6421, "L") + " ".concat(
          size * 0.5712, " ").concat(size * -0.616, "L") + " ".concat(
          size * 0.0336, " ").concat(size * -0.0747, "z") + "M" + " ".concat(

          size * 1.6539, " ").concat(size * -0.9856, "L") + " ".concat(
          size * 1.5493, " ").concat(size * -1.0901, "C") + " ".concat(
          size * 1.5344, " ").concat(size * -1.1051, " ").concat(size * 1.512, " ").concat(size * -1.1051, " ").concat(size * 1.4971, " ").concat(size * -1.0901, "L") + " ".concat(
          size * 0.9707, " ").concat(size * -0.5637, "C") + " ".concat(
          size * 0.9669, " ").concat(size * -0.56, " ").concat(size * 0.9632, " ").concat(size * -0.5525, " ").concat(size * 0.9595, " ").concat(size * -0.5488, "L") + " ".concat(
          size * 0.9109, " ").concat(size * -0.3845, "L") + " ".concat(
          size * 0.3136, " ").concat(size * -0.9819, "L") + " ".concat(
          size * 0.4555, " ").concat(size * -1.0229, "L") + " ".concat(
          size * 0.6757, " ").concat(size * -0.8027, "C") + " ".concat(
          size * 0.6832, " ").concat(size * -0.7952, " ").concat(size * 0.6944, " ").concat(size * -0.7915, " ").concat(size * 0.7019, " ").concat(size * -0.7915, "S") + " ".concat(
          size * 0.7205, " ").concat(size * -0.7952, " ").concat(size * 0.728, " ").concat(size * -0.8027, "C") + " ".concat(
          size * 0.7429, " ").concat(size * -0.8176, " ").concat(size * 0.7429, " ").concat(size * -0.84, " ").concat(size * 0.728, " ").concat(size * -0.8549, "L") + " ".concat(
          size * 0.5189, " ").concat(size * -1.064, "L") + " ".concat(
          size * 0.9931, " ").concat(size * -1.5381, "L") + " ".concat(
          size * 1.176, " ").concat(size * -1.3515, "C") + " ".concat(
          size * 1.1835, " ").concat(size * -1.344, " ").concat(size * 1.1947, " ").concat(size * -1.3403, " ").concat(size * 1.2021, " ").concat(size * -1.3403, "S") + " ".concat(
          size * 1.2208, " ").concat(size * -1.344, " ").concat(size * 1.2283, " ").concat(size * -1.3515, "C") + " ".concat(
          size * 1.2432, " ").concat(size * -1.3664, " ").concat(size * 1.2432, " ").concat(size * -1.3888, " ").concat(size * 1.2283, " ").concat(size * -1.4037, "L") + " ".concat(
          size * 1.0155, " ").concat(size * -1.6165, "L") + " ".concat(
          size * 0.9147, " ").concat(size * -1.7248, "L") + " ".concat(
          size * 1.0603, " ").concat(size * -1.8704, "L") + " ".concat(
          size * 1.7995, " ").concat(size * -1.1312, "L") + " ".concat(
          size * 1.6539, " ").concat(size * -0.9856, "z")
        },
        'geo-flag-1': {
          outer:
          "".concat('M' + ' ').concat(size * 0.7417, " ").concat(size * -0.6333, "C") + " ".concat(
          size * 0.735, " ").concat(size * -0.6467, " ").concat(size * 0.7283, " ").concat(size * -0.6567, " ").concat(size * 0.7217, " ").concat(size * -0.67, "C") + " ".concat(
          size * 0.7183, " ").concat(size * -0.6767, " ").concat(size * 0.7117, " ").concat(size * -0.6833, " ").concat(size * 0.7083, " ").concat(size * -0.69, "C") + " ".concat(
          size * 0.695, " ").concat(size * -0.7133, " ").concat(size * 0.6917, " ").concat(size * -0.7433, " ").concat(size * 0.6983, " ").concat(size * -0.77, "C") + " ".concat(
          size * 0.705, " ").concat(size * -0.7933, " ").concat(size * 0.7183, " ").concat(size * -0.8167, " ").concat(size * 0.735, " ").concat(size * -0.84, "C") + " ".concat(
          size * 0.7383, " ").concat(size * -0.8467, " ").concat(size * 0.7417, " ").concat(size * -0.85, " ").concat(size * 0.745, " ").concat(size * -0.8567, "C") + " ".concat(
          size * 0.7583, " ").concat(size * -0.8767, " ").concat(size * 0.755, " ").concat(size * -0.9033, " ").concat(size * 0.7383, " ").concat(size * -0.92, "C") + " ".concat(
          size * 0.6617, " ").concat(size * -1, " ").concat(size * 0.5317, " ").concat(size * -1.0233, " ").concat(size * 0.4283, " ").concat(size * -0.9767, "C") + " ".concat(
          size * 0.3983, " ").concat(size * -0.9633, " ").concat(size * 0.375, " ").concat(size * -0.9467, " ").concat(size * 0.3483, " ").concat(size * -0.93, "C") + " ".concat(
          size * 0.3317, " ").concat(size * -0.9167, " ").concat(size * 0.315, " ").concat(size * -0.9067, " ").concat(size * 0.295, " ").concat(size * -0.8967, "C") + " ".concat(
          size * 0.215, " ").concat(size * -0.85, " ").concat(size * 0.1083, " ").concat(size * -0.85, " ").concat(size * 0.025, " ").concat(size * -0.8967, "L") + " ".concat(
          size * 0.025, " ").concat(size * -0.9667, "C") + " ".concat(
          size * 0.025, " ").concat(size * -0.9867, " ").concat(size * 0.0117, " ").concat(size * -1, " ").concat(size * -0.0083, " ").concat(size * -1, "S") + " ".concat(
          size * -0.0417, " ").concat(size * -0.9867, " ").concat(size * -0.0417, " ").concat(size * -0.9667, "L") + " ".concat(
          size * -0.0417, " ").concat(size * -0.0333, "C") + " ".concat(
          size * -0.0417, " ").concat(size * -0.0133, " ").concat(size * -0.0283, " ", 0, " ").concat(size * -0.0083, " ", 0, "S") + " ".concat(
          size * 0.025, " ").concat(size * -0.0133, " ").concat(size * 0.025, " ").concat(size * -0.0333, "L") + " ".concat(
          size * 0.025, " ").concat(size * -0.4267, "C") + " ".concat(
          size * 0.0683, " ").concat(size * -0.41, " ").concat(size * 0.115, " ").concat(size * -0.4, " ").concat(size * 0.1617, " ").concat(size * -0.4, "C") + " ".concat(
          size * 0.2183, " ").concat(size * -0.4, " ").concat(size * 0.2783, " ").concat(size * -0.4133, " ").concat(size * 0.3283, " ").concat(size * -0.44, "C") + " ".concat(
          size * 0.3483, " ").concat(size * -0.45, " ").concat(size * 0.3683, " ").concat(size * -0.4633, " ").concat(size * 0.3883, " ").concat(size * -0.4767, "C") + " ".concat(
          size * 0.4117, " ").concat(size * -0.4933, " ").concat(size * 0.435, " ").concat(size * -0.5067, " ").concat(size * 0.4583, " ").concat(size * -0.52, "C") + " ".concat(
          size * 0.525, " ").concat(size * -0.55, " ").concat(size * 0.615, " ").concat(size * -0.54, " ").concat(size * 0.675, " ").concat(size * -0.49, "C") + " ".concat(
          size * 0.6917, " ").concat(size * -0.4767, " ").concat(size * 0.7117, " ").concat(size * -0.4767, " ").concat(size * 0.7283, " ").concat(size * -0.4833, "C") + " ".concat(
          size * 0.745, " ").concat(size * -0.4933, " ").concat(size * 0.7583, " ").concat(size * -0.51, " ").concat(size * 0.755, " ").concat(size * -0.53, "C") + " ".concat(
          size * 0.7583, " ").concat(size * -0.5667, " ").concat(size * 0.755, " ").concat(size * -0.6, " ").concat(size * 0.7417, " ").concat(size * -0.6333, "z"),
          inner:
          "".concat('M' + ' ').concat(size * 0.8633, " ").concat(size * -1.1667, "C") + " ".concat(
          size * 0.8033, " ").concat(size * -1.14, " ").concat(size * 0.7567, " ").concat(size * -1.1067, " ").concat(size * 0.7033, " ").concat(size * -1.0733, "C") + " ".concat(
          size * 0.67, " ").concat(size * -1.0467, " ").concat(size * 0.63, " ").concat(size * -1.0267, " ").concat(size * 0.5967, " ").concat(size * -1.0067, "C") + " ".concat(
          size * 0.43, " ").concat(size * -0.9133, " ").concat(size * 0.2167, " ").concat(size * -0.92, " ").concat(size * 0.05, " ").concat(size * -1.0067, "L") + " ".concat(
          size * 0.05, " ").concat(size * -1.6467, "C") + " ".concat(
          size * 0.2433, " ").concat(size * -1.5667, " ").concat(size * 0.4767, " ").concat(size * -1.5733, " ").concat(size * 0.6633, " ").concat(size * -1.6733, "C") + " ".concat(
          size * 0.7033, " ").concat(size * -1.6933, " ").concat(size * 0.7433, " ").concat(size * -1.72, " ").concat(size * 0.7833, " ").concat(size * -1.7467, "C") + " ".concat(
          size * 0.83, " ").concat(size * -1.78, " ").concat(size * 0.8767, " ").concat(size * -1.8067, " ").concat(size * 0.9233, " ").concat(size * -1.8333, "C") + " ".concat(
          size * 1.07, " ").concat(size * -1.9, " ").concat(size * 1.25, " ").concat(size * -1.8667, " ").concat(size * 1.37, " ").concat(size * -1.7667, "L") + " ".concat(
          size * 1.3633, " ").concat(size * -1.76, "C") + " ".concat(
          size * 1.33, " ").concat(size * -1.7067, " ").concat(size * 1.29, " ").concat(size * -1.6533, " ").concat(size * 1.27, " ").concat(size * -1.58, "C") + " ".concat(
          size * 1.25, " ").concat(size * -1.4933, " ").concat(size * 1.2567, " ").concat(size * -1.4, " ").concat(size * 1.3033, " ").concat(size * -1.32, "C") + " ".concat(
          size * 1.31, " ").concat(size * -1.3, " ").concat(size * 1.3233, " ").concat(size * -1.2867, " ").concat(size * 1.3367, " ").concat(size * -1.2667, "S") + " ".concat(
          size * 1.3633, " ").concat(size * -1.2267, " ").concat(size * 1.37, " ").concat(size * -1.2133, "C") + " ".concat(
          size * 1.3833, " ").concat(size * -1.1867, " ").concat(size * 1.39, " ").concat(size * -1.16, " ").concat(size * 1.39, " ").concat(size * -1.1267, "C") + " ".concat(
          size * 1.2233, " ").concat(size * -1.22, " ").concat(size * 1.0233, " ").concat(size * -1.24, " ").concat(size * 0.8633, " ").concat(size * -1.1667, "z")
        },
        'geo-flag-2': {
          outer:
          "".concat('M' + ' ').concat(size * 0.6456, " ").concat(size * -0.928, "L") + " ".concat(
          size * 0.0538, " ").concat(size * -0.928, "L") + " ".concat(
          size * 0.0538, " ").concat(size * -0.9818, "C") + " ".concat(
          size * 0.0538, " ").concat(size * -0.9926, " ").concat(size * 0.0466, " ").concat(size * -0.9998, " ").concat(size * 0.0359, " ").concat(size * -0.9998, "L") + " ".concat(
          size * -0.0359, " ").concat(size * -0.9998, "C") + " ".concat(
          size * -0.0466, " ").concat(size * -0.9998, " ").concat(size * -0.0538, " ").concat(size * -0.9926, " ").concat(size * -0.0538, " ").concat(size * -0.9818, "L") + " ".concat(
          size * -0.0538, " ").concat(size * -0.0134, "C") + " ".concat(
          size * -0.0538, " ").concat(size * -0.0027, " ").concat(size * -0.0466, " ").concat(size * 0.0045, " ").concat(size * -0.0359, " ").concat(size * 0.0045, "L") + " ".concat(
          size * 0.0359, " ").concat(size * 0.0045, "C") + " ".concat(
          size * 0.0466, " ").concat(size * 0.0045, " ").concat(size * 0.0538, " ").concat(size * -0.0027, " ").concat(size * 0.0538, " ").concat(size * -0.0134, "L") + " ".concat(
          size * 0.0538, " ").concat(size * -0.4438, "L") + " ".concat(
          size * 0.6456, " ").concat(size * -0.4438, "C") + " ".concat(
          size * 0.6564, " ").concat(size * -0.4438, " ").concat(size * 0.6635, " ").concat(size * -0.451, " ").concat(size * 0.6635, " ").concat(size * -0.4618, "L") + " ".concat(
          size * 0.6635, " ").concat(size * -0.9101, "C") + " ".concat(
          size * 0.6635, " ").concat(size * -0.9209, " ").concat(size * 0.6564, " ").concat(size * -0.928, " ").concat(size * 0.6456, " ").concat(size * -0.928, "z"),
          inner:
          "".concat('M' + ' ').concat(size * 0.0359, " ").concat(size * -0.0717, "L") + " ".concat(
          size * -0.0359, " ").concat(size * -0.0717, "L") + " ".concat(
          size * -0.0359, " ").concat(size * -1.9368, "L") + " ".concat(
          size * 0.0359, " ").concat(size * -1.9368, "L") + " ".concat(
          size * 0.0359, " ").concat(size * -0.0717, "z") + "M" + " ".concat(

          size * 1.2553, " ").concat(size * -0.9684, "L") + " ".concat(
          size * 0.1076, " ").concat(size * -0.9684, "L") + " ".concat(
          size * 0.1076, " ").concat(size * -1.7933, "L") + " ".concat(
          size * 1.2553, " ").concat(size * -1.7933, "L") + " ".concat(
          size * 1.2553, " ").concat(size * -0.9684, "z")
        },
        'geo-flag-3': {
          inner:
          "".concat('M' + ' ').concat(size * 0.664, " ").concat(size * -0.5013, "L") + " ".concat(
          size * 0.664, " ").concat(size * -0.508, "C") + " ".concat(
          size * 0.664, " ").concat(size * -0.5113, " ").concat(size * 0.6607, " ").concat(size * -0.5113, " ").concat(size * 0.6607, " ").concat(size * -0.5146, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.5146, " ").concat(size * 0.6607, " ").concat(size * -0.5179, " ").concat(size * 0.6574, " ").concat(size * -0.5179, "L") + " ".concat(
          size * 0.5412, " ").concat(size * -0.664, "L") + " ".concat(
          size * 0.6574, " ").concat(size * -0.8101, "S") + " ".concat(
          size * 0.6574, " ").concat(size * -0.8134, " ").concat(size * 0.6607, " ").concat(size * -0.8134, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.8167, " ").concat(size * 0.664, " ").concat(size * -0.8167, " ").concat(size * 0.664, " ").concat(size * -0.82, "L") + " ".concat(
          size * 0.664, " ").concat(size * -0.841, "C") + " ".concat(
          size * 0.664, " ").concat(size * -0.8433, " ").concat(size * 0.664, " ").concat(size * -0.8433, " ").concat(size * 0.6607, " ").concat(size * -0.8466, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.8499, " ").concat(size * 0.6574, " ").concat(size * -0.8499, " ").concat(size * 0.6574, " ").concat(size * -0.8532, "S") + " ".concat(
          size * 0.654, " ").concat(size * -0.8566, " ").concat(size * 0.654, " ").concat(size * -0.8599, "C") + " ".concat(
          size * 0.654, " ").concat(size * -0.8599, " ").concat(size * 0.6507, " ").concat(size * -0.8599, " ").concat(size * 0.6507, " ").concat(size * -0.8632, "C") + " ".concat(
          size * 0.6474, " ").concat(size * -0.8632, " ").concat(size * 0.6474, " ").concat(size * -0.8665, " ").concat(size * 0.6441, " ").concat(size * -0.8665, "L") + " ".concat(
          size * 0.3685, " ").concat(size * -0.8665, "L") + " ".concat(
          size * 0.3685, " ").concat(size * -0.8964, "C") + " ".concat(
          size * 0.3685, " ").concat(size * -0.9163, " ").concat(size * 0.3552, " ").concat(size * -0.9296, " ").concat(size * 0.3353, " ").concat(size * -0.9296, "L") + " ".concat(
          size * 0.0332, " ").concat(size * -0.9296, "L") + " ".concat(
          size * 0.0332, " ").concat(size * -0.9628, "C") + " ".concat(
          size * 0.0332, " ").concat(size * -0.9827, " ").concat(size * 0.0199, " ").concat(size * -0.996, " ", 0, " ").concat(size * -0.996, "S") + " ".concat(
          size * -0.0332, " ").concat(size * -0.9827, " ").concat(size * -0.0332, " ").concat(size * -0.9628, "L") + " ".concat(
          size * -0.0332, " ", 0, "L") + " ".concat(
          size * 0.0332, " ", 0, "L") + " ".concat(
          size * 0.0332, " ").concat(size * -0.5312, "L") + " ".concat(
          size * 0.2988, " ").concat(size * -0.5312, "L") + " ".concat(
          size * 0.2988, " ").concat(size * -0.498, "C") + " ".concat(
          size * 0.2988, " ").concat(size * -0.4781, " ").concat(size * 0.3121, " ").concat(size * -0.4648, " ").concat(size * 0.332, " ").concat(size * -0.4648, "L") + " ".concat(
          size * 0.6308, " ").concat(size * -0.4648, "C") + " ".concat(
          size * 0.6341, " ").concat(size * -0.4648, " ").concat(size * 0.6374, " ").concat(size * -0.4648, " ").concat(size * 0.6441, " ").concat(size * -0.4681, "C") + " ".concat(
          size * 0.6441, " ").concat(size * -0.4681, " ").concat(size * 0.6474, " ").concat(size * -0.4681, " ").concat(size * 0.6474, " ").concat(size * -0.4714, "C") + " ".concat(
          size * 0.6474, " ").concat(size * -0.4714, " ").concat(size * 0.6507, " ").concat(size * -0.4714, " ").concat(size * 0.6507, " ").concat(size * -0.4748, "C") + " ".concat(
          size * 0.654, " ").concat(size * -0.4748, " ").concat(size * 0.654, " ").concat(size * -0.4781, " ").concat(size * 0.654, " ").concat(size * -0.4814, "C") + " ".concat(
          size * 0.654, " ").concat(size * -0.4814, " ").concat(size * 0.6574, " ").concat(size * -0.4847, " ").concat(size * 0.6574, " ").concat(size * -0.488, "S") + " ".concat(
          size * 0.6574, " ").concat(size * -0.4914, " ").concat(size * 0.6607, " ").concat(size * -0.4947, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.498, " ").concat(size * 0.6607, " ").concat(size * -0.498, " ").concat(size * 0.664, " ").concat(size * -0.5013, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.5013, " ").concat(size * 0.6607, " ").concat(size * -0.5013, " ").concat(size * 0.6607, " ").concat(size * -0.5046, "C") + " ".concat(
          size * 0.664, " ").concat(size * -0.498, " ").concat(size * 0.664, " ").concat(size * -0.5013, " ").concat(size * 0.664, " ").concat(size * -0.5013, "z"),
          outer:
          "".concat('M' + ' ').concat(size * 0.664, " ").concat(size * -0.5013, "L") + " ".concat(
          size * 0.664, " ").concat(size * -0.508, "C") + " ".concat(
          size * 0.664, " ").concat(size * -0.5113, " ").concat(size * 0.6607, " ").concat(size * -0.5113, " ").concat(size * 0.6607, " ").concat(size * -0.5146, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.5146, " ").concat(size * 0.6607, " ").concat(size * -0.5179, " ").concat(size * 0.6574, " ").concat(size * -0.5179, "L") + " ".concat(
          size * 0.5412, " ").concat(size * -0.664, "L") + " ".concat(
          size * 0.6574, " ").concat(size * -0.8101, "S") + " ".concat(
          size * 0.6574, " ").concat(size * -0.8134, " ").concat(size * 0.6607, " ").concat(size * -0.8134, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.8167, " ").concat(size * 0.664, " ").concat(size * -0.8167, " ").concat(size * 0.664, " ").concat(size * -0.82, "L") + " ".concat(
          size * 0.664, " ").concat(size * -0.841, "C") + " ".concat(
          size * 0.664, " ").concat(size * -0.8433, " ").concat(size * 0.664, " ").concat(size * -0.8433, " ").concat(size * 0.6607, " ").concat(size * -0.8466, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.8499, " ").concat(size * 0.6574, " ").concat(size * -0.8499, " ").concat(size * 0.6574, " ").concat(size * -0.8532, "S") + " ".concat(
          size * 0.654, " ").concat(size * -0.8566, " ").concat(size * 0.654, " ").concat(size * -0.8599, "C") + " ".concat(
          size * 0.654, " ").concat(size * -0.8599, " ").concat(size * 0.6507, " ").concat(size * -0.8599, " ").concat(size * 0.6507, " ").concat(size * -0.8632, "C") + " ".concat(
          size * 0.6474, " ").concat(size * -0.8632, " ").concat(size * 0.6474, " ").concat(size * -0.8665, " ").concat(size * 0.6441, " ").concat(size * -0.8665, "L") + " ".concat(
          size * 0.3685, " ").concat(size * -0.8665, "L") + " ".concat(
          size * 0.3685, " ").concat(size * -0.8964, "C") + " ".concat(
          size * 0.3685, " ").concat(size * -0.9163, " ").concat(size * 0.3552, " ").concat(size * -0.9296, " ").concat(size * 0.3353, " ").concat(size * -0.9296, "L") + " ".concat(
          size * 0.0332, " ").concat(size * -0.9296, "L") + " ".concat(
          size * 0.0332, " ").concat(size * -0.9628, "C") + " ".concat(
          size * 0.0332, " ").concat(size * -0.9827, " ").concat(size * 0.0199, " ").concat(size * -0.996, " ", 0, " ").concat(size * -0.996, "S") + " ".concat(
          size * -0.0332, " ").concat(size * -0.9827, " ").concat(size * -0.0332, " ").concat(size * -0.9628, "L") + " ".concat(
          size * -0.0332, " ", 0, "L") + " ".concat(
          size * 0.0332, " ", 0, "L") + " ".concat(
          size * 0.0332, " ").concat(size * -0.5312, "L") + " ".concat(
          size * 0.2988, " ").concat(size * -0.5312, "L") + " ".concat(
          size * 0.2988, " ").concat(size * -0.498, "C") + " ".concat(
          size * 0.2988, " ").concat(size * -0.4781, " ").concat(size * 0.3121, " ").concat(size * -0.4648, " ").concat(size * 0.332, " ").concat(size * -0.4648, "L") + " ".concat(
          size * 0.6308, " ").concat(size * -0.4648, "C") + " ".concat(
          size * 0.6341, " ").concat(size * -0.4648, " ").concat(size * 0.6374, " ").concat(size * -0.4648, " ").concat(size * 0.6441, " ").concat(size * -0.4681, "C") + " ".concat(
          size * 0.6441, " ").concat(size * -0.4681, " ").concat(size * 0.6474, " ").concat(size * -0.4681, " ").concat(size * 0.6474, " ").concat(size * -0.4714, "C") + " ".concat(
          size * 0.6474, " ").concat(size * -0.4714, " ").concat(size * 0.6507, " ").concat(size * -0.4714, " ").concat(size * 0.6507, " ").concat(size * -0.4748, "C") + " ".concat(
          size * 0.654, " ").concat(size * -0.4748, " ").concat(size * 0.654, " ").concat(size * -0.4781, " ").concat(size * 0.654, " ").concat(size * -0.4814, "C") + " ".concat(
          size * 0.654, " ").concat(size * -0.4814, " ").concat(size * 0.6574, " ").concat(size * -0.4847, " ").concat(size * 0.6574, " ").concat(size * -0.488, "S") + " ".concat(
          size * 0.6574, " ").concat(size * -0.4914, " ").concat(size * 0.6607, " ").concat(size * -0.4947, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.498, " ").concat(size * 0.6607, " ").concat(size * -0.498, " ").concat(size * 0.664, " ").concat(size * -0.5013, "C") + " ".concat(
          size * 0.6607, " ").concat(size * -0.5013, " ").concat(size * 0.6607, " ").concat(size * -0.5013, " ").concat(size * 0.6607, " ").concat(size * -0.5046, "C") + " ".concat(
          size * 0.664, " ").concat(size * -0.498, " ").concat(size * 0.664, " ").concat(size * -0.5013, " ").concat(size * 0.664, " ").concat(size * -0.5013, "z")
        },
        'geo-location-3': {
          outer:
          "".concat('M' + ' ').concat(size * -0.3654, " ").concat(size * -0.928, "L") + " ".concat(
          size * -0.3654, " ").concat(size * -0.3712, "C") + " ".concat(
          size * -0.319, " ").concat(size * -0.1392, " ").concat(size * -0.1334, " ").concat(size * -0.0928, " ").concat(size * 0.0058, " ", 0, "C") + " ".concat(
          size * 0.145, " ").concat(size * -0.0928, " ").concat(size * 0.3306, " ").concat(size * -0.1392, " ").concat(size * 0.377, " ").concat(size * -0.3712, "L") + " ".concat(
          size * 0.377, " ").concat(size * -0.928, "C") + " ".concat(
          size * 0.0522, " ").concat(size * -1.0208, " ").concat(size * -0.0406, " ").concat(size * -1.0208, " ").concat(size * -0.3654, " ").concat(size * -0.928, "Z"),
          inner:
          "".concat('M' + ' ').concat(size * -0.5452, " ").concat(size * -1.392, "L") + " ".concat(
          size * -0.174, " ").concat(size * -1.392, "L") + " ".concat(
          size * 0.0116, " ").concat(size * -1.7632, "L") + " ".concat(
          size * 0.1972, " ").concat(size * -1.392, "L") + " ".concat(
          size * 0.5684, " ").concat(size * -1.392, "L") + " ".concat(
          size * 0.29, " ").concat(size * -1.1136, "L") + " ".concat(
          size * 0.4756, " ").concat(size * -0.6496, "L") + " ".concat(
          size * 0.0116, " ").concat(size * -0.928, "L") + " ".concat(
          size * -0.4524, " ").concat(size * -0.6496, "L") + " ".concat(
          size * -0.2668, " ").concat(size * -1.1136)
        }
      };

      return symbols[type][side];
    }
    Registry.setComponent('svg.symbolPath.geo', getGeoSVGSymbol);

    function whiskerSize(d, y, quartileIdx, whiskerIdx, minmaxId, yidx) {
      if (defined(yidx)) {
        return mathAbs(y(d[yidx][1]) - y(d[yidx][0]));
      }
      return y(d[whiskerIdx][minmaxId]) - y(d[quartileIdx][minmaxId]);
    }

    // export function whiskers(type1, size1, type2, size2) {
    //     return `${getSVGsymbol(type1)(size1)} Z ${getSVGsymbol(type2)(size2)}`;
    // }

    function whiskers(symbols) {
      var lastPos = symbols.length - 1,
        whiskerSymbol = '';
      symbols.map(function (d, i) {
        if (i == lastPos) {
          whiskerSymbol += "".concat(getSVGsymbol(d[0])(d[1]));
        } else {
          whiskerSymbol += "".concat(getSVGsymbol(d[0])(d[1]), " Z "); //d[0] = type of the symbol, d[1] = size of the symbol
        }
      });
      return whiskerSymbol;
    }

    function whiskerDouble(w, h, isHorizontal) {
      var hLine = getSVGsymbol('line')(w),
        vLine = getSVGsymbol('vertical-line')(h),
        _replace = function _replace(val) {
          return function () {
            var type = arguments[0][0];
            return type + val;
          };
        };

      if (isHorizontal) {
        var pattern = / (\d)+/g,
          hLine1 = hLine.replace(pattern, _replace(-h / 2)),
          hLine2 = hLine.replace(pattern, _replace(h / 2));

        return "".concat(vLine, " ").concat(hLine1, " ").concat(hLine2);
      } else {
        var _pattern2 = /M(\d)+|L(\d)+/g,
          vLine1 = vLine.replace(_pattern2, _replace(-w / 2)),
          vLine2 = vLine.replace(_pattern2, _replace(w / 2));

        return "".concat(hLine, " ").concat(vLine1, " ").concat(vLine2);
      }
    }

    function getSegmentsForWhisker(size, x, y, h, axisrotated) {
      if (axisrotated) {
        var vLine1 = getSegmentsForSymbol('vertical-line', size, y - h / 2, x),
          hLine = getSegmentsForSymbol('line', h, y, x);
        var vLine2 = getSegmentsForSymbol('vertical-line', size, y + h / 2, x);
        return [vLine1, hLine, vLine2];
      } else {
        var hLine1 = getSegmentsForSymbol('line', size, x, y - h),
          vLine = getSegmentsForSymbol('vertical-line', h, x, y);
        var hLine2 = getSegmentsForSymbol('line', size, x, y + h);
        return [hLine1, vLine, hLine2];
      }
    }

    //

    var cssProperties = {};
    add('fill', 'fill');
    add('fillColor', 'fill'); // TODO: work for html
    add('fillOpacity', 'fill-opacity');
    add('stroke', 'stroke');
    add('strokeColor', 'stroke');
    add('strokeOpacity', 'stroke-opacity');
    add('strokeWidth', 'stroke-width');
    add('dashStyle', 'stroke-dasharray');
    add('lineCap', 'stroke-linecap');
    add('fontColor', { svg: 'fill', html: 'color' });
    add('fontSize', 'font-size', undefined, function (_) {return "".concat(_, "px");});
    add('fontFamily', 'font-family');
    add('fontStyle', 'font-style');
    add('fontWeight', 'font-weight');
    add('text', 'text', 'text');
    add('html', 'html', 'html');
    add('anchor', 'text-anchor', 'attr');
    add('backgroundColor', 'background-color');
    add('background', 'background');
    add('border', 'border');
    add('borderRadius', 'border-radius');
    add('boxShadow', 'box-shadow');
    add('width', 'width');
    add('height', 'height');
    add('opacity', 'opacity');

    function add(name, cssName) {var attrType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'style';var value = arguments.length > 3 ? arguments[3] : undefined;
      cssProperties[name] = { cssName: cssName, attrType: attrType, value: value };
    }

    //

    var customType = ['pattern', 'gradient', 'image'];
    function convertOperatorToProperty(config) {
      if (!isObject(config)) {
        return config;
      }

      var obj = {},
        self = this;
      each(config, function (value, prop) {
        var _;
        if (value && value._type) {
          var a = arrayIncludes(customType, value._type) && convertOperatorToProperty(_objectSpread(_objectSpread({}, value), {}, { _type: null }));
          _ = ALLOWED_CONFIG_OPERATORS.get(value._type).call(self, value, a);
        } else if (isArray$1(value)) {
          _ = value.map(function (_) {return convertOperatorToProperty(_);});
        } else {
          _ = value;
        }
        obj[prop] = _;
      });

      return obj;
    }
    Registry.setComponent('markUtils.convertOperatorToProperty', convertOperatorToProperty);

    //

    var _defaultMarkValue = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      angle: 0,
      radius: 0,
      size: 0,
      points: [],
      fillColor: TRANSPARENT,
      strokeColor: TRANSPARENT
    };

    // props => radius | [radius, borderRadius]
    function getMarkValue(node, args, config, props) {
      var prop = isArray$1(props) ? props[0] : props,
        val = getVal(isArray$1(props) ? props.reduce(function (prev, cur) {return prev || config[cur];}, null) : config[prop], args, node);
      // console.log(node);
      node.zc_cache = node.zc_cache || {};
      if (defined(val)) {
        node.zc_cache[prop] = val;
      }
      // console.log(prop, val, node.zc_cache[prop], getVal(_defaultMarkValue[prop], args, node));
      return pick(val, node.zc_cache[prop], getVal(_defaultMarkValue[prop], args, node));
    }

    //

    function rectMark(config) {
      return {
        config: {
          d: function d(_d2, i) {
            var node = this,
              args = [_d2, i],
              newConfig = config.d ? getMarkValue(node, args, config, 'd') : config,
              isRange = ['x1', 'y1', 'x2', 'y2'].some(function (_) {return defined(newConfig[_]);}),
              _x,
              _y,
              _width,
              _height,
              _radius;

            var propMap = getPropMap(isRange);
            _x = getMarkValue(node, args, newConfig, propMap.x);
            _y = getMarkValue(node, args, newConfig, propMap.y);
            _width = getMarkValue(node, args, newConfig, propMap.width);
            _height = getMarkValue(node, args, newConfig, propMap.height);
            _radius = getMarkValue(node, args, newConfig, ['radius', 'borderRadius']);

            return roundedRect(_x, _y, _width, _height, getBorderRadius(_radius), null, null, isRange);
          }
        },
        depends: {
          d: ['x', 'y', 'width', 'height', 'radius', 'borderRadius', 'x1', 'y1', 'x2', 'y2']
        }
      };
    }

    function getPropMap(isRange) {
      return isRange ? { x: 'x1', y: 'y1', width: 'x2', height: 'y2' } : { x: 'x', y: 'y', width: 'width', height: 'height' };
    }

    //
    /**
     *
     * @param node
     * @return {number[]}
     */

    function getTranslationFromOwnerSVGElement(node) {
      if (node.isD3Selection) {
        node = node.node();
      }

      var ownerSVGElement = node.ownerSVGElement,
        translatedValue = [0, 0];

      while (node !== ownerSVGElement) {
        var translate = getSvgTransform(node).translate;
        translatedValue[0] += translate[0];
        translatedValue[1] += translate[1];
        node = node.parentNode;
      }

      return translatedValue;
    }

    function defined$1(obj) {
      return obj !== undefined && obj !== null;
    }
    /**
     *
     * @param element
     * @returns {{translate: Array, skew: Array, rotate: Number, scale: Array}}
     */
    function getSvgTransform(element) {
      // consolidate the SVGTransformList containing all transformations
      // to a single SVGTransform of type SVG_TRANSFORM_MATRIX and get
      // its SVGMatrix.

      if (element.isD3Selection) {
        element = element.node();
      }

      var baseVal = element.transform.baseVal.consolidate(),
        matrix = defined$1(baseVal) ? baseVal.matrix : null;

      if (defined$1(matrix)) {
        // Below calculations are taken and adapted from the private function
        // https://github.com/d3/d3-interpolate/blob/master/src/transform/decompose.js

        var a = matrix.a,
          b = matrix.b,
          c = matrix.c,
          d = matrix.d,
          e = matrix.e,
          f = matrix.f;

        var scaleX, scaleY, skewX;

        if (scaleX = Math.sqrt(a * a + b * b)) {
          a /= scaleX, b /= scaleX;
        }

        if (skewX = a * c + b * d) {
          c -= a * skewX, d -= b * skewX;
        }

        if (scaleY = Math.sqrt(c * c + d * d)) {
          c /= scaleY, d /= scaleY, skewX /= scaleY;
        }

        if (a * d < b * c) {
          a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        }
        return {
          translate: [e, f],
          skew: [Math.atan2(b, a) * 180 / Math.PI, Math.atan(skewX) * 180 / Math.PI],
          rotate: Math.atan2(b, a) * 180 / Math.PI,
          scale: [scaleX, scaleY]
        };
      }

      return {
        translate: [0, 0],
        skew: [0, 0],
        rotate: 0,
        scale: [0, 0]
      };
    }
    Registry.setComponent('domUtils.getSvgTransform', getSvgTransform);

    function translateString(position, angle) {
      return "translate(".concat(position.join(' '), ")") + (defined$1(angle) ? " rotate(".concat(angle, ")") : '');
    }

    //

    function groupMark(config) {
      return {
        config: {
          transform: function transform(d, i) {
            var node = this,
              args = [d, i],
              _x,
              _y;

            if (config.transform) {var _getMarkValue =
              getMarkValue(node, args, config, 'transform');_x = _getMarkValue.x;_y = _getMarkValue.y;
            } else {
              _x = getMarkValue(node, args, config, 'x');
              _y = getMarkValue(node, args, config, 'y');
            }

            return translateString([_x, _y]);
          }
        },
        depends: {
          transform: ['x', 'y']
        }
      };
    }

    //

    function polygonMark(config) {
      var _config$curve = config.curve,_curve = _config$curve === void 0 ? 'linear' : _config$curve,
        line = d3_line().curve(d3_curves(_curve));
      return {
        config: {
          d: function d(_d3, i) {
            var node = this,
              args = [_d3, i],
              _points;

            if (config.d) {var _getMarkValue2 =
              getMarkValue(node, args, config, 'd');_points = _getMarkValue2.points;
            } else {
              _points = getMarkValue(node, args, config, 'points');
            }

            return line(_points);
          }
        },
        depends: {
          d: ['points', 'curve']
        }
      };
    }

    function updateChartAndPlotBound(chartObj) {
      var legendData = chartObj.systemConf.legend,
        isContinuousLegend = legend_helpers.isContinousLegend(chartObj),
        element = chartObj.legendarea.element.node(),
        floating = defined(legendData.x) && defined(legendData.y),
        legendAlign = getLegendAlignment(legendData),
        isRowView = legendAlign.layout === 'vertical',
        isColumnView = !isRowView,
        left = 0,
        top = 0,
        hAlign = legendAlign.hAlign,vAlign = legendAlign.vAlign,
        width,
        height,
        x,
        y;

      if (isContinuousLegend) {var _bbox =
        bbox(element);width = _bbox.width;height = _bbox.height;x = _bbox.x;y = _bbox.y;
      } else {
        width = element.offsetWidth;height = element.offsetHeight;x = element.offsetLeft;y = element.offsetTop;
      }

      var adjustPlotHeight = function adjustPlotHeight() {
          top = height + legendData.marginTop + legendData.marginBottom;
          chartObj.chartarea.height -= top;
          chartObj.plotarea.height -= top;

          if (legendData.vAlign === 'top') {
            chartObj.chartarea.top += top;
            chartObj.plotarea.top += top;
          }
          chartObj.legendarea.adjust = 'x';
        },
        adjustPlotWidth = function adjustPlotWidth() {
          left = width + legendData.marginLeft + legendData.marginRight;
          chartObj.chartarea.width -= left;
          chartObj.plotarea.width -= left;

          if (legendData.hAlign === 'left') {
            left = width + legendData.marginLeft + legendData.marginRight;
            chartObj.chartarea.left += left;
            chartObj.plotarea.left += left;
          }
          chartObj.legendarea.adjust = 'y';
        };

      if (!floating) {
        if (isColumnView) {
          // ---> direction
          if (vAlign === 'top' || vAlign === 'bottom') {
            adjustPlotHeight();
          } else if (vAlign === 'center') {
            adjustPlotWidth();
          }
        } else if (isRowView) {
          //  direction
          if (hAlign === 'left' || hAlign === 'right') {
            adjustPlotWidth();
          } else if (hAlign === 'center') {
            adjustPlotHeight();
          }
        }
      }

      chartObj.legendarea.x = x;
      chartObj.legendarea.y = y;
      chartObj.legendarea.width = width;
      chartObj.legendarea.height = height;
    }

    function getLegendBound(config, bound) {var customMax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var w = bound.width - config.marginLeft - config.marginRight,
        h = bound.height - config.marginTop - config.marginBottom,
        defaultMax = getDefaultLegendMaxDimension(config),
        maxWidth = perToPx(customMax.maxWidth || config.maxWidth || defaultMax.width, w),
        maxHeight = perToPx(customMax.maxHeight || config.maxHeight || defaultMax.height, h);

      return { maxWidth: maxWidth, maxHeight: maxHeight };
    }

    function getMaxToResize(w, h, bound) {
      w = w || bound.maxWidth;
      h = h || bound.maxHeight;

      return { w: w, h: h };
    }

    //$Id$

    var legutil = function legutil() {};
    legutil.colorpallete = d3_map();

    legutil.colorpallete.set('greenish', [
    '#6c6c6d',
    '#1ba98e',
    '#00ff80',
    '#00ffc0',
    '#00ffff',
    '#40ff00',
    '#40ff40',
    '#40ff80',
    '#40ffc0',
    '#40ffff',
    '#80ff00',
    '#80ff40',
    '#80ff80',
    '#80ffc0',
    '#80ffff']);

    legutil.colorpallete.set('pinkish', [
    '#ff00ff',
    '#ff00c0',
    '#ff0080',
    '#ff0040',
    '#ff0000',
    '#c000ff',
    '#c000c0',
    '#c00080',
    '#c00040',
    '#c00000',
    '#8000ff',
    '#8000c0',
    '#800080',
    '#800040',
    '#800000']);

    legutil.colorpallete.set('countries', ['#00c6e4', '#faa43a', '#5da5da', '#60bd68', '#f17cb0', '#b2912f', '#307d99']);
    legutil.colorpallete.set('saturate5', ['#594f4f', '#547980', '#45ada8', '#97843a', '#518058', '#975156']);
    legutil.colorpallete.set('ocean5', ['#ff7f00', '#6a4a3c', '#cc333f', '#eb6841', '#edc951', '#975156']);
    legutil.colorpallete.set('zoho-reports-old', [
    '#FF465B',
    '#04C36B',
    '#3A92E9',
    '#FDC33A',
    '#D65587',
    '#FC7C63',
    '#51A5A9',
    '#BFBFBF',
    '#91CD6A',
    '#BE9B89',
    '#7D8DB0',
    '#B68E2E',
    '#C6D5B0',
    '#D1ACCE',
    '#E0AE60',
    '#5CD29F',
    '#716398',
    '#AD8686',
    '#FF99A8',
    '#A0C0C0',
    '#2D7094',
    '#553D4E',
    '#B2449D',
    '#FED577',
    '#D3D159',
    '#AAAAAA',
    '#7ED9D9',
    '#F7A26D',
    '#8ABFA2',
    '#767676',
    '#E36068',
    '#A3AFC7']);

    legutil.colorpallete.set('zoho-reports-new', [
    '#60bfdf',
    '#ffa060',
    '#aadf80',
    '#ff6c7d',
    '#c9ac66',
    '#bf80bf',
    '#df6060',
    '#606060',
    '#60a0df',
    '#ff99a8',
    '#feff60',
    '#a0dfdf',
    '#dfa080',
    '#dfdfdf',
    '#a0a060',
    '#a080bf',
    '#a06060',
    '#5cd29f',
    '#ffbe60',
    '#bfa080',
    '#f28fb5',
    '#8080bf',
    '#bfbfbf',
    '#dfdf80',
    '#80a060',
    '#80a060',
    '#a08060',
    '#7ed9d9',
    '#be9b89',
    '#bf6060',
    '#a0bf60',
    '#fc7c63']);

    legutil.colorpallete.set('colors', ['#0eaadd', '#1ac9bb', '#92c658', '#dbbe56', '#ee7d54', '#ef4f6a', '#b952ef']);
    legutil.colorpallete.set('flat-ui-colors', [
    '#23a96e',
    '#bca634',
    '#f75a51',
    '#39b6c5',
    '#f9ce8d',
    '#983a67',
    '#634c3f',
    '#d7dab9',
    '#357180',
    '#983a67',
    '#b16b76',
    '#7f90a0']);

    legutil.colorpallete.set('MEMobile', [
    '#73c2f4',
    '#ecd543',
    '#e6be3f',
    '#da7b36',
    '#c84b37',
    '#9c240f',
    '#9bcedd',
    '#ffe560',
    '#ffe560',
    '#c67c99',
    '#c6db4c']);

    legutil.colorpallete.set('Toddler', [
    '#f8d0db',
    '#9be1ed',
    '#c4ead1',
    '#fbe2aa',
    '#e5e5e5',
    '#d6b65f',
    '#be9fbf',
    '#ffe560',
    '#ffe560',
    '#c67c99',
    '#c6db4c']);

    legutil.colorpallete.set('BrightNDull', [
    '#47bac1',
    '#8ccace',
    '#72c3f5',
    '#71bfee',
    '#ac66ad',
    '#c5a0c6',
    '#906aa6',
    '#b29dbf',
    '#fd9f94',
    '#f6cac4',
    '#ff759c',
    '#f6acc1']);

    legutil.colorpallete.set('BlueShades', ['#00c6e4', '#6ad4e4', '#a3dbe4', '#c3e0e4', '#e4e4e4', '#c8c8c8', '#aac4c8']);
    legutil.colorpallete.set('graphite6', ['#595959', '#767676', '#373737', '#9d9d9d', '#bfbfbf', '#222222']);
    legutil.colorpallete.set('chalk', ['#FFFFFF', '#FAFAFA', '#CCCCCC']);
    legutil.colorpallete.set('map', ['#FB0D0D', '#53B808', '#B80894', '#2ADBDD']);

    legutil.patternPallete = d3_map();
    legutil.imagePallete = d3_map();

    legutil.imagePallete.set('linesndots', [
    '01.png',
    '02.png',
    '03.png',
    '04.png',
    '05.png',
    '06.png',
    '07.png',
    '08.png',
    '09.png',
    '10.png',
    '11.png',
    '12.png',
    '13.png',
    '14.png',
    '15.png',
    '16.png',
    '17.png',
    '18.png',
    '19.png',
    '20.png']);


    legutil.imagePallete.set('dotsfirst', ['13.png', '12.png', '13.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '20.png']);

    legutil.imagePallete.set('stones', ['01.jpg', '02.jpg', '03.jpg']);

    generateDefaultPatternTheme();
    legutil.patternPallete.set('stripes-fill', [
    'hatchfill',
    'hatchDashfill',
    'checkerBoard',
    'horizontalStripesfill',
    'verticalStripesfill',
    'crossStripesfill']);

    legutil.patternPallete.set('stripes', [
    'hatch',
    'thinThickHatch',
    'hatchLeft',
    'hatchDash',
    'horizontalStripes',
    'crossStripes',
    'verticalStripes',
    'thickHatch',
    'thinHatch',
    'thinVerticalStripes',
    'thinHorizontalStripes']);

    legutil.patternPallete.set('dotted', ['circle', 'tinyCircle', 'crossCircle', 'floatingCircle', 'dot']);
    legutil.patternPallete.set('dotted-fill', ['circlefill', 'crossCirclefill', 'floatingCirclefill', 'dotfill']);
    legutil.patternPallete.set('shapes', ['thinThickHatch', 'crossCircle', 'star', 'wave', 'cap', 'nylon']);
    legutil.patternPallete.set('shapes-fill', [
    'checkerBoard',
    'floatingCirclefill',
    'squarefill',
    'starfill',
    'wavefill',
    'capfill',
    'nylonfill']);


    var setLegendColorPallete = function setLegendColorPallete(name, value) {
      legutil.colorpallete.set(name, value);
    };

    var getLegendColorPallete = function getLegendColorPallete(name) {
      return legutil.colorpallete.get(name);
    };

    var setLegendPatternPallete = function setLegendPatternPallete(name, value) {
      legutil.patternPallete.set(name, value);
    };

    var getLegendPatternPallete = function getLegendPatternPallete(name) {
      return legutil.patternPallete.get(name);
    };

    var setLegendImagePallete = function setLegendImagePallete(name, value) {
      legutil.imagePallete.set(name, value);
    };

    var getLegendImagePallete = function getLegendImagePallete(name) {
      return legutil.imagePallete.get(name);
    };

    // $ZC.legutil.patternPallete.set("stripes", ["Default00001.png", "Default00002.png", "Default00003.png", "Default00004.png", "Default00005.png", "Default00006.png", "Default00007.png", "Default00008.png",
    //     "Default00009.png", "Default00010.png", "Default00011.png", "Default00012.png", "Default00013.png", "Default00014.png", "Default00015.png", "Default00016.png",
    //     "Default00017.png", "Default00018.png", "Default00019.png", "Default00020.png", "Default00021.png", "Default00022.png"
    // ]);
    //append relative pattern filepath
    appendFilePath();

    legutil.getMonochromeColorPallette = function (conf) {
      var domain = [0, +conf.count - 1],
        range = [+conf.colorGamma[0], +conf.colorGamma[1]];
      var monoClrGen = getMonochromeColor(conf.baseColor, domain, range);
      return d3_range(conf.count).map(function (d, i) {
        return monoClrGen(i);
      });
    };

    function appendFilePath() {
      legutil.imagePallete.each(function (value, pallete) {
        var arr = value.map(function (d, i) {
          return _imageFilePath + d;
        });
        legutil.imagePallete.set(pallete, arr);
      });
    }

    /**
     *
     * @param {{width:number, height:number, left: number, top: number}} area
     * @param chartObj
     * @param considerMargin
     * @return {{x: number, y: number}}
     */
    function getLegendPosition(area, chartObj, considerMargin, element, legendConfig) {
      var isSingleLayout = chartObj.legend.isSingleLayout; //Remove
      element = element || chartObj.legendarea.element;
      legendConfig = legendConfig || chartObj.systemConf.legend;

      var legNode = element.node(),
        alignment = getLegendAlignment(legendConfig),
        left = 0,
        top = 0,
        getMargin = function getMargin(side) {
          if (considerMargin === false) {
            return 0;
          }
          return +legendConfig[side];
        },
        isContinuousLegend = isSvgElement(legNode),
        legendBBox = isContinuousLegend ? bbox(legNode) : legNode.getBoundingClientRect(),
        legendWidth = legendBBox.width,
        legendHeight = legendBBox.height,
        floating = alignment.floating,
        canvasArea = chartObj.canvasarea,_getLegendBound =
        getLegendBound(legendConfig, chartObj.chartarea),maxWidth = _getLegendBound.maxWidth,maxHeight = _getLegendBound.maxHeight;

      if (!isContinuousLegend) {
        legendBBox.x = 0;
        legendBBox.y = 0;
      }

      if (floating) {
        left = legendConfig.x - legendBBox.x;
        top = legendConfig.y - legendBBox.y;

        left = mathMin(canvasArea.width - mathMin(legendBBox.width, maxWidth), left);
        top = mathMin(canvasArea.height - mathMin(legendBBox.height, maxHeight), top);

        return [left, top];
      }

      switch (alignment.hAlign) {
        case 'left':{
            left = area.left + getMargin('marginLeft') - legendBBox.x;
            break;
          }
        case 'center':{
            left = area.width / 2 - legendWidth / 2 - legendBBox.x;
            break;
          }
        case 'right':{
            // TODO #ZC1506
            var l = isContinuousLegend || !isSingleLayout ? area.left : 0;
            left = l + area.width - legendWidth - getMargin('marginRight') - legendBBox.x;
            break;
          }}


      switch (alignment.vAlign) {
        case 'top':{
            top = area.top + getMargin('marginTop') - legendBBox.y;
            break;
          }
        case 'center':{
            top = area.top + area.height / 2 - legendHeight / 2 - (!isSingleLayout ? legendBBox.y : 0);
            break;
          }
        case 'bottom':{
            top = area.top + area.height - legendHeight - getMargin('marginBottom') - legendBBox.y;
          }}


      return [left, top, legendWidth, legendHeight];
    }

    function getLegendShowAsText(d, i, options, chartObj) {
      var showAs = options.showAs,
        seriesPos = 0,
        itemPos = i;

      if (chartObj.isAxisCategory || chartObj.isNonAxisMultiSeriesCategory || chartObj.isGeoMap) {
        seriesPos = i;
        itemPos = 0;
      }

      // added function support in showAs
      if (showAs) {
        showAs = invokeFunction(showAs, d, i, chartObj);
        return chartObj.dataset.getCustomizedVal(chartObj, showAs, seriesPos, 0, itemPos, d, 'legend');
      }
    }

    //$Id$

    var getClr = legend_helpers.getClr,
      isDisabled = legend_helpers.isDisabled,
      hexToRGB = legend_helpers.hexToRGB;

    legend.setColorBoxBackground = function (elements, chartObj, states, order) {
      var legendOptions =
        order > 1 && chartObj.systemConf.legend.color ? chartObj.systemConf.legend.color[order] : chartObj.systemConf.legend,
        colorBoxOptions = legendOptions.colorBox,
        disabledOptions = getDisabledOptions(legendOptions, 'clr'),
        disabledColorBoxOptions = disabledOptions.colorBox || {},
        //current Pallete priority
        //imagePallete > patternPallete > colors
        imagePallete = legendOptions.imagePallete ? legutil.imagePallete.get(legendOptions.imagePallete) : null,
        useImagePallete = chartObj.imagePallete && defined(imagePallete) && imagePallete.length > 0,
        patternPallete = chartObj.patternPallete,
        patternPalleteLength = patternPallete && patternPallete.length,
        useSVGImage = !chartObj.patternPallete && (defined(legendOptions.shapes) || colorBoxOptions.shape !== 'square'),
        effect = getChartEffect(legendOptions, chartObj),
        grayScale = disabledColorBoxOptions.grayScale,
        fontSize = +utils.getVal(legendOptions.fontSize || chartObj.systemConf.canvas.fontSize),
        colorBoxSize = legend_helpers.getFilterBoxSize(colorBoxOptions, fontSize),
        colorBoxWidth = colorBoxSize[0],
        colorBoxHeight = colorBoxSize[1],
        background,
        backgroundColor,
        borderRadius = colorBoxOptions.borderRadius,
        backgroundSizeArray = [],
        _clr = function _clr(d, i, _default, order) {
          var _ = getClr(_disabled(d), pick(_default, getColorByIndex(chartObj, i, null, order)), disabledOptions);
          if ($Browser.IE && grayScale && _disabled(d)) {
            _ = getGrayScaleColor(_);
          }
          return _;
        },
        _disabled = function _disabled(d) {return isDisabled(d, states.allSelected, states.isFirstClickAfterDeselection);},
        _borderColor = function _borderColor(d, i) {return _clr(d, i, colorBoxOptions.strokeColor, order);},
        _background = function _background(d, i) {
          var disabled = _disabled(d);
          var backgroundSize = null;

          backgroundColor = _clr(d, i, colorBoxOptions.fillColor, order);

          if (useImagePallete) {
            if (disabled && disabledOptions.color) {
              background = disabledOptions.color;
            } else {
              background = "url(\"".concat(imagePallete[i % imagePallete.length], "\")");
              var patternSize = chartObj.patternImageSizes && chartObj.patternImageSizes;
              backgroundSize = patternSize[i] ? "".concat(
              patternSize[i % patternSize.length][0] + PX, " ").concat(patternSize[i % patternSize.length][1]).concat(PX) :
              null;
            }
          } else if (useSVGImage) {
            background = getsvgImage(colorBoxWidth, colorBoxHeight, _borderColor(d, i), backgroundColor, chartObj, i, disabled);
          } else if (patternPalleteLength) {
            var svgPattern = patternPallete[i % patternPalleteLength];
            var prop = patternThemes[svgPattern] ? getPattern(svgPattern) : addPatternThemeByEle(svgPattern);
            prop.bgClr_base = backgroundColor;
            prop.stroke_base = backgroundColor;
            prop.width = colorBoxWidth;
            prop.customStaticClr = disabled ? disabledOptions.patternColor : chartObj.userdata.legend.customPatternColor;
            prop.x = prop.y = 0;
            var patternID = "zp".concat(generateIdByPropValue(prop, 'legelegendndFill'));
            var p = effects.svg_patterns.svgPatternFill(
            prop,
            patternID,
            null,
            true,
            true,
            chartObj,
            chartObj.getPatternSvg(),
            'objectBoundingBox');

            var patternWidth = p.width,
              patternHeight = p.height;
            background = "url(\"".concat(p.url, "\")");
            backgroundSize = "".concat((patternWidth * 2 < colorBoxWidth ? patternWidth : colorBoxWidth / 2) + PX, " ").concat(
            patternHeight * 2 < colorBoxHeight ? patternHeight : colorBoxHeight / 2).concat(
            PX);
          } else {
            background = backgroundColor;
          }

          if (isImageUrl(background)) {
            backgroundSize = backgroundSize || "".concat(colorBoxWidth + PX, " ").concat(colorBoxHeight).concat(PX);
            if (disabled && grayScale && $Browser.IE) {
              var dim = backgroundSize.split('px').map(function (d) {return +d;});
              background = setGrayScaleForIE(background, dim[0], dim[1]);
            }
          }

          backgroundSizeArray[i] = backgroundSize;

          return background;
        },
        _styles = {
          opacity: function opacity(d) {return _disabled(d) ? disabledColorBoxOptions.fillOpacity : null;},
          filter: function filter(d) {
            var _effects = [];
            _effects.push(_disabled(d) && grayScale && !$Browser.IE ? 'grayscale(1)' : null);
            _effects.push(effect);
            _effects = _effects.filter(function (_) {return !!_;});
            return _effects.length ? _effects.join(' ') : null;
          },
          'border-radius': !useSVGImage && defined(borderRadius) ? borderRadius + PX : null,
          color: function color(d) {return _disabled(d) ? disabledColorBoxOptions.fontColor : colorBoxOptions.fontColor || 'white';},
          border: function border(d, i) {return useImagePallete || useSVGImage ? null : "".concat(colorBoxOptions.strokeWidth + PX, "solid ").concat(_borderColor(d, i));},
          background: _background,
          'background-size': function backgroundSize(d, i) {return backgroundSizeArray[i];}
        },
        _html = function _html(d) {return _disabled(d) ? disabledColorBoxOptions.text || '' : colorBoxOptions.text;};

      if (elements) {
        elements.styles(_styles).html(_html);
      } else {
        return {
          styles: _styles,
          html: _html
        };
      }
    };

    function getsvgImage(width, height, strokeColor, fillColor, chartObj, index, disabled) {
      //SVG data uri as div background
      strokeColor = hexToRGB(strokeColor);
      fillColor = hexToRGB(fillColor);
      var legendOptions = chartObj.systemConf.legend,
        colorBoxOptions = legendOptions.colorBox,
        symbolsArray = legendOptions.shapes,
        symbol = (symbolsArray ? symbolsArray[index % symbolsArray.length] : null) || colorBoxOptions.shape;

      var elements =
      !symbol &&
      legend.getHTML4ChartTypeSymbol &&
      !(colorscale_helpers.isQuantileColorScale(chartObj) && chartObj.dataObject.isCombinationalChart) ?
      legend.getHTML4ChartTypeSymbol(width, height, fillColor, chartObj, index, disabled) :
      getHTML4SVGSymbol(width, height, strokeColor, fillColor, symbol, colorBoxOptions);
      if (isImageUrl(elements)) {
        return "url(\"".concat(elements, "\")");
      }
      return getSVGSymbolString(elements, width, height);
    }

    function isImageUrl(str) {
      return str && !(str[0] === '<' || str.indexOf('url("data') === 0);
    }

    function setGrayScaleForIE(src, w, h) {
      // www.majas-lapu-izstrade.lv/cross-browser-grayscale-image-example-using-css3-js/
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      canvas.width = w;
      canvas.height = h;

      var imgObj = new Image();
      imgObj.src = src.substring(5, src.length - 2); // (e.g): src = url("<<URL>>")
      imgObj.width = w;
      imgObj.height = h;

      imgObj.onload = function () {
        ctx.drawImage(imgObj, 0, 0, w, h);
        var imgPixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
        for (var y = 0; y < imgPixels.height; y++) {
          for (var x = 0; x < imgPixels.width; x++) {
            var i = y * 4 * imgPixels.width + x * 4;
            var avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
            imgPixels.data[i] = avg;
            imgPixels.data[i + 1] = avg;
            imgPixels.data[i + 2] = avg;
          }
        }
        ctx.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);
        return "url(".concat(canvas.toDataURL(), ")");
      };
    }

    /**
     *
     * @param width
     * @param height
     * @param strokeColor
     * @param fillColor
     * @param symbol
     * @param colorBoxOptions
     * @return {string}
     */
    function getHTML4SVGSymbol(width, height, strokeColor, fillColor, symbol, colorBoxOptions, dontScale) {
      var _colorBoxOptions$fill = colorBoxOptions.fillOpacity,fillOpacity = _colorBoxOptions$fill === void 0 ? 1 : _colorBoxOptions$fill,_colorBoxOptions$stro = colorBoxOptions.strokeOpacity,strokeOpacity = _colorBoxOptions$stro === void 0 ? 1 : _colorBoxOptions$stro,strokeWidth = colorBoxOptions.strokeWidth,_colorBoxOptions$padd = colorBoxOptions.padding,padding = _colorBoxOptions$padd === void 0 ? 0 : _colorBoxOptions$padd,borderRadius = colorBoxOptions.borderRadius,
        size_w = dontScale ? mathMax(width - padding * 2, 1) : 10,
        size_h = dontScale ? mathMax(height - padding * 2, 1) : 10,
        _wF = mathMax(width - padding * 2, 1) / (size_w + 2 * validateNullVal(strokeWidth, 1)),
        _hF = mathMax(height - padding * 2, 1) / (size_h + 2 * validateNullVal(strokeWidth, 1)),
        symbolpath = getSVGsymbol(symbol || 'square')(size_w, size_h, borderRadius),
        hexToRGB = legend_helpers.hexToRGB;

      return "<path d='".concat(symbolpath, "' transform='translate(").concat(width / 2, ",").concat(height / 2, ") scale(").concat(_wF, ",").concat(_hF, ")' style='stroke: ").concat(hexToRGB(
      strokeColor), "; fill: ").concat(
      hexToRGB(fillColor), "; fill-opacity: ").concat(fillOpacity, "; stroke-width: ").concat(validateNullVal(
      strokeWidth,
      1), "px; stroke-opacity: ").concat(
      strokeOpacity, ";'></path>");
    }

    /**
     *
     * @param pathString
     * @param width
     * @param height
     * @return {string}
     */
    function getSVGSymbolString(pathString, width, height) {
      var xml = "<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='".concat(width, "' height='").concat(height, "'>");
      xml += pathString;
      xml += ' </svg>';
      return "".concat('url("' + 'data:image/svg+xml;').concat($Browser.IE ? 'base64' : 'utf8', ",").concat($Browser.IE ? btoa(xml) : xml, "\")");
    }

    /**
     *
     * @param vAlign
     * @param labelHeight
     * @param colorBoxHeight
     * @param fontSize
     * @param colorBoxSize
     * @param textOverflow
     * @return {number}
     */
    function getColorBoxVerticalPosition(vAlign, labelHeight, colorBoxHeight, fontSize, colorBoxSize, textOverflow) {
      var textHangingGap = ~~(fontSize * 1.195 - fontSize);
      var margin_top = 0;

      switch (vAlign) {
        case 'top':{
            margin_top = textHangingGap;
            break;
          }
        case 'bottom':{
            margin_top = labelHeight - colorBoxHeight - textHangingGap;
            break;
          }
        default:{
            if (vAlign === 'center' && textOverflow !== 'wrap') {
              margin_top = (mathMax(labelHeight, colorBoxHeight) - colorBoxHeight) / 2;
            } else if (defined(colorBoxSize) || textOverflow === 'wrap') {
              margin_top = (mathMax(fontSize, colorBoxHeight) - colorBoxHeight) / 2;
            } else if (labelHeight > colorBoxHeight) {
              margin_top = (labelHeight - colorBoxHeight) / 2;
            }
          }}

      return margin_top;
    }

    //

    function divMark(config) {
      var _config$shape = config.shape,shape = _config$shape === void 0 ? 'square' : _config$shape,
        useSVGImage = shape !== 'square' && shape !== 'rect';
      return {
        config: {
          background: useSVGImage ?
          function (d, i) {
            var node = this,
              args = [d, i],
              _width = getMarkValue(node, args, config, 'width'),
              _height = getMarkValue(node, args, config, 'height'),
              _strokeColor = getMarkValue(node, args, config, 'strokeColor'),
              _fillColor = getMarkValue(node, args, config, 'fillColor'),
              _shape = getMarkValue(node, args, config, 'shape');

            return getSVGSymbolString(
            getHTML4SVGSymbol(_width, _height, _strokeColor, _fillColor, _shape, config, true),
            _width,
            _height);

          } :
          function (d, i) {
            var node = this,
              args = [d, i],
              _fillColor = getMarkValue(node, args, config, 'fillColor');
            return _fillColor;
          },
          borderRadius: useSVGImage ?
          null :
          function (d, i) {
            var node = this,
              args = [d, i];
            return "".concat(getMarkValue(node, args, config, ['radius', 'borderRadius']), "px");
          },
          border: useSVGImage ?
          'none' :
          function (d, i) {
            var node = this,
              args = [d, i],
              _strokeWidth = getMarkValue(node, args, config, 'strokeWidth'),
              _strokeColor = getMarkValue(node, args, config, 'strokeColor');
            return "".concat(pick(_strokeWidth, 1), "px solid ").concat(_strokeColor); // TODO: dashStyle can be applied
          },
          width: function width(d, i) {
            var node = this,
              args = [d, i],
              _width = getMarkValue(node, args, config, 'width');
            return "".concat(_width, "px");
          },
          height: function height(d, i) {
            var node = this,
              args = [d, i],
              _height = getMarkValue(node, args, config, 'height');
            return "".concat(_height, "px");
          }
        },
        depends: {
          background: useSVGImage ? ['width', 'height', 'strokeColor', 'fillColor', 'shape'] : ['fillColor'],
          borderRadius: useSVGImage ? [] : ['radius', 'borderRadius'],
          border: useSVGImage ? [] : ['strokeWidth', 'strokeColor'],
          width: ['width'],
          height: ['height']
        }
      };
    }

    //

    function pointMark(config) {
      return {
        config: {
          d: function d(_d4, i) {
            var node = this,
              args = [_d4, i],
              _shape,
              _size;

            if (config.d) {var _getMarkValue3 =
              getMarkValue(node, args, config, 'd');_shape = _getMarkValue3.shape;_size = _getMarkValue3.size;
            } else {
              _shape = getMarkValue(node, args, config, 'shape');
              _size = getMarkValue(node, args, config, 'size');
            }

            return getSVGsymbol(_shape).apply(void 0, _toConsumableArray(splat(_size)));
          },
          transform: function transform(d, i) {
            var node = this,
              args = [d, i],
              _x,
              _y,
              _angle;

            if (config.transform) {var _getMarkValue4 =
              getMarkValue(node, args, config, 'transform');_x = _getMarkValue4.x;_y = _getMarkValue4.y;_angle = _getMarkValue4.angle;
            } else {
              _x = getMarkValue(node, args, config, 'x');
              _y = getMarkValue(node, args, config, 'y');
              _angle = getMarkValue(node, args, config, 'angle');
            }

            return translateString([_x, _y], _angle);
          }
        },
        depends: {
          d: ['shape', 'size'],
          transform: ['x', 'y', 'angle']
        }
      };
    }

    //

    var customMarkMap = {
      _rect: rectMark,
      _div: divMark,
      group: groupMark,
      point: pointMark,
      polygon: polygonMark
    };

    //

    function parseMarkConfig(mark, config, obj, morph) {
      config = convertOperatorToProperty.call(obj, config);

      if (!customMarkMap[mark]) {
        return _objectSpread(_objectSpread({}, config), morpheConfig(config));
      }

      var parsed = customMarkMap[mark](config),
        o = {},
        parsedConfig = {},
        keys = Object.keys(parsed.depends),
        _delete = d3_merge(objectValues(parsed.depends)).filter(function (_) {return !arrayIncludes(keys, _);});

      each(config, function (value, prop) {
        if (!arrayIncludes(_delete, prop)) {
          o[prop] = value;
        }
      });

      // Check for atleast one config or shorthand config
      each(parsed.config, function (value, prop) {
        if (defined(config[prop]) || parsed.depends[prop].some(function (_) {return defined(config[_]);})) {
          parsedConfig[prop] = value;
        }
      });

      return morph ? _objectSpread(_objectSpread({}, o), parsedConfig) : _objectSpread(_objectSpread(_objectSpread({}, o), parsedConfig), morpheConfig(config));
    }

    function morpheConfig(config) {
      var strokeWidth = config.strokeWidth,lineCap = config.lineCap,dashStyle = config.dashStyle,_title2 = config.tooltip;

      // Dash style
      strokeWidth = pick(strokeWidth, 1);
      lineCap = getLineCap(lineCap, dashStyle);
      dashStyle = getDashArray(dashStyle, strokeWidth);
      _title2 = function title() {
        return _title2 ? this.textContent : NULL;
      };

      return { strokeWidth: strokeWidth, lineCap: lineCap, dashStyle: dashStyle, title: _title2 };
    }
    Registry.setComponent('markUtils.customMark', parseMarkConfig);

    //

    function paintDom(properties, ele) {
      if (ele.empty()) {
        return;
      }

      each(properties, function (value, prop) {
        if (prop === 'styles') {
          value = propertiesToStyles(value);
          if (isSvgElement(ele)) {
            value = enhanceStyles(value);
          }
        }

        // if (isObject(value)) {
        //     var a = prop.substr(0, prop.length - 1);
        //     for (var attr in value) {
        //         ele[a](attr, value[attr]);
        //     }
        // } else {
        //     ele[prop](value);
        // }
        ele[prop](value);
      });
    }

    function paintDomByConfig(obj, ele, cache, morph) {
      var mark = obj.mark,config = obj.config,
        output = {};

      if (ele.empty() || !config) {
        return;
      }

      config = parseMarkConfig(mark, config, cache, morph);
      var keys = customMarkMap[mark] ? Object.keys(customMarkMap[mark](config).depends) : [];

      each(config, function (value, prop) {
        var _ref2 = cssProperties[prop] || {},_ref2$attrType = _ref2.attrType,attrType = _ref2$attrType === void 0 ? 'attr' : _ref2$attrType,_ref2$cssName = _ref2.cssName,cssName = _ref2$cssName === void 0 ? prop : _ref2$cssName,valueFunction = _ref2.value,
          _value = valueFunction ?
          function (d, i) {
            return valueFunction(getVal(value, [d, i], this));
          } :
          value;

        if (attrType === 'attr' || attrType === 'style') {
          if (isObject(cssName)) {
            cssName = isSvgElement(ele) ? cssName.svg : cssName.html;
          }
          output["".concat(attrType, "s")] = output["".concat(attrType, "s")] || {};
          output["".concat(attrType, "s")][cssName] = _value;
        } else {
          output[attrType] = _value;
        }

        ele.each(function (d, i) {
          var node = this;
          if (node.zc_cache) {
            if (!arrayIncludes(keys, prop)) {
              node.zc_cache[prop] = _value;
            }
          }
        });
      });

      for (var _attr2 in output) {
        ele[_attr2](output[_attr2]);
      }
    }

    function propertiesToStyles(properties) {
      var styles = {};
      each(properties, function (value, prop) {return styles[svgStyles[prop] || prop] = value;});
      return styles;
    }

    function enhanceStyles(styles) {
      styles['stroke-width'] = pick(styles['stroke-width'], 1);
      styles['stroke-linecap'] = getLineCap(styles['stroke-linecap'], styles['stroke-dasharray']);
      styles['stroke-dasharray'] = getDashArray(styles['stroke-dasharray'], styles['stroke-width']);

      return styles;
    }

    var svgStyles = {
      //Fill styles
      fillColor: 'fill',
      fillOpacity: 'fill-opacity',
      //Stroke styles
      strokeColor: 'stroke',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      lineCap: 'stroke-linecap',
      dashStyle: 'stroke-dasharray'
    };

    //

    function animeDom(config, parser, element, cache, mark, _final) {
      if (element.empty() || !config) {
        return;
      }

      config = splat(config);
      var args = { arr: config, i: 0, element: element, cache: cache, mark: mark, parser: parser };
      d3ChainAnimation(args.arr, args, _final);

      // let terminator = (_, i) => {
      //         if (_.i >= config.length || i === config.length - 1) {
      //             final && final();
      //             // invokeFunction(parser.onEnd, element, parser);
      //             return true;
      //         }
      //     },
      //     onEnd = (_) => _.i++;
      // chainPromise({ args, terminator, onEnd, callback: simpleAnime });
    }

    function d3ChainAnimation(config, args, onEnd) {
      var element = args.element,cache = args.cache,mark = args.mark,parser = args.parser,
        transition;

      config.forEach(function (_, i) {
        if (isFunction(_)) {
          if (transition) {
            transition.on('end', function () {return _(element, transition);});
          } else {
            _(element, transition);
          }
        } else if (isArray$1(_)) {
          if (transition) {
            transition.on('end', function () {return syncAnimation(_, args);});
          } else {
            syncAnimation(_, args);
          }
        } else {
          var _getConfigStops2 = getConfigStops(_),from = _getConfigStops2.from,to = _getConfigStops2.to,interpolate = _getConfigStops2.interpolate,property = _getConfigStops2.property,_d3AnimeConfig2 =
            d3AnimeConfig(_, parser),duration = _d3AnimeConfig2.duration,delay = _d3AnimeConfig2.delay,easing = _d3AnimeConfig2.easing,transitionName = _d3AnimeConfig2.transition;

          applyConfig(transition || element, from, cache, mark);
          applyProperties(transition || element, property.from);

          transition = (transition || element).transition(transitionName);
          if (!defined(transitionName)) {
            transition.
            duration(duration).
            delay(delay).
            ease(d3_ease(easing));
          }
          applyConfig(transition, to, cache, mark);
          applyProperties(transition, property.to);

          if (!isEmptyObject$1(interpolate)) {
            tween(transition, interpolate, cache, mark);
          }

          if (i === config.length - 1) {
            transition.on('end', onEnd);
          }
        }
      });
    }

    function syncAnimation(config, args) {
      var element = args.element,cache = args.cache,mark = args.mark,parser = args.parser,
        node = element.node();

      if (element.empty()) {
        return;
      }

      config.forEach(function (_) {
        var _getConfigStops3 = getConfigStops(_),from = _getConfigStops3.from,to = _getConfigStops3.to,interpolate = _getConfigStops3.interpolate,_d3AnimeConfig3 =
          d3AnimeConfig(_, parser),duration = _d3AnimeConfig3.duration,delay = _d3AnimeConfig3.delay,easing = _d3AnimeConfig3.easing,transitionName = _d3AnimeConfig3.transition,
          a1 = {};

        each(to, function (value, prop) {
          a1[prop] = pick(from[prop], node.zc_cache[prop], _defaultMarkValue[prop]);
        });

        var _from = parseMarkConfig(mark, a1, cache, true),
          _to = parseMarkConfig(mark, to, cache, true);

        var transition = d3_select({}).transition(transitionName);
        if (!defined(transitionName)) {
          transition.
          duration(duration).
          delay(delay).
          ease(d3_ease(easing));
        }
        transition.tween('style', function (d, i) {
          var _i = {};

          each(_to, function (value, prop) {
            var _ref3 = cssProperties[prop] || {},_ref3$attrType = _ref3.attrType,attrType = _ref3$attrType === void 0 ? 'attr' : _ref3$attrType,_ref3$cssName = _ref3.cssName,cssName = _ref3$cssName === void 0 ? prop : _ref3$cssName,valueFunction = _ref3.value,
              _value = function _value(_) {return valueFunction ? valueFunction(getVal(_, [d, i], node)) : getVal(_, [d, i], node);};
            _i[prop] = d3_interpolate(_value(_from[prop]), _value(value));
          });
          return function (t) {
            each(_to, function (value, prop) {
              var _ref4 = cssProperties[prop] || {},_ref4$attrType = _ref4.attrType,attrType = _ref4$attrType === void 0 ? 'attr' : _ref4$attrType,_ref4$cssName = _ref4.cssName,cssName = _ref4$cssName === void 0 ? prop : _ref4$cssName,valueFunction = _ref4.value;

              if (attrType === 'attr' || attrType === 'style') {
                element[attrType](cssName, _i[prop](t));
              } else {
                element[attrType](_i(t));
              }
            });
          };
        });
      });
    }

    function getConfigStops(_) {
      var _from = {},
        _to = {},
        _interpolate = {},
        _property = { from: {}, to: {} },
        _default = ['duration', 'delay', 'easing', 'transition'];

      for (var _attr4 in _) {
        if (_.hasOwnProperty(_attr4)) {
          var cur = _[_attr4];
          if (!arrayIncludes(_default, _attr4)) {
            var property = cur.property,from = cur.from,to = cur.to,_interpolator = cur.interpolator;
            if (property && cur.hasOwnProperty('property')) {
              from !== undefined && (_property.from[_attr4] = [property, from]);
              _property.to[_attr4] = [property, to];
            } else {
              if (!_interpolator) {
                from !== undefined && (_from[_attr4] = from);
                _to[_attr4] = to !== undefined ? to : cur;
              }
              _interpolate[_attr4] = cur;
            }
          }
        }
      }
      return { from: _from, to: _to, interpolate: _interpolate, property: _property };
    }

    function applyConfig(element, config, cache, mark) {
      if (!config || isEmptyObject$1(config)) {
        return;
      }
      paintDomByConfig({ mark: mark, config: config }, element, cache, true);
    }

    function applyProperties(element, property) {
      if (!property || isEmptyObject$1(property)) {
        return;
      }
      for (var attr in property) {
        var cur = property[attr];
        element[cur[0]](attr, cur[1]);
      }
    }

    function isEmptyObject$1(obj) {
      for (var name in obj) {
        return false;
      }
      return true;
    }

    function tween(ele, config, cache, mark) {
      if (ele.empty() || !config) {
        return;
      }

      var from = {},
        to = {},
        interpolator = {};
      for (var _attr6 in config) {
        if (config[_attr6].from !== undefined) {
          from[_attr6] = config[_attr6].from;
        }
        if (config[_attr6].to !== undefined) {
          to[_attr6] = config[_attr6].to;
        } else {
          to[_attr6] = config[_attr6];
        }
        if (config[_attr6].interpolator !== undefined) {
          interpolator[_attr6] = config[_attr6].interpolator;
        }
      }

      if (isEmptyObject$1(interpolator)) {
        return;
      }

      var _from = parseMarkConfig(mark, from, cache, true),
        _to = parseMarkConfig(mark, to, cache, true);

      each(_to, function (value, prop) {
        var _ref5 = cssProperties[prop] || {},_ref5$attrType = _ref5.attrType,attrType = _ref5$attrType === void 0 ? 'attr' : _ref5$attrType,_ref5$cssName = _ref5.cssName,cssName = _ref5$cssName === void 0 ? prop : _ref5$cssName,valueFunction = _ref5.value;
        // _value = valueFunction
        //     ? function(d, i) {
        //           return valueFunction(getVal(value, [d, i], this));
        //       }
        //     : value;
        //
        ele["".concat(attrType, "Tween")](prop, function tween(d, i, j) {
          var a1 = {};
          var node = this;
          each(to, function (value, prop) {
            a1[prop] = (interpolator[prop] || d3_interpolate)(pick(from[prop], node.zc_cache[prop], _defaultMarkValue[prop]), value);
          });

          return function (t) {
            var a = {};
            each(a1, function (value, prop) {
              a[prop] = a1[prop](t);
            });
            return getVal(parseMarkConfig(mark, a, cache, true)[prop], [d, i], node);
          };
        });
      });
    }

    // function chainPromise(_) {
    //     let { args, terminator, onEnd, callback } = _;
    //     // callback(args);
    //     // return;
    //
    //     if (terminator && terminator(args)) {
    //         return;
    //     }
    //
    //     let _promise = new Promise((resolve, reject) => {
    //         callback(args, () => {
    //             onEnd(args);
    //             resolve(_);
    //         });
    //     }).then(chainPromise);
    // }

    // function simpleAnime(args, onEnd) {
    //     let { arr, i, element, cache, mark, parser } = args,
    //         config = arr[i],
    //         { duration, delay, easing, transition: transitionName } = d3AnimeConfig(config, parser),
    //         transition = element.transition(transitionName);
    //
    //     if (isFunction(config)) {
    //         config(element, transition);
    //         onEnd(); // Check for args
    //         return;
    //     }
    //
    //     if (isArray(config)) {
    //         return syncAnimation(config, args);
    //     }
    //
    //     let { from, to, interpolate } = getConfigStops(config);
    //
    //     applyConfig(element, from, cache, mark);
    //
    //     transition
    //         .duration(duration)
    //         .delay(delay)
    //         .ease(d3_ease(easing))
    //         .on('end', function (d, i) {
    //             let _this = this;
    //             setTimeout(function () {
    //                 onEnd.call(_this, d, i);
    //             }, 0);
    //         });
    //
    //     applyConfig(transition, to, cache, mark);
    //
    //     if (!isEmptyObject(interpolate)) {
    //         tween(transition, interpolate, cache, mark);
    //     }
    // }

    function d3AnimeConfig(config, globalConfig) {
      return {
        duration: pick(getValByPriority([config, globalConfig], 'duration'), 250),
        delay: getValByPriority([config, globalConfig], 'delay') || 0,
        easing: getValByPriority([config, globalConfig], 'easing'),
        transition: getValByPriority([config, globalConfig], 'transition')
      };
    }
    Registry.setComponent('mark.anime', animeDom);

    //

    var markNodeMap = {
      _rect: 'path', // TODO: legend-background-svg uses 'rect'
      _div: 'div',
      group: 'g',
      point: 'path',
      polygon: 'path'
    };

    function markToNode(mark) {
      return markNodeMap[mark] || mark;
    }

    //

    function exportMark(parser, cache) {
      var as = parser.as,name = parser.name,element = parser.element;

      if (!as) {
        return;
      }

      var exported = parser._as = {};
      each(as, function (value) {return exported[value] = [];});

      element.each(function () {
        var bb = isSvgElement(this) ? bbox(this) : getBoundingRect(this);
        each(as, function (value, attr) {return exported[value].push(pick(bb[attr], bb));});
      });
    }

    //

    function scanMark(parser) {
      var cache = { _name: {}, dependency: {}, as: {} };
      loopMark(parser, cache);

      each(cache.dependency, function (value, prop) {return cache.dependency[prop].push(cache._name[prop]);});

      delete cache._name;
      return cache;
    }

    function loopMark(parser, cache) {var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var children = parser.children,name = parser.name,dependency = parser.dependency,as = parser.as;

      parser._level = level;

      if (name) {
        cache._name[name] = parser;
      }

      if (dependency) {
        cache.dependency[isObject(dependency) ? dependency.name : dependency] = [];
      }

      if (as) {
        var unNamed = 'zcUnNamed';
        cache.as[pick(name, unNamed)] = cache.as[pick(name, unNamed)] || [];
        cache.as[pick(name, unNamed)].push(parser);

        cache.as[unNamed] = cache.as[unNamed] || [];
        cache.as[unNamed].push(parser);
      }

      if (children && children.length) {
        children.forEach(function (_, i) {return loopMark(_, cache, level + '_' + i);});
      }
    }

    //

    // {
    //     dependency: {
    //         name: 'legend-content',
    //         parent: d3.select("svg.svgPattern"), or "svg.svgPattern" or document.querySelector("svg.svgPattern")
    //         exclude: 'name', or ['name1', 'name2']
    //         onEnd: _ => _.parent.select("g").remove()
    //     }
    // }
    // TODO: doc - dependency: { name: 'legend-content', exclude: ['remi', 'laila'], parent: d3.select('.svgPattern') }
    function renderDependencies(dependency, _parent, cache) {
      if (!dependency) {
        return;
      }

      dependency = splat(dependency);
      dependency.forEach(function (_) {
        var obj = !isObject(_) ? { name: _ } : _,
          name = obj.name,parent = obj.parent,onStart = obj.onStart,onEnd = obj.onEnd,_obj$exclude = obj.exclude,exclude = _obj$exclude === void 0 ? [] : _obj$exclude;

        invokeFunction(onStart, _);
        var dependencyParser = getDependencyParser(name, cache);
        _renderDom(dependencyParser, getParent(obj, _parent), _objectSpread(_objectSpread({}, cache), {}, { exclude: splat(exclude) }));
        dependencyParser._rendered = !parent;
        invokeFunction(onEnd, _);
      });
    }

    function getDependencyParser(_, cache) {
      return cache.dependency[_][0];
    }

    function getParent(obj, parent) {
      var dependencyParent = obj.parent;
      if (defined(dependencyParent)) {
        if (dependencyParent.isD3Selection) {
          return dependencyParent;
        } else {
          return d3_select(dependencyParent);
        }
      }

      return parent;
    }

    //

    function renderDom(root, parent) {
      var cache = scanMark(root);
      return _renderDom(root, parent, cache);
    }

    function _renderDom(root, _parent, cache) {
      var mark = root.mark,_root$data = root.data,data = _root$data === void 0 ? [1] : _root$data,_root$selector = root.selector,selector = _root$selector === void 0 ? '' : _root$selector,order = root.order,children = root.children,name = root.name,dependency = root.dependency,dataAccessor = root.dataAccessor,_root$on = root.on,on = _root$on === void 0 ? {} : _root$on,
        parent = getParent(root, _parent),
        markType = markToNode(mark),_cache$exclude =
        cache.exclude,exclude = _cache$exclude === void 0 ? [] : _cache$exclude,

        onStart = on.start || root.onStart,
        onEnd = on.end || root.onEnd;

      if (defined(name) && exclude.length && arrayIncludes(exclude, name)) {
        return;
      }

      if (root._rendered) {
        var n = root.element.node();
        var _p = n.parentNode;

        _p.removeChild(n);
        parent.node().appendChild(n);
        delete root._rendered;
        return;
      }

      var selectionObj = createElement(markType, selector, data, parent, order, dataAccessor, { enter_update_exit: true, remove: false }),
        updateSelection = selectionObj.update,exitSelection = selectionObj.exit,
        ele = updateSelection;

      if (root.accessor) {
        ele.each(function (d, i) {
          root.accessor.call(this, d, i);
        });
        return;
      }

      if (root.depends) {
        ele = updateSelection = selectionObj.update = parent.select(markType + selector);
      }

      updateSelection.each(initCache);
      exitSelection.each(initCache);

      // onStart callback
      invokeFunction(onStart, ele);

      // Dependencies
      renderDependencies(dependency, parent, cache);

      // Paint by properties
      _paintDomByProps(selectionObj, root);

      // Paint by config
      _paintDomByConfig(selectionObj, root, cache);

      //paintbycss

      root.element = ele;

      // Animation
      if (root.anime) {
        _animeDom(selectionObj, root, cache);
      } else {
        exitSelection.remove(); // Remove exit nodes
      }

      if (root.element) {
        root.element._zc = true; // ZC3271
      }

      var fullSelection = parent.selectAll(markType + selector),
        isInnerHTML = root.config && root.config.html;
      if (children && children.length) {
        children.forEach(function (_) {return _renderDom(_, fullSelection, cache);});
      } else
      if (!isInnerHTML) {// TODO: add a condition to remove only if it has children
        ele.selectAll('*').remove();
        //reason : in some cases - for example DEMOEVENTS_HEATMAP_4
        //when first event triggered - .zc-band-brush component will have children in it
        //but inorder to calculate its transform,its bbox needed,if children there inside it, it was not proper
      }

      // onEnd callback
      invokeFunction(onEnd, ele);

      // Mark as
      exportMark(root, cache);
    }

    function _paintDomByConfig(selection, root, cache) {
      var mark = root.mark,_root$config = root.config,config = _root$config === void 0 ? {} : _root$config,
        paintOptions = { cache: cache, parser: root },
        enterConfig = config.enter,updateConfig = config.update,exitConfig = config.exit,
        enterSelection = selection.enter,updateSelection = selection.update,exitSelection = selection.exit;

      updateConfig = _objectSpread(_objectSpread({}, config), updateConfig);
      ['enter', 'update', 'exit'].forEach(function (_) {return delete updateConfig[_];});

      paintDomByConfig({ mark: mark, config: enterConfig }, enterSelection, paintOptions);
      paintDomByConfig({ mark: mark, config: updateConfig }, updateSelection, paintOptions);
      paintDomByConfig({ mark: mark, config: exitConfig }, exitSelection, paintOptions);
    }

    function _paintDomByProps(selection, root) {
      var _root$properties = root.properties,properties = _root$properties === void 0 ? {} : _root$properties,
        enterProps = properties.enter,updateProps = properties.update,exitProps = properties.exit,
        enterSelection = selection.enter,updateSelection = selection.update,exitSelection = selection.exit;

      updateProps = _objectSpread(_objectSpread({}, properties), updateProps);
      ['enter', 'update', 'exit'].forEach(function (_) {return delete updateProps[_];});

      paintDom(enterProps, enterSelection);
      paintDom(updateProps, updateSelection);
      paintDom(exitProps, exitSelection);
    }

    function _animeDom(selection, root, cache) {
      var mark = root.mark,anime = root.anime;

      if (!anime) {
        return;
      }

      var enterConfig = anime.enter,updateConfig = anime.update,exitConfig = anime.exit,
        enterSelection = selection.enter,updateSelection = selection.update,exitSelection = selection.exit;

      if (!isArray$1(updateConfig)) {
        updateConfig = _objectSpread(_objectSpread({}, anime), updateConfig);
        ['enter', 'update', 'exit'].forEach(function (_) {return delete updateConfig[_];});
      }

      animeDom(enterConfig, anime, enterSelection, cache, mark);
      animeDom(updateConfig, anime, updateSelection, cache, mark);
      animeDom(exitConfig, anime, exitSelection, cache, mark, function () {return exitSelection.remove();});
    }

    function initCache() {
      var node = this;
      node.zc_cache = node.zc_cache || {};
    }
    Registry.setComponent('mark.render', renderDom);

    //$Id$

    function getSVGsymbol(type) {
      /*
       * Default arguments
       * 0 - size | width
       * 1 - height
       * 2 - border radius
       */
      return function (size, size1, custom, side) {
        if (LOCATION_MARKERS.has(type)) {
          return Registry.getComponent('svg.symbolPath.geo')(type, size, side);
        }

        switch (type) {
          case 'asterisk':
            return "M0 0 C".concat(size * -0.25, " ").concat(size * -0.65, " ").concat(size * 0.25, " ").concat(size * -0.65, " 0 0 C").concat(size * 0.5, " ").concat(size * -0.633, " ").concat(size *
            0.65, " ").concat(size * -0.117, " 0 0 C").concat(size * 0.583, " ").concat(size * 0.083, " ").concat(size * 0.583, " ").concat(size * 0.65, " 0 0 C").concat(size * 0.25, " ").concat(size *
            0.65, " ").concat(size * -0.25, " ").concat(size * 0.65, " 0 0 C").concat(size * -0.617, " ").concat(size * 0.65, " ").concat(size * -0.55, " ").concat(size * 0.017, " 0 0 C").concat(size *
            -0.483, " ").concat(size * -0.05, " ").concat(size * -0.583, " ").concat(size * -0.717, " 0 0 Z");
          case 'bean':
            return "M0 ".concat(size * 0.5, " A").concat(size * 0.25, " ").concat(size * 0.5, " 0 0 1 0 ").concat(-size * 0.5, " A").concat(size * 0.15, " ").concat(size *
            0.25, " 0 0 1 1 0 A").concat(size * 0.15, " ").concat(size * 0.25, " 0 0 1 0 ").concat(size * 0.5);
          case 'butterfly':
            return "M0 ".concat(-size * 0.25, " C0 ").concat(-size * 0.25, " ").concat(size * 0.85, " ").concat(-size, " ").concat(size * 0.3, " ").concat(size * 0.25, " C").concat(size * 0.6, " ").concat(size *
            0.7, " 0 ").concat(size * 0.4, " 0 ").concat(size * 0.4, " M0 ").concat(-size * 0.25, " C0 ").concat(-size * 0.25, " ").concat(-size * 0.85, " ").concat(-size, " ").concat(-size *
            0.3, " ").concat(size * 0.25, " C").concat(-size * 0.6, " ").concat(size * 0.7, " 0 ").concat(size * 0.4, " 0 ").concat(size * 0.4, " M0 ").concat(-size * 0.25, " L").concat(size *
            0.1, " ").concat(-size * 0.5, " M0 ").concat(-size * 0.25, " L").concat(-size * 0.1, " ").concat(-size * 0.5);
          case 'clover':
            return "M".concat(size * 0.033, " ").concat(size * -0.033, " C").concat(size * -0.133, " ").concat(size * -0.966, " ").concat(size * 1.066, " ").concat(size * -0.116, " ").concat(size *
            0.1, " ").concat(size * 0.033, " C").concat(size * 0.933, " ").concat(size * 0.233, " ").concat(size * -0.133, " ").concat(size * 0.9, " ").concat(size * 0.016, " ").concat(size *
            0.083, " C").concat(size * -0.633, " ").concat(size * 0.6, " ").concat(size * -0.6, " ").concat(size * -0.6, " ").concat(size * 0.033, " ").concat(size * -0.033, " Z");
          case 'cloverFour':
            return "M".concat(-size * 0.05, " ").concat(-size * 0.05, " C").concat(-size * 0.4, " ").concat(-size * 0.6, " ").concat(size * 0.4, " ").concat(-size * 0.6, " ").concat(size *
            0.05, " ").concat(-size * 0.05, " C").concat(size * 0.6, " ").concat(-size * 0.4, " ").concat(size * 0.6, " ").concat(size * 0.4, " ").concat(size * 0.05, " ").concat(size * 0.05, " C").concat(size *
            0.4, " ").concat(size * 0.6, " ").concat(-size * 0.4, " ").concat(size * 0.6, " ").concat(-size * 0.05, " ").concat(size * 0.05, " C").concat(-size * 0.6, " ").concat(size * 0.4, " ").concat(-size *
            0.6, " ").concat(-size * 0.4, " ").concat(-size * 0.05, " ").concat(-size * 0.05, " Z");
          case 'cross':
            return "M".concat(-size / 2, " ").concat(-size * 0.2, " L").concat(-size * 0.2, " ").concat(-size * 0.2, " L").concat(-size * 0.2, " ").concat(-size / 2, " L").concat(size * 0.2, " ").concat(-size /
            2, " L").concat(size * 0.2, " ").concat(-size * 0.2, " L").concat(size / 2, " ").concat(-size * 0.2, " L").concat(size / 2, " ").concat(size * 0.2, " L").concat(size * 0.2, " ").concat(size *
            0.2, " L").concat(size * 0.2, " ").concat(size / 2, " L").concat(-size * 0.2, " ").concat(size / 2, " L").concat(-size * 0.2, " ").concat(size * 0.2, " L").concat(-size / 2, " ").concat(size *
            0.2, " Z");
          case 'diamond':
            return "M".concat(-size * 0.4, " 0 L0 ").concat(-size / 2, " L").concat(size * 0.4, " 0 L0 ").concat(size / 2, " Z");
          case 'ellipse':
            return "M".concat(-size * 0.5, " 0 A").concat(size * 0.5, " ").concat(size * 0.35, " 0 0 1 ").concat(size * 0.5, " 0 A").concat(size * 0.5, " ").concat(size * 0.35, " 0 0 1 ").concat(-size *
            0.5, " 0");
          case 'gear':
            return "M".concat(size * -0.088, " ").concat(size * -0.365, " L").concat(size * -0.084, " ").concat(size * -0.471, " L").concat(size * 0.092, " ").concat(size * -0.471, " L").concat(size *
            0.097, " ").concat(size * -0.369, " L").concat(size * 0.194, " ").concat(size * -0.317, " L").concat(size * 0.27, " ").concat(size * -0.386, " L").concat(size * 0.409, " ").concat(size *
            -0.263, " L").concat(size * 0.339, " ").concat(size * -0.189, " L").concat(size * 0.364, " ").concat(size * -0.088, " L").concat(size * 0.478, " ").concat(size * -0.088, " L").concat(size *
            0.478, " ").concat(size * 0.097, " L").concat(size * 0.369, " ").concat(size * 0.097, " L").concat(size * 0.325, " ").concat(size * 0.192, " L").concat(size * 0.394, " ").concat(size *
            0.265, " L").concat(size * 0.254, " ").concat(size * 0.396, " L").concat(size * 0.197, " ").concat(size * 0.325, " L").concat(size * 0.092, " ").concat(size * 0.364, " L").concat(size *
            0.092, " ").concat(size * 0.476, " L").concat(size * -0.084, " ").concat(size * 0.476, " L").concat(size * -0.084, " ").concat(size * 0.364, " L").concat(size * -0.185, " ").concat(size *
            0.32, " L").concat(size * -0.263, " ").concat(size * 0.394, " L").concat(size * -0.388, " ").concat(size * 0.26, " L").concat(size * -0.317, " ").concat(size * 0.192, " L").concat(size *
            -0.354, " ").concat(size * 0.097, " L").concat(size * -0.473, " ").concat(size * 0.097, " L").concat(size * -0.473, " ").concat(size * -0.091, " L").concat(size * -0.356, " ").concat(size *
            -0.091, " L").concat(size * -0.317, " ").concat(size * -0.189, " L").concat(size * -0.384, " ").concat(size * -0.258, " L").concat(size * -0.267, " ").concat(size *
            -0.384, " L").concat(size * -0.184, " ").concat(size * -0.312, " L").concat(size * -0.088, " ").concat(size * -0.365, " Z");
          case 'heart':
            return "M0 ".concat(-size * 0.2, " C").concat(size * 0.65, " ").concat(-size * 0.65, " ").concat(size * 0.65, " ").concat(size * 0.2, " 0 ").concat(size * 0.45, " C").concat(-size *
            0.65, " ").concat(size * 0.2, " ").concat(-size * 0.65, " ").concat(-size * 0.65, " 0 ").concat(-size * 0.2, "Z");
          case 'star':
            return "M0 ".concat(-size * 0.5, " L").concat(size * 0.122, " ").concat(-size * 0.12, " L").concat(size * 0.5, " ").concat(-size * 0.12, " L").concat(size * 0.197, " ").concat(size *
            0.12, " L").concat(size * 0.306, " ").concat(size * 0.5, " L0 ").concat(size * 0.274, " L").concat(-size * 0.306, " ").concat(size * 0.5, " L").concat(-size * 0.197, " ").concat(size *
            0.12, " L").concat(-size * 0.5, " ").concat(-size * 0.12, " L").concat(-size * 0.122, " ").concat(-size * 0.12, " Z");
          case 'malteseCross':
            return "M".concat(-size * 0.3, " ").concat(-size * 0.4, " A").concat(size * 0.3, " ").concat(size * 0.1, " 0 0 1 ").concat(size * 0.3, " ").concat(-size * 0.4, " L").concat(size *
            0.2, " ").concat(-size * 0.2, " L").concat(size * 0.4, " ").concat(-size * 0.3, " A").concat(size * 0.1, " ").concat(size * 0.3, " 0 0 1 ").concat(size * 0.4, " ").concat(size *
            0.3, " L").concat(size * 0.2, " ").concat(size * 0.2, " L").concat(size * 0.3, " ").concat(size * 0.4, " A").concat(size * 0.3, " ").concat(size * 0.1, " 0 0 1 ").concat(-size *
            0.3, " ").concat(size * 0.4, " L").concat(-size * 0.2, " ").concat(size * 0.2, " L").concat(-size * 0.4, " ").concat(size * 0.3, " A").concat(size * 0.1, " ").concat(size *
            0.3, " 0 0 1 ").concat(-size * 0.4, " ").concat(-size * 0.3, " L").concat(-size * 0.2, " ").concat(-size * 0.2, " Z");
          case 'square':
            var side = +arguments[0],
              r = +pick(arguments[2], 0);

            if (defined(arguments[2])) {
              return roundedRect(-side / 2, -side / 2, side, side, getBorderRadius(r));
            } else {
              return "M".concat(-size * 0.5, " ").concat(-size * 0.5, " L").concat(size * 0.5, " ").concat(-size * 0.5, " ").concat(size * 0.5, " ").concat(size * 0.5, " ").concat(-size * 0.5, " ").concat(size *
              0.5, " Z");
            }

          case 'triangle-up':
            return "M".concat(-size * 0.5, " ").concat(size * 0.285, " L0 ").concat(-size * 0.43, " ").concat(size * 0.5, " ").concat(size * 0.285, " Z");
          case 'triangle-down':
            return "M0 ".concat(size * 0.43, " L").concat(-size * 0.5, " ").concat(-size * 0.285, " L").concat(size * 0.5, " ").concat(-size * 0.285, " Z");
          case 'triangle-right':
            return "M".concat(-size * 0.5, " ").concat(-size * 0.43, " L").concat(size * 0.285, " 0 L").concat(-size * 0.5, " ").concat(size * 0.43, " Z");
          case 'triangle-left':
            return "M".concat(size * 0.5, " ").concat(size * 0.43, " L").concat(-size * 0.285, " 0 L").concat(size * 0.5, " ").concat(-size * 0.43, " Z");
          case 'arrow':
            return "M".concat(-size * 0.5, " ").concat(size * 0.2, " L0 ").concat(-size * 0.5, " ").concat(size * 0.5, " ").concat(size * 0.2, " ").concat(size * 0.25, " ").concat(size * 0.2, " ").concat(size *
            0.25, " ").concat(size * 0.5, " ").concat(-size * 0.25, " ").concat(size * 0.5, " ").concat(-size * 0.25, " ").concat(size * 0.2, " Z");
          case 'rocket':
            return "M".concat(-size * 0.5, " ").concat(size * 0.5, " L0 ").concat(-size * 0.5, " ").concat(size * 0.5, " ").concat(size * 0.5, " 0 ").concat(size * 0.25, " ").concat(-size * 0.5, " ").concat(size *
            0.5, " Z");
          case 'nylon':
            return "M".concat(-size / 2, " ").concat(-size / 4, " L").concat(-size / 4, " ").concat(-size / 4, " L").concat(-size / 4, " ").concat(-size / 2, " M").concat(-size / 4, " 0 L").concat(-size /
            4, " ").concat(size / 4, " L0 ").concat(size / 4, " M0 ").concat(-size / 4, " L").concat(size / 4, " ").concat(-size / 4, " L").concat(size / 4, " 0 M").concat(size / 4, " ").concat(size /
            2, " L").concat(size / 4, " ").concat(size / 4, " L").concat(size / 2, " ").concat(size / 4);
          case 'waves':
            return "M".concat(-size, " 0 C").concat(-size * 7 / 8, " ").concat(-size / 4, " ").concat(-size * 5 / 8, " ").concat(-size / 4, " ").concat(-size / 2, " 0 C").concat(-size * 3 /
            8, " ").concat(-size / 4, " ").concat(-size / 8, " ").concat(-size / 4, " 0 0 C").concat(size / 8, " ").concat(size / 4, " ").concat(size * 3 / 8, " ").concat(size / 4, " ").concat(size /
            2, " 0 C").concat(size * 5 / 8, " ").concat(-size / 4, " ").concat(size * 7 / 8, " ").concat(-size / 4, " ").concat(size * 3 / 4, " 0");
          case 'woven':
            return "M".concat(-size / 4, " ").concat(-size / 4, " L").concat(size / 4, " ").concat(size / 4, " M").concat(size / 4, " ").concat(-size / 4, " L").concat(size / 2, " ").concat(-size / 2, " M").concat(-size /
            4, " ").concat(size / 4, " L").concat(-size / 2, " ").concat(size / 2, " M").concat(size / 4, " ").concat(size * 3 / 4, " L").concat(size * 3 / 4, " ").concat(size / 4);
          case 'crosses':
            return "M ".concat(-size / 4, " ").concat(-size / 4, " L").concat(size / 4, ",").concat(size / 4, " M").concat(-size / 4, ",").concat(size / 4, " L").concat(size / 4, ",").concat(-size / 4);
          case 'caps':
            return "M".concat(-size / 4, " ").concat(size / 4, " L0 ").concat(-size / 4, " ").concat(size / 4, " ").concat(size / 4);
          case 'hexagons':
            return "M".concat(-size / 2, " 0 L").concat(-size / 4, " 0 M").concat(size / 2, " 0 L").concat(size / 4, " ").concat(-size / 2, " L0 ").concat(-size / 2, " L").concat(-size / 4, " 0 L0 ").concat(size /
            2, " L").concat(size / 4, " ").concat(size / 2, "Z");
          case 'line':
          case 'horizontal-line':
            return "M".concat(-size * 0.5, " 0 L").concat(size * 0.5, " 0");
          case 'diagonal-line-right':
            return "M".concat(-size * 3 / 4, " ").concat(-size / 4, " L").concat(-size / 4, " ").concat(-size * 3 / 4, " M").concat(-size / 2, " ").concat(size / 2, " L").concat(size / 2, " ").concat(-size /
            2, " M").concat(size / 4, " ").concat(size * 3 / 4, " L").concat(size * 3 / 4, " ").concat(size / 4);
          case 'vertical-line':
            return "M0 ".concat(-size / 2, " L0 ").concat(size / 2);
          case 'vertical-line-z':
            return "M0 0 L0 ".concat(size);
          case 'hexagon':
            return "M".concat(size * 0.433, " ").concat(size * 0.25, " L").concat(0 * size, " ").concat(size * 0.5, " L").concat(size * -0.433, " ").concat(size * 0.25, " L").concat(size *
            -0.433, " ").concat(size * -0.26, " L").concat(0 * size, " ").concat(size * -0.5, " L").concat(size * 0.433, " ").concat(size * -0.26, " Z");
          case 'diagonal-line-left':
            return "M".concat(-size * 3 / 4, " ").concat(size / 4, " L").concat(-size / 4, " ").concat(size * 3 / 4, " M").concat(-size / 2, " ").concat(-size / 2, " L").concat(size / 2, " ").concat(size /
            2, " M").concat(size / 4, " ").concat(-size * 3 / 4, " L").concat(size * 3 / 4, " ").concat(-size / 4);
          case 'oval':
            return "M".concat(-size / 2, " 0 A").concat(size / 2, " ").concat(size / 2, " 0 0 1 0 ").concat(-size / 2, " A").concat(size / 2, " ").concat(size / 2, " 0 0 1 ").concat(-size / 2, " 0");
          case 'rect':
            var w = +arguments[0],
              h = +pick(arguments[1], 0),
              r = +pick(arguments[2], 0);

            if (defined(arguments[2])) {
              return roundedRect(-w / 2, -h / 2, w, h, getBorderRadius(r));
            } else {
              return "M".concat(-w / 2, " ").concat(-h / 2, " L").concat(w / 2, " ").concat(-h / 2, " L").concat(w / 2, " ").concat(h / 2, " L").concat(-w / 2, " ").concat(h / 2, "Z");
            }

          case 'ninja':
            return "M".concat(size * -0.267, " ").concat(size * -0.367, " L").concat(size * 0.167, " ").concat(size * -0.133, " L").concat(size * 0.433, " ").concat(size * -0.267, " L").concat(size *
            0.2, " ").concat(size * 0.167, " L").concat(size * 0.333, " ").concat(size * 0.433, " L").concat(size * -0.1, " ").concat(size * 0.167, " L").concat(size * -0.367, " ").concat(size *
            0.333, " L").concat(size * -0.167, " ").concat(size * -0.1, " Z");
          case 'whiskers':
            return whiskers([
            ['line', size],
            [custom.symbol, custom.size]]);

          case 'whisker':
            return whiskerDouble(arguments[0], pick(arguments[1], 8), false);
          case 'horizontal-whisker':
            return whiskerDouble(pick(arguments[0], 8), arguments[1], true);
          case 'half-circle':
            return "M".concat(-size / 2, " ").concat(size / 4, " A").concat(size / 2, " ").concat(size / 2, " 0 0 1 ").concat(size / 2, " ").concat(size / 4, " Z");
          case 'arrow-line':
            return "M".concat(-size * 0.5, " 0 L").concat(size * 0.25, " 0 M").concat(size * 0.25, " ").concat(-size * 0.25, " L").concat(size * 0.5, " 0 L").concat(size * 0.25, " ").concat(size *
            0.25);
          default:
            //circle
            return "M".concat(-size / 2, " 0 A").concat(size / 2, " ").concat(size / 2, " 0 0 1 ").concat(size / 2, " 0 A").concat(size / 2, " ").concat(size / 2, " 0 0 1 ").concat(-size / 2, " 0");}

      };
    }
    Registry.setComponent('svg.symbolPath', getSVGsymbol);

    function addSVGmarker(parentElement, id, config, extraParams, chartObj) {
      var DIM = 10,
        transform = extraParams.transform,rotate = extraParams.rotate,color = extraParams.color,_extraParams$symbolSi = extraParams.symbolSize,symbolSize = _extraParams$symbolSi === void 0 ? { outer: 1, inner: 0.5 } : _extraParams$symbolSi,
        _position = transform ? { x: transform[0], y: transform[1], angle: rotate } : {},
        shape = config.symbol || extraParams.symbol,
        hasImage = config.imageUrl != null && config.imageUrl !== '',
        size = pick(config.size, pick(extraParams.strokeWidth, 1)),
        outersize = size * symbolSize.outer,
        innersize = size * symbolSize.inner,
        imgSize = (id != null ? size : outersize) * pick(extraParams.imageSize, DIM),






        innerFillColor = config.innerFillColor || color,
        innerData =
        hasImage || config.innerStrokeWidth === 0 && (config.innerFillOpacity === 0 || innerFillColor === 'transparent') ? [] : [1],
        outerMarkSize = [hasImage ? imgSize : outersize * DIM, extraParams.size2d, extraParams.custom],
        innerMarkSize = [innersize * DIM, extraParams.size2d, extraParams.custom, 'inner'],
        marker;

      if (id != null) {
        //if id is not null create marker element else create path/image element
        var markerMark = Mark('marker', '#' + id);
        setPropVal(markerMark, 'properties.attrs', markerAttrs(size * DIM));
        renderDom(markerMark, chartObj.getPatternSvg().select('defs'));
        marker = markerMark.element;
      } else {
        marker = parentElement;
      }

      var isUpdate = marker.selectAll('path.outer').nodes().length; //No need to add animation for redraw

      //TODO: check 'stroke-width': (config.outerStrokeWidth || 0).toString()
      var outerMark = MarkerParser({
          prefix: 'outer',
          selection: '.outer',
          config: _objectSpread(_objectSpread(_objectSpread({}, _position), config), {}, { shape: shape, color: color, size: outerMarkSize }),
          context: chartObj.getPatternSvg(),
          defsPath: chartObj.defsLocation
        }),
        innerMark = MarkerParser({
          prefix: 'inner',
          selection: '.inner',
          data: innerData,
          config: _objectSpread(_objectSpread(_objectSpread({}, _position), config), {}, { shape: shape, color: color, size: innerMarkSize })
        });

      renderDom(outerMark, marker);
      renderDom(innerMark, marker);
      outerMark.element.style('stroke-width', (config.outerStrokeWidth || 0).toString());

      // Animation
      var outermarkerpath = outerMark.element,
        animationOptions = config.animation;

      if (!isUpdate && animationOptions && animationOptions.enabled) {
        //Implemented only for boxplot markers
        outermarkerpath.
        styles({
          'stroke-opacity': 0,
          'fill-opacity': 0
        }).
        transition().
        delay(animationOptions.duration).
        duration(animationOptions.duration).
        styles({
          'stroke-opacity': config.outerStrokeOpacity
        });
      }
      return marker;
    }
    Registry.setComponent('svgRenderer.marker', addSVGmarker);

    function markerAttrs(size) {
      return {
        orient: 0,
        viewBox: "".concat(-size / 2, " ").concat(-size / 2, " ").concat(size, " ").concat(size),
        markerUnits: 'userSpaceOnUse',
        markerWidth: size,
        markerHeight: size
      };
    }

    function getMarkerSize(chart) {
      // For area, line, scatter charts - if marker is enabled, the top markers will be clipped.
      // To avoid this, calculate the marker size and increase the clip area
      var DIM = { left: 0, top: 0, right: 0, bottom: 0 },
        behaviours = chart.behaviouralEvents && chart.behaviouralEvents.eventManager.behaviours || {};

      if (!chart.isAxisCategory || behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL) {
        return DIM;
      }
      // If minrange and maxrange of the axes is specified, don't consider the marker size
      var xaxis = chart.systemConf.chart.axes.xaxis,
        yaxes = chart.systemConf.chart.axes.yaxis;
      var cXmin = xaxis.minRange != null && xaxis.minRange !== '',
        cXmax = xaxis.maxRange != null && xaxis.maxRange !== '',
        cYmin = yaxes.some(function (d) {
          return d.minRange != null && d.minRange !== '';
        }),
        cYmax = yaxes.some(function (d) {
          return d.maxRange != null && d.maxRange !== '';
        });
      if (cXmin && cXmax && cYmin && cYmax) {
        return DIM;
      }
      var rotated = chart.axes.rotated;

      var ms = d3_max(getMarkerSizes(chart)) / 2;
      return {
        left: (rotated ? cYmin : cXmin) ? DIM.left : ms,
        top: (rotated ? cXmax : cYmax) ? DIM.top : ms,
        right: (rotated ? cYmax : cXmax) ? DIM.right : ms,
        bottom: (rotated ? cXmin : cYmin) ? DIM.bottom : ms
      };
    }

    function getMarkerSizes(chart) {
      var commonPlotoptions = chart.systemConf.chart.plot.plotoptions,
        canvasarea = chart.canvasarea;
      return chart.seriesdata.map(function (d, i) {
        var plotoptions = d.plotoptions,
          markerSize = 0,
          cName = chart.chartTypes[i].name;
        var gvp = utils.getValueOfPlotOptions(plotoptions ? plotoptions.marker : null, commonPlotoptions[cName].marker);
        if (
        /(area|arearange|line)/.test(cName) &&
        gvp('enabled') &&
        datacount_based_intelligence(chart, 'marker') &&
        dimension_based_intelligence(chart, 'marker', mathMin(canvasarea.width, canvasarea.height)))
        {
          var size = gvp('size');
          markerSize = validateNullVal(
          size,
          validateNullVal(plotoptions ? plotoptions.strokeWidth : commonPlotoptions[cName].strokeWidth, 1));

        } else if (cName === SCATTER_CHARTNAME) {
          markerSize = validateNullVal(gvp('size'), 2);
        }
        return markerSize * 10;
      });
    }

    function blinkSVGsymbols(ele, blinkConf, chartObj) {
      if ($Browser.IE && blinkConf.enabled) {
        //Doesn't support css transforms on SVG element
        blinkSVGsymbolsByD3(ele, blinkConf); //Have to work
        return;
      }

      var defaultstyles = {
        animation: NULL$1,
        opacity: NULL$1,
        transform: NULL$1
      };
      if (!blinkConf.enabled) {
        ele.styles(defaultstyles);
        return;
      }

      var repeat = defined(blinkConf.repeat) ? blinkConf.repeat : 'infinite',
        type = blinkConf.type || 'twinkle',
        duration = (blinkConf.duration || 800) / 1000,
        delay = (type === 'fade' ? 250 : 0) / 1000,
        easingType = blinkConf.easingType || 'linear',
        parentContainer = d3_select(getRootBody(chartObj.container.node())).selectAll('div.__baseZC_Container__'),
        styleEle = appendEle(parentContainer, 'style', [1]),
        styleNode = styleEle.node(),
        keyFrame = '',
        animationID = "ZC".concat(generateIdByPropValue(blinkConf, 'blink'));

      switch (type) {
        case 'twinkle':
          keyFrame =
          "".concat('\n@' + 'keyframes ').concat(animationID, " { ") + "0% {transform: scale(1);}" + "50% {transform: scale(0);}" + "100% {transform: scale(1);} }\n";



          break;
        case 'fade':
          keyFrame =
          "".concat('\n@' + 'keyframes ').concat(animationID, " { ") + "0% {transform: scale(0);opacity: 1;}" + "100% {transform: scale(1);opacity: 0;} }\n";


          ele.styles({
            transform: 'scale(0)',
            opacity: 1
          });
          break;}

      var documentIndex = _getDocumentIndex(chartObj.container.node()),
        EFFECTS_STORE = DOCUMENT_OBJECT_HOLDER[documentIndex].ANIMATION;
      if (!(EFFECTS_STORE && defined(EFFECTS_STORE[animationID]))) {
        styleNode.innerHTML += keyFrame;
        EFFECTS_STORE[animationID] = true;
      }

      ele.style('animation', "".concat(animationID, " ").concat(duration, "s ").concat(easingType, " ").concat(delay, "s ").concat(repeat)).on('animationend', function () {
        d3_select(this).styles(defaultstyles);
      });
    }

    function blinkSVGsymbolsByD3(ele, blinkConf, repeat) {
      var count = defined(repeat) ? repeat - 1 : blinkConf.repeat || Infinity;
      if (!ele.node() || !count) {
        ele.styles({
          transform: null,
          opacity: null
        });
        return;
      }
      var isFade = (blinkConf.type || 'twinkle') === FADE_ANIMATION;
      var dur = (blinkConf.duration || 800) / 2,
        ease = d3_ease(blinkConf.easingType);
      var dur1 = dur,
        del1 = isFade ? 500 : 0,
        dur2 = isFade ? 0 : dur,
        start = isFade ?
        {
          transform: 'scale(1)',
          opacity: 0
        } :
        {
          transform: 'scale(0)'
        },
        end = isFade ?
        {
          transform: 'scale(0)',
          opacity: 1
        } :
        {
          transform: 'scale(1)'
        };
      ele.transition(); //Stop all the transitions. This will help to switch the blink type.
      ele.attrs(end).
      transition().
      delay(del1).
      duration(dur1).
      ease(ease).
      attrs(start).
      transition().
      duration(dur2).
      ease(ease).
      attrs(end).
      on('end', function () {
        blinkSVGsymbols(ele, blinkConf, count);
      });
    }

    function getSegmentsForSymbol(type, size, x, y, h, rotated) {
      var start, end;
      switch (type) {
        case 'line':
          start = [x - size * 0.5, y];
          end = [x + size * 0.5, y];
          return [start, end];
        case "vertical-line":
          start = [x, y - size * 0.5];
          end = [x, y + size * 0.5];
          return [start, end];
        case "horizontal-whisker":
          return getSegmentsForWhisker(size, x, y, h, rotated);
        case "whisker":
          return getSegmentsForWhisker(size, x, y, h);}

    }

    function d3_mouse(_node) {
      var node = _node;
      if (node.isD3Selection) {
        node = node.node();
      }

      // do firefox check only with svg elements
      if ($Browser.FIREFOX && node.ownerSVGElement) {
        // Firefox getScreenCTM() issue
        // getScreenCTM() doesn't work correctly with parent container positioned with transform:translate
        // https://bugzilla.mozilla.org/show_bug.cgi?id=972041
        // http://bl.ocks.org/mwdchang/raw/a88aa3f61f5a2243d15bb8a264aa432e/
        // https://github.com/d3/d3/issues/2771

        // Since d3.mouse is not working properly, using fallback getBoundingClientRect

        var svg = node.ownerSVGElement;

        var event = d3_zc.event,
          source,
          rect = svg.getBoundingClientRect();
        while (source = event.sourceEvent) {
          event = source;
        }
        if (event.changedTouches) {
          event = event.changedTouches[0];
        }

        var _getTranslationFromOw3 = getTranslationFromOwnerSVGElement(node),_getTranslationFromOw4 = _slicedToArray(_getTranslationFromOw3, 2),_translateX = _getTranslationFromOw4[0],_translateY = _getTranslationFromOw4[1];

        _translateX = event.clientX - rect.left - node.clientLeft - _translateX;
        _translateY = event.clientY - rect.top - node.clientTop - _translateY;

        return [_translateX, _translateY];
      } else {
        return d3_zc.mouse.apply(this, [node]);
      }
    }

    //$Id$

    var TOUCH_EVENTS = ['tap', 'taphold', 'dbltap', 'tapholdend', 'touchmove', 'touchend', 'singletouchmove', 'doubletouchmove'];

    /**
     *
     * @param node
     * @return {Array}
     */
    function getMousePosition(node, event) {
      // For touch devices d3.mouse(node) will return incorrect values, if the document is scrolled. So that pageXOffset and pageYOffset is added.
      var mouse = d3_mouse(node);
      if (event.touches != null && !$Browser.ANDROID && $Browser.uiwebview && !$Browser.WKWebView) {
        //d3.mouse(node) considers pageXOffset and pageYOffset in android devices
        mouse[0] += window.pageXOffset;
        mouse[1] += window.pageYOffset;
      }
      return mouse;
    }
    Registry.setComponent('events.getMousePosition', getMousePosition);

    /*
     * If mouse is on a rotated element, this returns the mouse based on rotation
     */
    function getRotatedMouse(mouse, point) {
      var x = point.x,y = point.y,rotation = point.rotation;

      if (defined(rotation)) {
        return geometryUtils.rotatePoint(mouse, rotation, { x: x, y: y });
      }

      return mouse;
    }
    /*
     *Events related to statechange
     */

    function stateChangeListener(chartObj, eventdata, ele, type, defaultCallback) {
      //type: chartinit, chartload, chartreload, axisinit, axisload, plotinit, plotload

      var callback = eventdata && eventdata[type] || defaultCallback;
      if (defined(callback)) {
        invokeFunction(callback, d3_event(), chartObj);
      }
    }

    function attachevents(ele, mouseHandlers, touchHandlers, options, namespace) {
      /*
       * This function attaches event listeners to the element. For touch devices, events will be mapped with touchstart,touchmove and touchend.
       * ele -> To which element the listeners will be attached
       * namespace -> To register multiple listeners for the same event type, the optional namespace is used. (e.g) : "zoom" or null. Refer github.com/mbostock/d3/wiki/Selections#on
       * mouseHandlers -> An object of event type and listener. (e.g) : { "click" : function(){}, "mousemove" : function(){} }
       * touchleave -> whether to handle touch leave or not
       */
      options = options || {};
      namespace = options.namespace || namespace;
      if ($Browser.isMouseDevice && !isEmptyObject(mouseHandlers)) {
        attachMouseEvents(ele, namespace, mouseHandlers);
      }
      if ($Browser.isTouchDevice && !isEmptyObject(touchHandlers)) {
        attachTouchEvents(ele, namespace, touchHandlers, options);
      }
    }

    function detachevent(ele, namespace, handlers) {
      namespace = namespace != null && namespace != '' ? ".".concat(namespace) : '';
      if ($Browser.isMouseDevice) {
        if (namespace !== '') {
          ele.on(namespace, null);
        } else {
          for (var attr in handlers) {
            ele.on(attr, null);
          }
        }
        handlers = null;
      }
    }

    function attachMouseEvents(ele, namespace, handlers) {
      if (ele.node() == null) {
        return;
      }
      // if (namespace) {
      namespace = ".".concat(namespace);
      var updatedHandlers = {};
      for (var attr in handlers) {
        updatedHandlers[attr + namespace] = handlers[attr];
        ele.on(attr + namespace, updatedHandlers[attr + namespace]);
      }
      handlers = updatedHandlers;
      // }

      ele.on(handlers);
    }

    function attachTouchEvents(ele, namespace, handlers, options) {
      if (ele.node() == null) {
        return;
      }
      var touchleave = options.touchleave,
        target = options.target,
        chartObj = options.chartObj,
        plotEventOptions = chartObj && chartObj.systemConf.chart.plot.events || {},
        doPreventDefault = options.preventDefault !== false;
      var isFocusedTouchmove = !(target === 'plot' && plotEventOptions.isFocusedTouchmove == false);
      namespace = namespace != null ? ".".concat(namespace) : '';

      var MINDISTANCE = 30,
        SINGLETAPDURATION = 150,
        DOUBLETAPDURATION = 500,
        FOCUSEDMOVEDURATION = 100,
        TOUCHMOVETIMER = 50,
        TAPHOLDDURATION = 500;
      var prevElement,
        touchstart = {},
        lastMove = 0,
        lastTap = 0,
        tapDifference = DOUBLETAPDURATION - SINGLETAPDURATION,
        firstMove = null,
        isDoubletouchStarted = false,
        tapholdDetected,
        tapHoldTimer;

      var mousemoveFn = handlers.touchmove,
        touchendFn = handlers.touchend,
        tapFn = handlers.tap,
        dbltapFn = handlers.dbltap,
        singletouchmoveFn = handlers.singletouchmove,
        doubletouchmoveFn = handlers.doubletouchmove,
        tapholdFn,
        tapholdendFn;

      if (
      target === 'plot' &&
      getEventConf(null, chartObj.systemConf.chart.plot.plotoptions[chartObj.chartTypes[0].name], chartObj, 'taphold'))
      {
        tapholdFn = handlers.tap;
        tapholdendFn = touchendFn;
      } else {
        tapholdFn = handlers.taphold;
        tapholdendFn = handlers.tapholdend;
      }

      var touchstartProp = "touchstart".concat(namespace),
        touchmoveProp = "touchmove".concat(namespace),
        touchendProp = "touchend".concat(namespace);

      var updatedHandlers = {};
      updatedHandlers[touchstartProp] = function () {
        if (plotEventOptions.enabled == false) {
          return;
        }

        var touchObject = d3_event().touches;

        if (touchObject.length > 1) {
          return;
        }

        touchstart.time = new Date();
        touchstart.location = getMousePosition(this, d3_event());
        firstMove = null;
        isDoubletouchStarted = false;
        tapholdDetected = false;

        if (tapholdFn) {
          var e = d3_event();
          var arg = arguments;
          var self = this;
          tapHoldTimer = setTimeout(function () {
            d3_event(e);
            if (chartObj) {
              chartObj.zcEventType = 'taphold'; //change
            }

            tapholdFn.apply(self, arg);

            tapholdDetected = true;
          }, TAPHOLDDURATION);
        }
      };
      updatedHandlers[touchmoveProp] = function () {
        if (plotEventOptions.enabled == false) {
          return;
        }

        var touchObject = d3_event().touches;

        if (tapholdFn) {
          var currentLocation = getMousePosition(this, d3_event());
          var distance =
          touchstart.location != null ?
          getEuclideanDistance(touchstart.location[0], touchstart.location[1], currentLocation[0], currentLocation[1]) :
          null;

          if (distance > MINDISTANCE) {
            clearTimeout(tapHoldTimer);
          } else {
            if (tapholdDetected) {
              preventDefault();
              return false;
            }
          }
        }

        if (touchObject.length > 1) {
          if (touchObject.length == 2 && doubletouchmoveFn) {
            isDoubletouchStarted = true;
            doubletouchmoveFn.apply(this, arguments);
            preventDefault();
          }
          return;
        }

        var currentTime = new Date().getTime();
        if (!firstMove) {
          firstMove = currentTime;
        }

        // Touchleave event is not available. So finding the element to which the touchmove would be called is necessary. Call the mouseout of previous element and mousemove of the current element
        if (touchleave && document.elementFromPoint != null) {
          var timer = lastMove == 0 || currentTime - lastMove > TOUCHMOVETIMER;
          var curTouch = touchObject[0];
          var currentEle = document.elementFromPoint(curTouch.pageX - window.pageXOffset, curTouch.pageY - window.pageYOffset);
          if (!timer || currentEle.localName === 'svg' || currentEle.id.match(/tooltip/gi) != null) {
            preventDefault();
            return;
          }

          if (currentEle != this) {
            // Call mouse out of the previous element
            if (prevElement != currentEle) {
              var touchEndElement = prevElement || this;
              var element = d3_select(touchEndElement);
              var endEvent = element.on(touchendProp),
                d = element.datum(),
                identity = element.attr('id') || element.attr('class');
              var i = identity != null ? identity.match(/(\d)+$/gi) : null;
              i = i != null && i[0] != null ? parseInt(i[0]) : null;

              if (endEvent != null && i != null) {
                endEvent.call(touchEndElement, d, i);
              }
            }
            // Call mouse move of the current element
            var element = d3_select(currentEle),
              className = element.attr('class');
            if (chartObj.chartTypes[0].value === charttype.dial && (className === 'inner' || className === 'outer')) {
              element = d3_select(currentEle.parentNode);
            }
            var moveEvent = element.on(touchmoveProp),
              d = element.datum(),
              identity = element.attr('id') || element.attr('class');
            var i = identity != null ? identity.match(/(\d)+$/gi) : null;
            i = i != null && i[0] != null ? parseInt(i[0]) : null;
            if (moveEvent != null && i != null) {
              moveEvent.call(currentEle, d, i);
              prevElement = currentEle;
              lastMove = currentTime;
            }
            return;
          }
        }

        if (!(isFocusedTouchmove && firstMove - touchstart.time < FOCUSEDMOVEDURATION)) {
          if (singletouchmoveFn) {
            if (chartObj) {
              chartObj.zcEventType = 'touchmove'; //change
            }

            singletouchmoveFn.apply(this, arguments);
            preventDefault();
          }
        }
      };
      updatedHandlers[touchendProp] = function () {
        if (plotEventOptions.enabled == false) {
          return;
        }

        var touchObject = d3_event().touches;

        if (tapholdFn) {
          clearTimeout(tapHoldTimer);
          if (tapholdDetected) {
            tapholdDetected = false;
            preventDefault();
            if (tapholdendFn) {
              tapholdendFn.apply(this, arguments);
            }
            return false;
          }
        }

        if (touchObject.length > 1) {
          return;
        }

        if (isDoubletouchStarted && doubletouchmoveFn && touchendFn) {
          isDoubletouchStarted = false;
          touchendFn.apply(this, arguments);
          preventDefault();
          return;
        }

        var currentTime = new Date(),
          currentLocation = getMousePosition(this, d3_event());
        var duration = currentTime - touchstart.time;
        var distance =
        touchstart.location != null ?
        getEuclideanDistance(touchstart.location[0], touchstart.location[1], currentLocation[0], currentLocation[1]) :
        null;
        var tapLength = currentTime - lastTap;

        if (tapLength <= tapDifference && tapLength > 0 && distance <= MINDISTANCE) {
          // Double tap event
          if (dbltapFn) {
            if (chartObj) {
              chartObj.zcEventType = 'doubletap'; //change
            }

            dbltapFn.apply(this, arguments);
            preventDefault();
          }
          lastTap = 0;
        } else if (duration <= SINGLETAPDURATION && distance <= MINDISTANCE) {
          // Single tap event
          if (tapFn) {
            if (chartObj) {
              chartObj.zcEventType = 'tap'; //change
            }

            tapFn.apply(this, arguments);
            preventDefault();
          }
        } else {
          if (touchendFn) {
            touchendFn.apply(this, arguments);
          }
        }
        lastTap = currentTime;
      };

      // use capture only for brush events
      var useBubble = chartObj && chartObj.isAxisCategory && chartObj.systemConf.chart.brush.enabled;
      for (var attr in updatedHandlers) {
        ele.on(attr, updatedHandlers[attr], useBubble);
      }

      function getEuclideanDistance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      }

      function preventDefault() {
        var event = d3_event();
        if (doPreventDefault && event.cancelable) {
          event.preventDefault();
        }
      }
    }

    function pointerEventsNonePolyfill(ele) {
      var callback = function callback() {
          ele.style('display', NONE);

          var bottomElement = document.elementFromPoint(d3_event().clientX, d3_event().clientY),
            bottomElementD3 = d3_select(bottomElement),
            currentEvent =
            bottomElement &&
            bottomElement.__on &&
            bottomElement.__on.filter(function (e) {
              return e.type === d3_event().type;
            })[0].value;

          ele.style('display', NULL$1);
          d3_select(this).style('cursor', currentEvent ? bottomElementD3.style('cursor') : NULL$1);

          if (currentEvent) {
            currentEvent.call(bottomElement, bottomElementD3.datum(), bottomElementD3.attr('index') || 0);
          }
          return false;
        },
        mouseHandlers = {
          mousemove: callback,
          mouseout: callback,
          click: callback,
          dblclick: callback
        },
        touchHandlers = {
          singletouchmove: callback,
          touchend: callback,
          tap: callback,
          dbltap: callback
        };
      attachevents(ele, mouseHandlers, touchHandlers);
    }

    // ;//$Id$
    /*
     types = zBlocks, zBars, zCircle1, zCircle2, zCrossBars
     scale - transform scale
     duration - time duration for one iteration
     */
    //detect Browser Func

    var loadDetectBrowser = function loadDetectBrowser() {
      var userAgent = navigator.userAgent;
      var browser = {};
      if (userAgent.indexOf('OPR') > 0) {
        browser.name = 'Opera';
        browser.jsPrefix = 'webkit';
        browser.cssPrefix = '-webkit-';
        var index = userAgent.indexOf('OPR/');
        browser.version = pInt(userAgent.substr(index + 4));
      } else if (userAgent.indexOf('Chrome') > 0) {
        browser.name = 'Chrome';
        browser.jsPrefix = 'webkit';
        browser.cssPrefix = '-webkit-';
        var index = userAgent.indexOf('Chrome/');
        browser.version = pInt(userAgent.substr(index + 7));
      } else if (userAgent.indexOf('Safari') > 0) {
        browser.name = 'Safari';
        browser.jsPrefix = 'webkit';
        browser.cssPrefix = '-webkit-';
        var index = userAgent.indexOf('Version/');
        browser.version = pInt(userAgent.substr(index + 8));
      } else if (userAgent.indexOf('Firefox') > 0) {
        browser.name = 'Firefox';
        browser.jsPrefix = 'Moz';
        browser.cssPrefix = '-moz-';
        var index = userAgent.indexOf('Firefox/');
        browser.version = pInt(userAgent.substr(index + 8));
      } else if (userAgent.indexOf('MSIE') > 0) {
        browser.name = 'Internet Explorer';
        browser.jsPrefix = 'ms';
        browser.cssPrefix = '-ms-';
        var index = userAgent.indexOf('MSIE');
        browser.version = pInt(userAgent.substr(index + 5));
      } else {
        browser = undefined;
      }
      return browser;
    };

    var loadSetStyle = function loadSetStyle(elementObj, paramsObj) {
      var docStyles = getComputedStyle(elementObj);
      var browser = loadDetectBrowser();

      for (var property in paramsObj) {
        if (paramsObj.hasOwnProperty(property)) {
          if (property in docStyles) {
            elementObj.style[property] = paramsObj[property];
          } else if (browser != undefined) {
            var propertyFix = browser.jsPrefix + property.charAt(0).toUpperCase() + property.slice(1);
            elementObj.style[propertyFix] = paramsObj[property];
          }
        }
      }
    };

    var ZCloader = function ZCloader(elemObj, customObj) {
      //Base Object with default configuration
      var baseObj = {
          type: 'zBars',
          scale: 1,
          duration: 1.2
        },
        style = document.getElementById('ZCloader');

      if (!ZCloader.style) {
        style = document.createElement('style');
        style.setAttribute('id', 'ZCloader');
        document.head.appendChild(style);
        ZCloader.style = true;
      }

      for (var config in customObj) {
        if (customObj.hasOwnProperty(config)) {
          baseObj[config] = customObj[config];
        }
      }

      var clr = baseObj.colors || ['rgb(204, 32, 50)', 'rgb(24, 153, 74)', 'rgb(1, 115, 178)', 'rgb(253, 208, 25)'];
      var clr1 = clr[0 % clr.length],
        clr2 = clr[1 % clr.length],
        clr3 = clr[2 % clr.length],
        clr4 = clr[3 % clr.length];

      var browser = loadDetectBrowser();
      var animString = '';
      if (browser === undefined) {
        browser = {};
        browser.cssPrefix = '';
      } else if (browser.name === 'Internet Explorer' && browser.version < 10) {
        baseObj.type = 'wheel';
      }

      if (!elemObj.loader) {
        var animBlock = document.createElement('div');

        if (baseObj.type == 'zBlocks') {
          if (!ZCloader.zBlocks) {
            var animString = "\n@".concat(browser.cssPrefix, "keyframes ").concat(baseObj.type, " {");
            animString += "0% { left:0px; top:0px; ".concat(browser.cssPrefix, "transform:rotate(0deg) scale(1)}");
            animString += "25% { left:40px; top:0px; ".concat(browser.cssPrefix, "transform:rotate(90deg) scale(0.5)}");
            animString += "50% { left:40px; top:40px; ".concat(browser.cssPrefix, "transform:rotate(180deg) scale(1.0)}");
            animString += "75% { left:0px; top:40px; ".concat(browser.cssPrefix, "transform:rotate(270deg) scale(0.5)}");
            animString += "100% { left:0px; top:0px; ".concat(browser.cssPrefix, "transform:rotate(360deg)scale(1)} }\n");
            style.innerHTML += animString;

            ZCloader.zBlocks = true;
          }

          loadSetStyle(animBlock, {
            display: 'inline-block',
            verticalAlign: 'middle',
            width: '70px',
            height: '70px',
            transform: "scale(".concat(baseObj.scale, ")")
          });

          var block1 = document.createElement('div');
          block1.innerHTML = '&nbsp';
          animBlock.appendChild(block1);
          loadSetStyle(block1, {
            backgroundColor: clr1,
            width: '30px',
            height: '30px',
            borderRadius: '1px',
            position: 'absolute',
            top: '0',
            left: '0',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out'
          });

          var block2 = document.createElement('div');
          block2.innerHTML = '&nbsp';
          animBlock.appendChild(block2);
          loadSetStyle(block2, {
            backgroundColor: clr2,
            width: '30px',
            height: '30px',
            borderRadius: '1px',
            position: 'absolute',
            top: '0',
            left: '0',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration / 4 * 1, "s")
          });

          var block3 = document.createElement('div');
          block3.innerHTML = '&nbsp';
          animBlock.appendChild(block3);
          loadSetStyle(block3, {
            backgroundColor: clr3,
            width: '30px',
            height: '30px',
            borderRadius: '1px',
            position: 'absolute',
            top: '0',
            left: '0',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration / 4 * 2, "s")
          });

          var block4 = document.createElement('div');
          block4.innerHTML = '&nbsp';
          animBlock.appendChild(block4);
          loadSetStyle(block4, {
            backgroundColor: clr4,
            width: '30px',
            height: '30px',
            borderRadius: '1px',
            position: 'absolute',
            top: '0',
            left: '0',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration / 4 * 3, "s")
          });

          elemObj.loader = true;
        } else if (baseObj.type == 'zCircle1') {
          if (!ZCloader.zCircle1) {
            var animString = "\n@".concat(browser.cssPrefix, "keyframes ").concat(baseObj.type, " { ");
            animString += "0% ,25%, 50%, 75%, 100%{ ".concat(browser.cssPrefix, "transform: scale(0.0);  } ");
            animString += "12.5%  { ".concat(browser.cssPrefix, "transform: scale(1.0); background-color: ").concat(clr1, ";}");
            animString += "37.5%  { ".concat(browser.cssPrefix, "transform: scale(1.0); background-color: ").concat(clr2, ";}");
            animString += "62.5%  { ".concat(browser.cssPrefix, "transform: scale(1.0); background-color: ").concat(clr3, ";}");
            animString += "87.5%  { ".concat(browser.cssPrefix, "transform: scale(1.0); background-color: ").concat(clr4, ";} }\n");
            style.innerHTML += animString;

            ZCloader.zCircle1 = true;
          }

          loadSetStyle(animBlock, {
            display: 'inline-block',
            verticalAlign: 'middle',
            width: '70px',
            height: '70px',
            transform: "scale(".concat(baseObj.scale, ")")
          });

          var circle = document.createElement('div');
          circle.innerHTML = '&nbsp';
          animBlock.appendChild(circle);
          loadSetStyle(circle, {
            width: '100%',
            height: '100%',
            borderRadius: '50%',
            opacity: '0.6',
            position: 'absolute',
            top: '0',
            left: '0',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out'
          });

          elemObj.loader = true;
        } else if (baseObj.type == 'zBars') {
          if (!ZCloader.zBars) {
            var animString = "\n@".concat(browser.cssPrefix, "keyframes ").concat(baseObj.type, " { ");
            animString += "0%, 40%, 100% { ".concat(browser.cssPrefix, "transform: scaleY(0.4) }");
            animString += "20% { ".concat(browser.cssPrefix, "transform: scaleY(1.0) } }\n");
            style.innerHTML += animString;

            ZCloader.zBars = true;
          }

          loadSetStyle(animBlock, {
            display: 'inline-block',
            verticalAlign: 'middle',
            width: '50px',
            height: '30px',
            textAlign: 'center',
            fontSize: '10px',
            transform: "scale(".concat(baseObj.scale, ")")
          });

          var bar1 = document.createElement('div');
          bar1.innerHTML = '&nbsp';
          animBlock.appendChild(bar1);
          loadSetStyle(bar1, {
            backgroundColor: clr1,
            marginLeft: '1px',
            display: 'inline-block',
            width: '6px',
            height: '100%',
            borderRadius: '1px',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out'
          });

          var bar2 = document.createElement('div');
          bar2.innerHTML = '&nbsp';
          animBlock.appendChild(bar2);
          loadSetStyle(bar2, {
            backgroundColor: clr2,
            marginLeft: '1px',
            display: 'inline-block',
            width: '6px',
            height: '100%',
            borderRadius: '1px',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration - 0.1, "s")
          });

          var bar3 = document.createElement('div');
          bar3.innerHTML = '&nbsp';
          animBlock.appendChild(bar3);
          loadSetStyle(bar3, {
            backgroundColor: clr3,
            marginLeft: '1px',
            display: 'inline-block',
            width: '6px',
            height: '100%',
            borderRadius: '1px',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration - 0.2, "s")
          });

          var bar4 = document.createElement('div');
          bar4.innerHTML = '&nbsp';
          animBlock.appendChild(bar4);
          loadSetStyle(bar4, {
            backgroundColor: clr4,
            marginLeft: '1px',
            display: 'inline-block',
            width: '6px',
            height: '100%',
            borderRadius: '1px',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration - 0.3, "s")
          });

          elemObj.loader = true;
        } else if (baseObj.type == 'zCircle2') {
          if (!ZCloader.zCircle2) {
            var animString = "\n@".concat(browser.cssPrefix, "keyframes ").concat(baseObj.type, " { ");
            animString += "0%, 80%, 100% { ".concat(browser.cssPrefix, "transform: scale(0.0) }");
            animString += "40% { ".concat(browser.cssPrefix, "transform: scale(1.0) } }\n");
            style.innerHTML += animString;

            ZCloader.zCircle2 = true;
          }

          loadSetStyle(animBlock, {
            display: 'inline-block',
            verticalAlign: 'middle',
            width: '72px',
            height: '18px',
            textAlign: 'center',
            fontSize: '10px',
            transform: "scale(".concat(baseObj.scale, ")")
          });

          var circ1 = document.createElement('div');
          circ1.innerHTML = '&nbsp';
          animBlock.appendChild(circ1);
          loadSetStyle(circ1, {
            backgroundColor: clr1,
            display: 'inline-block',
            width: '18px',
            height: '18px',
            borderRadius: '100%',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out'
          });

          var circ2 = document.createElement('div');
          circ2.innerHTML = '&nbsp';
          animBlock.appendChild(circ2);
          loadSetStyle(circ2, {
            backgroundColor: clr2,
            display: 'inline-block',
            width: '18px',
            height: '18px',
            borderRadius: '100%',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration - 0.2, "s")
          });

          var circ3 = document.createElement('div');
          circ3.innerHTML = '&nbsp';
          animBlock.appendChild(circ3);
          loadSetStyle(circ3, {
            backgroundColor: clr3,
            display: 'inline-block',
            width: '18px',
            height: '18px',
            borderRadius: '100%',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration - 0.4, "s")
          });

          var circ4 = document.createElement('div');
          circ4.innerHTML = '&nbsp';
          animBlock.appendChild(circ4);
          loadSetStyle(circ4, {
            backgroundColor: clr4,
            display: 'inline-block',
            width: '18px',
            height: '18px',
            borderRadius: '100%',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'ease-in-out',
            animationDelay: "-".concat(baseObj.duration - 0.6, "s")
          });

          elemObj.loader = true;
        } else if (baseObj.type == 'zCrossBars') {
          if (!ZCloader.zCrossBars) {
            var animString = "\n@".concat(browser.cssPrefix, "keyframes ").concat(baseObj.type, " { ");
            animString += '0%{left:-50%;}';
            animString += '100%{left: 150%;} }\n';
            style.innerHTML += animString;

            ZCloader.zCrossBars = true;
          }

          loadSetStyle(animBlock, {
            display: 'inline-block',
            position: 'relative',
            verticalAlign: 'middle',
            width: '70px',
            height: '30px',
            boxSizing: 'border-box',
            borderWidth: '2px',
            borderStyle: 'solid',
            borderColor: 'rgb(160, 150, 150)',
            borderRadius: '8px',
            overflow: 'hidden',
            transform: "scale(".concat(baseObj.scale, ")")
          });

          var bar1 = document.createElement('div');
          bar1.innerHTML = '&nbsp';
          animBlock.appendChild(bar1);
          loadSetStyle(bar1, {
            backgroundColor: clr1,
            width: '10px',
            height: '100%',
            position: 'absolute',
            transform: 'rotate(45deg) scaleY(2)',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'linear',
            animationDelay: "-".concat(baseObj.duration, "s")
          });

          var bar2 = document.createElement('div');
          bar2.innerHTML = '&nbsp';
          animBlock.appendChild(bar2);
          loadSetStyle(bar2, {
            backgroundColor: clr2,
            width: '10px',
            height: '100%',
            position: 'absolute',
            transform: 'rotate(45deg) scaleY(2)',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'linear',
            animationDelay: "-".concat(baseObj.duration / 100 * 80, "s")
          });

          var bar3 = document.createElement('div');
          bar3.innerHTML = '&nbsp';
          animBlock.appendChild(bar3);
          loadSetStyle(bar3, {
            backgroundColor: clr3,
            width: '10px',
            height: '100%',
            position: 'absolute',
            transform: 'rotate(45deg) scaleY(2)',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'linear',
            animationDelay: "-".concat(baseObj.duration / 100 * 60, "s")
          });

          var bar4 = document.createElement('div');
          bar4.innerHTML = '&nbsp';
          animBlock.appendChild(bar4);
          loadSetStyle(bar4, {
            backgroundColor: clr4,
            width: '10px',
            height: '100%',
            position: 'absolute',
            transform: 'rotate(45deg) scaleY(2)',
            animationName: baseObj.type,
            animationDuration: "".concat(baseObj.duration, "s"),
            animationIterationCount: 'infinite',
            animationTimingFunction: 'linear',
            animationDelay: "-".concat(baseObj.duration / 100 * 40, "s")
          });

          elemObj.loader = true;
        } else {
          loadSetStyle(animBlock, {
            display: 'inline-block',
            verticalAlign: 'middle',
            width: '30px',
            height: '30px',
            position: 'absolute',
            backgroundImage: "url('".concat(_imageFilePath, "loader_").concat(baseObj.type, ".gif')"),
            backgroundSize: '30px 30px',
            backgroundRepeat: 'no-repeat',
            backgroundPosition: 'center'
          });
        }

        // elemObj.stopLoader = function() {
        //     elemObj.removeChild(animBlock);
        //     elemObj.loader = false;
        //     delete elemObj.stopLoader;
        // }
        return animBlock;
      }
    };

    //series-parser-helpers.js

    function getAllSeriesTypes(userData) {
      var data = userData.seriesdata;
      if (!data || !data.chartdata) {
        return [];
      }

      var globalSeriesType = data.type,
        chartNames = [],
        _addChartType = function _addChartType(series) {
          var type = series.type || globalSeriesType,
            chartName;

          if (typeof type === 'number') {
            //Trash
            chartName = charttypenames.get(type);
          } else {
            chartName = type.toLowerCase();
          }

          chartNames.push(chartName);
        },
        facetRendering = userData.facets;

      if (facetRendering) {
        hierarchyTraverse(data.chartdata, _addChartType);
      } else {
        data.chartdata.forEach(_addChartType);
      }

      return chartNames;
    }

    function hierarchyTraverse(data, callback) {
      data.forEach(function (_) {
        callback(_);
        if (_.data) {
          hierarchyTraverse(_.data, callback);
        }
      });
    }

    //$Id$

    var svg_clips = function svg_clips() {};

    svg_clips.polygon = function (properties, clipID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var clipElement = svg_clips.createElement(PATH_ELEMENT, clipID, chartObj, renderToSvg);
      svg_clips.setAttributes(clipElement, properties, ['d']);
      return clipID;
    };

    svg_clips.rect = function (properties, clipID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var clipElement = svg_clips.createElement(RECT_ELEMENT, clipID, chartObj, renderToSvg);
      svg_clips.setAttributes(clipElement, properties, ['x', 'y', 'width', 'height']);
      return clipID;
    };

    svg_clips.circle = function (properties, clipID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var clipElement = svg_clips.createElement(CIRCLE_ELEMENT, clipID, chartObj, renderToSvg);
      svg_clips.setAttributes(clipElement, properties, ['cx', 'cy', 'r']);
      return clipID;
    };

    svg_clips.createElement = function (elementName, clipID, chartObj, renderToSvg) {
      var patternSvg = chartObj.getPatternSvg();
      var svg = $Browser.SAFARI ? chartObj.svg || patternSvg : renderToSvg || patternSvg; //Element order is important in safari. If the clipPath is appended on $ZCG.patternSVG, transition is not working properly

      var parent = createElement('clipPath', "#".concat(clipID), [1], svg.select('defs'));

      return createElement(elementName, '.clip', [1], parent);
    };

    svg_clips.setAttributes = function (clipElement, properties, attributes) {
      attributes.forEach(function (attr) {
        clipElement.attr(attr, properties[attr]);
      });
    };

    effects.svg_clips = svg_clips;

    //$Id$

    function getAnimationConf(commonPlotOptions, plotoptions, chartObj, cType) {
      var animationOptions =
        plotoptions && plotoptions.animation ?
        mergeJSON$1(commonPlotOptions.animation, plotoptions.animation, true) :
        commonPlotOptions.animation,
        globalAnimation = chartObj.systemConf.chart.plot.animation,
        obj = {},
        easingType =
        animationOptions.easingType ||
        globalAnimation.easingType || (
        /(scatter|bubble$|packedbubble|heatmap)/.test(cType) ? 'cubic-in-out' : null) ||
        'linear'; //bubble$ - bubblepie chart shouldnot pass this case

      if (isDocumentVisible() || chartObj.isHiddenCoainer || chartObj.disableAnimation) {
        obj.enabled = false;
      } else {
        obj.enabled = datacount_based_intelligence(chartObj, 'animation') ?
        getValByPriority([animationOptions, globalAnimation], 'enabled') :
        false;
      }
      obj.enabled = window.rendererMode == 'canvas' ? cType == 'dial' : obj.enabled;
      obj.type = animationOptions.type;
      obj.easingType = d3_ease(easingType);
      obj.duration = !obj.enabled ? 0 : validateNullVal(animationOptions.duration, +(globalAnimation.duration || defaultDuration()));
      return obj;

      function defaultDuration() {
        return /(bar|bullet|gantt|waterfall)/.test(cType) ?
        300 :
        /(line|area|arearange)/.test(cType) ?
        600 :
        /(scatter|bubble$|funnel|pyramid|heatmap)/.test(cType) ?
        1000 //bubble$ - bubblepie chart shouldnot pass this case
        : 500;
      }
    }

    function interTween(
    baseData,
    basedataShift,
    serData,
    categories,
    animationType,
    easingType,
    transitionDuration,
    rp,
    layout,
    eleEnter,
    chartName)
    {
      var isPointTween = animationType == POINTTWEEN_ANIMATION;
      var dataset = rp.dataset,
        yaxiscolumnorder = rp.yaxiscolumnorder;
      var count = isPointTween ? 0 : -1;
      var len = serData.length;
      var interTweenDuration = transitionDuration; //Negative Duration not supported in D3V4, hence removed delay 17
      var duration = mathRound(interTweenDuration / (isPointTween ? categories.length - 1 : len));
      tween();

      function tween() {
        count++;
        if (isPointTween) {
          for (var j = 0; j < len; j++) {
            baseData[j] = serData[j < count ? j : mathMax(0, count - 1)];
            basedataShift[j] = serData[j < count ? j : count];
          }
        } else {
          baseData[count - 1] = serData[count - 1];
          basedataShift[count] = serData[count];
        }
        if (count < len) {
          var del = count == 1 && isPointTween ? (categories.indexOf(dataset.getX(serData[0])) - (count - 1)) * duration : 0,
            dur =
            (isPointTween ?
            categories.indexOf(dataset.getX(serData[count])) - categories.indexOf(dataset.getX(serData[count - 1])) :
            1) * duration,
            notNull = isPointTween ?
            dataset.getY(serData[count], yaxiscolumnorder) != null &&
            dataset.getY(serData[mathMax(0, count - 1)], yaxiscolumnorder) != null :
            dataset.getY(serData[count], yaxiscolumnorder) != null;
          if (notNull) {
            eleEnter.
            attrs(layout(baseData)).
            transition().
            delay(del).
            duration(dur).
            ease(easingType).
            attrs(layout(basedataShift)).
            on(
            'end',
            chartName === SCATTER_CHARTNAME ?
            function (d, j) {
              if (j == len - 1) {
                tween();
              }
            } :
            tween);

          } else {
            tween();
          }
        }
      }
    }

    function flipTween(element) {
      var rad = d3_interpolate(0, mathPI);
      element.attrTween('transform', function () {
        var transform = d3_select(this).attr('transform');
        return function (t) {
          return "".concat(transform, " matrix(").concat(mathCos(rad(t)), ",0,0,1,0,0)");
        };
      });
    }

    function fadeTween(element) {
      var opacity = d3_interpolate(0, 1);
      element.styleTween('opacity', function () {
        return function (t) {
          return opacity(t);
        };
      });
    }

    function scaleTween(element) {
      var scaleObj = d3_interpolate(0, 1);
      element.attrTween('transform', function () {
        var transform = d3_select(this).attr('transform') || '';
        return function (t) {
          return "".concat(transform, " scale(").concat(scaleObj(t), ")");
        };
      });
    }

    function cancelAnimation(element) {
      element.interrupt();
    }

    function getDynamicSeriesPosition(chartObj, index) {
      var position,
        params = chartObj.renderer[index].commonRendererProp().params,
        dynamicPos = params.dynamicSeriesPosition,
        datasetIndex = params.datasetIndex,
        addRemoveInfo = chartObj.seriesAddRemoveDetails;
      if (addRemoveInfo.seriesAdded) {
        var seriesPositionMap = addRemoveInfo.seriesPositionMap;
        if (seriesPositionMap.get(index)) {
          position = seriesPositionMap.get(index);
        } else {
          if (!isUndefined(dynamicPos)) {
            position = dynamicPos;
          } else {
            position = datasetIndex;
          }
        }
      } else if (chartObj.seriesAddRemoveDetails.seriesRemoved) {
        if (!isUndefined(dynamicPos)) {
          position = dynamicPos;
        } else {
          position = datasetIndex;
        }
      } else if (dynamicPos) {
        position = dynamicPos;
      }
      return position;
    }
    /*
       _  ->chart.seriesAddRemoveDetails
    */
    function updateAddRemoveSeriesProperty(_, mode, seriesDataLength) {
      if (isUndefined(_)) {
        _ = {};
      }
      if (mode === 'add') {
        _.seriesAdded = true;
        _.seriesPositionMap = d3_map();
        if (_.seriesRemoved) {
          _.seriesRemoved = false;
        }
      } else if (mode === 'remove') {
        _.seriesRemoved = true;
        if (_.seriesAdded) {
          _.seriesAdded = false;
          delete _.seriesPositionMap;
        }
      }
      if (isUndefined(_.maxDOMseriesIndex)) {
        if (!seriesDataLength) {
          _.maxDOMseriesIndex = 0;
        } else {
          _.maxDOMseriesIndex = seriesDataLength - 1;
        }
      }
      _.seriesAddRemovePhase = true;

      return _;
    }

    //$Id$

    plot.rendererConf = function () {
      var renderer = {};
      renderer.params = {};

      renderer.dynamicSeriesPosition = function (_) {
        if (!arguments.length) {
          return renderer.params.dynamicSeriesPosition;
        }
        renderer.params.dynamicSeriesPosition = _;
        return renderer;
      };
      renderer.xscale = function (_) {
        if (!arguments.length) {
          return renderer.params.xscale;
        }
        renderer.params.xscale = _;
        return renderer;
      };

      renderer.yscale = function (_) {
        if (!arguments.length) {
          return renderer.params.yscale;
        }
        renderer.params.yscale = _;
        return renderer;
      };

      renderer.shapescale = function (_) {
        if (!arguments.length) {
          return renderer.params.shapescale;
        }
        renderer.params.shapescale = _;
        return renderer;
      };

      renderer.stacked = function (_) {
        if (!arguments.length) {
          return renderer.params.stacked;
        }
        renderer.params.stacked = _;
        return renderer;
      };

      renderer.datasetIndex = function (_) {
        if (!arguments.length) {
          return renderer.params.datasetIndex;
        }
        renderer.params.datasetIndex = _;
        return renderer;
      };
      renderer.renderingOrderIndex = function (_) {
        if (!arguments.length) {
          return renderer.params.renderingOrderIndex;
        }
        renderer.params.renderingOrderIndex = _;
        return renderer;
      };
      renderer.legendOrderIndex = function (_) {
        if (!arguments.length) {
          return renderer.params.legendOrderIndex;
        }
        renderer.params.legendOrderIndex = _;
        return renderer;
      };
      renderer.rendererIndex = function (_) {
        if (!arguments.length) {
          return renderer.params.rendererIndex;
        }
        renderer.params.rendererIndex = _;
        return renderer;
      };

      renderer.axisrotated = function (_) {
        if (!arguments.length) {
          return renderer.params.axisrotated;
        }
        renderer.params.axisrotated = _;
        return renderer;
      };

      renderer.commonPlotOptions = function (_) {
        if (!arguments.length) {
          return renderer.params.commonPlotOptions;
        }
        renderer.params.commonPlotOptions = _;
        return renderer;
      };

      renderer.color = function (_) {
        if (!arguments.length) {
          return renderer.params.color;
        }
        renderer.params.color = _;
        return renderer;
      };

      renderer.paneColor = function (_) {
        if (!arguments.length) {
          return renderer.params.paneColor;
        }
        renderer.params.paneColor = _;
        return renderer;
      };

      renderer.chartObj = function (_) {
        if (!arguments.length) {
          return renderer.params.chartObj;
        }
        renderer.params.chartObj = _;
        return renderer;
      };

      renderer.notes = function (_) {
        if (!arguments.length) {
          return renderer.params.notesArray;
        }
        renderer.params.notesArray = _;
        return renderer;
      };

      renderer.updateLabelArrayAndLabelQueue = function (la, lq) {
        if (!arguments.length) {
          return [renderer.params.labelArray, renderer.params.labelQueue];
        }
        renderer.params.labelArray = la;
        renderer.params.labelQueue = lq;
        return renderer;
      };

      renderer.hasNegValue = function (_) {
        if (!arguments.length) {
          return renderer.params.hasNegValue;
        }
        renderer.params.hasNegValue = _;
        return renderer;
      };

      renderer.dataset = function (_) {
        if (!arguments.length) {
          return renderer.params.dataset;
        }
        renderer.params.dataset = _;
        return renderer;
      };

      renderer.yaxiscolumnorder = function (_) {
        if (!arguments.length) {
          return renderer.params.yaxiscolumnorder;
        }
        renderer.params.yaxiscolumnorder = _;
        return renderer;
      };

      renderer.threshold = function (_) {
        if (!arguments.length) {
          return renderer.params.threshold;
        }
        renderer.params.threshold = _;
        return renderer;
      };

      renderer.thresholdType = function (_) {
        if (!arguments.length) {
          return renderer.params.thresholdType;
        }
        renderer.params.thresholdType = _;
        return renderer;
      };

      renderer.colorOverlay = function (_) {
        if (!arguments.length) {
          return renderer.params.colorOverlay;
        }
        renderer.params.colorOverlay = _;
        return renderer;
      };

      renderer.bound = function (_) {
        if (!arguments.length) {
          return renderer.params.bound;
        }
        renderer.params.bound = _;
        return renderer;
      };

      renderer.legendIndex = function (_) {
        if (!arguments.length) {
          return renderer.params.legendIndex;
        }
        renderer.params.legendIndex = _;
        return renderer;
      };

      renderer.legendOrder = function (_) {
        if (!arguments.length) {
          return renderer.params.legendOrder;
        }
        renderer.params.legendOrder = _;
        return renderer;
      };

      return renderer;
    };

    //$Id$

    plot.render = function (chartObj) {
      var mode = chartObj.systemConf.chart.plot.renderer.mode.toLowerCase();

      var render = {
          mode: hasSvgOnly(chartObj) ? 'svg' : mode.toLocaleLowerCase()
        },
        args = {};

      args.labelQueue = [];
      args.notesArray = [];
      args.labelArray = {};

      if (!chartObj.rendererConf) {
        chartObj.rendererConf = [];
      }

      if (typeof plot["".concat(render.mode, "Renderer")] === 'function') {
        render[render.mode] = plot["".concat(render.mode, "Renderer")](chartObj, args);
      } else {
        throw new SyntaxError("".concat(render.mode, "Renderer not found"));
      }

      render.draw = function (update) {
        chartObj.chartRendered = false;
        args.labelArray = {};
        args.labelQueue = [];
        chartObj.annotation = { events: [] }; // TODO: check
        this[this.mode].draw(update);

        var _annotationDelay = annotationDelay(chartObj);
        if (_annotationDelay !== 'chartRendered') {
          chartObj.timerObj[chartObj.timerObj.length] = setTimeout(function () {
            renderAnnotation(chartObj, args);
          }, _annotationDelay);
        }
      };
      return render;
    };

    renderer_helpers.renderCompletedEvents = function (chartObj, update, args, callback) {
      var systemconf = chartObj.systemConf,
        isDialChart = chartObj.dataObject.hasLevelMarker && !chartObj.isAxisCategory,
        DoWaitForChartRendered = wait4Rendered(chartObj),
        renderer = chartObj.renderer,
        k,
        axesRendered = false;
      // var labelHolder = chartObj.staticPaneSVG.select(".labelholder").style("opacity", 0);

      if (chartObj._isAxisCategory() || chartObj.dataObject.isPolarAxisCategory) {
        chartObj.timerObj[chartObj.timerObj.length] = setTimeout(function () {
          axesRendered = true;
        }, chartObj.axes.animationDuration + 17);
      } else {
        axesRendered = true;
      }

      var checkRendered = function checkRendered() {
        if (isDocumentVisible()) {
          chartObj.chartRendered = true;
        }

        if (chartObj.destroying) {
          clearInterval(timer);
          return true;
        }

        k = renderer.length;
        while (k--) {
          if (renderer[k].chartRendered !== true || !axesRendered) {
            return false;
          }
          // args.notesArray = renderer[k].commonRendererProp().notes();
        }
        proceed();

        clearInterval(timer);

        if (isFunction(callback)) {
          callback();
        } else {
          // ZC1740
          chartObj.updating = false;
          chartObj.chartRendered = true;
        }

        return true;
      };

      function proceed() {
        try {
          // labelHolder.transition().duration(250).style("opacity", 1);

          // fixes #ZC1767 (ticks hiding on chrome while scrolling)
          if (chartObj.divScroll && $Browser.CHROME) {
            chartObj.divScroll.fixScrollView(true, chartObj.canvasarea, chartObj);
          }
          if (chartObj.viewFlow && chartObj.viewFlow.marks._custom.length) {
            chartObj.viewFlow.marks._custom.map(function (mark) {
              var parser = invokeFunction(mark.mark.parser, chartObj);
              renderDom(parser);
            });

          }
          stateChangeListener(chartObj, systemconf.chart.plot.events, 'plot', update ? 'onreload' : 'onload');
          callDatalableAndAnnotationRenderer(chartObj, args, !(DoWaitForChartRendered && update), update);
          chartObj.handleHiddenContainer(true);
          chartObj.timerObj[chartObj.timerObj.length] = setTimeout(function () {
            // setTimeout is needed for Analytics - Dial chart export as HTML issue
            stateChangeListener(chartObj, systemconf.canvas.events, 'chart', update ? 'onreload' : 'onload');
          }, 30);
        } catch (err) {
          VizLayout.helpers.handleErrors(chartObj, err);
        }

        // reset the chart phase
        chartObj.phase = null;
      }

      var timer = chartObj.timerObj[chartObj.timerObj.length] = setInterval(checkRendered, 1000 / 60);

      if (DoWaitForChartRendered) {
        callDatalableAndAnnotationRenderer(chartObj, args, isDialChart || update, update);
      }
    };
    function getChartName(chartName) {
      switch (chartName) {
        case 'waterfall':
        case 'gantt':
        case 'boxplot':
        case 'bullet':
        case 'barrange':{
            chartName = 'bar';
            break;
          }
        case 'web':
        case 'arearange':{
            chartName = 'area';
            break;
          }
        case 'bubble':
        case 'geobubble':
        case 'geoscatter':{
            chartName = 'scatter';
            break;
          }
        case 'bubblepie':
        case 'geobubblepie':{
            chartName = 'bubblepie';
            break;
          }}

      return chartName;
    }

    function callDatalableAndAnnotationRenderer(chartObj, args, enable, update) {
      var systemConf = chartObj.systemConf,
        dataLabels = systemConf.chart.plot.datalabels;
      if (chartObj.systemConf.__$overview) {
        return false;
      }
      /*
       * It will call datalabels renderer and annotation renderer
       */
      if (enable) {
        if (labelRenderer && args.labelQueue.length && !dataLabels.renderOnInit) {
          //MODULARIZE
          var datalabelEvents = dataLabels.events;

          stateChangeListener(chartObj, datalabelEvents, 'plot', 'init');

          var dataLabelComponent = Registry.getComponent('labelRenderer');
          dataLabelComponent(args.labelQueue, args.labelArray, chartObj);
          stateChangeListener(chartObj, datalabelEvents, 'plot', update ? 'onreload' : 'onload');
        }
        args.labelArray = {};
        args.labelQueue = [];
        if (annotationDelay(chartObj) === 'chartRendered') {
          if (chartObj.dataObject.isFlowChartCategory) {
            renderAnnotation(chartObj, args);
          } else {
            chartObj.timerObj[chartObj.timerObj.length] = setTimeout(function () {
              renderAnnotation(chartObj, args);
            }, 17);
          }
        }
      }
    }

    function renderAnnotation(chartObj, args) {
      var notes = chartObj.systemConf.notes,
        notesEnabled = defined(notes) && notes.enabled === true,
        notesArray;

      if (notesEnabled) {
        var _annotation = Registry.getComponent('annotation');
        if (!_annotation._empty) {
          notesArray = _annotation.draw(chartObj, args.notesArray);

          // ZC3288 - on redraw it needs some time
          setTimeout(function () {
            pick(isObjectPropDefined(chartObj, 'annotation.flatten', true), []).forEach(function (_) {return _();});
          }, 0);
        }
      } else {
        chartObj.notes.selectAll('*').remove();
        chartObj.container.selectAll('g.zc-annotation').remove(); // annotations with custom parent
      }

      args.notesArray = notesArray || [];
    }

    function annotationDelay(chartObj) {
      return pick(isObjectPropDefined(chartObj.systemConf, 'notes.animation.delay', true), 'chartRendered');
    }

    function wait4Rendered(chartObj) {
      var dataObject = chartObj.dataObject;

      if (isFacet(chartObj)) {
        var allDistinctSeriesTypes_val = chartObj.distinctChartTypes || getDistinct(getAllSeriesTypes(chartObj.userdata)),
          allDistinctSeriesTypes = allDistinctSeriesTypes_val.map(function (_) {return charttype[_];});
        return allDistinctSeriesTypes.every(function (chartType) {return arrayIncludes(chartcategory.axis, chartType);});
      }

      var isDialChart = dataObject.hasLevelMarker && !dataObject.isAxisCategory;
      return (
        (dataObject.isAxisCategory || dataObject.isPolarAxisCategory) && !dataObject.pieWithAxis ||
        isDialChart ||
        chartObj.isGeoMap && !dataObject.hasBubblePie);

    }

    renderer_helpers.arrangeSeriesRenderingOrder = function (chartObj, data, startIdx, facets) {
      var seriesdata = data || chartObj.seriesdata,
        dataProcessorHelpers = DataProcessor.helpers;

      if (chartObj.dataObject.isCombinationalChart) {
        var order = {
            defaultType: 0,
            area: 0,
            arearange: 0,
            geoheatmap: 0,
            bar: 1,
            barrange: 1,
            line: 2,
            bubble: 3,
            geobubble: 3,
            bubblepie: 4,
            geobubblepie: 4,
            scatter: 5,
            geoscatter: 5
          },
          globalChartType = chartObj.userdata.seriesdata.type;

        if (facets) {
          seriesdata = data.map(function (d) {
            return d.node;
          });
        }
        var seriesdata_cpy = simpleClone(seriesdata);
        var counter = startIdx || 0;
        seriesdata_cpy.map(function (d, i) {
          d.counter = i;
          d.seriesidx = counter++;
          return d;
        });
        seriesdata_cpy.sort(function (a, b) {
          var type1 = dataProcessorHelpers.getChartType(a.type || globalChartType, 'string'),
            type2 = dataProcessorHelpers.getChartType(b.type || globalChartType, 'string');
          var order1 = order[type1] == null ? order.defaultType : order[type1],
            order2 = order[type2] == null ? order.defaultType : order[type2],
            seriesidx1 = a.seriesidx,
            seriesidx2 = b.seriesidx;
          return order1 < order2 ?
          -1 :
          order1 > order2 ?
          1 //Arrange by chart type
          : seriesidx1 < seriesidx2 ?
          -1 :
          seriesidx1 > seriesidx2 ?
          1 :
          0; //Arrange by series index
        });
        if (facets) {
          return data.map(function (d, i) {
            d.node = seriesdata[seriesdata_cpy[i].counter];
            return d;
          });
        }
        return seriesdata_cpy;
      }
      return seriesdata;
    };

    renderer_helpers.setRendererProp = function (chartObj, renderer, seriesdata, index, renderingOrder, args, rendererIdx, charttype, layerIdx) {
      rendererIdx = pick(rendererIdx, index);
      //index - legendIndex -
      //renderingOrder - sorted seriesdata for combochart
      //rendererIdx - for grids refers overall serial counter
      var cTypeObj = chartObj.chartTypes[index];
      var cType = charttype ? charttypenames.get(charttype) : cTypeObj.name;
      var cTypeNumeric = charttype || cTypeObj.value;
      var systemconf = chartObj.systemConf,
        helpers = DataProcessor.helpers;
      var hierarchical = chartObj.dataObject.hierarchical,
        facetRendering = hierarchical && hierarchical.facetRendering,
        rowList,
        columnList,
        rowCount,
        clustersCount,
        hasMultiCluster,
        hasMultiLayers,
        columnLeavesCount,
        layers;

      if (facetRendering) {
        rowList = hierarchical.pivotLayout.getRootNodeList('row'),
        columnList = hierarchical.pivotLayout.getRootNodeList('column'),
        rowCount = rowList.getCount(),
        clustersCount = rowList.getClustersCount(),
        hasMultiCluster = rowList.hasMultiCluster(),
        columnLeavesCount = columnList.getLeavesCount(),
        layers = hierarchical.pivotLayout.layers.groups[layerIdx],
        hasMultiLayers = hasMultiCluster ? hierarchical.pivotLayout.layers.isLayerNode : false;
        var gridOptions = hierarchical.gridOptions,
          paneid = "".concat(seriesdata[index].row, "_").concat(seriesdata[index].column);
        if (gridOptions[paneid]) {
          gridOptions[paneid].renderer[index] = renderer;
        }
      }
      var legendIdx = facetRendering ? layers.indexOf(seriesdata[index].value) : index;
      setCommonRendererProp(renderer, seriesdata, index, cType, cTypeNumeric, legendIdx, rendererIdx);
      renderer.commonRendererProp(chartObj.rendererConf[rendererIdx]);
      var yaxiscolumnorder = hasMultiLayers ?
      seriesdata[legendIdx].parent.node.yaxiscolumnorder :
      chartObj.seriesdata[index].yaxiscolumnorder;
      var data = hasMultiLayers ? seriesdata[legendIdx] : chartObj.seriesdata[legendIdx];
      var yscindex = helpers.getParsedYAxisOrder(yaxiscolumnorder);

      renderer.chartRendered = false;

      if (chartObj._isAxisCategory() || chartObj.dataObject.isPolarAxisCategory) {
        var yaxis = chartObj.axes.y.groups[yscindex];
        var ysc = yaxis.scale || chartObj.axes.y.groups[0].scale;

        var yscidx = facetRendering && (hasMultiCluster || rowCount) ? seriesdata[index].row || 0 : null,
          xscale = facetRendering ?
          columnLeavesCount > 1 ?
          chartObj.axes.x.leaves[seriesdata[index].column].scale :
          chartObj.axes.x.leafScaleGrid :
          chartObj.axes.x.scale,
          yscale = facetRendering && (hasMultiCluster || rowCount) ? chartObj.axes.y.leaves[yscidx].scale : ysc;
        var dynamicSeriesPosition = chartObj.renderer[index].commonRendererProp().params.dynamicSeriesPosition;
        if (chartObj.seriesAddRemoveDetails && chartObj.seriesAddRemoveDetails.seriesAddRemovePhase) {
          dynamicSeriesPosition = getDynamicSeriesPosition(chartObj, index);
        }

        chartObj.rendererConf[rendererIdx].
        dynamicSeriesPosition(dynamicSeriesPosition).
        xscale(xscale).
        yscale(yscale).
        shapescale(defined(chartObj.dataset.shapeidx) ? arrayFind(chartObj.scales, function (_) {return _.id === 'shape-0';}).getScale() : null).
        datasetIndex(index).
        renderingOrderIndex(renderingOrder).
        legendOrderIndex(index).
        legendIndex(legendIdx) // TODO: check legendOrderIndex, datasetIndex
        .legendOrder(layerIdx) // TODO: check legendOrderIndex, datasetIndex
        .rendererIndex(rendererIdx).
        axisrotated(chartObj.axes.rotated).
        hasNegValue(chartObj.dataObject.containsNegativeData(yscindex)).
        stacked(chartObj.dataObject.isstacked(cTypeNumeric));

        args.labelArray = chartObj.rendererConf[rendererIdx].params.labelArray;
        args.labelQueue = chartObj.rendererConf[rendererIdx].params.labelQueue;
      }

      if (chartObj.dataObject.isFlowChartCategory) {
        chartObj.rendererConf[rendererIdx].datasetIndex(index);
      }

      if (isBarChartType(cTypeNumeric) && !isHeatMapChartType(cTypeNumeric)) {
        renderer.bandwidth1(chartObj.barscale1).bandwidth2(chartObj.barscale2);
        args.barDatasetIndex = facetRendering && chartObj.barscale2.domain().length > 1 ? legendIdx : args.barDatasetIndex; //TODO for pivot with subseries data , pivot2 case
        if (!args.image) {
          renderer.barDatasetIndex(args.barDatasetIndex);
        }
        if (data.disabled == null || !data.disabled) {
          args.barDatasetIndex = args.barDatasetIndex + data.data.length;
        }
      }

      if (isWaterfallChartType(cTypeNumeric)) {
        var commonParams = chartObj.rendererConf[rendererIdx].params;
        commonParams.categoryColorConfig = renderer_helpers.getWaterfallCategoriesConfig(
        chartObj.seriesdata[index].plotoptions,
        commonParams.commonPlotOptions);

      }

      chartObj.rendererConf[rendererIdx].bound(renderer_helpers.getBound(chartObj, seriesdata[index]));

      function setCommonRendererProp(renderer, seriesdata, index, cType, actualCType, legendIdx, rendererIdx) {
        var hierarchical = chartObj.dataObject.hierarchical,
          facetRendering = hierarchical && hierarchical.facetRendering,
          paneColor = facetRendering && seriesdata[legendIdx] ? seriesdata[legendIdx].node.color : null,
          hasMultiCluster = facetRendering && hierarchical.pivotLayout.rows && hierarchical.pivotLayout.rows.hasMultiCluster(),
          hasMultiLayers = hasMultiCluster ? hierarchical.pivotLayout.layers.isLayerNode : false;

        var currentseriesdata = facetRendering && hasMultiLayers ? seriesdata[legendIdx].node : chartObj.seriesdata[legendIdx];
        var paneid = seriesdata[index] ? "".concat(seriesdata[index].row, "_").concat(seriesdata[index].column) : '0_0';
        var seriesClr = facetRendering ?
        getChartSeriesColor(chartObj, paneid, index) :
        currentseriesdata.color || getChartSeriesColor(chartObj, paneid, index); //previously it is legendIdx; Now values are properly updated in gridoptions
        var yaxiscolumnorder = hasMultiLayers ?
        seriesdata[legendIdx].parent.node.yaxiscolumnorder :
        chartObj.seriesdata[index].yaxiscolumnorder;
        var yscindex =
        facetRendering && hierarchical.hasRows() ?
        getLeafAxisOrder(seriesdata[index].row || 0, null, 'y', chartObj) :
        helpers.getParsedYAxisOrder(yaxiscolumnorder);
        var commonProp = chartObj.rendererConf[rendererIdx];
        commonProp.
        chartObj(chartObj).
        dataset(chartObj.dataset).
        yaxiscolumnorder(yscindex).
        commonPlotOptions(chartObj.systemConf.chart.plot.plotoptions[cType]).
        color(
        cType == 'bubblepie' ?
        chartObj.seriesColor :
        chartObj.isAxisCategory ?
        checkNgetColorOverlayData(renderer, seriesdata, seriesClr, index, yscindex, cType, rendererIdx) :
        chartObj.dataObject.isPolarAxisCategory || hasColorColumnInNonAxis(chartObj) ?
        seriesClr :
        chartObj.seriesColor).

        paneColor(paneColor).
        notes(args.notesArray).
        updateLabelArrayAndLabelQueue(args.labelArray, args.labelQueue);
      }

      function checkNgetColorOverlayData(renderer, seriesdata, seriesClr, index, yscindex, cType, rendererIdx) {
        var xaxis_userdata = isObjectPropDefined(chartObj.userdata, 'chart.axes.xaxis') ? chartObj.userdata.chart.axes.xaxis : {},
          yaxes_userdata = isObjectPropDefined(chartObj.userdata, 'chart.axes.yaxis') ? chartObj.userdata.chart.axes.yaxis : {},
          yaxes_threshold = yaxes_userdata != null && yaxes_userdata[yscindex] != null && yaxes_userdata[yscindex].threshold != null ? yaxes_userdata[yscindex].threshold : null,
          xaxis_threshold = isObjectPropDefined(xaxis_userdata, 'threshold') ? xaxis_userdata.threshold : null;
        var thOverlay_data_x = xaxis_threshold ? xaxis_threshold.coloroverlay || {} : {};
        var thOverlay_data_y = yaxes_threshold ? yaxes_threshold.coloroverlay || {} : {};
        var showColorOverlay = thOverlay_data_x.show || thOverlay_data_y != null && thOverlay_data_y.show;
        if (!showColorOverlay) {
          return seriesClr;
        } else {
          var type = thOverlay_data_y != null && thOverlay_data_y.show ? 'y' : thOverlay_data_x.show ? 'x' : null,
            overlayData =
            thOverlay_data_y != null && thOverlay_data_y.show ? thOverlay_data_y : thOverlay_data_x.show ? thOverlay_data_x : null;
          var negThreshType = thOverlay_data_y != null && thOverlay_data_y.show ? 'y' : thOverlay_data_x.show ? 'x' : null;
          var colorOverlay = showColorOverlay ? axis.threshold.overlay(chartObj, 'continous') : null,
            axisOrder = negThreshType === 'y' ? yscindex : 0;

          chartObj.rendererConf[rendererIdx].
          threshold(showColorOverlay ? overlayData : null).
          thresholdType(negThreshType).
          colorOverlay(showColorOverlay ? axis.threshold.overlay(chartObj, 'discrete', type, overlayData) : null);

          return cType == 'bar' || cType == 'scatter' || cType == 'bubble' ?
          seriesClr :
          colorOverlay(seriesClr, overlayData, axisOrder, negThreshType);
        }
      }
    };

    renderer_helpers.getBound = function (chartObj, gridData) {
      var hierarchical = chartObj.dataObject.hierarchical,
        facetRendering = hierarchical && hierarchical.facetRendering;

      if (facetRendering) {
        var row = gridData.row,column = gridData.column,
          pivotLayout = hierarchical.pivotLayout,
          columnList = pivotLayout.columns,
          rowList = pivotLayout.rows,
          columnSize = columnList.leafSize,
          rowSize = rowList.leafSize,

          firstColumnBranchCount = columnList.count ? columnList.branches[0].domain.length : 1,
          firstRowBranchCount = rowList.count ? rowList.branches[0].domain.length : 1,

          columnCount = firstColumnBranchCount * columnList.clustersCount,
          rowCount = firstRowBranchCount * rowList.clustersCount,

          columnBranchCount = columnList.branches.length,
          rowBranchCount = rowList.branches.length,

          x,
          y,
          width,
          height,
          polar = chartObj.cache.polar && chartObj.cache.polar["".concat(row, "-").concat(column)],
          xReversed = columnBranchCount && getAxisData(chartObj, 'x', 0).reversed,
          yReversed = rowBranchCount && getAxisData(chartObj, 'y', 0).reversed;

        if (chartObj.axes.rotated) {
          x = (yReversed ? rowCount - row - 1 : row) * rowSize;
          y = (xReversed ? column : columnCount - column - 1) * columnSize;
          width = rowSize;
          height = columnSize;
        } else {
          x = (xReversed ? columnCount - column - 1 : column) * columnSize;
          y = (yReversed ? rowCount - row - 1 : row) * rowSize;
          width = columnSize;
          height = rowSize;
        }

        return { width: width || 0, height: height || 0, x: x || 0, y: y || 0, polar: polar };
      } else {
        var _chartObj$plotarea3 = chartObj.plotarea,_width2 = _chartObj$plotarea3.width,_height2 = _chartObj$plotarea3.height,
          _polar = chartObj.plotarea_approx;
        return _defineProperty({ width: _width2, height: _height2, polar: _polar, x: 0, y: 0, left: 0, top: 0 }, "polar", _polar);
      }
    };

    renderer_helpers.saveSeriesdataInRenderer = function (chartObj, seriesIndex, rendererIndex) {
      rendererIndex = pick(rendererIndex, seriesIndex);
      var rp = chartObj.rendererConf[seriesIndex].params, // TODO: check the rendererConf for pivot
        xscale = rp.xscale,
        yscale = rp.yscale,
        yaxiscolumnorder = rp.yaxiscolumnorder,
        dataset = chartObj.dataset,
        datatypeX = dataset.getDataType('x'),
        datatypeY = dataset.getDataType('y', yaxiscolumnorder),
        currentseriesdata = chartObj.seriesdata[seriesIndex].data,
        renderer = chartObj.renderer[rendererIndex];

      if (datatypeX == ORDINAL_DATATYPE || datatypeY == ORDINAL_DATATYPE) {
        renderer.seriesdataAfterUpdate = [];
        var dataProcessorHelpers = DataProcessor.helpers,
          isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
          isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder),
          xCategories = datatypeX == ORDINAL_DATATYPE ? xscale.domain() : null,
          yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null;
        currentseriesdata.forEach(function (d, i) {
          renderer.seriesdataAfterUpdate[i] = chartObj.dataObject.updateSeriesdatabyCategories(
          d3_values(d),
          xCategories,
          yCategories,
          yaxiscolumnorder);

        });
      } else {
        renderer.seriesdataAfterUpdate = null;
      }
    };

    function hasSvgOnly(chartObj) {
      if (isFacet(chartObj)) {
        var gridList = getGridList(chartObj.dataObject);
        return gridList.some(function (grid) {
          var paneID = "".concat(grid.row, "_").concat(grid.column);
          var cType = getChartTypeByIndex(chartObj, paneID, 0).value;
          return arrayIncludes(chartcategory.svgOnly, cType);
        });
      } else {
        var cType = chartObj.chartTypes[0];
        return chartcategory.svgOnly.indexOf(cType.value) > -1 || chartObj.dataObject.pieWithAxis;
      }
    }

    //$Id$

    var canvas_plot_renderer = {};

    plot.canvasRenderer = function (chartObj, args) {

      var canvasRenderer = {};
      var systemconf = chartObj.systemConf,
        helpers = DataProcessor.helpers;

      canvasRenderer.draw = function (update) {
        var waitForOverview = chartObj.scroll && !chartObj.scroll.initialized && chartObj.scroll.visible;

        /**
         * Disable legendHighlight
         */
        //systemconf.legend.highlightEffect.selectedSeries = NONE;

        chartObj.container.select('.highlight-canvas').style('visibility', 'hidden');

        if (chartObj.canvasScrollGroup) {
          // for scroll chart, we are moving the canvases to a new group, that transformed to plot area with overflow hidden.
          // #ZC1770
          chartObj.context = updateCanvasContext(chartObj, 'zc-canvas', null, chartObj.canvasScrollGroup);
          chartObj.labelHolderContext = updateCanvasContext(chartObj, 'zc-labelholder-canvas', null, chartObj.canvasScrollGroup);
          chartObj.canvasScrollGroup.selectAll('canvas').styles({ left: 0, top: 0 });
        } else {
          chartObj.context = updateCanvasContext(chartObj, 'zc-canvas', '.static');
          chartObj.labelHolderContext = updateCanvasContext(
          chartObj,
          'zc-labelholder-canvas',
          window.PointerEvent ? chartObj.container.selectAll('div.legendarea').node() : null);

        }

        // we draw only after the scroll has rendered and a view is set
        if (waitForOverview) {
          return false;
        }

        args.barDatasetIndex = 0;

        if (chartObj.systemConf.legend.enabled) {
          chartObj.svg.
          select('.seriesholder').
          selectAll('*:not(.zmarea)').
          remove(); // remove all except zoom are
        }

        if (chartObj.dataObject.isPolarAxisCategory) {
          chartObj.labelHolderContext.translate(chartObj.plotarea_approx.x, chartObj.plotarea_approx.y);
        }

        if (chartObj.dataset.getDataType('x') == ORDINAL_DATATYPE && chartObj.isAxisCategory) {
          scale.barBandwidth(chartObj);
        }

        var type = null;
        chartObj.chartRendered = false;
        var isComboChart = chartObj.dataObject.isCombinationalChart,
          plotRect = chartObj.plotarea;
        var orderedSeriesdata = isComboChart ? renderer_helpers.arrangeSeriesRenderingOrder(chartObj) : chartObj.seriesdata,
          hierarchical = chartObj.dataObject.hierarchical,
          facetRendering = hierarchical && hierarchical.facetRendering,
          gridlist = [{ data: orderedSeriesdata }];
        if (facetRendering) {
          var pivotLayout = facetRendering && hierarchical.pivotLayout,
            layers = pivotLayout.getRootNodeList('layer'),
            panes = layers.panes;
          gridlist = objectValues(panes);
        }
        if (chartObj.isAxisedHierarchyChart) {
          var dataAdapterObj = new (Registry.getComponent('hierarchyDataAdapter'))(chartObj.seriesdata, chartObj.preProcessor);
          gridlist = [{ data: dataAdapterObj.getData() }];
        }

        var renderCounter = 0,
          rendererIdx;
        gridlist.forEach(function (grid, gridIdx) {
          args.barDatasetIndex = 0;

          grid.data.forEach(function (d, i) {
            var currOrdereddata = facetRendering ?
            renderer_helpers.arrangeSeriesRenderingOrder(chartObj, grid.data, renderCounter, true) :
            orderedSeriesdata; //orderedSeriesdata[i];
            var currentRenderData = facetRendering ? d.node : d;
            var renderingOrder = isComboChart ? facetRendering ? i : currOrdereddata[i].seriesidx : i;

            rendererIdx = facetRendering ? isComboChart ? renderCounter++ : renderCounter++ : renderingOrder;
            var layerIdx = facetRendering ? d.layer : 0;

            type = helpers.getChartType(currentRenderData.type || chartObj.userdata.seriesdata.type, 'string');
            var type_name = helpers.getChartType(currentRenderData.type || chartObj.userdata.seriesdata.type, NUMERIC_DATATYPE);

            if (chartObj.renderer[rendererIdx] == null) {
              chartObj.renderer[rendererIdx] = createCanvasRenderer(type);
              chartObj.rendererConf[rendererIdx] = new plot.rendererConf();
            }
            chartObj.renderer[rendererIdx].chartRendered = false;

            if (i == 0) {
              stateChangeListener(chartObj, systemconf.chart.plot.events, 'plot', 'init');
              chartObj.hideLoading(chartObj.container);
            }

            renderer_helpers.setRendererProp(
            chartObj,
            chartObj.renderer[rendererIdx],
            currOrdereddata,
            renderingOrder,
            i,
            args,
            rendererIdx,
            type_name,
            layerIdx);

          });
        });

        var renderCounter = 0,
          rendererIdx;
        gridlist.forEach(function (grid, gridIdx) {
          grid.data.forEach(function (d, i) {
            var currOrdereddata = facetRendering || chartObj.isAxisedHierarchyChart ?
            renderer_helpers.arrangeSeriesRenderingOrder(chartObj, grid.data, renderCounter, true) :
            orderedSeriesdata; //orderedSeriesdata[i];
            var currentRenderData = facetRendering ? d.node : d;
            var renderingOrder = isComboChart ? facetRendering ? i : currOrdereddata[i].seriesidx : i;

            rendererIdx = facetRendering ? isComboChart ? renderCounter++ : renderCounter++ : renderingOrder;

            var chartType = helpers.getChartType(currentRenderData.type || chartObj.userdata.seriesdata.type, NUMERIC_DATATYPE),
              isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
              isPolarAxisCategory = isCategoryOf(chartObj, chartType, 'polarAxis');

            if ((!chartObj._isAxisCategory() || chartObj.isAxisedHierarchyChart) && !isPolarAxisCategory && renderingOrder > 0) {
              chartObj.renderer[rendererIdx].chartRendered = true;
              return;
            }

            type = helpers.getChartType(currentRenderData.type || chartObj.userdata.seriesdata.type, 'string');

            // pivot non-axis chart: for all color series it will be rendered in single renderer only
            if (chartObj._isAxisCategory() && !isAxisCategory && !isPolarAxisCategory && i != 0) {
              chartObj.renderer[rendererIdx].chartRendered = true;
              return;
            }

            // #ZC1151
            if (plotRect.width > 0 && plotRect.height > 0) {
              var bound = chartObj.renderer[rendererIdx].commonRendererProp().params.bound,
                x = isAxisCategory ? 0 : bound.x + (isPolarAxisCategory ? bound.polar.x : 0),
                y = isAxisCategory ? 0 : bound.y + (isPolarAxisCategory ? bound.polar.y : 0);

              chartObj.context.translate(x, y);
              drawCanvas(chartObj, currOrdereddata, chartObj.renderer[rendererIdx]);
              chartObj.context.translate(-x, -y);
            }
          });
        });
        if (chartObj.systemConf.chart.plot.datalabels.renderOnInit) {
          var datalabelEvents = chartObj.systemConf.chart.plot.datalabels.events;
          stateChangeListener(chartObj, datalabelEvents, 'plot', 'init');
          var dataLabelComponent = Registry.getComponent('labelRenderer');
          dataLabelComponent(args.labelQueue, args.labelArray, chartObj);
          stateChangeListener(chartObj, datalabelEvents, 'plot', update ? 'onreload' : 'onload');
        }
        renderer_helpers.renderCompletedEvents(chartObj, update, args);

        if (!update) {
          /**
           * Fade Effect
           */
          var commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[type];
          var animationOptions = getAnimationConf(commonPlotOptions, chartObj.seriesdata[0].plotoptions, chartObj, type);
          var animationDuration = defined(animationOptions.duration) ? animationOptions.duration : 400;
          if (!defined(animationOptions.enabled) || animationDuration === 0) {
            return;
          }

          var totalSeries = chartObj.seriesdata.length;
          var canvases = chartObj.d3container.selectAll('canvas').style('opacity', 0);
          // chartObj.context.canvas.style.opacity = 0;

          var fadeTimeout = chartObj.timerObj[chartObj.timerObj.length] = setInterval(function () {
            var allRendered = true;
            if (chartObj.destroying) {
              clearInterval(fadeTimeout);
              return;
            }
            if (chartObj.renderer.length === totalSeries) {
              for (var i = 0; i < chartObj.renderer.length; i++) {
                if (!chartObj.renderer[i].chartRendered) {
                  allRendered = false;
                  break;
                }
              }
            }

            if (allRendered) {
              clearInterval(fadeTimeout);

              canvases.
              style('opacity', 0).
              transition().
              duration(animationDuration).
              style('opacity', 1);
            }
          }, 1000 / 60);
        }
      };

      return canvasRenderer;
    };

    var createCanvasRenderer = plot.canvasRenderer.createCanvasRenderer = function (chartName) {
      chartName = getChartName(chartName);
      return new canvas_plot_renderer[chartName]();
    };

    var drawCanvas = plot.canvasRenderer.drawCanvas = function (chartObj, renderdata, renderer, context, styles, filterIndex, encode, index) {
      context = defined(context) ? context : chartObj.context;
      var wrap = chartObj.wrap;
      transformWrap(wrap, 'seriesholder', {
        x: chartObj.plotarea.left,
        y: chartObj.plotarea.top
      });
      transformWrap(chartObj.staticPaneSVG, 'labelholder', {
        x: chartObj.plotarea.left,
        y: chartObj.plotarea.top
      });
      renderer(context, renderdata, styles, filterIndex, encode, index);

      function transformWrap(wrap, selection, translate) {
        return wrap.select("g.".concat(selection)).attr('transform', "translate(".concat(translate.x, ",").concat(translate.y, ")"));
      }
    };

    var updateCanvasContext = plot.canvasRenderer.updateCanvasContext = function (chartObj, selector, prevElement, parentNode) {
      var canvas = chartObj.svg.node().parentNode.querySelector("canvas.".concat(selector)),
        width = getPlotSize(chartObj, 'width'),
        height = getPlotSize(chartObj, 'height'),
        defaultRelativeElement = chartObj.staticPaneSVG.node(),
        defaultParentNode = chartObj.svg.node().parentNode;

      parentNode = parentNode || defaultParentNode;
      if (parentNode.isD3Selection) {
        parentNode = parentNode.node();
      }

      if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.className = selector;
        canvas.setAttribute('actual-width', width);
        canvas.setAttribute('actual-height', height);
        canvas.style.position = 'absolute';
        canvas.style.pointerEvents = NONE;

        if (typeof prevElement === 'string') {
          prevElement = chartObj.container.node().querySelector(prevElement);
        }
        // # ZC1808
        parentNode.insertBefore(canvas, prevElement || (defaultParentNode === parentNode ? defaultRelativeElement : null));
      }

      canvas.width = width;
      canvas.height = height;
      canvas.style.left = "".concat(mathRound(chartObj.plotarea.left), "px");
      canvas.style.top = "".concat(mathRound(chartObj.plotarea.top), "px");
      canvas.style.visibility = 'visible';

      // fix it
      var context = canvas.getContext('2d'),
        imageSmoothingEnabled = "".concat($Browser.prefix.lowercase, "ImageSmoothingEnabled");

      context.clearRect(0, 0, width, height);
      context[imageSmoothingEnabled] = false; // fix old browser
      context.imageSmoothingEnabled = false;

      return fixHDPI(context);
    };

    /**
     *
     * @param context
     * @param node
     * @param nodeOptions
     * @param minHeight
     */
    function drawSankeyNode(context, node, nodeOptions) {var minHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (isNaN(node.x0)) {
        node.x0 = 0;
      }
      if (isNaN(node.x1)) {
        node.x1 = nodeOptions.width;
      }
      context.moveTo(node.x0, node.y0);
      context.lineTo(node.x1, node.y0);
      context.lineTo(node.x1, node.y1);
      context.lineTo(node.x0, node.y1);
      context.closePath();

      // TODO configurable
      // for hover
      minHeight = 4;
      var height = node.y1 - node.y0,
        yCenter = node.y0 + height / 2,
        y0 = node.y0,y1 = node.y1;

      if (height < minHeight) {
        y0 = yCenter - minHeight / 2;
        y1 = yCenter + minHeight / 2;
      }

      // poly
      node._polypoints = [
      [node.x0, y0],
      [node.x1, y0],
      [node.x1, y1],
      [node.x0, y1]];

    }

    /**
     *
     * @param link
     * @param context
     * @param linkOptions
     * @return {Path}
     */

    function sankeyLinkBezier(context, link, linkOptions) {var minWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var halfWidth = mathMax(link.width / 2, minWidth / 2),
        x0 = link.source.x1,
        y0 = link.y0 - halfWidth,
        x1 = link.target.x0,
        y1 = link.y1 - halfWidth,
        padding = linkOptions.padding || 0;

      // add the padding in the offset
      x0 += padding;
      x1 -= padding;

      var width = mathMax(link.width, minWidth),
        controlPointX = (x0 + x1) / 2,
        controlPointX2 = (x0 + x1) / 2;

      if (x1 - x0 > width / 2) {
        if (y0 > y1) {
          controlPointX2 += width / 2;
        } else {
          controlPointX += width / 2;
        }
      }

      context.moveTo(x0, y0);
      context.bezierCurveTo(controlPointX, y0, controlPointX, y1, x1, y1);
      context.lineTo(x1, y1 + width);
      context.bezierCurveTo(controlPointX2, y1 + width, controlPointX2, y0 + width, x0, y0 + width);
      context.closePath();

      return context;
    }

    /**
     *
     * @param context
     * @param link
     * @param linkOptions
     * @param minWidth
     * @return {Path}
     */
    function sankeyLinkLinear(context, link, linkOptions) {var minWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var halfWidth = mathMax(link.width / 2, minWidth / 2),
        x0 = link.source.x1,
        y0 = link.y0 - halfWidth,
        x1 = link.target.x0,
        y1 = link.y1 - halfWidth,
        h = mathMax(link.width, minWidth),
        padding = linkOptions.padding || 0;

      x0 += padding;
      x1 -= padding;

      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
      context.lineTo(x1, y1 + h);
      context.lineTo(x0, y0 + h);
      context.closePath();

      // poly
      link._polypoints = [
      [x0, y0],
      [x1, y1],
      [x1, y1 + h],
      [x0, y0 + h]];


      return context;
    }

    function drawSankeyExitLink(context, link, linkOptions) {var minWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var layout = arguments.length > 4 ? arguments[4] : undefined;
      var width = mathMax(link.width, minWidth),
        x0 = link.source.x1,
        y0 = link.y0 - width / 2,
        y1 = mathMin(y0 + width, layout.y1 - 10),
        radius = mathMin(width, 25),
        x2 = x0 + radius,
        y2 = y0 + radius,
        extendLength = mathMin(0.5 * width, 10),
        extendY1 = y1 + extendLength,
        padding = linkOptions.padding || 0;

      // add the padding in the offset
      x0 += padding;

      // context.moveTo(x0, y0);
      // context.arcTo(x1, y0, x1, y1, width);
      // context.lineTo(x0, y1);

      // context.moveTo(x0, y0);
      // context.arcTo(x1, y0, x1, y1, width);
      // context.lineTo(x1, extendY1);
      // context.lineTo(x1 - width / 2, extendY1 + 10);
      // context.lineTo(x0, extendY1);
      // context.lineTo(x0, y1);

      context.moveTo(x0, y0);
      context.arcTo(x2, y0, x2, y2, radius);
      context.lineTo(x2, y1);
      context.lineTo(x2 - radius / 2, extendY1);
      context.lineTo(x0, y1);
      // context.lineTo(x0, y1);

      context.closePath();

      return context;
    }

    /**
     *
     * @param parent
     * @param layout
     * @param nodeOptions
     * @param linkOptions
     * @param nodeFillColor
     * @param linkFillColor
     */
    function drawSankeySvg(parent, layout, nodeOptions, linkOptions, nodeFillColor, linkFillColor) {
      var nodes = layout.nodes,links = layout.links;

      var sankeyChart = createElement('g', '.sankey-chart', [1], parent).attr(
        'transform', "translate(".concat(
        nodeOptions.strokeWidth, ",").concat(nodeOptions.strokeWidth, ")")),

        linkParent = createElement('g', '.sankey-links', [1], sankeyChart),
        nodeParent = createElement('g', '.sankey-nodes', [1], sankeyChart);

      createElement('path', '.sankey-link', links, linkParent, null, function (p) {return p.point;}).
      attrs({
        d: function d(link) {
          this.index = link.index;
          return getSankeyPointPath(link, nodeOptions, linkOptions, 0.5, layout);
        }
      }).
      styles({
        fill: function fill(link) {return linkFillColor(link.point);},
        'fill-opacity': linkOptions.fillOpacity,
        stroke: linkOptions.strokeColor,
        'stroke-width': linkOptions.strokeWidth,
        'mix-blend-mode': linkOptions.blendMode
      });

      createElement('path', '.sankey-node', nodes, nodeParent, null, function (p) {return p.point;}).
      attrs({
        d: function d(node) {return getSankeyPointPath(node, nodeOptions, linkOptions);}
      }).
      styles({
        fill: function fill(node) {return nodeFillColor(node.point);},
        'fill-opacity': nodeOptions.fillOpacity,
        stroke: nodeOptions.strokeColor,
        'stroke-width': nodeOptions.strokeWidth
      });
    }

    /**
     *
     * @param point
     * @param nodeOptions
     * @param linkOptions
     * @param minWidth
     * @return {Path}
     */
    function getSankeyPointPath(point, nodeOptions, linkOptions) {var minWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;var layout = arguments.length > 4 ? arguments[4] : undefined;
      minWidth = defined(linkOptions.minWidth) ? linkOptions.minWidth : minWidth;
      var path = d3_path();
      if (point._type === 'node' || point._type === 'node') {
        drawSankeyNode(path, point, nodeOptions);
      } else if (point._type === 'link') {
        if (point.circular) {
          path = point.circularPathData.path;
        } else if (point.exit) {
          drawSankeyExitLink(path, point, linkOptions, minWidth, layout);
        } else {
          (linkOptions.curve === 'linear' ? sankeyLinkLinear : sankeyLinkBezier)(path, point, linkOptions, minWidth);
        }
      }
      return path;
    }

    /**
     *
     * @type {{parse, drawPath}}
     */
    var SVGParser = function () {
      var mag = function mag(v) {
          return mathSQRT(mathPow(v[0], 2) + mathPow(v[1], 2));
        },
        dot = function dot(u, v) {
          return u[0] * v[0] + u[1] * v[1];
        },
        ratio = function ratio(u, v) {
          var rat = dot(u, v) / (mag(u) * mag(v));
          // #ZC1690
          if (rat < 0) {
            return mathMax(-1, rat);
          } else {
            return mathMin(1, rat);
          }
        },
        angle = function angle(u, v) {
          var sign = 1.0;
          if (u[0] * v[1] - u[1] * v[0] < 0) {
            sign = -1.0;
          }
          return sign * Math.acos(ratio(u, v));
        },
        rotClockwise = function rotClockwise(v, angle) {
          var cost = mathCos(angle),
            sin = Math.sin(angle);
          return [cost * v[0] + sin * v[1], -1 * sin * v[0] + cost * v[1]];
        },
        rotCounterClockwise = function rotCounterClockwise(v, angle) {
          var cost = mathCos(angle),
            sin = Math.sin(angle);
          return [cost * v[0] - sin * v[1], sin * v[0] + cost * v[1]];
        },
        midPoint = function midPoint(u, v) {
          return [(u[0] - v[0]) / 2.0, (u[1] - v[1]) / 2.0];
        },
        meanVec = function meanVec(u, v) {
          return [(u[0] + v[0]) / 2.0, (u[1] + v[1]) / 2.0];
        },
        pointMul = function pointMul(u, v) {
          return [u[0] * v[0], u[1] * v[1]];
        },
        scale = function scale(c, v) {
          return [c * v[0], c * v[1]];
        },
        sum = function sum(u, v) {
          return [u[0] + v[0], u[1] + v[1]];
        },
        ellipseFromEllipticalArc = function ellipseFromEllipticalArc(x1, rx, ry, phi, fA, fS, x2, options) {
          // Convert from endpoint to center parametrization, as detailed in:
          // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
          if (rx === 0 || ry === 0) {
            options.push({ type: 'lineTo', args: x2 });
            return;
          }

          phi = phi * (Math.PI / 180.0);
          rx = Math.abs(rx);
          ry = Math.abs(ry);

          var xPrime = rotClockwise(midPoint(x1, x2), phi),
            xPrime2 = pointMul(xPrime, xPrime),
            rx2 = mathPow(rx, 2),
            ry2 = mathPow(ry, 2),
            lambda = mathSQRT(xPrime2[0] / rx2 + xPrime2[1] / ry2),
            factor;

          if (lambda > 1) {
            rx *= lambda;
            ry *= lambda;
            rx2 = mathPow(rx, 2);
            ry2 = mathPow(ry, 2);
          }

          factor = mathSQRT(Math.abs((rx2 * ry2 - rx2 * xPrime2[1] - ry2 * xPrime2[0]) / (rx2 * xPrime2[1] + ry2 * xPrime2[0])));

          if (fA === fS) {
            factor *= -1.0;
          }

          var cPrime = scale(factor, [rx * xPrime[1] / ry, -ry * xPrime[0] / rx]),
            c = sum(rotCounterClockwise(cPrime, phi), meanVec(x1, x2)),
            x1UnitVector = [(xPrime[0] - cPrime[0]) / rx, (xPrime[1] - cPrime[1]) / ry],
            x2UnitVector = [(-1.0 * xPrime[0] - cPrime[0]) / rx, (-1.0 * xPrime[1] - cPrime[1]) / ry],
            start = angle([1, 0], x1UnitVector), // theta
            deltaTheta = angle(x1UnitVector, x2UnitVector),
            end = start + deltaTheta;

          options.push(
          { type: 'save', args: [] },
          { type: 'translate', args: [c[0], c[1]] },
          { type: 'rotate', args: [phi] },
          { type: 'scale', args: [rx, ry] },
          { type: 'arc', args: [0, 0, 1, start, end, 1 - fS] },
          { type: 'restore', args: [] });

        },
        /**
         *
         * @param {String} pathString SVG Path (d)
         * @return {Array}
         */
        parseSvg = function parseSvg(pathString) {
          var lastCoordinates = [0, 0],
            lastControl = [0, 0],
            options = [],
            lastCharacter = '',
            firstSubPath = false;

          // Convert a position into an absolute position.
          function makeAbsolute(c, coordinates) {
            if ('mlazhvcsqt'.indexOf(c) === -1) {
              lastCoordinates = coordinates;
            } else {
              lastCoordinates[0] += coordinates[0];
              lastCoordinates[1] += coordinates[1];
            }
            lastCharacter = c;
            return lastCoordinates.slice(0);
          }

          // Convert a sequence of coordinates into absolute coordinates.
          // For arguments that take multiple coordinates pairs, such as bezier.
          function makeAbsoluteMultiple(c, seq) {
            var r = [];
            var lastPosCopy = lastCoordinates.slice(0);
            for (var i = 0; i < seq.length; i += 2) {
              // Only the last point should update lastCoordinates.
              lastCoordinates = lastPosCopy.slice(0);
              var coordinates = makeAbsolute(c, seq.slice(i, i + 2));
              r = r.concat(coordinates);
              // Record the last control point, it might be needed for shorthand operations.
              if (i === seq.length - 4) {
                lastControl = coordinates.slice(0);
              }
            }
            return r;
          }

          // Find the reflection of the last control point over the last postion in the path.
          function makeReflected() {
            if ('CcSsQqTt'.indexOf(lastCharacter) === -1) {
              lastControl = lastCoordinates.slice(0);
            }
            // reflected = 2*lastCoordinates - lastControl
            // Note the result is absolute, not relative.
            var r = [0, 0];
            r[0] = 2 * lastCoordinates[0] - lastControl[0];
            r[1] = 2 * lastCoordinates[1] - lastControl[1];
            return r;
          }

          function makeAbsoluteFromX(c, x) {
            var coordinates = [x, 0];
            if (c === 'H') {
              coordinates[1] = lastCoordinates[1];
            }
            return makeAbsolute(c, coordinates);
          }

          function makeAbsoluteFromY(c, y) {
            var coordinates = [0, y];
            if (c === 'V') {
              coordinates[0] = lastCoordinates[0];
            }
            return makeAbsolute(c, coordinates);
          }

          var p,
            svgPathFunctions = {
              m: function m(ch, args) {
                var moveCh = ch;
                // If this is the first move cmd then force it to be absolute.
                if (firstSubPath) {
                  moveCh = 'M';
                  firstSubPath = false;
                }
                options.push({ type: 'moveTo', args: makeAbsolute(moveCh, args) });
                while (args.length) {
                  p = args.splice(0, 2);
                  options.push({ type: 'lineTo', args: makeAbsolute(ch, p) });
                }
              },
              z: function z() {
                options.push({ type: 'closePath', args: [] });
              },
              l: function l(ch, args) {
                while (args.length) {
                  p = args.splice(0, 2);
                  options.push({ type: 'lineTo', args: makeAbsolute(ch, p) });
                }
              },
              h: function h(ch, args) {
                options.push({ type: 'lineTo', args: makeAbsoluteFromX(ch, args) });
              },
              v: function v(ch, args) {
                options.push({ type: 'lineTo', args: makeAbsoluteFromY(ch, args) });
              },
              c: function c(ch, args) {
                while (args.length) {
                  p = args.splice(0, 6);
                  options.push({ type: 'bezierCurveTo', args: makeAbsoluteMultiple(ch, p) });
                }
              },
              s: function s(ch, args) {
                options.push({
                  type: 'bezierCurveTo',
                  args: makeReflected().concat(makeAbsoluteMultiple(ch, args))
                });
              },
              q: function q(ch, args) {
                while (args.length) {
                  p = args.splice(0, 6);
                  options.push({ type: 'quadraticCurveTo', args: makeAbsoluteMultiple(ch, args) });
                }
              },
              t: function t(ch, args) {
                var reflected = makeReflected();
                options.push({
                  type: 'quadraticCurveTo',
                  args: reflected.concat(makeAbsoluteMultiple(ch, args))
                });
                lastControl = reflected.slice(0);
              },
              a: function a(ch, args) {
                var x1 = [lastCoordinates.slice()],
                  x2 = [makeAbsolute(ch, args.slice(-2))],
                  absArgs = x1.concat(args.slice(0, -2), x2, [options]);
                ellipseFromEllipticalArc.apply(this, absArgs);
              }
            };

          // parse and draw
          var steps = parseSVGPath(pathString);
          if (steps.length) {
            steps.forEach(function (step) {
              var stepLowerCase = step["function"].toLowerCase();
              svgPathFunctions[stepLowerCase](step.type, step.moves);
            });
          }
          return options;
        },
        /**
         *
         * @param {String} pathString SVG Path (d)
         * @param {CanvasRenderingContext2D} context Canvas Context 2d
         */
        drawPath = function drawPath(pathString, context) {
          var parsed = parseSvg(pathString);
          parsed.forEach(function (command) {
            context[command.type].apply(context, command.args);
          });
        };

      return {
        parse: parseSvg,
        drawPath: drawPath
      };
    }();

    // create a d path using the addCircularPathData
    //reference code : https://bl.ocks.org/tomshanley/b82d9aede85694b1422786ef41536ec5
    function sankeyCircularLink(link) {
      var pathString = '';

      if (link.circularLinkType == 'top') {
        pathString =
        // start at the right of the source node
        "M".concat(link.circularPathData.sourceX, " ").concat(link.circularPathData.sourceY, " ") +
        // line right to buffer point
        "L".concat(link.circularPathData.leftInnerExtent, " ").concat(link.circularPathData.sourceY, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius, " ").concat(link.circularPathData.leftSmallArcRadius, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftFullExtent, " ").concat(
        link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius, " ") + // End of arc X
        // line up to buffer point
        "L".concat(link.circularPathData.leftFullExtent, " ").concat(link.circularPathData.verticalLeftInnerExtent, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius, " ").concat(link.circularPathData.leftLargeArcRadius, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftInnerExtent, " ").concat(
        link.circularPathData.verticalFullExtent, " ") + // End of arc X
        // line left to buffer point
        "L".concat(link.circularPathData.rightInnerExtent, " ").concat(link.circularPathData.verticalFullExtent, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.rightLargeArcRadius, " ").concat(link.circularPathData.rightLargeArcRadius, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightFullExtent, " ").concat(
        link.circularPathData.verticalRightInnerExtent, " ") + // End of arc X
        // line down
        "L".concat(link.circularPathData.rightFullExtent, " ").concat(link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.rightLargeArcRadius, " ").concat(link.circularPathData.rightSmallArcRadius, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightInnerExtent, " ").concat(
        link.circularPathData.targetY, " ") + // End of arc X
        // line to end
        "L".concat(link.circularPathData.targetX, " ").concat(
        link.circularPathData.targetY

        //RT
        , " ") + "L".concat(
        link.circularPathData.targetX, " ").concat(link.circularPathData.targetY - link.width, " ") + // line right to buffer point
        "L".concat(link.circularPathData.rightInnerExtent1, " ").concat(link.circularPathData.targetY - link.width, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.rightLargeArcRadius1, " ").concat(link.circularPathData.rightSmallArcRadius1, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightFullExtent1, " ").concat(
        link.circularPathData.targetY - link.width - link.circularPathData.rightSmallArcRadius1, " ") + // End of arc X
        // line up to buffer point
        "L".concat(link.circularPathData.rightFullExtent1, " ").concat(link.circularPathData.verticalRightInnerExtent1 +
        link.circularPathData.rightLargeArcRadius1, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.rightLargeArcRadius1, " ").concat(link.circularPathData.rightLargeArcRadius1, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightInnerExtent1, " ").concat(
        link.circularPathData.verticalFullExtent1, " ") + // End of arc X
        // line left to buffer point
        "L".concat(link.circularPathData.leftInnerExtent1, " ").concat(link.circularPathData.verticalFullExtent1, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius1, " ").concat(link.circularPathData.leftLargeArcRadius1, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftFullExtent1, " ").concat(
        link.circularPathData.verticalLeftInnerExtent1 + link.circularPathData.leftLargeArcRadius1, " ") + // End of arc X
        // line down
        "L".concat(link.circularPathData.leftFullExtent1, " ").concat(link.circularPathData.sourceY -
        link.width -
        link.circularPathData.leftSmallArcRadius1, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius1, " ").concat(link.circularPathData.leftSmallArcRadius1, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftInnerExtent1, " ").concat(
        link.circularPathData.sourceY - link.width, " ") + // End of arc X
        // line to end
        "L".concat(link.circularPathData.sourceX, " ").concat(link.circularPathData.sourceY - link.width);
      } else {
        // bottom path
        pathString =
        // start at the right of the source node
        "M".concat(link.circularPathData.sourceX, " ").concat(link.circularPathData.sourceY, " ") +
        // line right to buffer point
        "L".concat(link.circularPathData.leftInnerExtent, " ").concat(link.circularPathData.sourceY, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius, " ").concat(link.circularPathData.leftSmallArcRadius, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftFullExtent, " ").concat(
        link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius, " ") + // End of arc X
        // line down to buffer point
        "L".concat(link.circularPathData.leftFullExtent, " ").concat(link.circularPathData.verticalLeftInnerExtent, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius, " ").concat(link.circularPathData.leftLargeArcRadius, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftInnerExtent, " ").concat(
        link.circularPathData.verticalFullExtent, " ") + // End of arc X
        // line left to buffer point
        "L".concat(link.circularPathData.rightInnerExtent, " ").concat(link.circularPathData.verticalFullExtent, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.rightLargeArcRadius, " ").concat(link.circularPathData.rightLargeArcRadius, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightFullExtent, " ").concat(
        link.circularPathData.verticalRightInnerExtent, " ") + // End of arc X
        // line up
        "L".concat(link.circularPathData.rightFullExtent, " ").concat(link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.rightLargeArcRadius, " ").concat(link.circularPathData.rightSmallArcRadius, " 0 0 1 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightInnerExtent, " ").concat(
        link.circularPathData.targetY, " ") + // End of arc X
        // line to end
        "L".concat(link.circularPathData.targetX, " ").concat(link.circularPathData.targetY, " ") +
        //RT
        "L".concat(link.circularPathData.targetX, " ").concat(link.circularPathData.targetY + link.width, " ") + "L".concat(
        link.circularPathData.rightInnerExtent1, " ").concat(link.circularPathData.targetY + link.width, " ") + "A".concat(
        link.circularPathData.rightLargeArcRadius1, " ").concat(link.circularPathData.rightSmallArcRadius1, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightFullExtent1, " ").concat(
        link.circularPathData.targetY + link.width + link.circularPathData.rightSmallArcRadius1, " ") + // End of arc X
        //
        "L".concat(link.circularPathData.rightFullExtent1, " ").concat(
        link.circularPathData.verticalRightInnerExtent1 - link.circularPathData.rightLargeArcRadius1
        // line down to buffer point
        //
        //     // Arc around: Centre of arc X and  //Centre of arc Y
        , " ") + "A".concat(
        link.circularPathData.rightLargeArcRadius1, " ").concat(link.circularPathData.rightLargeArcRadius1, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.rightInnerExtent1, " ").concat(

        link.circularPathData.verticalFullExtent1
        // End of arc X
        //     // line left to buffer point
        , " ") + "L".concat(
        link.circularPathData.leftInnerExtent1, " ").concat(link.circularPathData.verticalFullExtent1, " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius1, " ").concat(link.circularPathData.leftLargeArcRadius1, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftFullExtent1, " ").concat(
        link.circularPathData.verticalLeftInnerExtent1 - link.circularPathData.leftLargeArcRadius1, " ") + // End of arc X
        // line up
        "L".concat(link.circularPathData.leftFullExtent1, " ").concat(
        link.circularPathData.sourceY + link.width + link.circularPathData.leftSmallArcRadius1
        //
        , " ") +
        // Arc around: Centre of arc X and  //Centre of arc Y
        "A".concat(link.circularPathData.leftLargeArcRadius1, " ").concat(link.circularPathData.leftSmallArcRadius1, " 0 0 0 ").concat(
        // End of arc X //End of arc Y
        link.circularPathData.leftInnerExtent1, " ").concat(
        link.circularPathData.sourceY + link.width, " ") + // End of arc X
        // line to end
        "L".concat(link.circularPathData.sourceX, " ").concat(link.circularPathData.sourceY + link.width);
      }

      return pathString;
    }

    function sankeyCanvasCircularLink(context, link) {
      var pathString = sankeyCircularLink(link);
      SVGParser.drawPath(pathString, context);
    }

    /**
     *
     * @param context
     * @param layout
     * @param nodeOptions
     * @param linkOptions
     * @param nodeFillColor
     * @param linkFillColor
     */

    function drawSankeyCanvas(context, layout, nodeOptions, linkOptions, nodeFillColor, linkFillColor, imagePallet) {
      var nodes = layout.nodes,links = layout.links,
        nodeStrokeWidth = nodeOptions.strokeWidth,
        linkStrokeWidth = linkOptions.strokeWidth;

      context.save();
      context.translate(nodeStrokeWidth, nodeStrokeWidth);

      if (defined(linkOptions.blendMode)) {
        context.globalCompositeOperation = linkOptions.blendMode;
      }

      /**
       *
       * @param link
       * @param fillStyle
       */
      var renderLink = function renderLink(link, fillStyle, layout) {
        context.save();

        context.fillStyle = fillStyle;
        context.strokeStyle = linkOptions.strokeColor;
        context.lineWidth = linkStrokeWidth;
        context.beginPath();
        if (link.circular) {
          sankeyCanvasCircularLink(context, link);
        } else if (link.exit) {
          drawSankeyExitLink(context, link, linkOptions, 0.5, layout);
        } else {
          (linkOptions.curve === 'linear' ? sankeyLinkLinear : sankeyLinkBezier)(context, link, linkOptions, 0.5);
        }

        // #ZC2592
        context.translate(link.source.x0, 0);
        context.fill();

        if (linkStrokeWidth) {
          context.stroke();
        }

        context.restore();
      };

      links.forEach(function (link) {
        if (isCanvasPattern(linkOptions.fillColor)) {
          renderLink(link, linkOptions.fillColor, layout);
        } else if (defined(imagePallet)) {
          var params = { context: context, name: imagePallet[link.source.index] };
          effects.canvas_patterns.imageFill(params, function (context, pattern) {return renderLink(link, pattern, layout);});
        } else {
          renderLink(link, linkFillColor(link.point), layout);
        }
      });

      var renderNode = function renderNode(node, fillStyle) {
        context.save();
        context.fillStyle = fillStyle;
        context.lineWidth = nodeStrokeWidth;
        context.strokeStyle = nodeOptions.strokeColor;
        context.beginPath();
        node.color = fillStyle;
        drawSankeyNode(context, node, nodeOptions);
        context.fill();

        if (nodeStrokeWidth) {
          context.stroke();
        }
        context.restore();
      };

      nodes.forEach(function (node) {
        if (isCanvasPattern(nodeOptions.fillColor)) {
          renderNode(node, nodeOptions.fillColor);
        } else if (defined(imagePallet)) {
          var params = { context: context, name: imagePallet[node.index] };
          effects.canvas_patterns.imageFill(params, function (context, pattern) {return renderNode(node, pattern);});
        } else {
          renderNode(node, nodeFillColor(node.point));
        }
      });

      context.restore();
    }

    /**
     *
     * @param fillStyle
     * @return {boolean}
     */
    function isCanvasPattern(fillStyle) {
      return fillStyle instanceof CanvasPattern;
    }

    /// /////////////////////////////////////////////////////////////////////////////////

    // Create a normal curve or circular curve
    //var curveSankeyForceLink =

    // Return the angle between a straight line between the source and target of the link, and the vertical plane of the node
    function linkAngle(link) {
      var adjacent = Math.abs(link.y1 - link.y0);
      var opposite = Math.abs(link.target.x0 - link.source.x1);

      return Math.atan(opposite / adjacent);
    }

    function circularLinksCross(link1, link2) {
      if (link1.source.depth < link2.target.depth) {
        return false;
      } else if (link1.target.depth > link2.source.depth) {
        return false;
      } else {
        return true;
      }
    }
    function getCircularLinkMargin(graph, ky, ratio, maxColumn) {
      var verticalMargin = 25;
      var baseRadius = 10;

      var totalTopLinksWidth = 0,
        totalBottomLinksWidth = 0,
        totalRightLinksWidth = 0,
        totalLeftLinksWidth = 0,
        totalLeftSubLinksWidth = {},
        totalRightSubLinksWidth = {},
        linkCount = {
          top: 0,
          bottom: 0,
          left: 0
        };
      /*
      calculate circular link widths
       */
      graph.links.forEach(function (link, i) {
        if (ky != null || ratio != null) {
          if (ky != null) {
            link.width = link.value * ky;
          } else {
            link.width = link.width * ratio;
          }
        }

        if (link.circular) {
          if (link.circularLinkType == 'top') {
            linkCount.top++;
            totalTopLinksWidth = totalTopLinksWidth + link.width;
          } else {
            linkCount.bottom++;
            totalBottomLinksWidth = totalBottomLinksWidth + link.width;
          }

          // if (link.source.column > link.target.column) {
          // totalLeftSubLinksWidth
          //left side extra link width calculation

          if (totalLeftSubLinksWidth[link.target.column]) {
            totalLeftSubLinksWidth[link.target.column].total += link.width;
          } else {
            totalLeftSubLinksWidth[link.target.column] = {};
            totalLeftSubLinksWidth[link.target.column].total = link.width;
          }

          //ignore the case for link with target column as 0, as we calculate at the end 
          if (link.target.column != 0 && totalLeftSubLinksWidth[link.target.column]) {
            if (link.target.x0 - totalLeftSubLinksWidth[link.target.column].total < graph.x0) {
              totalLeftSubLinksWidth[link.target.column].extra =
              (totalLeftSubLinksWidth[link.target.column].extra || 0) + link.width;
            }
          }

          //totalRightSubLinksWidth
          //Right side extra link width calculation
          if (totalRightSubLinksWidth[link.source.column]) {
            totalRightSubLinksWidth[link.source.column].total += link.width;
          } else {
            totalRightSubLinksWidth[link.source.column] = {};
            totalRightSubLinksWidth[link.source.column].total = link.width;
          }
          //ignore the case for link with source column as maxColumn, as we calculate at the end 
          if (link.source.column != maxColumn && totalRightSubLinksWidth[link.source.column]) {
            if (link.source.x1 + totalRightSubLinksWidth[link.source.column].total > graph.x1) {
              totalRightSubLinksWidth[link.source.column].extra =
              (totalRightSubLinksWidth[link.source.column].extra || 0) + link.width;
            }
          }
          // }
          // if (link.source.column < link.target.column) {
          //     //right side link
          //     if (totalRightSubLinksWidth[link.target.column]) {
          //         totalRightSubLinksWidth[link.target.column].total += link.width;
          //     } else {
          //         totalRightSubLinksWidth[link.target.column] = {};
          //         totalRightSubLinksWidth[link.target.column].total = link.width;
          //     }
          //     if (totalRightSubLinksWidth[link.target.column]) {
          //         if (link.target.x1 + totalRightSubLinksWidth[link.target.column].total > graph.x1) {
          //             totalRightSubLinksWidth[link.target.column].extra =
          //                 (totalRightSubLinksWidth[link.target.column].extra || 0) + link.width;
          //         }
          //     }
          // }

          if (link.target.column == 0) {
            totalLeftLinksWidth = totalLeftLinksWidth + link.width;
          }

          if (link.source.column == maxColumn) {
            totalRightLinksWidth = totalRightLinksWidth + link.width;
          }
        }
      });

      var x = Object.keys(totalLeftSubLinksWidth),
        y = Object.keys(totalRightSubLinksWidth);
      totalLeftLinksWidth +=
      d3_max(x, function (d) {
        return totalLeftSubLinksWidth[d].extra || 0;
      }) || 0,
      totalRightLinksWidth +=
      d3_max(y, function (d) {
        return totalRightSubLinksWidth[d].extra || 0;
      }) || 0;

      //account for radius of curves and padding between links
      totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;
      totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;
      totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;
      totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;

      /*
      calculate circular link margin
      */
      var circularLinkMargin = {
        top: totalTopLinksWidth,
        bottom: totalBottomLinksWidth + 0,
        left: totalLeftLinksWidth,
        right: totalRightLinksWidth,
        linkCount: linkCount
      };
      graph.circularSize = {
        width: circularLinkMargin.left + circularLinkMargin.right,
        height: circularLinkMargin.top + circularLinkMargin.bottom,
        hCount: x.length + y.length
      };

      // console.log("hiiiii", circularLinkMargin.top)
      return circularLinkMargin;
    }
    function fillHeight(graph, y0, y1, initialExtent) {
      var nodes = graph.nodes;
      var links = graph.links;

      links.forEach(function (link) {
        if (link.circularLinkType == 'top') ;else if (link.circularLinkType == 'bottom') ;
      });

      var maxColumn = d3_max(graph.nodes, function (node) {
        return node.column;
      });
      var margin = getCircularLinkMargin(graph, null, null, maxColumn);
      // graph.links.forEach(function(link) {
      //     if (link.circular) {
      //         if (link.circularLinkType == 'top') {
      //             m = Math.max(link.totalHeight, m);
      //             totalTopLinksWidth = totalTopLinksWidth + link.width;
      //         } else {
      //             totalBottomLinksWidth = totalBottomLinksWidth + link.width;
      //         }
      //
      //         if (link.target.column == 0) {
      //             totalLeftLinksWidth = totalLeftLinksWidth + link.width;
      //         }
      //
      //         if (link.source.column == maxColumn) {
      //             totalRightLinksWidth = totalRightLinksWidth + link.width;
      //         }
      //     }
      // });
      //
      // //account for radius of curves and padding between links
      // totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;
      // totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;
      // totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;
      // totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;

      // var margin = {
      //     top: totalTopLinksWidth,
      //     bottom: totalBottomLinksWidth,
      //     left: totalLeftLinksWidth,
      //     right: totalRightLinksWidth
      // };

      var maxColumn = d3_max(graph.nodes, function (node) {
        return node.column;
      });
      var minY0 = d3_min(nodes, function (node) {
        return node.y0;
      });
      var maxY1 = d3_max(nodes, function (node) {
        return node.y1;
      });

      // var currentWidth = graph.x1 - graph.x0;
      // var currentHeight = graph.y1 - graph.y0;

      // var newWidth = currentWidth + margin.right + margin.left;
      var bottomLinkgap = margin.linkCount.bottom * 1;
      var newHeight = y1 = graph.y1 = initialExtent.y1 - margin.bottom - bottomLinkgap;
      return;
      // var ratio = newHeight / maxY1;
      var ratio = newHeight / maxY1;
      var dy = minY0 > margin.top ? minY0 - margin.top - 5 : 0;
      nodes.forEach(function (node) {
        var nodeHeight = (node.y1 - node.y0) * ratio;
        node.y0 = (node.y0 - dy) * ratio;
        node.y1 = node.y0 + nodeHeight;
      });

      links.forEach(function (link) {
        link.y0 = (link.y0 - dy) * ratio;
        link.y1 = (link.y1 - dy) * ratio;
        link.width = link.width * ratio;
      });

      // var newHeight1 = (y0 = graph.y0 = initialExtent.y0 + margin.top);
      // var dy = minY0 > margin.top ? minY0 - margin.top : 0;
      //
      // var ratio1 = newHeight1/minY0;
      //
      // nodes.forEach(function(node) {
      //     var nodeHeight = (node.y1 - node.y0) * ratio1;
      //     node.y0 = (node.y0 - 0) * ratio1;
      //     node.y1 = node.y0 + nodeHeight;
      // });
      //
      // links.forEach(function(link) {
      //     link.y0 = (link.y0 - 0) * ratio1;
      //     link.y1 = (link.y1 - 0) * ratio1;
      //     link.width = link.width * ratio1;
      // });
      // }
    }
    function calcVerticalBuffer(links) {
      var circularLinkGap = 2;
      links.sort(sortLinkDepthAscending);
      links.forEach(function (link, i) {
        var buffer = 0;

        var j = 0;
        for (j; j < i; j++) {
          if (circularLinksCross(links[i], links[j])) {
            var bufferOverThisLink = links[j].circularPathData.verticalBuffer1 + links[j].width / 2 + circularLinkGap;
            buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;
          }
        }
        link.circularPathData.verticalBuffer1 = buffer + link.width / 2;
        link.circularPathData.verticalBuffer = buffer + link.width;
      });

      return links;
    }
    // sort links based on the distance between the source and tartget node depths
    // if the same, then use Y position of the source node
    function sortLinkDepthAscending(link1, link2) {
      if (linkDepthDistance(link1) == linkDepthDistance(link2)) {
        return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);
      } else {
        // return linkDepthDistance(link1) - linkDepthDistance(link2);
        return linkDepthDistance(link2) - linkDepthDistance(link1);
      }
    }

    function sortLinkSourceYAscending(link1, link2) {
      return link1.y0 - link2.y0;
    }

    function sortLinkSourceYDescending(link1, link2) {
      return link2.y0 - link1.y0;
    }

    function sortLinkTargetYAscending(link1, link2) {
      return link1.y1 - link2.y1;
    }

    function sortLinkTargetYDescending(link1, link2) {
      return link2.y1 - link1.y1;
    }

    // return the distance between the link's target and source node, in terms of the nodes' depth
    function linkDepthDistance(link) {
      return link.target.depth - link.source.depth;
    }

    // return the distance between the link's target and source node, in terms of the nodes' X coordinate
    function linkXLength(link) {
      return link.target.x0 - link.source.x1;
    }

    function linkPerpendicularYToLinkSource(longerLink, shorterLink) {
      // Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
      // * approx, based on a straight line from target to source, when in fact the path is a bezier

      // get the angle for the longer link
      var angle = linkAngle(longerLink);

      // get the adjacent length to the other link's x position
      var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

      // add or subtract from longer link1's original y1, depending on the slope
      var yPerpendicular =
      incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;

      return yPerpendicular;
    }

    function linkPerpendicularYToLinkTarget(longerLink, shorterLink) {
      // Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
      // * approx, based on a straight line from target to source, when in fact the path is a bezier

      // get the angle for the longer link
      var angle = linkAngle(longerLink);

      // get the adjacent length to the other link's x position
      var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

      // add or subtract from longer link's original y1, depending on the slope
      var yPerpendicular =
      incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;

      return yPerpendicular;
    }

    function resolveNodeLinkOverlaps(graph) {
      var minY0 = d3_min(graph.nodes, function (node) {
        return node.y0;
      });
      var maxY1 = d3_max(graph.nodes, function (node) {
        return node.y1;
      });
      var extent = { y0: minY0, y1: maxY1 };
      graph.links.forEach(function (link) {
        if (link.circular) {
          return;
        }

        if (link.target.depth - link.source.depth > 1) {
          var depthToTest = link.source.depth + 1;
          var maxDepthToTest = link.target.depth - 1;

          var i = 1;
          var numberOfDepthsToTest = maxDepthToTest - depthToTest + 1;

          for (i = 1; depthToTest <= maxDepthToTest; depthToTest++, i++) {
            adjustNodePosition(link, graph, extent, depthToTest, numberOfDepthsToTest, i);
          }
        }
      });
    }

    function adjustNodePosition(link, graph, extent, depthToTest, numberOfDepthsToTest, i) {
      graph.nodes.forEach(function (node) {
        if (node.depth == depthToTest) {
          var t = i / (numberOfDepthsToTest + 1);

          // Find all the points of a cubic bezier curve in javascript
          // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript

          var B0_t = Math.pow(1 - t, 3);
          var B1_t = 3 * t * Math.pow(1 - t, 2);
          var B2_t = 3 * Math.pow(t, 2) * (1 - t);
          var B3_t = Math.pow(t, 3);

          var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;

          var linkY0AtDepth = py_t - link.width / 2;
          var linkY1AtDepth = py_t + link.width / 2;

          // If top of link overlaps node, push node up
          if (linkY0AtDepth > node.y0 && linkY0AtDepth < node.y1) {
            // console.log("OVERLAP!")

            var dy = -(node.y1 - linkY0AtDepth + 10);

            //check if other nodes need to move up too
            var nodeListToCheck = getOverlappedNodes(graph, node);

            var leavesOut = checkAnyNodeLeavesOut(nodeListToCheck, extent, dy);
            if (!leavesOut) {
              nodeListToCheck.map(function (node) {
                adjustNodeHeight(node, dy);
              });
            }
          } else if (linkY1AtDepth > node.y0 && linkY1AtDepth < node.y1) {
            // If bottom of link overlaps node, push node down
            var _dy2 = linkY1AtDepth - node.y0 + 10;

            //check if other nodes need to move down too
            var nodeListToCheck = getOverlappedNodes(graph, node, true);

            var _leavesOut = checkAnyNodeLeavesOut(nodeListToCheck, extent, _dy2);
            if (!_leavesOut) {
              nodeListToCheck.map(function (node) {
                adjustNodeHeight(node, _dy2);
              });
            }
          } else if (linkY0AtDepth < node.y0 && linkY1AtDepth > node.y1) {
            // if link completely overlaps node
            var _dy3 = linkY1AtDepth - node.y0 + 10;

            var nodeListToCheck = getOverlappedNodes(graph, node, true);

            var _leavesOut2 = checkAnyNodeLeavesOut(nodeListToCheck, extent, _dy3);
            if (!_leavesOut2) {
              nodeListToCheck.map(function (node) {
                adjustNodeHeight(node, _dy3);
              });
            }
          }
        }
      });
    }

    function getOverlappedNodes(graph, node, checkOnlyBottom) {
      var arr = [node];
      //check if other nodes need to move up too
      graph.nodes.forEach(function (otherNode) {
        //don't need to check itself or nodes at different depths
        if (otherNode.name == node.name || otherNode.depth != node.depth) {
          return;
        }
        if (checkOnlyBottom) {
          if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {
            arr.push(otherNode);
          }
        } else {
          if (nodesOverlap(node, otherNode)) {
            arr.push(otherNode);
          }
        }
      });
      return arr;
    }
    function nodesOverlap(nodeA, nodeB) {
      //test if nodeA top partially overlaps nodeB
      if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {
        return true;
      }
      //test if nodeA bottom partially overlaps nodeB
      else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {
        return true;
      }
      //test if nodeA covers nodeB
      else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {
        return true;
      } else {
        return false;
      }
    }

    function adjustNodeHeight(node, dy) {
      node.y0 = node.y0 + dy;
      node.y1 = node.y1 + dy;

      node.targetLinks.forEach(function (l) {
        l.y1 = l.y1 + dy;
      });

      node.sourceLinks.forEach(function (l) {
        l.y0 = l.y0 + dy;
      });

      return node;
    }
    function checkAnyNodeLeavesOut(nodes, extent, dy) {
      var leavesOutside = nodes.some(function (node) {
        //isWithInExtent
        return !(node.y0 + dy > extent.y0 && node.y1 + dy < extent.y1);
      });
      return leavesOutside;
    }
    function sortSourceLinks(graph, height) {
      graph.nodes.forEach(function (node) {
        // move any nodes up which are off the bottom
        if (node.y + (node.y1 - node.y0) > height) {
          node.y = node.y - (node.y + (node.y1 - node.y0) - height);
        }

        var nodesSourceLinks = graph.links.filter(function (l) {
          return l.source.name == node.name;
        });

        // if more than 1 link then sort
        if (nodesSourceLinks.length > 1) {
          nodesSourceLinks.sort(function (link1, link2) {
            // if both are not circular...
            if (!link1.circular && !link2.circular) {
              // if the target nodes are the same depth, then sort by the link's target y
              if (link1.target.depth == link2.target.depth) {
                return link1.y1 - link2.y1;
              } else if (!sameInclines(link1, link2)) {
                // if the links slope in different directions, then sort by the link's target y
                return link1.y1 - link2.y1;

                // if the links slope in same directions, then sort by any overlap
              } else {
                if (link1.target.depth > link2.target.depth) {
                  // if (node.name == "process10") {console.log("here")}
                  /* let link2Angle = linkAngleFromSource(link2);
                      let link2AdjToLink1Y = linkXLength(link1) / Math.tan(link2Angle);
                      let link2Adj = incline(link2) == "up"
                        ? link2.y0 - link2AdjToLink1Y
                        : link2.y0 + link2AdjToLink1Y; */

                  var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);

                  return link1.y1 - link2Adj;
                }
                if (link2.target.depth > link1.target.depth) {
                  /* let link1Angle = linkAngleFromSource(link1);
                      let link1AdjToLink2Y = linkXLength(link2) / Math.tan(link1Angle);
                      let link1Adj = incline(link1) == "up"
                        ? link1.y0 - link1AdjToLink2Y
                        : link1.y0 + link1AdjToLink2Y; */

                  var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);

                  return link1Adj - link2.y1;
                }
              }
            }

            // if only one is circular, the move top links up, or bottom links down
            if (link1.circular && !link2.circular) {
              return link1.circularLinkType == 'top' ? -1 : 1;
            } else if (link2.circular && !link1.circular) {
              return link2.circularLinkType == 'top' ? 1 : -1;
            }

            // if both links are circular...
            if (link1.circular && link2.circular) {
              // ...and they both loop the same way (both top)
              if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
                // ...and they both connect to a target with same depth, then sort by the target's y
                if (link1.target.depth === link2.target.depth) {
                  return link1.target.y1 - link2.target.y1;
                } else {
                  // ...and they connect to different depth targets, then sort by how far back they
                  return link2.target.depth - link1.target.depth;
                }
              } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
                // ...and they both loop the same way (both bottom)
                // ...and they both connect to a target with same depth, then sort by the target's y
                if (link1.target.depth === link2.target.depth) {
                  return link2.target.y1 - link1.target.y1;
                } else {
                  // ...and they connect to different depth targets, then sort by how far back they
                  return link1.target.depth - link2.target.depth;
                }
              } else {
                // ...and they loop around different ways, the move top up and bottom down
                return link1.circularLinkType == 'top' ? -1 : 1;
              }
            }
          });
        }

        // update y0 for links
        var ySourceOffset = node.y0;

        nodesSourceLinks.forEach(function (link) {
          link.y0 = ySourceOffset + link.width / 2;
          ySourceOffset = ySourceOffset + link.width;
        });
      });
    }

    function sortTargetLinks(graph, height) {
      graph.nodes.forEach(function (node) {
        var nodesTargetLinks = graph.links.filter(function (l) {
          return l.target.name == node.name;
        });

        if (nodesTargetLinks.length > 1) {
          nodesTargetLinks.sort(function (link1, link2) {
            // if both are not circular, the base on the source y position
            if (!link1.circular && !link2.circular) {
              if (link1.source.depth == link2.source.depth) {
                return link1.y0 - link2.y0;
              } else if (!sameInclines(link1, link2)) {
                return link1.y0 - link2.y0;
              } else {
                // get the angle of the link to the further source node (ie the smaller depth)
                if (link2.source.depth < link1.source.depth) {
                  var link2Adj = linkPerpendicularYToLinkSource(link2, link1);

                  return link1.y0 - link2Adj;
                }
                if (link1.source.depth < link2.source.depth) {
                  var link1Adj = linkPerpendicularYToLinkSource(link1, link2);

                  return link1Adj - link2.y0;
                }
              }
            }

            // if only one is circular, the move top links up, or bottom links down
            if (link1.circular && !link2.circular) {
              return link1.circularLinkType == 'top' ? -1 : 1;
            } else if (link2.circular && !link1.circular) {
              return link2.circularLinkType == 'top' ? 1 : -1;
            }

            // if both links are circular...
            if (link1.circular && link2.circular) {
              // ...and they both loop the same way (both top)
              if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
                // ...and they both connect to a target with same depth, then sort by the target's y
                if (link1.source.depth === link2.source.depth) {
                  return link1.source.y1 - link2.source.y1;
                } else {
                  // ...and they connect to different depth targets, then sort by how far back they
                  return link1.source.depth - link2.source.depth;
                }
              } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
                // ...and they both loop the same way (both bottom)
                // ...and they both connect to a target with same depth, then sort by the target's y
                if (link1.source.depth === link2.source.depth) {
                  return link1.source.y1 - link2.source.y1;
                } else {
                  // ...and they connect to different depth targets, then sort by how far back they
                  return link2.source.depth - link1.source.depth;
                }
              } else {
                // ...and they loop around different ways, the move top up and bottom down
                return link1.circularLinkType == 'top' ? -1 : 1;
              }
            }
          });
        }

        // update y1 for links
        var yTargetOffset = node.y0;

        nodesTargetLinks.forEach(function (link) {
          link.y1 = yTargetOffset + link.width / 2;
          yTargetOffset = yTargetOffset + link.width;
        });
      });
    }

    function sameInclines(link1, link2) {
      return incline(link1) == incline(link2);
    }

    function incline(link) {
      // positive => slopes up from source to target
      // negative => slopes down from source to target
      return link.y0 - link.y1 > 0 ? 'up' : 'down';
    }

    function addCircularPathData(graph, linkPadding) {
      var baseRadius = 10;
      var buffer = 10;
      var verticalMargin = 25;
      var circularLinkGap = 2,
        height = graph.y1;

      var minY = d3_min(graph.links, function (link) {
        return link.source.y0;
      });

      // create object for circular Path Data
      graph.links.forEach(function (link) {
        if (link.circular) {
          link.circularPathData = {};
        }
      });

      // calc vertical offsets per top/bottom links
      var topLinks = graph.links.filter(function (l) {
        return l.circularLinkType == 'top';
      });
      topLinks = calcVerticalBuffer(topLinks);

      var bottomLinks = graph.links.filter(function (l) {
        return l.circularLinkType == 'bottom';
      });
      bottomLinks = calcVerticalBuffer(bottomLinks);

      // add the base data for each link
      graph.links.forEach(function (link) {
        if (link.circular) {
          link.circularPathData.arcRadius = link.width + baseRadius;
          link.circularPathData.leftNodeBuffer = buffer;
          link.circularPathData.rightNodeBuffer = buffer;
          link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;

          if (link.circularLinkType == 'bottom') {
            link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth + linkPadding;
            link.circularPathData.targetX = link.target.x0 - linkPadding;
            link.circularPathData.sourceY = link.y0 - link.width / 2;
            link.circularPathData.targetY = link.y1 - link.width / 2;
          } else {
            link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth + linkPadding;
            link.circularPathData.targetX = link.target.x0 - linkPadding;
            link.circularPathData.sourceY = link.y0 + link.width / 2;
            link.circularPathData.targetY = link.y1 + link.width / 2;
          }

          // add left extent coordinates, based on links with same source depth and circularLink type
          var thisDepth = link.source.depth;
          var thisCircularLinkType = link.circularLinkType;
          var sameDepthLinks = graph.links.filter(function (l) {
            return l.source.depth == thisDepth && l.circularLinkType == thisCircularLinkType;
          });

          if (link.circularLinkType == 'bottom') {
            sameDepthLinks.sort(sortLinkSourceYDescending);
          } else {
            sameDepthLinks.sort(sortLinkSourceYAscending);
          }

          var radiusOffset = 0;
          sameDepthLinks.forEach(function (l, i) {
            if (l.circularLinkID == link.circularLinkID) {
              link.circularPathData.leftSmallArcRadius = baseRadius + link.width + radiusOffset;
              link.circularPathData.leftLargeArcRadius = baseRadius + link.width + i * circularLinkGap + radiusOffset;

              link.circularPathData.leftSmallArcRadius1 = link.circularPathData.leftSmallArcRadius - link.width;
              link.circularPathData.leftLargeArcRadius1 = link.circularPathData.leftLargeArcRadius - link.width;
            }
            radiusOffset = radiusOffset + l.width;
          });

          // add right extent coordinates, based on links with same target depth and circularLink type
          thisDepth = link.target.depth;
          sameDepthLinks = graph.links.filter(function (l) {
            return l.target.depth == thisDepth && l.circularLinkType == thisCircularLinkType;
          });
          if (link.circularLinkType == 'bottom') {
            sameDepthLinks.sort(sortLinkTargetYDescending);
          } else {
            sameDepthLinks.sort(sortLinkTargetYAscending);
          }

          radiusOffset = 0;
          sameDepthLinks.forEach(function (l, i) {
            if (l.circularLinkID == link.circularLinkID) {
              link.circularPathData.rightSmallArcRadius = baseRadius + link.width + radiusOffset;
              link.circularPathData.rightLargeArcRadius = baseRadius + link.width + i * circularLinkGap + radiusOffset;

              link.circularPathData.rightSmallArcRadius1 = link.circularPathData.rightSmallArcRadius - link.width;
              link.circularPathData.rightLargeArcRadius1 = link.circularPathData.rightLargeArcRadius - link.width;
            }
            radiusOffset = radiusOffset + l.width;
          });

          // all links
          link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;
          link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;
          link.circularPathData.leftFullExtent =
          link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;
          link.circularPathData.rightFullExtent =
          link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;

          link.circularPathData.rightFullExtent1 = link.circularPathData.rightFullExtent + link.width;
          link.circularPathData.rightInnerExtent1 = link.circularPathData.rightFullExtent1 + link.circularPathData.rightLargeArcRadius1;

          link.circularPathData.leftFullExtent1 = link.circularPathData.leftFullExtent - link.width;
          link.circularPathData.leftInnerExtent1 = link.circularPathData.leftFullExtent1 - link.circularPathData.leftLargeArcRadius1;

          link.circularPathData.leftWidth = link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;
          link.circularPathData.rightWidth = link.circularPathData.rightLargeArcRadius + link.circularPathData.rightNodeBuffer;
          // bottom links
          if (link.circularLinkType == 'bottom') {
            link.circularPathData.verticalFullExtent = height + verticalMargin + link.circularPathData.verticalBuffer;
            link.circularPathData.verticalLeftInnerExtent =
            link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;
            link.circularPathData.verticalRightInnerExtent =
            link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;

            link.circularPathData.verticalFullExtent1 = height + verticalMargin + link.circularPathData.verticalBuffer - link.width;
            link.circularPathData.verticalRightInnerExtent1 = link.circularPathData.verticalFullExtent1;

            link.circularPathData.verticalLeftInnerExtent1 = link.circularPathData.verticalFullExtent1;
            link.circularPathData.totalHeight = verticalMargin + link.circularPathData.verticalBuffer;
            // link.circularPathData.verticalRightInnerExtent1 = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius/2
          } else {
            // top links
            link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;
            link.circularPathData.verticalLeftInnerExtent =
            link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;
            link.circularPathData.verticalRightInnerExtent =
            link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;

            link.circularPathData.verticalFullExtent1 = link.circularPathData.verticalFullExtent + link.width;
            link.circularPathData.verticalLeftInnerExtent1 = link.circularPathData.verticalFullExtent1;
            link.circularPathData.verticalRightInnerExtent1 = link.circularPathData.verticalFullExtent1;

            link.circularPathData.totalHeight = verticalMargin + link.circularPathData.verticalBuffer;
          }

          link.circularPathData.path = sankeyCircularLink(link);
        }
      });
    }

    function circularSankeyGenerator(graph, sankeyExtent, linkPadding) {
      //sort links per node, based on the links' source/target positions
      sortSourceLinks(graph);
      sortTargetLinks(graph);

      //adjust nodes that overlap links that span 2+ depths
      resolveNodeLinkOverlaps(graph);

      //sort links per node, based on the links' source/target positions
      sortSourceLinks(graph, graph.y1);
      sortTargetLinks(graph, graph.y1);

      // adjustSankeySize(graph, graph.y1);
      fillHeight(graph, graph.y0, graph.y1, sankeyExtent);
      //add d string for circular paths
      addCircularPathData(graph, linkPadding);
    }

    function targetDepth(d) {
      return d.target.depth;
    }

    function left(node) {
      return node.depth;
    }

    function right(node, n) {
      return n - 1 - node.height;
    }

    function justify(node, n) {
      return node.sourceLinks.length ? node.depth : n - 1;
    }

    function center(node) {
      return node.targetLinks.length ? node.depth : node.sourceLinks.length ? d3_min(node.sourceLinks, targetDepth) - 1 : 0;
    }

    function constant(x) {
      return function () {
        return x;
      };
    }

    function ascendingSourceBreadth(a, b) {
      return ascendingBreadth(a.source, b.source) || a.index - b.index;
    }

    function ascendingTargetBreadth(a, b) {
      return ascendingBreadth(a.target, b.target) || a.index - b.index;
    }

    function ascendingBreadth(a, b) {
      if (a.partOfCycle === b.partOfCycle) {
        return a.y0 - b.y0;
      } else {
        if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {
          return -1;
        } else {
          return 1;
        }
      }
    }

    function value(d) {
      return d.value;
    }

    function defaultId(d) {
      return d.index;
    }

    function defaultNodes(graph) {
      return graph.nodes;
    }

    function defaultLinks(graph) {
      return graph.links;
    }

    function find(nodeById, id) {
      var node = nodeById.get(id);

      if (!node) {
        throw new Error("missing: ".concat(id));
      }

      return node;
    }

    var Sankey = function Sankey() {
      var x0 = 0,
        y0 = 0,
        x1 = 1,
        y1 = 1, // extent
        dx = 24, // nodeWidth
        py, // nodePadding
        dy = 8,
        scale = 1,
        id = defaultId,
        align = justify,
        nodes = defaultNodes,
        links = defaultLinks,
        link_padding = 0,
        iterations = 1;
      var sort;
      var linkSort;
      var paddingRatio = 0.1,
        height,
        margin;

      function sankey() {
        var graph = {
          nodes: nodes.apply(null, arguments),
          links: links.apply(null, arguments),
          x0: x0,
          y0: y0,
          x1: x1,
          y1: y1
        };
        var sankeyExtent = {
          x0: x0,
          y0: y0,
          x1: x1,
          y1: y1
        };
        computeNodeLinks(graph);
        identifyCircles(graph);
        selectCircularLinkTypes(graph);
        computeNodeValues(graph);

        computeNodeDepths(graph);
        adjustSankeySize(graph, sankeyExtent);
        computeNodeBreadths(graph, iterations);
        computeLinkBreadths(graph, sankeyExtent);

        if (graph.circular) {
          circularSankeyGenerator(graph, sankeyExtent, link_padding);
        }

        return graph;
      }

      sankey.update = function (graph) {
        computeLinkBreadths(graph);
        return graph;
      };

      sankey.nodeId = function (_) {
        return arguments.length ? (id = typeof _ === 'function' ? _ : constant(_), sankey) : id;
      };

      sankey.nodeAlign = function (_) {
        return arguments.length ? (align = typeof _ === 'function' ? _ : constant(_), sankey) : align;
      };

      sankey.nodeSort = function (_) {
        return arguments.length ? (sort = _, sankey) : sort;
      };

      sankey.nodeWidth = function (_) {
        return arguments.length ? (dx = +_, sankey) : dx;
      };

      sankey.nodePadding = function (_) {
        return arguments.length ? (dy = py = +_, sankey) : dy;
      };
      sankey.linkPadding = function (_) {
        return arguments.length ? (link_padding = +_, sankey) : link_padding;
      };

      sankey.scale = function (_) {
        return arguments.length ? (scale = +_, sankey) : scale;
      };

      sankey.nodes = function (_) {
        return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant(_), sankey) : nodes;
      };

      sankey.links = function (_) {
        return arguments.length ? (links = typeof _ === 'function' ? _ : constant(_), sankey) : links;
      };

      sankey.linkSort = function (_) {
        return arguments.length ? (linkSort = _, sankey) : linkSort;
      };

      sankey.size = function (_) {
        return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
      };

      sankey.extent = function (_) {
        return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
      };

      sankey.iterations = function (_) {
        return arguments.length ? (iterations = +_, sankey) : iterations;
      };

      sankey.nodePaddingRatio = function (_) {
        return arguments.length ? (paddingRatio = +_, sankey) : paddingRatio;
      };

      sankey.height = function (_) {
        return arguments.length ? (height = +_, sankey) : height;
      };
      sankey.margin = function (_) {
        return arguments.length ? (margin = _, sankey) : margin;
      };

      // Populate the sourceLinks and targetLinks for each node.
      // Also, if the source and target are not objects, assume they are indices.
      function computeNodeLinks(graph) {
        graph.nodes.forEach(function (node, i) {
          node.index = i;
          node.sourceLinks = [];
          node.targetLinks = [];
        });
        var nodeById = d3_map(graph.nodes, id);
        graph.links.forEach(function (link, i) {
          link.index = i;
          var source = link.source;
          var target = link.target;
          if (_typeof(source) !== 'object') {
            source = link.source = find(nodeById, source);
          }
          if (_typeof(target) !== 'object' && !link.exit) {
            target = link.target = find(nodeById, target);
          }
          source.sourceLinks.push(link);
          if (!link.exit) {
            source.hasExitLink = true;
            target.targetLinks.push(link);
          }
        });

        graph.nodes.forEach(function (node, i) {
          if (node.hasExitLink) {
            node.sourceLinks.sort(function (a, b) {
              return a.exit ? 100000 - b.index : b.exit ? a.index - 100000 : a.index - b.index;
            });
          }
        });
      }

      // Compute the value (size) and cycleness of each node by summing the associated links.
      function computeNodeValues(graph) {
        graph.nodes.forEach(function (node) {
          node.partOfCycle = false;
          node.value = Math.max(d3_sum(node.sourceLinks, value), d3_sum(node.targetLinks, value));
          node.sourceLinks.forEach(function (link) {
            if (link.circular) {
              node.partOfCycle = true;
              node.circularLinkType = link.circularLinkType;
            }
          });
          node.targetLinks.forEach(function (link) {
            if (link.circular) {
              node.partOfCycle = true;
              node.circularLinkType = link.circularLinkType;
            }
          });
        });
      }

      // Iteratively assign the depth (x-position) for each node.
      // Nodes are assigned the maximum depth of incoming neighbors plus one;
      // nodes with no incoming links are assigned depth zero, while
      // nodes with no outgoing links are assigned the maximum depth.
      function computeNodeDepths(graph) {
        var nodes, next, x;

        for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
          for (var i in nodes) {
            if (nodes.hasOwnProperty(i)) {
              var node = nodes[i];
              node.depth = x;
              for (var j in node.sourceLinks) {
                if (node.sourceLinks.hasOwnProperty(j)) {
                  var link = node.sourceLinks[j];
                  if (next.indexOf(link.target) < 0 && !link.circular && !link.exit) {
                    next.push(link.target);
                  }
                }
              }
            }
          }
        }

        for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
          for (var _i3 in nodes) {
            if (nodes.hasOwnProperty(_i3)) {
              var _node2 = nodes[_i3];
              _node2.height = x;
              for (var _j2 in _node2.targetLinks) {
                if (_node2.targetLinks.hasOwnProperty(_j2)) {
                  var _link = _node2.targetLinks[_j2];
                  if (next.indexOf(_link.source) < 0 && !_link.circular) {
                    next.push(_link.source);
                  }
                }
              }
            }
          }
        }

        var kx = (x1 - x0 - dx) / (x - 1);
        graph.nodes.forEach(function (node) {
          node.x1 = (node.x0 = x0 + Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x)))) * kx) + dx;
        });
        // assign column numbers, and get max value
        graph.nodes.forEach(function (node) {
          node.column = Math.floor(align.call(null, node, x));
        });
      }
      function computeNodeLayers(graph) {
        var nodes = graph.nodes,
          x = d3_max(nodes, function (d) {return d.depth;}) + 1,
          kx = (x1 - x0 - dx) / (x - 1);

        var columns = new Array(x);
        nodes.forEach(function (node) {
          var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
          node.layer = i;
          node.x0 = x0 + i * kx;
          node.x1 = node.x0 + dx;

          if (columns[i]) {
            columns[i].push(node);
          } else {
            columns[i] = [node];
          }
        });

        if (sort) {
          columns.forEach(function (column) {
            column.sort(sort);
          });
        }

        return columns;
      }
      function computeNodeBreadths(graph) {
        var columns = computeNodeLayers(graph),
          maxRows = d3_max(columns, function (c) {return c.length;});
        graph.columns = columns.length;
        graph.rows = maxRows;
        py = Math.min(dy, (y1 - y0) / (maxRows - 1));

        initializeNodeBreadth();

        for (var i = 0; i < iterations; ++i) {
          var alpha = Math.pow(0.99, i);
          var beta = Math.max(1 - alpha, (i + 1) / iterations);
          relaxRightToLeft(columns, alpha, beta);
          relaxLeftToRight(columns, alpha, beta);
        }
        // Reposition each node based on its incoming (target) links.
        function _loop1(column, i, alpha, beta) {
          if (column.hasOwnProperty(i)) {
            var target = column[i];
            var y = 0;
            var w = 0;
            target.targetLinks.forEach(function (targetLink) {
              var source = targetLink.source,value = targetLink.value,
                v = value * (target.layer - source.layer);
              y += targetTop(source, target) * v;
              w += v;
            });
            if (!(w > 0)) ;else {
              var _dy4 = (y / w - target.y0) * alpha;
              target.y0 += _dy4;
              target.y1 += _dy4;
              reorderNodeLinks(target);
            }

          }
        }
        function relaxLeftToRight(columns, alpha, beta) {
          for (var _i5 = 1, n = columns.length; _i5 < n; ++_i5) {
            var column = columns[_i5];
            for (var _i7 in column) {
              _loop1(column, _i7, alpha, beta);
            }
            if (sort === undefined) {
              column.sort(ascendingBreadth);
            }
            resolveCollisions(column, beta, graph.circular);
          }
        }


        function _loop2(column, i, alpha, beta) {
          if (column.hasOwnProperty(i)) {
            var source = column[i];
            var y = 0;
            var w = 0;
            source.sourceLinks.forEach(function (sourceLink) {
              var target = sourceLink.target,value = sourceLink.value,
                v = value * (target.layer - source.layer);
              y += sourceTop(source, target) * v;
              w += v;
            });
            if (!(w > 0)) ;else {
              var _dy5 = (y / w - source.y0) * alpha;
              source.y0 += _dy5;
              source.y1 += _dy5;
              reorderNodeLinks(source);
            }

          }
        }
        // Reposition each node based on its outgoing (source) links.
        function relaxRightToLeft(columns, alpha, beta) {
          for (var n = columns.length, _i9 = n - 2; _i9 >= 0; --_i9) {
            var column = columns[_i9];
            for (var _i11 in column) {
              _loop2(column, _i11, alpha, beta);
            }
            if (sort === undefined) {
              column.sort(ascendingBreadth);
            }
            resolveCollisions(column, beta);
          }
        }


        function resolveCollisions(nodes, alpha) {
          var i = nodes.length >> 1;
          var subject = nodes[i];
          resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
          resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
          resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
          resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
        }

        // Push any overlapping nodes down.
        function resolveCollisionsTopToBottom(nodes, y, i, alpha) {
          for (; i < nodes.length; ++i) {
            var node = nodes[i];
            var _dy6 = (y - node.y0) * alpha;
            if (_dy6 > 1e-6) {
              node.y0 += _dy6, node.y1 += _dy6;
            }
            y = node.y1 + py;
          }
        }

        // Push any overlapping nodes up.
        function resolveCollisionsBottomToTop(nodes, y, i, alpha) {
          for (; i >= 0; --i) {
            var node = nodes[i];
            var _dy7 = (node.y1 - y) * alpha;
            if (_dy7 > 1e-6) {
              node.y0 -= _dy7, node.y1 -= _dy7;
            }
            y = node.y0 - py;
          }
        }

        function reorderNodeLinks(_ref7) {var sourceLinks = _ref7.sourceLinks,targetLinks = _ref7.targetLinks;
          if (linkSort === undefined) {
            if (targetLinks) {
              targetLinks.forEach(function (targetLink) {
                var
                sourceLinks =
                targetLink.source.sourceLinks;
                sourceLinks.sort(ascendingTargetBreadth);
              });
            }
            sourceLinks.forEach(function (sourceLink) {
              var
              targetLinks =
              sourceLink.target.targetLinks;
              if (targetLinks) {
                targetLinks.sort(ascendingSourceBreadth);
              }
            });
          }
        }
        function reorderLinks(nodes) {
          if (linkSort === undefined) {
            nodes.forEach(function (node) {
              var sourceLinks = node.sourceLinks,targetLinks = node.targetLinks;
              sourceLinks.sort(ascendingTargetBreadth);
              if (targetLinks) {
                targetLinks.sort(ascendingSourceBreadth);
              }
            });
          }
        }
        // Returns the target.y0 that would produce an ideal link from source to target.
        function targetTop(source, target) {
          var y = source.y0 - (source.sourceLinks.length - 1) * py / 2;
          for (var _i13 in source.sourceLinks) {
            if (source.sourceLinks.hasOwnProperty(_i13)) {
              var _source$sourceLinks$_2 = source.sourceLinks[_i13],node = _source$sourceLinks$_2.target,width = _source$sourceLinks$_2.width;
              if (node === target) {
                break;
              }
              y += width + py;
            }
          }
          for (var _i15 in target.targetLinks) {
            if (target.targetLinks.hasOwnProperty(_i15)) {
              var _target$targetLinks$_2 = target.targetLinks[_i15],_node3 = _target$targetLinks$_2.source,_width3 = _target$targetLinks$_2.width;
              if (_node3 === source) {
                break;
              }
              y -= _width3;
            }
          }
          return y;
        }

        // Returns the source.y0 that would produce an ideal link from source to target.
        function sourceTop(source, target) {
          if (target != 'null') {
            var y = target.y0 - (target.targetLinks.length - 1) * py / 2;
            for (var _i17 in target.targetLinks) {
              if (target.targetLinks.hasOwnProperty(_i17)) {
                var _target$targetLinks$_4 = target.targetLinks[_i17],node = _target$targetLinks$_4.source,width = _target$targetLinks$_4.width;
                if (node === source) {
                  break;
                }
                y += width + py;
              }
            }
            for (var _i19 in source.sourceLinks) {
              if (source.sourceLinks.hasOwnProperty(_i19)) {
                var _source$sourceLinks$_4 = source.sourceLinks[_i19],_node4 = _source$sourceLinks$_4.target,_width4 = _source$sourceLinks$_4.width;
                if (_node4 === target) {
                  break;
                }
                y -= _width4;
              }
            }
            return y;
          }
        }
        function initializeNodeBreadth() {
          // columns.forEach(function(nodes) {
          //     let thisPadding = (y1 * paddingRatio) / (nodes.length + 1);
          //     padding = thisPadding < padding ? thisPadding : padding;
          // });
          //
          // py = padding;

          var ky = d3_min(columns, function (c) {return (y1 - y0 - (c.length - 1) * py) / d3_sum(c, value);});
          var ky1 = d3_min(columns, function (c) {return (y1 - y0 - (c.length - 1) * py) / d3_sum(c, value);});

          ky = graph.ky || ky;
          // ky = ky * scale;

          columns.forEach(function (nodes) {
            var y = y0;
            nodes.forEach(function (node) {
              node.y0 = y;
              node.y1 = y + node.value * ky;
              y = node.y1 + py;
              node.sourceLinks.forEach(function (link) {
                link.width = link.value * ky;
              });
            });
            y = (y1 - y + py) / (nodes.length + 1);
            for (var _i21 = 0; _i21 < nodes.length; ++_i21) {
              var node = nodes[_i21];
              if (node.partOfCycle) {
                if (node.circularLinkType == 'top') {
                  node.y0 = y0 + _i21;
                  node.y1 = node.y0 + node.value * ky;
                } else {
                  node.y0 = y1 - node.value * ky - _i21;
                  node.y1 = node.y0 + node.value * ky;
                }
              } else {
                node.y0 += y * (_i21 + 1);
                node.y1 += y * (_i21 + 1);
              }
            }
            reorderLinks(nodes);
          });
        }
        function resolveCollisions(nodes, alpha, circular) {
          if (circular) {
            return resolveCollisions1();
          }
          var i = nodes.length >> 1;
          var subject = nodes[i];
          resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
          resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
          resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
          resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
        } // Push any overlapping nodes down.
        function resolveCollisions1() {
          // for (; i >= 0; --i) {
          //     const node = nodes[i];
          //     const dy = (node.y1 - y) * alpha;
          //     if (dy > 1e-6) {
          //         (node.y0 -= dy), (node.y1 -= dy);
          //     }
          //     y = node.y0 - py;
          // }
          columns.forEach(function (nodes) {
            var node,
              dy,
              y = y0,
              n = nodes.length,
              i;

            // Push any overlapping nodes down.
            nodes.sort(ascendingBreadth);

            for (i = 0; i < n; ++i) {
              node = nodes[i];
              dy = y - node.y0;

              if (dy > 0) {
                node.y0 += dy;
                node.y1 += dy;
              }
              y = node.y1 + py;
            }

            // If the bottommost node goes outside the bounds, push it back up.
            dy = y - py - y1;
            if (dy > 0) {
              y = node.y0 -= dy, node.y1 -= dy;

              // Push any overlapping nodes back up.
              for (i = n - 2; i >= 0; --i) {
                node = nodes[i];
                dy = node.y1 + py - y;
                if (dy > 0) {
                  node.y0 -= dy, node.y1 -= dy;
                }
                y = node.y0;
              }
            }
          });
        }
      }

      function computeLinkBreadths(graph, sankeyExtent) {
        graph.nodes.forEach(function (node) {
          node.sourceLinks.sort(ascendingTargetBreadth);
          node.targetLinks.sort(ascendingSourceBreadth);
        });
        graph.nodes.forEach(function (node) {
          var y0 = node.y0;
          var y1 = y0;

          // start from the bottom of the node for cycle links
          var y0cycle = node.y1;
          var y1cycle = y0cycle;

          node.sourceLinks.forEach(function (link) {
            if (link.circular) {
              link.y0 = y0cycle - link.width / 2;
              y0cycle = y0cycle - link.width;
            } else {
              link.y0 = y0 + link.width / 2;
              y0 += link.width;
            }
            //Precalculate exit node at end node details
            if (link.exit && !graph.exitAtEndNode && sankeyExtent) {
              var s = link.source;
              if (s.x1 == sankeyExtent.x1) {
                graph.exitAtEndNode = link.width;
              }
            }
          });
          node.targetLinks.forEach(function (link) {
            if (link.circular) {
              link.y1 = y1cycle - link.width / 2;
              y1cycle = y1cycle - link.width;
            } else {
              link.y1 = y1 + link.width / 2;
              y1 += link.width;
            }
          });
        });
      }
      function adjustSankeySize(inputGraph, sankeyExtent) {
        // return
        var graph = inputGraph;
        if (graph.circular) {
          var columns = computeNodeLayers(graph);

          graph.py = py;
          var ky = d3_min(columns, function (c) {return (sankeyExtent.y1 - sankeyExtent.y0 - (c.length - 1) * py) / d3_sum(c, value);});

          // graph.links.forEach(function(link) {
          //     link.width = link.value * ky;
          // });

          var maxColumn = d3_max(graph.nodes, function (node) {
            return node.column;
          });
          //determine how much to scale down the chart, based on circular links
          /*
          PRECALCULATE CIRCULAR LINK MARGINS
           */
          var currentWidth = graph.x1 - graph.x0;
          var currentHeight = graph.y1 - graph.y0;

          var linkmargin = getCircularLinkMargin(graph, ky, null, maxColumn);

          /*
              RECALCULATE Y0, Y1
               */
          var newWidth = currentWidth + linkmargin.right + linkmargin.left;
          var newHeight = currentHeight + linkmargin.top + linkmargin.bottom;

          var scaleX = currentWidth / newWidth;
          var scaleY = currentHeight / newHeight;

          if (linkmargin.top > currentHeight || linkmargin.top > graph.y1 * scaleY) {
            //if margin values exceed the actual height of sanky, we will calculate proportions between margin top and margin bottom.
            var expectedHei = currentHeight * scaleY;
            var remaining = currentHeight - expectedHei;
            var totalYMargin = linkmargin.top + linkmargin.bottom,
              topRatio = linkmargin.top / totalYMargin,
              bottomRatio = linkmargin.bottom / totalYMargin,
              newTopMargin = remaining * topRatio,
              newBottomMargin = remaining * bottomRatio;
            y0 = graph.y0 = newTopMargin;
            y1 = graph.y1 = graph.y1 - newBottomMargin;
          } else {
            y0 = graph.y0 = graph.y0 * scaleY + linkmargin.top;
            y1 = graph.y1 = linkmargin.bottom == 0 ? graph.y1 : graph.y1 * scaleY;

            x0 = graph.x0 = graph.x0 * scaleX + linkmargin.left;
            x1 = graph.x1 = linkmargin.right == 0 ? graph.x1 : graph.x1 * scaleX;
          }
          /*
          re-calculate widths BASED ON NEW KY
            */

          // ky = ky * scaleY;
          ky = d3_min(columns, function (c) {return (y1 - y0 - (c.length - 1) * py) / d3_sum(c, value);});
          // graph.ky = ky;
          var linkmargin = getCircularLinkMargin(graph, ky, null, maxColumn);

          /*
          ADJUSTMENT BASED ON ORIGINAL HEIGHT
          find final estimated sankey height
           */

          var existingY1 = graph.y1;
          var existingY0 = graph.y0;
          // y0 = graph.y0 = sankeyExtent.y0 + linkmargin.top;
          var newHeight = y1 = graph.y1 = sankeyExtent.y1 - linkmargin.bottom;

          // var y_ratio = (y1 - y0) / (existingY1 - existingY0);
          var y_ratio = newHeight / existingY1;

          // currentHeight = existingY1 - existingY0;
          // scaleY = currentHeight / (currentHeight + linkmargin.top + linkmargin.bottom);

          // y0 = graph.y0 = sankeyExtent.y0 * scaleY + linkmargin.top;
          // y0 = graph.y0 = existingY0 * scaleY + linkmargin.top+existingY0 ;
          // y1 = graph.y1 = (existingY1 - existingY1 * scaleY);

          // var y_ratio = (sankeyExtent.y1 - linkmargin.bottom - sankeyExtent.y0 + linkmargin.top) / (existingY1 - existingY0);
          // var y_ratio = newHeight / existingY1;

          ky = d3_min(columns, function (c) {return (y1 - y0 - (c.length - 1) * py) / d3_sum(c, value);});
          // graph.ky = ky;

          /*
          Find actual deviated margins from original margin calculated for outside label
          Already sankeyextent.x0 and x1 values loaded with datalabel margin
          Now we need to adjust it with circular link margin
           */
          var linkmargin = getCircularLinkMargin(graph, null, y_ratio, maxColumn);
          if (margin && margin.right) {
            //if outside label margin is >  circular link margin, then no need of correction, else find differenece between the both
            linkmargin.right = margin.right > linkmargin.right ? 0 : linkmargin.right - margin.right;
          }
          if (margin && margin.left) {
            linkmargin.left = margin.left > linkmargin.left ? 0 : linkmargin.left - margin.left;
          }

          currentWidth = sankeyExtent.x1 - sankeyExtent.x0;
          scaleX = currentWidth / (currentWidth + linkmargin.right + linkmargin.left);
          // x0 = graph.x0 = sankeyExtent.x0 * scaleX + linkmargin.left;
          // x1 = graph.x1 = linkmargin.right == 0 ? sankeyExtent.x1 : sankeyExtent.x1 * scaleX;

          x0 = graph.x0 = sankeyExtent.x0 + linkmargin.left;
          x1 = graph.x1 = sankeyExtent.x1 - linkmargin.right;

          // y0 = graph.y0 = sankeyExtent.y0 + linkmargin.top;
          // y1 = graph.y1 = sankeyExtent.y1 - linkmargin.bottom;
          ky = d3_min(columns, function (c) {return (y1 - y0 - (c.length - 1) * py) / d3_sum(c, value);});
          // graph.ky = ky;
          graph.nodes.forEach(function (node) {
            node.x0 = graph.x0 + node.column * ((graph.x1 - graph.x0 - dx) / maxColumn);
            node.x1 = node.x0 + dx;
          });
        }

        return graph;
      }

      return sankey;
    };

    /// /////////////////////////////////////////////////////////////////////////////////
    // Cycle functions

    //portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043

    // Identify circles in the link objects
    function identifyCircles(graph) {
      var addedLinks = [];
      var circularLinkID = 0;
      graph.links.forEach(function (link) {
        if (createsCycle(link.source, link.target, addedLinks)) {
          graph.circular = true;
          link.circular = true;
          link.circularLinkID = circularLinkID;
          circularLinkID = circularLinkID + 1;
        } else {
          link.circular = false;
          addedLinks.push(link);
        }
      });
    }

    function selectCircularLinkTypes(graph) {
      if (graph.circular) {
        var numberOfTops = 0;
        var numberOfBottoms = 0;
        graph.links.forEach(function (link) {
          if (link.circular) {
            // if either souce or target has type already use that
            if (link.source.circularLinkType || link.target.circularLinkType) {
              // default to source type if available
              link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;
            } else {
              link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';
            }

            if (link.circularLinkType == 'top') {
              numberOfTops = numberOfTops + 1;
            } else {
              numberOfBottoms = numberOfBottoms + 1;
            }

            graph.nodes.forEach(function (node) {
              if (node.name == link.source.name || node.name == link.target.name) {
                node.circularLinkType = link.circularLinkType;
              }
            });
          }
        });
        graph.circularLinks = numberOfTops + numberOfBottoms;
      }
    }

    // Checks if link creates a cycle
    function createsCycle(originalSource, nodeToCheck, graph) {
      if (graph.length == 0) {
        return false;
      }

      var nextLinks = findLinksOutward(nodeToCheck, graph);
      // leaf node check
      if (nextLinks.length == 0) {
        return false;
      }

      // cycle check
      for (var i = 0; i < nextLinks.length; i++) {
        var nextLink = nextLinks[i];

        if (nextLink.target === originalSource) {
          return true;
        }

        // Recurse
        if (createsCycle(originalSource, nextLink.target, graph)) {
          return true;
        }
      }

      // Exhausted all links
      return false;
    }

    /* Given a node, find all links for which this is a source
       in the current 'known' graph  */
    function findLinksOutward(node, graph) {
      var children = [];

      for (var i = 0; i < graph.length; i++) {
        if (node == graph[i].source) {
          children.push(graph[i]);
        }
      }

      return children;
    }

    Registry.setComponent('d3_Sankey', Sankey);

    //$Id$

    var sankeyAlign = {
      left: left,
      right: right,
      center: center,
      justify: justify
    };

    /**
     *
     * @param extent
     * @param iterations
     * @param sankeyOptions
     * @return {*}
     */
    function getSankeyLayout(sankeyOptions, extent, iterations) {var nodeMaxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var margin = arguments.length > 4 ? arguments[4] : undefined;
      var linkOptions = sankeyOptions.link;
      var layout = Sankey().
      extent(extent).
      nodeWidth(mathMin(nodeMaxWidth, sankeyOptions.node.width)).
      nodeSort(sankeyOptions.node.sort).
      linkSort(sankeyOptions.link.sort).
      nodePadding(sankeyOptions.node.padding || 0).
      linkPadding(linkOptions.padding || 0).
      iterations(iterations || sankeyOptions.iterations || 64).
      nodeId(function (node) {return node.name;}).
      height(extent[1][1]).
      margin(margin);

      if (sankeyOptions.align) {
        layout.nodeAlign(sankeyAlign[sankeyOptions.align]);
      }

      return layout;
    }

    // #ZC2641 removed patternIndex = point.seriesIndex
    function patternFillEffect(point, basecolor, patternIndex) {
      var renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        legendH = this.chart.legendHighlight,
        hasMultiColor = isMultiColoring(rp.commonPlotOptions, this.chart),
        seriesIndex = point.seriesIndex,paneid = point.paneid,
        index = pick(patternIndex, hasMultiColor ? pick(point.categoryIndex, point.sortedItemIndex) : seriesIndex),
        cType_Obj = getChartTypeByIndex(this.chart, paneid, seriesIndex),
        cType = isBarChartType(cType_Obj.value) ? 'bar' : cType_Obj.name,
        highlightEffect = legendH.getLegendHighlightEffect(seriesIndex, 'selectedSeries', 'plot', paneid),
        unHighlightEffect = legendH.getLegendHighlightEffect(seriesIndex, 'unselectedSeries', 'plot', paneid),
        options = this.options(point),
        seriescolor = options.color,
        hasColor = HIGHLIGHT_EFFECT_REGEX.test(highlightEffect) || UNHIGHLIGHT_EFFECT_REGEX.test(unHighlightEffect),
        fillColor = hasColor ? seriescolor : TRANSPARENT,
        styleObj = {};

      if (highlightEffect == NONE) {
        styleObj.fill = cType_Obj.value === charttype.wordcloud && options.fillColor || fillColor;
      } else {
        var patternStyles = {};
        patternStyles.fill = fillColor;
        patternStyles.stroke = seriescolor;
        basecolor = basecolor == 'inherit' ? seriescolor : patternStyles.fill;
        styleObj = legendH.getEffect(highlightEffect, cType, basecolor, patternStyles, index, 'plot');

        if (arrayIncludes(chartcategory.nonAxisSingleSourceEvent, cType_Obj.value)) {
          styleObj = _objectSpread({
            fill: hasColor || cType_Obj.value === charttype.wordcloud ? options.fillColor : TRANSPARENT,
            stroke: options.strokeColor },
          styleObj);

        }
      }
      return styleObj;
    }

    var HIGHLIGHT_CONTEXT = d3_map();

    HIGHLIGHT_CONTEXT.set('bar', function (chart) {
      return chart.staticPaneSVG.selectAll('g.eventgroup').selectAll('g#zcbarhighlight');
    });
    HIGHLIGHT_CONTEXT.set('scatter', function (chart) {
      return chart.staticPaneSVG.selectAll('g.eventgroup').selectAll('g#zcscatterhighlight');
    });
    HIGHLIGHT_CONTEXT.set('area', function (chart) {
      return chart.staticPaneSVG.selectAll('g.eventgroup').selectAll('g#zcareahighlight');
    });

    HIGHLIGHT_CONTEXT.set('nonaxis', function (chart) {
      return chart.staticPaneSVG.selectAll('g.eventgroup').selectAll('g.zcnonaxishighlight');
    });

    HIGHLIGHT_CONTEXT.set('geo', function (chart) {
      return chart.staticPaneSVG.selectAll('g.map-highlight');
    });

    function clearHighlightContext(chart) {var _this7 = this;
      var keys = HIGHLIGHT_CONTEXT.keys();
      keys.forEach(function (d) {
        var context = HIGHLIGHT_CONTEXT.get(d).call(_this7, chart);
        context.selectAll('*').remove();
      });
    }

    function Quadtreesearch(nodes, size, radius, extent, sizeOffset) {
      this.size = size;
      this.radius = radius; //considers biggest bubblesize and offset
      this.sizeOffset = sizeOffset; //static offset 10 or custom offset
      this.tree = d3_zc.
      quadtree().
      x(function (d) {
        var data = d._data();
        return data._visible && data._x;
      }).
      y(function (d) {
        var data = d._data();
        return data._visible && data._y;
      }).
      size(function (d) {
        var data = d._data();
        return data._visible && data._size;
      }).
      extent([[0, 0], extent]).
      addAll(nodes);
    }

    var proto = Quadtreesearch.prototype;

    proto.find = function (mouse) {
      if (this.size) {
        return this.tree.findAll(mouse[0], mouse[1], this.radius, this.sizeOffset).points;
      } else {
        return this.tree.find(mouse[0], mouse[1], this.radius);
      }
    };
    Registry.setComponent('searchMode.quadtree', Quadtreesearch);

    //Radius Search
    function ScatterSelection(points, mouse, chart, key) {
      if (points._data) {
        return points;
      }

      var accessor = chart.eventHandler.dataAccesor(),
        cType = charttype[accessor.bestChartType(key)],
        radius = accessor.radius(key),
        isSize = chartcategory.bubble.has(cType) || chartcategory.bubblePie.has(cType) || key == 'segment',
        commonPlotOptions = chart.systemConf.chart.plot.plotoptions[key],
        customTriggerOffset = commonPlotOptions && commonPlotOptions.events && commonPlotOptions.events.triggerOffset,
        sizeOffset = customTriggerOffset || 10;
      var tree = new Quadtreesearch(points, isSize, radius, [chart.plotarea.width, chart.plotarea.height], sizeOffset);

      var xy = XY();
      var point = tree.find([mouse[xy[0]], mouse[xy[1]]]);
      return point;
    }

    function bubbleSelection(points, mouse, chart, key) {
      var doRadiusSearch = chart.cache.search.bisect,
        points_scatter = doRadiusSearch ? ScatterSelection(points, mouse, chart, key) : points;
      var dataObject = chart.dataObject,
        plotArea = chart.plotarea,
        isComboChart = dataObject.isCombinationalChart,
        point,
        distance = function distance(x, y, cx, cy) {
          return mathSQRT((x - cx) * (x - cx) + (y - cy) * (y - cy));
        },
        overPoints;
      if (!points_scatter) {
        return;
      }
      /**
       *
       * @type {{over: boolean, pointDistance: *, radius: number, point: *, bubbleDistance: number}[]}
       */
      var pointDetails = points_scatter.
      map(function (d) {
        var p = d._data(),
          rad = p._size / 2,
          xy = { x: p._x, y: p._y },
          dist = distance(mouse.x, mouse.y, xy.x, xy.y);

        // #ZC1805
        if (
        pointInRectangle(xy.x, xy.y, {
          x: chart.scrolledX || 0,
          y: chart.scrolledY || 0,
          width: plotArea.width,
          height: plotArea.height
        }))
        {
          return {
            radius: rad,
            bubbleDistance: dist - rad,
            pointDistance: dist,
            over: dist - rad <= 0,
            point: d
          };
        }
      }).
      filter(function (p) {return defined(p);});
      /**
       * 1. If only one point has been found within the radius, the use the it directly without any further checking.
       */
      if (pointDetails.length === 1) {
        /**
         * For combo charts, marking it active only if it is exactly over the point
         */
        if (!isComboChart || isComboChart && pointDetails[0].over) {
          point = pointDetails[0].point;
        }
      } else if (pointDetails.length > 1) {
        // filter all the that's hovered.
        overPoints = pointDetails.filter(function (p) {
          return p.over;
        });

        /**
         * 2. If the mouse is hovered inside a single point, use the it directly without any further checking.
         */
        if (overPoints.length === 1) {
          point = overPoints[0].point;
        } else if (overPoints.length > 1) {
          /**
           * 3. If the mouse is hovered inside of intersection of multiple points, then
           *      1. We sort the intersected points by it's real distance from the mouse in ascending order.
           *      2. Use the closet point. (Which is the first point, since it is sorted in ascending order)
           */
          var overlappingFindBy = 'radius'; // pointDistance  | radius
          var pointSortedPointDistance = overPoints.slice(0).sort(function (a, b) {
            return d3_ascending(a[overlappingFindBy], b[overlappingFindBy]);
          });
          point = pointSortedPointDistance[0].point;
        } else {
          /**
           * 4. If the mouse is not inside any points, then we find the closest one.
           *      1. We sort the points within the tracking radius by it's bubble distance from the mouse in ascending order.
           *      2. Use the closet point. (Which is the first point, since it is sorted in ascending order)
           */
          var pointSortedDistance = pointDetails.slice(0).sort(function (a, b) {
            return d3_ascending(a.bubbleDistance, b.bubbleDistance);
          });
          point = pointSortedDistance[0].point;
        }
      }
      return point;
    }

    function ScatterHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
      return this;
    }

    var proto$1 = ScatterHighlighter.prototype;

    proto$1._defaultH = function () {
      return [
      {
        shape: 'marker',
        data: proto$1.data,
        path: this.path,
        context: this.renderingContext,
        translate: this.translateContext
      }];

    };

    proto$1.data = function (point) {
      var rp = this.renderer.commonRendererProp().params;
      var chart = this.chart,
        renderer = this.renderer;

      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key];
        cache._x = point._x =
        cache._x || chart.dataObject.getXYvalue(rp.axisrotated, rp.stacked, rp.xscale, rp.yscale, rp.yaxiscolumnorder, point, 'x');
        cache._y = point._y =
        cache._y || chart.dataObject.getXYvalue(rp.axisrotated, rp.stacked, rp.xscale, rp.yscale, rp.yaxiscolumnorder, point, 'y');
        cache._size = point._size = cache._size || renderer.getSymbolSize(point);
        cache._visible = point._visible = isPointVisible(chart, point);
        cache._uid = point._uid = chart.dataset.getX(point);
        cache._point = point;
        return point;
      };
    };

    proto$1.commonOptions = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        markerOptions = rp.markerOptions || {},
        hoverOptions = rp.hoverOptions || {};

      var symbol = hoverOptions.symbol || markerOptions.symbol,
        size = hoverOptions.size != null ? 1 : markerOptions.size; //CXZAEVENTS_COMBO_2
      // size = hoverOptions.size || markerOptions.size;

      var color = getRawColor(
      this.chart,
      isMultiColoring(rp.commonPlotOptions, this.chart) ? point.sortedItemIndex : point.seriesIndex,
      point,
      point.seriesIndex,
      point.paneid,
      point.rendererIndex);


      return {
        options: hoverOptions,
        symbol: symbol,
        _size: size,
        color: color,
        size: {
          outer: size,
          inner: size
        }
      };
    };
    proto$1.options = function (point) {
      var commonOptions = this.commonOptions(point),
        symbol = commonOptions.symbol,
        size = commonOptions._size || 1;

      var sizeFactor_O = LOCATION_MARKERS.has(symbol) ? 1 : 2, //TODO SOON MODULARIZE
        sizeFactor_I = LOCATION_MARKERS.has(symbol) ? 0.5 : 1;

      commonOptions.size = {
        outer: size * sizeFactor_O,
        inner: size * sizeFactor_I
      };

      return commonOptions;
    };

    proto$1.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('scatter').call(this, this.chart);
    };

    proto$1.translateContext = function () {
      return [this.chart.plotarea.left, this.chart.plotarea.top];
    };

    proto$1.path = function (point, model) {
      point = point._data && point._data() || point;
      var _options = this.options(point),
        _hoveroptions = _options.options;
      var context = model.context.call(this),
        translate = model.translate.call(this),_point2 =
        point,seriesIndex = _point2.seriesIndex,paneid = _point2.paneid,
        cType = getChartTypeByIndex(this.chart, paneid, seriesIndex).value,
        isPointType = isBubbleChartType$1(cType) || cType === charttype.scatter,
        pathContext = appendEle(
        context,
        'g',
        [1],
        '.',
        'class',
        "highlight".concat(point.paneid).concat(seriesIndex).concat(point.itemIndex).concat(model.type) || '_'),

        highlightEffect = this.chart.legendHighlight.getLegendHighlightEffect(seriesIndex, 'selectedSeries', 'plot', paneid),
        isPatternPalleteEnabled =
        legend_helpers.hasPatternPallete(this.chart) &&
        highlightEffect !== 'strokeEnlarge' &&
        highlightEffect.constructor !== Function &&
        isPointType,
        mPosition = model.type == 'end' ? [point._x, point._y0] : [point._x, point._y];
      addSVGmarker(
      pathContext,
      null,
      isPatternPalleteEnabled ? { symbol: _options.symbol } : _options.options,
      {
        color: isPatternPalleteEnabled ? null : _options.color,
        symbolSize: {
          inner: _options.size.inner,
          outer: _options.size.outer
        },
        symbol: _options.symbol,
        transform: mPosition,
        imageSize: 15
      },
      this.chart);

      if (isPatternPalleteEnabled) {
        var highlightStyle =
        highlightEffect === NONE ?
        {
          fill: TRANSPARENT
        } :
        this.chart.legendHighlight.getEffect(
        highlightEffect,
        'scatter',
        HIGHLIGHT_EFFECT_REGEX.test(highlightEffect) ? _options.color : TRANSPARENT,
        { fill: TRANSPARENT, stroke: _options.color },
        point.seriesIndex,
        'plot');

        pathContext.styles(highlightStyle);
      }
      context.style('display', '');
      context.attr('transform', "translate(".concat(translate[0], ",").concat(translate[1], ")"));
      return pathContext;
    };

    function SankeyHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    inherit(SankeyHighlighter, ScatterHighlighter);

    var proto$2 = SankeyHighlighter.prototype;

    proto$2._defaultH = function () {var _this8 = this;
      return [
      {
        shape: 'poly',
        path: this.path,
        data: this.data,
        context: this.renderingContext,
        translate: this.translateContext,
        styles: function styles(point) {
          var nodeIndex;
          if (point._type === 'link') {
            nodeIndex = _this8.renderer.getSankeyNodeByPoint(point).index;
          } else {
            nodeIndex = point.itemIndex;
          }
          return patternFillEffect.call(_this8, point, 'inherit', nodeIndex);
        }
      }];

    };

    proto$2.data = function (point) {
      var self = this,
        chart = this.chart,
        // priority for event. less number means more priority
        rank = { node: 0, link: 1 };

      /**
       *
       * @param type
       * @return {*}
       * @private
       */
      // configurable polygon type
      point._setPolygonType = function (type) {return point._polygonType = type;};
      point._polydata = this.poly(point);
      // point._getDependentsPoints = point => self.getDependentLayoutPoints(point, true).map(d => d.point);
      point._getRank = function () {return rank[point._type];};

      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }

        var cache = chart.cache.data[point._key];

        if (!defined(cache._x)) {
          var _d3_polygonCentroid3 = d3_polygonCentroid(self.getPolygon(this)),_d3_polygonCentroid4 = _slicedToArray(_d3_polygonCentroid3, 2),x = _d3_polygonCentroid4[0],y = _d3_polygonCentroid4[1];
          cache._x = point._x = x;
          cache._y = point._y = y;
          cache._defined = point._defined = true;
          cache._point = point;
        }
        cache._visible = point._visible = self.isVisible(point);

        return point;
      };
    };

    proto$2.isVisible = function (point, from) {
      var self = this,
        chart = self.chart,
        disabledItems = chart.cache.disabledItems;

      var source = chart.dataset.getX(point),
        target = chart.dataset.getY(point, 0),
        weight = chart.dataset.getZ(point),
        negativeAsAbsolute = getPropVal(chart.systemConf, "chart.plot.plotoptions.sankey.showAsNegative") === 'absolute',
        hasFixedValue = false;

      // #ZC2589
      if (negativeAsAbsolute) {
        weight = mathAbs(weight);
      }

      var visible = !disabledItems.has(source) && !disabledItems.has(target) && weight > 0;

      var colorRangeCheck = point._type === 'node' || point._type === 'link' && isWithinColorRange(chart.dataset.getClr(point), chart);

      // fixed values is applied when no link is attached after legend filter
      if (visible && point._type === 'node' && from !== 'legend') {
        hasFixedValue = self.renderer.getSankeyNodeByPoint(point).hasOwnProperty('fixedValue');
      }

      return visible && colorRangeCheck && !point.disabled && !hasFixedValue;
    };

    /**
     *
     * @param point
     * @return {*[]}
     */
    proto$2.getPolygon = function (point) {
      var self = this,
        renderer = self.renderer,
        polygon,
        sampleSize = 10,
        linkOptions = renderer.sankeyOptions.link,
        isBezierCurve = linkOptions.curve === 'bezier';

      /**
       * sankey point has 2 types
       * 1. polygon
       * 2. path -- needs conversion
       */

      if (point._type === 'link') {
        var link = renderer.getLinkByPoint(point);

        // ZC2589
        if (link) {
          if (point._polygonType === 'path' || isBezierCurve || link.circular) {
            var path = renderer.getPath(link, 4);
            polygon = pathToPolygon(path, sampleSize);
          } else {
            polygon = link._polypoints;
          }
        }
      } else {
        var node = renderer.getSankeyNodeByPoint(point);
        if (node) {
          // node and liner link has pre-calculated polygon while rendering
          polygon = node._polypoints;
        }
      }
      return polygon || [[null, null]];
    };

    /**
     *
     * @param point
     * @return {function(): {points: *[]}}
     */
    proto$2.poly = function (point) {
      var self = this,
        chart = self.chart;

      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key];
        if (!cache._poly) {
          // get the polygon
          cache._poly = point._poly = { points: self.getPolygon(point) };
        }
        return point._poly;
      };
    };

    proto$2.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('area').call(this, this.chart);
    };

    proto$2.translateContext = function () {
      return [this.chart.plotarea.left, this.chart.plotarea.top];
    };

    proto$2.options = function (point) {
      var rp = this.renderer.commonRendererProp().params,
        commonOptions = rp.commonPlotOptions,
        fillOpacity = rp.hoverOptions.fillOpacity.fillOpacity;

      commonOptions.fillOpacity = fillOpacity;
      commonOptions.color = commonOptions[point._type].fillColor || this.renderer.getColor(point, true);
      if (!commonOptions.link.gradients.customGradient && defined(commonOptions.link.gradients.type)) {
        sankeyGradientDimension(point, commonOptions.link.gradients);
      }

      return commonOptions;
    };

    proto$2.path = function (point, model) {
      var self = this,
        context = model.context.call(self),
        translate = model.translate.call(self),
        renderer = self.renderer,_renderer$sankeyOptio =


        renderer.sankeyOptions,linkOptions = _renderer$sankeyOptio.link,nodeOptions = _renderer$sankeyOptio.node,
        nodeStrokeWidth = nodeOptions.strokeWidth;

      context.style('display', '').attr('transform', "translate(".concat(translate[0] + nodeStrokeWidth, ",").concat(translate[1] + nodeStrokeWidth, ")"));

      var layoutPoint;
      if (point._type === 'link') {
        layoutPoint = renderer.getLinkByPoint(point);
      } else if (point._type === 'node') {
        layoutPoint = renderer.getSankeyNodeByPoint(point);
      }

      return createElement('path', ".sankey-highlight-".concat(point._type, "-").concat(layoutPoint.index), [layoutPoint], context).attr('d', function (point) {return (
          getSankeyPointPath(point, nodeOptions, linkOptions, 0.5, renderer.sankeyLayout));});

    };

    /**
     *
     * @param point
     * @param flatten
     * @param from
     * @return
     */
    proto$2.getDependentLayoutPoints = function (point, flatten, from) {
      var self = this,
        renderer = self.renderer,
        layout = self.chart.dataObject.sankeyLayout,
        phase = self.chart.phase,
        filter = function filter(points) {
          return points.filter(function (p) {
            var point = p.point;
            if (point && point.hasOwnProperty('_visible') && phase !== 'legendFilter' && from !== 'legend') {
              return point._visible;
            } else if (point) {
              return point._visible = self.isVisible(point, from);
            }
          });
        },
        layoutPoint = {
          link: renderer.getLinkByPoint,
          node: renderer.getSankeyNodeByPoint
        }[point._type](point);

      if (layoutPoint) {
        var connectedPoints = layout.getAllConnectedPoints(layoutPoint, flatten);

        if (flatten) {
          return filter(connectedPoints);
        } else {
          return {
            links: filter(connectedPoints.links),
            nodes: filter(connectedPoints.nodes)
          };
        }
      }

      return [];
    };

    var LabelRegistry = {
      add: function add(name, component) {
        Registry.setComponent(_key(name), component);
      },
      get: function get(name) {return Registry.getComponent(_key(name));}
    };

    function _key(name) {
      return "datalabels-".concat(name);
    }

    //$Id$

    function getBoundBoxColor(actualColor, properties, chartObj, data, index) {
      var data_length = data.length;
      return (
        actualColor ||
        function (d, meta) {
          var clrIndex = getIndexForItemColor(meta.itemIndex, index, meta, chartObj);
          return getRawColor(chartObj, clrIndex, d && d.data ? d.data : d, index);
        });

    }

    function getMergedBoundBoxOptions(dataLabels, chartObj) {
      return mergeJSON$1(chartObj.systemConf.chart.plot.datalabels.boundBox, dataLabels.boundBox, true);
    }

    function isBoundBoxEnabled(dataLabels, chartObj) {
      return getValByPriority([dataLabels.boundBox || {}, chartObj.systemConf.chart.plot.datalabels.boundBox || {}], 'show') === true;
    }

    function getBoundBoxPadding(dataLabels, chartObj) {
      return mathMax(
      validateNullVal(
      getValByPriority([dataLabels.boundBox || {}, chartObj.systemConf.chart.plot.datalabels.boundBox || {}], 'padding'),
      2),

      0);

    }

    function getBoundBoxStrokeWidth(dataLabels, chartObj) {
      return validateNullVal(
      getValByPriority([dataLabels.boundBox || {}, chartObj.systemConf.chart.plot.datalabels.boundBox || {}], 'strokeWidth'),
      1);

    }

    function getSizeToBeAdded(defaultWidth, padding, radius, hookWidth) {
      var datalabels_min_width = 2 * (radius || 0) + hookWidth;
      return mathMax(datalabels_min_width - defaultWidth - 2 * padding, 0);
    }

    /*
     * Returns the options for boundbox hook
     * @param {Object} hookOptions
     * @return {Object} obj which contains enabled, width, height
     */
    function getBoundBoxHookConf(hookOptions) {
      hookOptions = hookOptions || {};
      var hookEnabled = hookOptions.enabled === true;
      var obj = {};

      obj.enabled = hookEnabled;
      obj.width = hookEnabled ? defined(hookOptions.width) ? +hookOptions.width : 10 : 0;
      obj.height = hookEnabled ? defined(hookOptions.height) ? +hookOptions.height : 4 : 0;
      return obj;
    }

    /**
     * Visibility property of bound box
     * @param  {Object}  d
     * @return {Boolean}
     */
    function hasBoundBox(d) {
      return !(d.display === false || isUndefined(d.text) || d.text === '');
    }

    function getMetaConfigForBoundbox(itemIndex, seriesIndex, properties) {
      return {
        seriesIndex: seriesIndex,
        itemIndex: itemIndex,
        multiColoring: properties.multiColoring,
        reverseColor: properties.reverseColor,
        dataCount: properties.dataUpdate.length
      };
    }

    function SankeyChart() {
      var commonRendererProp,
        sankeyLabelInside = false,
        sankeyNodeAligns,
        sankeyLayoutData,
        nodeMapped,
        chartInstance,
        nodeFillColor,
        linkFillColor,
        linkPadding,
        labelOutside = false,
        labelWidthStart = 0,
        labelWidthEnd = 0,
        sankeyOptions,
        /**
         *
         */
        chart = function chart(selection, data, styles, filterIndex, encode, itemIndex) {
          chartInstance = commonRendererProp.params.chartObj;

          var params = commonRendererProp.params,
            labelQueue = params.labelQueue,
            commonPlotOptions = params.commonPlotOptions,
            systemConf = chartInstance.systemConf,
            dataset = params.dataset,
            dataObject = chartInstance.dataObject,
            index = params.datasetIndex || 0,
            series = chartInstance.seriesdata[index],
            isCanvasMode = chartInstance.plot.renderer.mode === 'canvas',
            plotoptions = series.plotoptions;

          sankeyOptions = mergeJSON$1(pick(series.plotoptions, {}), commonPlotOptions);

          var _sankeyOptions = sankeyOptions,linkOptions = _sankeyOptions.link,nodeOptions = _sankeyOptions.node,_chartInstance$cache$ =
            chartInstance.cache.sankey,legendItemsMap = _chartInstance$cache$.legendItemsMap,legend = _chartInstance$cache$.legend,_dataObject$sankeyLay =
            dataObject.sankeyLayout,layout = _dataObject$sankeyLay.graph,linkLength = _dataObject$sankeyLay.linkLength,nodeLength = _dataObject$sankeyLay.nodeLength,_chartInstance$plotar =
            chartInstance.plotarea,width = _chartInstance$plotar.width,height = _chartInstance$plotar.height,
            linkGradientOptions = linkOptions.gradients,
            linearDim = linkGradientOptions.options.linear,
            customGradient = defined(linearDim.x1) || defined(linearDim.x2) || defined(linearDim.y1) || defined(linearDim.y2),
            isRedraw = defined(chartInstance.phase),
            isCanvasLegendHighlight = isCanvasMode && defined(itemIndex),
            animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartInstance, SANKEY_CHARTNAME),

            animationDuration = isRedraw ? 0 : animationOptions.duration,
            nodeStrokeWidth = nodeOptions.strokeWidth,
            labelOptions = sankeyOptions.datalabels,
            labelPadding = 0,
            hookHeight = 0,
            imagePallet = chartInstance.imagePallete,
            eventOptions = mergeJSON$1(pick(systemConf.chart.plot.events), commonPlotOptions.events),
            boundBoxPaddingSingle = 0,
            isLegendHighlight = defined(itemIndex),


            sankeyAlignMinSize = 0;
          customGradient = defined(linkGradientOptions.customGradient) ? linkGradientOptions.customGradient : customGradient;
          linkGradientOptions.customGradient = customGradient;
          if (chartInstance.systemConf.chart.width) {
            width = invokeFunction(chartInstance.systemConf.chart.width, chartInstance);
          }
          if (chartInstance.systemConf.chart.height) {
            height = invokeFunction(chartInstance.systemConf.chart.height, chartInstance);
          }

          // get the node aligns
          sankeyNodeAligns = chart.nodeAligns = getAlignedNodes(layout.nodes);
          sankeyLabelInside = labelOptions.labelPos === 'inside';
          labelOutside = labelOptions.labelPos === 'outside';
          linkPadding = linkOptions.padding || 0;

          // create maps for access
          nodeMapped = d3_map();
          layout.nodes.forEach(function (node) {
            nodeMapped.set(node.name, node);
            node.point.arcColor = getRawColor(chartInstance, node.index, node.point, index);
          });

          var linkMapped = d3_map();
          layout.links.forEach(function (link) {
            linkMapped.set(link.point._key, link);

            if (linkGradientOptions.type) {
              if (link.circular) {
                link.point.arcColor = [link.target.point.arcColor, link.source.point.arcColor];
              } else if (link.exit) {
                link.point.arcColor = linkOptions.exit.color;
                link.point.exit = true;
              } else {
                link.point.arcColor = [link.source.point.arcColor, link.target.point.arcColor];
              }
            } else {
              link.point.arcColor = link.exit ? linkOptions.exit.color : link.source.point.arcColor;
            }
          });

          // disabled because canvas highlight issue. and it is correct
          // legend = legend.filter(d => !d.disabled);

          // pre-calculate the edge labels and reduce that from sankey area.
          // so that we can place the label outside
          if (labelOutside && legend.length) {
            var boundBoxOptions = getMergedBoundBoxOptions(labelOptions, chartInstance);
            var hookOptions = getBoundBoxHookConf(boundBoxOptions.hook),
              boundBoxPadding = (boundBoxOptions.padding || 0) * 2,
              nodeMaxWidth = width / sankeyNodeAligns.layerCount * 0.8;

            hookHeight = hookOptions.height;
            labelPadding = (labelOptions.padding || 0) * 2 + boundBoxPadding;
            boundBoxPaddingSingle = boundBoxPadding / 2;

            // let tempExtent = [
            //     [labelWidthStart + nodeStrokeWidth + labelPadding + hookHeight, nodeStrokeWidth + boundBoxPadding],
            //     [width - nodeStrokeWidth - labelWidthEnd - labelPadding - hookHeight, height - nodeStrokeWidth - boundBoxPadding]
            // ];
            //
            // let rawSankeyLayout = getSankeyLayout(sankeyOptions, tempExtent, UNDEFINED, nodeMaxWidth);
            // layout = linkLength && nodeLength ? rawSankeyLayout(layout) : layout;

            // ZC2609
            if (isLegendHighlight) {var _chartInstance$render = _slicedToArray(
              chartInstance.renderer[0].labelWidthOutside, 2);labelWidthStart = _chartInstance$render[0];labelWidthEnd = _chartInstance$render[1];
            } else {var _LabelRegistry$get =
              LabelRegistry.get('preCalculation')(null, {}, chartInstance);var _LabelRegistry$get2 = _slicedToArray(_LabelRegistry$get, 2);labelWidthStart = _LabelRegistry$get2[0];labelWidthEnd = _LabelRegistry$get2[1];
              chartInstance.renderer[0].labelWidthOutside = [labelWidthStart, labelWidthEnd];
            }
          }

          var leftMargin = labelWidthStart + nodeStrokeWidth + labelPadding + hookHeight,
            rightMargin = labelWidthEnd + nodeStrokeWidth + labelPadding + hookHeight,
            verticalMargin = nodeStrokeWidth + boundBoxPaddingSingle + sankeyAlignMinSize,
            sankeyExtent = [[leftMargin, verticalMargin], [width - rightMargin, height - verticalMargin]],
            gradientDim = [width, height],
            nodeFillColorRaw = getFillColor(chartInstance, 0),
            linkFillColorRaw = getFillColor(chartInstance, 0, null, gradientDim, null, null, linkGradientOptions),
            hoverOptions = commonRendererProp.params.hoverOptions =
            plotoptions && plotoptions.hoveroptions ?
            mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
            commonPlotOptions.hoveroptions;

          var availablePlotWidth = sankeyExtent[1][0] - sankeyExtent[0][0];
          // sankey max node with is = 80% width / layer
          var maxNodeWidth = availablePlotWidth / sankeyNodeAligns.layerCount * 0.8;

          /**
           *
           * @param point
           * @param calculate
           * @return {*}
           */
          nodeFillColor = function nodeFillColor(point, calculate) {
            var node = getSankeyNodeByPoint(point),
              itemIndex;

            if (!node) {
              return;
            }

            itemIndex = legendItemsMap.get(node.name).index;

            if (calculate) {
              return nodeFillColorRaw(itemIndex, node.point, NULL$1, NULL$1, nodeOptions.fillOpacity);
            }
            return nodeFillColorRaw(itemIndex, node.point, NULL$1, nodeOptions.fillColor, nodeOptions.fillOpacity);
          };

          /**     *
           * @param point
           * @return {*}
           */
          linkFillColor = function linkFillColor(point) {
            var link = linkMapped.get(point._key),_ref8 =
              isCanvasLegendHighlight ? hoverOptions : linkOptions,fillOpacity = _ref8.fillOpacity;

            if (defined(linkGradientOptions.type)) {
              var source = link.source,target = link.target,
                fillColor = link.exit ? linkOptions.exit.color : linkOptions.fillColor,
                sourceColor = link.exit ?
                linkOptions.exit.color[0] :
                link.circular ?
                nodeFillColor(target.point, true) :
                nodeFillColor(source.point, true),
                targetColor = link.exit ?
                linkOptions.exit.color[1] :
                link.circular ?
                nodeFillColor(source.point, true) :
                nodeFillColor(target.point, true),
                dim = link.exit ? [source.x1 + link.width, 500] : [target.x0 - source.x1, 500];
              if (!customGradient) {
                sankeyGradientDimension(point, linkGradientOptions);
              }

              linkGradientOptions.options.linear.stopColor = [sourceColor, targetColor];

              return linkFillColorRaw(source.index, link.point, null, fillColor, fillOpacity, dim);
            } else {
              var sourceIndex = legendItemsMap.get(link.source.name).index,
                _fillColor2 = link.exit ? linkOptions.exit.color : linkOptions.fillColor;

              return linkFillColorRaw(sourceIndex, link.point, NULL$1, _fillColor2, fillOpacity, null, {
                context: chartInstance.context
              });
            }
          };
          var _layout = chartInstance.dataObject.sankeyLayout.layout,
            exitAtEndNode = _layout && _layout.exitAtEndNode;
          if (exitAtEndNode) {
            sankeyExtent[1][0] = sankeyExtent[1][0] - mathMin(exitAtEndNode, 25);
          }
          var rawSankeyLayout = getSankeyLayout(sankeyOptions, sankeyExtent, UNDEFINED, maxNodeWidth, {
            left: leftMargin,
            right: rightMargin
          });

          chart.sankeyLayout = sankeyLayoutData = linkLength || nodeLength ? rawSankeyLayout(layout) : layout;
          dataObject.sankeyLayout.layout = chart.sankeyLayout;

          // update index
          if (chartInstance.phase === 'legendFilter') {
            sankeyLayoutData.nodes.forEach(function (node) {
              node.index = legendItemsMap.get(node.name).index;
            });
          }

          chart.seriesdataAfterUpdate = [legend];
          chart.sankeyOptions = sankeyOptions;

          if (isCanvasMode) {
            // for legend highlight
            if (isLegendHighlight) {
              var highlighter = chartInstance.renderer[0].highlighter,
                currentSelectedPoint = legend[itemIndex],
                layoutPoints = highlighter.getDependentLayoutPoints(currentSelectedPoint),
                // #ZC2579 [$linkHoverStyles, $nodeHoverStyles]
                linkHoverStyles = _objectSpread(_objectSpread({}, linkOptions), {}, { fillColor: styles.fill, fillOpacity: styles['fill-opacity'] }),
                nodeHoverStyles = _objectSpread(_objectSpread({}, nodeOptions), {}, { fillColor: styles.fill });
              layoutPoints.x0 = sankeyLayoutData.x0;
              layoutPoints.x1 = sankeyLayoutData.x1;
              layoutPoints.y0 = sankeyLayoutData.y0;
              layoutPoints.y1 = sankeyLayoutData.y1;

              drawSankeyCanvas(selection, layoutPoints, nodeHoverStyles, linkHoverStyles, nodeFillColor, linkFillColor, imagePallet);
            } else {
              drawSankeyCanvas(selection, sankeyLayoutData, nodeOptions, linkOptions, nodeFillColor, linkFillColor, imagePallet);
            }
          } else {
            if (!isRedraw) {
              animateSankeySvg(selection, animationOptions);
            } else {
              updateAnimatorClipPath(selection);
            }

            drawSankeySvg(selection, sankeyLayoutData, nodeOptions, linkOptions, nodeFillColor, linkFillColor);
          }

          var labelPoints = linkLength || nodeLength ? legend.filter(function (d) {return !d.disabled;}) : [];

          labelQueue.length = 0;
          labelQueue.push({
            renderer: chart,
            charttype: 'hierarchy',
            chartObj: chartInstance,
            args: [chartInstance.seriesdata[0], 0, NULL$1, NULL$1, null, labelPoints, [0, 0]]
          });

          // create a path element for flatten the bezier curve to linear
          var tempPath = document.createElementNS(d3_namespaces.svg, 'path');

          // for highlighter
          chart.getPath = function (point, minWidth) {
            tempPath.setAttribute('d', getSankeyPointPath(point, nodeOptions, linkOptions, minWidth, sankeyLayoutData));
            return tempPath;
          };

          // method to get link by the actual series point
          chart.getLinkByPoint = function (point) {return linkMapped.get(point._key);};
          chart.getNodeByPoint = function (point) {return nodeMapped.get(point._key);};

          // #ZC2588
          legend.disabled = function () {return eventOptions.enabled === false;};
          chartInstance.cache.customPoints.sankeyNodes = { '0_0': legend };

          //
          setTimeout(function () {
            chart.chartRendered = true;
          }, animationDuration);
        };

      /**
       *
       * @param nodes
       * @return {{center: [], start: *, end: (*|*[])}}
       */
      function getAlignedNodes(nodes) {
        var grouped = groupBy(nodes, 'layer');
        var keys = Object.keys(grouped).
          map(parseFloat).
          sort(d3_ascending),
          layerCount = keys.length;

        var startKey = keys.shift();
        var endKey = keys.pop();
        var centerKey = keys;

        var centers = [];
        centerKey.forEach(function (key) {
          centers = [].concat(_toConsumableArray(centers), _toConsumableArray(grouped[key]));
        });

        return {
          start: grouped[startKey],
          center: centers,
          end: grouped[endKey] || [],
          layerCount: layerCount
        };
      }

      function getSankeyNodeByPoint(point, customNodeMap) {
        var key = formatPoint(chartInstance.dataset.getX(point), 'x');
        return pick(customNodeMap, nodeMapped).get(key);
      }

      /**
       *
       * @param d
       * @param computedLabelBound
       * @param padding
       * @param maxWidth
       * @param boundBoxPadding
       * @param hookHeight
       * @return {{x: number, width: number, y: number, height: number}}
       */
      function getSankeyLabelPosition(d, computedLabelBound) {var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var maxWidth = arguments.length > 3 ? arguments[3] : undefined;var boundBoxPadding = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;var hookHeight = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var node = getSankeyNodeByPoint(d);

        if (sankeyLabelInside) {
          return {
            x: node.x0,
            y: node.y0,
            width: node.x1 - node.x0,
            height: node.y1 - node.y0
          };
        } else {
          var x,
            nodeWidth = node.x1 - node.x0,
            nodeHeight = node.y1 - node.y0,
            labelWidth = 0,
            bPadding = boundBoxPadding * 2;

          if (computedLabelBound) {
            labelWidth = mathMin(computedLabelBound.width, maxWidth);
          }

          if (arrayIncludes(sankeyNodeAligns.start, node)) {
            if (labelOutside) {
              x = node.x0 - hookHeight - padding * 2 - labelWidth - bPadding;
            } else {
              x = node.x1 + hookHeight;
            }
          } else if (arrayIncludes(sankeyNodeAligns.end, node)) {
            if (labelOutside) {
              x = node.x1 + hookHeight;
            } else {
              x = node.x0 - labelWidth - hookHeight - padding * 2 - bPadding;
            }
          } else {
            var nodeCenter = node.x0 + nodeWidth / 2;
            x = nodeCenter - labelWidth / 2 - padding - bPadding;
          }

          return {
            x: x,
            y: node.y0,
            width: labelWidth + padding * 2 + bPadding,
            height: node.y1 - node.y0
          };
        }
      }

      /**
       *
       * @param d
       * @return {string}
       */
      function getLabelAnchor(d) {
        var node = getSankeyNodeByPoint(d),
          anchor;

        // return START_ALIGN;
        if (sankeyLabelInside) {
          return MIDDLE_ALIGN;
        } else {
          if (arrayIncludes(sankeyNodeAligns.center, node)) {
            anchor = MIDDLE_ALIGN;
          } else if (arrayIncludes(sankeyNodeAligns.end, node)) {
            anchor = labelOutside ? START_ALIGN : END_ALIGN;
          } else {
            anchor = labelOutside ? END_ALIGN : START_ALIGN;
          }
          return anchor;
        }
      }

      /**
       *
       * @param selection
       * @param animationOptions
       */
      function animateSankeySvg(selection, animationOptions) {
        var clipDimension = { x: 0, y: 0, width: 0, height: chartInstance.plotarea.height },
          clipRect = updateAnimatorClipPath(selection, clipDimension);

        clipRect.
        transition().
        ease(animationOptions.easingType).
        duration(animationOptions.duration).
        attr('width', chartInstance.plotarea.width);
      }

      /**
       *
       * @param selection
       * @param clipDimension
       */
      function updateAnimatorClipPath(
      selection)

      {var clipDimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { x: 0, y: 0, width: chartInstance.plotarea.width, height: chartInstance.plotarea.height };
        return sankeyClipPath(chartInstance, selection, clipDimension);
      }

      function formatPoint(value, type) {
        var column = chartInstance.dataset.getColumn(type, 0);
        return getFormattedValue(column[column.datatype], value, column.datatype, chartInstance);
      }

      /**
       *
       * @param chartObj
       * @param index
       * @return {SankeyHighlighter}
       */
      chart.getHighlighter = function (chartObj, index) {
        return chart.highlighter = new SankeyHighlighter(chartObj, chart, sankeyLayoutData);
      };

      chart.getPosition = getSankeyLabelPosition;
      chart.getLabelAnchor = getLabelAnchor;
      chart.getSankeyNodeByPoint = getSankeyNodeByPoint;

      /**
       *
       * @param point
       * @param isHighlight
       * @return {[*, *]|string|*}
       */
      chart.getColor = function (point, isHighlight) {
        var customColor = sankeyOptions[point._type].fillColor;

        if (!defined(customColor) && defined(point.arcColor)) {
          return point.arcColor;
        }

        if (point._type === 'node') {
          return nodeFillColor(point);
        } else if (point._type === 'link') {
          return linkFillColor(point, isHighlight);
        }
      };

      /**
       *
       * @param _
       * @return {*}
       */
      chart.commonRendererProp = function (_) {return !_ ? commonRendererProp : (commonRendererProp = _, chart);};

      return chart;
    }

    function sankeyClipPath(chartInstance, selection, clipDimension) {
      var clipId = "sankey-animation-clip-".concat(chartInstance.idNumeric),
        clipRect = svg_clips.createElement('rect', clipId, chartInstance);
      clipDimension = clipDimension || { x: 0, y: 0, width: chartInstance.plotarea.width, height: chartInstance.plotarea.height };

      if (isSmoothScrollEnabled(chartInstance)) {
        clipDimension.x = chartInstance.scrolledX || 0;
        clipDimension.y = chartInstance.scrolledY || 0;
        clipDimension.width += chartInstance.scrolledX || 0;
        clipDimension.height += chartInstance.scrolledY || 0;
      }

      // #ZC2587
      clipRect.interrupt();

      svg_clips.setAttributes(clipRect, clipDimension, ['x', 'y', 'width', 'height']);
      selection.attr('clip-path', "url(#".concat(clipId, ")"));

      var labelElement = chartInstance.container.selectAll('.labelholder');
      labelElement.attr('clip-path', "url(#".concat(clipId, ")"));

      return clipRect;
    }

    function sankeyGradientDimension(point, gradientOptions) {
      if (point && point.exit) {
        gradientOptions.options.linear.y1 = 0;
        gradientOptions.options.linear.y2 = 100;
        gradientOptions.options.linear.x1 = null;
        gradientOptions.options.linear.x2 = null;
      } else {
        gradientOptions.options.linear.x1 = 0;
        gradientOptions.options.linear.x2 = 100;
        gradientOptions.options.linear.y1 = null;
        gradientOptions.options.linear.y2 = null;
      }
    }
    svg_plot_renderer.sankey = SankeyChart;
    canvas_plot_renderer.sankey = SankeyChart;

    //$Id$

    var plotScroll_div = function plotScroll_div() {};
    plotScroll_div.prototype.defaultScroll = function (chartObj, state) {
      if (!isSmoothScrollEnabled(chartObj)) {
        return;
      }

      var isWidth = defined(chartObj.systemConf.chart.width),
        isHeight = defined(chartObj.systemConf.chart.height);
      var mode = this.mode = isWidth && isHeight ? 'xy' : isWidth ? 'x' : 'y';
      var defaultScroll = this,
        axisrotated = chartObj.axes.rotated,
        plotarea = chartObj.plotarea,
        isSupported = arrayIncludes(chartcategory.nonAxisSingleSourceEvent, chartObj.chartTypes[0].value);

      var XSIZE = getPlotSize(chartObj, 'width') - plotarea.width,
        YSIZE = getPlotSize(chartObj, 'height') - plotarea.height;

      // Initial clip-path
      var scroll = chartObj.container.selectAll('.d3container').selectAll('.zohocharts_scroll'),
        scrollbar_size = +scroll.attr('scrollbarSize');

      updateAxisClipPath(chartObj, mode, 'init');

      var scrollStyles = {
        left: plotarea.left + PX,
        top: plotarea.top + PX,
        height: plotarea.height + (this.mode == 'xy' || this.mode == 'x' ? scrollbar_size : 0) + PX,
        width: plotarea.width + (this.mode == 'xy' || this.mode == 'y' ? scrollbar_size : 0) + PX,
        'overflow-y': this.mode == 'xy' || this.mode == 'y' || axisrotated ? 'auto' : 'hidden',
        'overflow-x': this.mode == 'xy' || this.mode == 'x' || !axisrotated ? 'auto' : 'hidden'
      };

      // Scroll div
      scroll.styles(scrollStyles).on('scroll', function (e) {
        var src = d3_event().srcElement || d3_event().target,
          scrolled;
        // var scrolled = mode == 'xy' ? src.scrollLeft || src.scrollTop : !axisrotated ? src.scrollLeft : src.scrollTop;

        var scrollLeft = src.scrollLeft,
          scrollTop = src.scrollTop;

        var isScrollX = chartObj.scrolledX !== scrollLeft,
          isScrollY = chartObj.scrolledY !== scrollTop;

        chartObj.scrolledY = scrollTop;
        chartObj.scrolledX = scrollLeft;

        var scrollingMode = isScrollX ? 'x' : 'y';

        scrolled = isScrollX ? scrollLeft : scrollTop;

        //#ZC974
        d3_event().clientX = d3_event().clientX || 0;
        d3_event().clientY = d3_event().clientY || 0;

        // hide the tooltip when scrolled
        if (chartObj.dataObject.isAxisCategory) {
          chartObj.eventHandler.tooltipElement.hide();
          chartObj.eventHandler.handlers.mouseout.call(chartObj.eventHandler);
        }

        //Reset cache for data
        chartObj.cache.data = {};
        chartObj.cache.search = {};

        scrollGroups(scrolled, mode, scrollingMode);
      });

      if (chartObj.canvasScrollGroup) {
        chartObj.canvasScrollGroup.styles(scrollStyles);
      }

      // fixes #ZC1767 (ticks hiding chrome)
      if ($Browser.CHROME) {
        var canvasArea = chartObj.canvasarea;
        defaultScroll.fixScrollView(
        false,
        {
          width: canvasArea.width + (this.mode == 'xy' || !axisrotated ? XSIZE : 0),
          height: canvasArea.height + (this.mode == 'xy' || axisrotated ? YSIZE : 0)
        },
        chartObj);

      }

      // Scroll child
      scroll.selectAll('.child').styles({
        height: plotarea.height + (this.mode == 'xy' || this.mode == 'y' || axisrotated ? YSIZE : 0) + PX,
        width: plotarea.width + (this.mode == 'xy' || this.mode == 'x' || !axisrotated ? XSIZE : 0) + PX,
        'pointer-events': NONE,
        margin: 0,
        padding: 0,
        'background-color': TRANSPARENT
      });

      // Reset scroll position
      //ZC1768 (why reset?)
      // if (state !== "addorremoveseries") {
      // var scroll_node = scroll.node();
      // scroll_node.scrollLeft = 0;
      // scroll_node.scrollTop = 0;
      // }

      // Event listners
      if (chartObj.dataObject.isAxisCategory || chartObj.dataObject.isFlowChartCategory || isSupported) {
        chartObj.eventHandler.addListeners(scroll);
      }

      var scrollingMode = chartObj.scrolledX ? 'x' : 'y';
      var scrolled_1 = scrollingMode == 'x' ? chartObj.scrolledX : chartObj.scrolledY;

      if (scrolled_1 && state === 'addorremoveseries') {
        scrollGroups(scrolled_1, this.mode, scrollingMode);
      }

      function scrollGroups(scrolled, mode, scrollingMode) {
        var seriesholder = chartObj.container.selectAll('.seriesholder'),
          seriesHolderClipId = chartObj.container.select('.seriesClippathholder').attr('clip-path'),
          seriesTrans = getSvgTransform(seriesholder).translate,
          transX = scrollingMode == 'x' ? plotarea.left - scrolled : seriesTrans[0],
          transY = scrollingMode == 'x' ? seriesTrans[1] : plotarea.top - scrolled;

        seriesholder.attr('transform', "translate(".concat(transX, ",").concat(transY, ")"));
        chartObj.container.selectAll('.zc-fade-overlay').attr('transform', "translate(".concat(-chartObj.scrolledX, ",").concat(-chartObj.scrolledY, ")"));
        chartObj.container.selectAll('.labelholder').attr('transform', "translate(".concat(transX, ",").concat(transY, ")"));
        chartObj.container.selectAll('.eventgroup').attr('transform', "translate(".concat(-chartObj.scrolledX, ",").concat(-chartObj.scrolledY, ")"));
        chartObj.container.selectAll('rect.eventhandler').attr('transform', "translate(".concat(chartObj.scrolledX, ",").concat(chartObj.scrolledY, ")"));
        chartObj.container.selectAll('.qualitativeGroup').attr('transform', "translate(".concat(-chartObj.scrolledX, ",").concat(-chartObj.scrolledY, ")"));

        // #ZC1770
        var translate = "translate(".concat(-chartObj.scrolledX + PX, ",").concat(-chartObj.scrolledY + PX, ")");
        chartObj.container.selectAll('canvas').style('transform', translate);
        // #ZC1840 IE not scrolling
        chartObj.container.selectAll('canvas').style("".concat($Browser.prefix.css, "transform"), translate);

        if (chartObj.notesParent && chartObj.notesParent.length) {
          chartObj.notesParent.map(function (element) {
            if (element.node().ownerSVGElement) {
              var _x2 = element.attr('_x'),
                _y2 = element.attr('_y'),_transX,_transY;

              if (defined(_x2)) {

                _transX = scrollingMode == 'x' ? parseInt(_x2) - scrolled : parseInt(_x2),
                _transY = scrollingMode == 'x' ? parseInt(_y2) : parseInt(_y2) - scrolled;

              } else {
                var _seriesTrans = getSvgTransform(element).translate;

                element.attrs({
                  _x: _seriesTrans[0],
                  _y: _seriesTrans[1]
                });

                _transX = scrollingMode == 'x' ? _seriesTrans[0] - scrolled : _seriesTrans[0],
                _transY = scrollingMode == 'x' ? _seriesTrans[1] : _seriesTrans[1] - scrolled;
              }

              element.attr('transform', "translate(".concat(_transX, ",").concat(_transY, ")"));
            }

          });
        }

        chartObj.drawPlotareaClippath();
        var attrObj =
        scrollingMode == 'y' ?
        {
          y: -scrolled,
          height: plotarea.height + scrolled
        } :
        {
          x: -scrolled,
          width: plotarea.width + scrolled
        };

        if (
        chartObj.dataObject.isAxisCategory ||
        chartObj.dataObject.isPolarAxisCategory ||
        chartObj.dataObject.isFlowChartCategory ||
        isSupported)
        {
          chartObj.eventHandler.trackerElement.attrs(attrObj).attr('clip-path', seriesHolderClipId);
        }

        updateAxisClipPath(chartObj, scrollingMode);

        if (chartObj.dataObject.isFlowChartCategory) {
          sankeyClipPath(chartObj, chartObj.wrap.selectAll('g.seriesholder'));
        }

        var properties = {
          name: 'rect_highlight',
          id: chartObj.id
        };
        if (scrollingMode == 'y') {
          properties.x = -plotarea.left + chartObj.scrolledX;
          properties.y = scrolled;
          properties.width = plotarea.width + plotarea.left;
          properties.height = plotarea.height;
        } else {
          properties.x = scrolled;
          properties.y = plotarea.top + chartObj.scrolledY;
          properties.width = plotarea.width;
          properties.height = plotarea.height;
        }

        // #ZC1769
        var clipId = "default_scroll_highlight_clip_".concat(chartObj.id);
        svg_clips.rect(properties, clipId, null, null, null, chartObj);

        //BG Image position update
        if (chartObj.plot.hasBgAspectRatio) {
          var bgEle = chartObj.plotareaPropertyElement;
          bgEle.styles({
            'background-position-x': "".concat(-chartObj.scrolledX, "px"),
            'background-position-y': "".concat(-chartObj.scrolledY, "px")
          });
        }

        // var clipID = effects.get(effects.svg_clips, "rect", properties, args);
        // chartObj.container.selectAll('#zcareahighlight').attr('clip-path', `url(#${clipId})`);
      }
    };

    plotScroll_div.prototype.initialize = function (chartObj) {
      if (!isSmoothScrollEnabled(chartObj)) {
        return;
      }
      var isWidth = defined(chartObj.systemConf.chart.width),
        isHeight = defined(chartObj.systemConf.chart.height);
      var mode = this.mode = isWidth && isHeight ? 'xy' : isWidth ? 'x' : 'y';

      var axisrotated = chartObj.axes.rotated,
        mapping_axistype = {
          x: axisrotated ? 'y' : 'x',
          y: axisrotated ? 'x' : 'y'
        };

      var plotarea = chartObj.plotarea;

      chartObj.scrolledX = chartObj.scrolledX || 0;
      chartObj.scrolledY = chartObj.scrolledY || 0;

      var scrollStyles = {
        overflow: 'scroll',
        position: 'absolute',
        margin: 0,
        padding: 0,
        'background-color': 'rgba(0,0,0,0)',
        'box-sizing': 'content-box',
        '-webkit-tap-highlight-color': TRANSPARENT,
        '-webkit-overflow-scrolling': 'touch'
      };

      var scroll = appendEle(chartObj.container.selectAll('.d3container'), DIV_ELEMENT, [1], '.', 'class', 'zohocharts_scroll');
      scroll.styles(scrollStyles);

      appendEle(scroll, DIV_ELEMENT, [1], '.', 'class', 'child');

      var axisrotated = chartObj.axes.rotated,
        conf = chartObj.defaultScroll;

      //scrollbar size
      var scroll_node = scroll.node();
      var scrollbar_size;
      if (mode == 'xy') {
        scrollbar_size = scroll_node.offsetWidth - scroll_node.clientWidth + (scroll_node.offsetHeight - scroll_node.clientHeight);
      }
      var scrollbar_size =
      axisrotated || mode == 'y' ?
      scroll_node.offsetWidth - scroll_node.clientWidth :
      scroll_node.offsetHeight - scroll_node.clientHeight;
      scroll.attr('scrollbarSize', scrollbar_size);

      var axistype_horizontal = mapping_axistype.x,
        axistype_vertical = mapping_axistype.y,
        axisObj_horizontal = axistype_horizontal == 'x' ? chartObj.systemConf.chart.axes.xaxis : chartObj.systemConf.chart.axes.yaxis[0],
        axisObj_vertical = axistype_vertical == 'x' ? chartObj.systemConf.chart.axes.xaxis : chartObj.systemConf.chart.axes.yaxis[0];
      if (!conf) {
        conf = chartObj.defaultScroll = {};

        conf.tickmarkSize = +axisObj_horizontal.tickmark.size;
        conf.marginRight = +chartObj.systemConf.chart.marginRight;
        conf.tickmarkSizeVertical = +axisObj_vertical.tickmark.size;
      }
      if ((mode == 'x' || mode == 'xy') && axisObj_horizontal.orient !== 'top') {
        axisObj_horizontal.tickmark.size = +conf.tickmarkSize + scrollbar_size;
      }
      if ((mode == 'y' || mode == 'xy') && axisObj_vertical.orient == 'right') {
        axisObj_vertical.tickmark.size = +conf.tickmarkSizeVertical + scrollbar_size;
      }

      // #ZC1770
      // add canvas group for canvas charts
      if (chartObj.systemConf.chart.plot.renderer.mode.toLowerCase() === 'canvas') {
        chartObj.canvasScrollGroup = createElement('div', '.canvas_scroll_group', [1], chartObj.chartParentElement, '.static').styles(
        scrollStyles);

      }

      if (mode == 'xy' || mode == 'y') {
        chartObj.plotarea.bottom += scrollbar_size;
        chartObj.plotarea.width -= scrollbar_size;
      }
    };

    function getClipPathAttrs(chartObj, axisType, dimension, axisOrder) {
      var hierachyObj = chartObj.dataObject.hierarchical,
        plotarea = chartObj.plotarea,
        scrolled = dimension == 'width' ? chartObj.scrolledX : chartObj.scrolledY,
        attrObj,
        axesCount = chartObj.axes[axisType].count;
      var axisLen = 0;
      if (hierachyObj) {
        axisLen = getAxisAreaForLowerOrder(axisType, axisOrder, chartObj);
      } else {
        axisLen = axisType == 'x' ? chartObj.axes.x.ticks.preCalcAxisLen : chartObj.axes.y.groups[0].ticks.preCalcAxisLen;
      }

      var axisIndex = axisOrder;
      if (isFacet(chartObj) && !chartObj.isAxisCategory) {
        // Pivot non-axis chart
        axisIndex = hierachyObj.pivotLayout.getRootNodeList(axisType == 'y' ? 'row' : 'column').getLeavesCount();
      }

      var axisObj_cur = getAxisObject(chartObj, axisType, axisIndex),
        axisLen_cur = axisObj_cur.component.tickLabelWidth(),
        orient = axisObj_cur.component.orient();

      if (dimension == 'height') {
        if (orient == 'left') {
          attrObj = {
            x: -plotarea.left,
            y: scrolled,
            width: plotarea.width + plotarea.left + axisLen,
            height: plotarea.height
          };
        } else {
          attrObj = {
            x: -axisLen - plotarea.width,
            y: scrolled,
            width: plotarea.width + axisLen_cur + axisLen,
            height: plotarea.height
          };
        }
      } else {
        if (orient == 'bottom') {
          attrObj = {
            x: scrolled,
            y: -axisLen - plotarea.height,
            width: plotarea.width,
            height: axisLen + plotarea.height + axisLen_cur
          };
        } else {
          attrObj = {
            x: scrolled,
            y: -plotarea.top,
            width: plotarea.width,
            height: plotarea.height + plotarea.top + axisLen
          };
        }
      }

      return attrObj;
    }

    function getPolarClipPathAttrs(chartObj, axisType, node) {
      var scrollPosByEvent = getScrollPositionByEvent(chartObj),
        trans = getSvgTransform(node.parentNode).translate,
        plotarea = chartObj.plotarea,
        plotarea_approx = chartObj.plotarea_approx,
        bound = chartObj.rendererConf[0].bound(),
        polarMode =
        chartObj.dataObject.isPolarAxisCategory && axisType === 'x' || !chartObj.dataObject.isPolarAxisCategory && axisType === 'y';

      var x = polarMode ?
        -trans[0] - plotarea_approx.x + plotarea.left + scrollPosByEvent[0] :
        -trans[0] + plotarea.left + scrollPosByEvent[0],
        y = polarMode ? -trans[1] - plotarea_approx.y + plotarea.top + scrollPosByEvent[1] : -trans[1] + plotarea.top + scrollPosByEvent[1],
        width = mathMin(plotarea.width, mathMax(-x + bound.width, 0)),
        height = mathMin(plotarea.height, mathMax(-y + bound.height, 0));

      return { x: x, y: y, width: width, height: height };
    }

    function getAxisGroups(chartObj, axisType, dimension, leafOnly) {
      var axis = chartObj.container.selectAll("g.".concat(axisType, "-axis")).selectAll('g.axisgroup,g.minmaxlabelsGroup'),_getScrollPosition =
        getScrollPosition(chartObj, dimension),_getScrollPosition2 = _slicedToArray(_getScrollPosition, 2),transX = _getScrollPosition2[0],transY = _getScrollPosition2[1],
        scrollPosByEvent = getScrollPositionByEvent(chartObj),
        isPolarLeafAxis = function isPolarLeafAxis(_class) {return _class && _class.search('-') > -1;};

      axis.each(function (d, i) {
        var comp = d3_select(this),
          _class,
          clipAttrs;

        if (hasPolarAxis(chartObj)) {
          _class = getAxisID(axisType, this);

          if (comp.attr('class') === 'minmaxlabelsGroup' || isPolarLeafAxis(_class)) {
            // Leaf axis
            clipAttrs = getPolarClipPathAttrs(chartObj, axisType, this);
          } else {
            if (leafOnly) {
              return;
            }

            clipAttrs = getClipPathAttrs(chartObj, axisType, dimension, +_class);
          }
        } else {
          clipAttrs = getClipPathAttrs(chartObj, axisType, dimension, i);
        }

        var pos = isPolarLeafAxis(_class) ?
        chartObj.dataObject.isPolarAxisCategory && axisType === 'x' ||
        !chartObj.dataObject.isPolarAxisCategory && axisType === 'y' ?
        [-scrollPosByEvent[0] + chartObj.plotarea_approx.x, -scrollPosByEvent[1] + chartObj.plotarea_approx.y] :
        [-scrollPosByEvent[0], -scrollPosByEvent[1]] :
        [transX, transY];
        var clipid = "default_scroll_axes_".concat(axisType, "_").concat(i, "_clip").concat(chartObj.id);
        svg_clips.rect(clipAttrs, clipid, null, null, null, chartObj);

        comp.attrs({
          transform: "translate(".concat(pos[0], ",").concat(pos[1], ")"),
          'clip-path': "url(#".concat(clipid, ")")
        });
        chartObj.staticPaneSVG.selectAll('g.threshold').attrs({
          transform: "translate(".concat(pos[0], ",").concat(pos[1], ")")
        });
        if (chartObj.dataObject.hierarchical && chartObj.dataObject.hierarchical.categoryTree && !isPolarLeafAxis(_class)) {
          var isLeafAxisType = isLeafAxis(axisType, i, chartObj);
          if (isLeafAxisType) {
            var axislabelG = d3_select(this.parentElement).
            selectAll('g.axislabelgroup').
            attrs({
              transform: "translate(".concat(transX, ",").concat(transY, ")"),
              'clip-path': "url(#".concat(clipid, ")")
            });
          }
        }

        // comp.selectAll('g.axisgroup').attr('clip-path', '');
      });
    }

    function getAxisID(axisType, node) {
      return d3_select(node.parentNode).
      attr('class').
      replace("".concat(axisType, "-axis-"), '');
    }

    function getScrollPosition(chartObj, dimension) {
      var scrolled = dimension == 'width' ? chartObj.scrolledX : chartObj.scrolledY;
      if (dimension == 'height') {
        return [0, -scrolled];
      } else {
        return [-scrolled, 0];
      }
    }

    function getScrollPositionByEvent(chartObj) {
      var event = d3_event();
      if (event) {
        var src = event.srcElement || event.target;
        return [src.scrollLeft, src.scrollTop];
      }

      return [chartObj.scrolledX || 0, chartObj.scrolledY || 0];
    }

    function updateAxisClipPath(chartObj, scrollingMode, state) {
      var axisrotated = chartObj.axes.rotated,
        plotarea = chartObj.plotarea,
        scrolled = scrollingMode == 'x' ? chartObj.scrolledX : chartObj.scrolledY,
        hierachyObj = chartObj.dataObject.hierarchical,
        mapping_orient = {
          x: axisrotated ? 'height' : 'width',
          y: axisrotated ? 'width' : 'height'
        },
        mapping_axistype = {
          x: axisrotated ? 'y' : 'x',
          y: axisrotated ? 'x' : 'y'
        };

      if (scrollingMode == 'xy') {
        //x
        getAxisGroups(chartObj, 'x', mapping_orient.x);

        //y
        getAxisGroups(chartObj, 'y', mapping_orient.y);
      } else if (scrollingMode == 'x') {
        //x
        getAxisGroups(chartObj, mapping_axistype[scrollingMode], mapping_orient[mapping_axistype[scrollingMode]]);

        if (hasPolarAxis(chartObj)) {
          getAxisGroups(chartObj, mapping_axistype.y, mapping_orient[mapping_axistype[scrollingMode]], true);
        }
      } else {
        //y
        getAxisGroups(chartObj, mapping_axistype[scrollingMode], mapping_orient[mapping_axistype[scrollingMode]]);

        if (hasPolarAxis(chartObj)) {
          getAxisGroups(chartObj, mapping_axistype.x, mapping_orient[mapping_axistype[scrollingMode]], true);
        }
      }

      if (state == 'init' && scrollingMode == 'xy' && hierachyObj) {
        var rowList = hierachyObj.pivotLayout.getRootNodeList('row'),
          rowCount = rowList.getCount(),
          yaxesCount = chartObj.axes.y.count,
          parentRowAxisObj = chartObj.axes.y.branches[rowCount - 1],
          gridInfo = parentRowAxisObj.component.majorTicks(),
          orient = parentRowAxisObj.component.orient();

        var scrollGridGroup = createElement(
          'g',
          '.scroll_roller_grid_group',
          [1],
          chartObj.wrap.selectAll("g.y-axis-".concat(yaxesCount - 1)),
          '.y-axis'),

          scrollGridlineHeaderGroup = createElement('g', '.scroll_roller_header_grid_group', [1], scrollGridGroup, '.y-axis'),
          scrollGridlineFooterGroup = createElement('g', '.scroll_roller_footer_grid_group', [1], scrollGridGroup, '.y-axis'),
          gridlineNode = chartObj.wrap.
          selectAll("g.y-axis-".concat(yaxesCount - 1)).
          selectAll('line.majorTicks').
          nodes();
        if (gridlineNode.length) {
          var gridTemplate = gridlineNode[0].cloneNode(0),
            gridTemplate1 = gridlineNode[0].cloneNode(0);

          scrollGridlineHeaderGroup.node().appendChild(gridTemplate);
          scrollGridlineFooterGroup.node().appendChild(gridTemplate1);

          if (orient == 'left') {
            scrollGridlineHeaderGroup.attr('transform', 'translate(0,0.5)');
            scrollGridlineFooterGroup.attr('transform', "translate(0,".concat(chartObj.plotarea.height + 0.5, ")"));
          } else if (orient == 'bottom') {
            scrollGridlineHeaderGroup.attr('transform', 'translate(0.5,0)');
            scrollGridlineFooterGroup.attr('transform', "translate(".concat(chartObj.plotarea.width + 0.5, ",0)"));
          }
        }
      }
    }

    /**
     *
     * @param {boolean} reset
     * @param {{width: number, height: number}} dimension
     * @param {string} chart
     */
    plotScroll_div.prototype.fixScrollView = function () {var reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;var dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var chart = arguments.length > 2 ? arguments[2] : undefined;
      chart.svg.styles({
        width: dimension.width + PX,
        height: dimension.height + PX
      });
      chart.d3container.style('overflow', reset ? null : 'hidden');
    };

    /**
     *
     * @param chartObj
     * @return {{top: number, left: number, width: number, height: number}}
     */
    function getPlotBoundingRect(chartObj, exludeLeftTop) {
      var area = chartObj.plotarea,
        left = area.left,
        top = area.top,
        width = area.width,
        height = area.height;

      if (exludeLeftTop) {
        left = top = 0;
      }

      if (defined(chartObj.divScroll)) {
        left -= chartObj.scrolledX;
        top -= chartObj.scrolledY;
        width += chartObj.scrolledX;
        height += chartObj.scrolledY;
      }

      return { x: left, y: top, left: left, top: top, width: width, height: height };
    }

    function hasPolarAxis(chartObj) {
      return chartObj.dataObject.isPolarAxisCategory || seriesIs(chartObj.chartTypes[0].value, DIAL_CHARTNAME);
    }

    function isSmoothScrollEnabled(chartObj) {
      return (
        (chartObj._isAxisCategory() || chartObj.dataObject.isFlowChartCategory) && chartObj.systemConf.chart.width ||
        chartObj.systemConf.chart.height);

    }

    Registry.setComponent('smoothScroll', plotScroll_div);

    /**
     * @param  {Array} array
     * @param  {[Array | Number | String]} keys
     * @return {Array}       [categories]
     */
    function categories(array, keys) {
      var data = getDataByKeys(array, keys);
      return getDistinct(data);
    }

    var LOG = 'log',
      SQRT = 'sqrt';

    //$Id$
    //labeltype-constants.js
    //labeltype-constants.js

    var POLAR_SCALETYPE = 'polar',
      QUANTILE_SCALETYPE = 'quantile';

    function getAxisObject$1(chartObj, type) {var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      return getAxisObjects(chartObj, type)[index];
    }

    function getAxisObjects(chartObj, type) {
      var axes = chartObj.axes[type];

      if (isFacet(chartObj)) {
        if (type === 'y') {
          var hierarchical = chartObj.dataObject.hierarchical,
            nodeList = hierarchical.pivotLayout.getRootNodeList('row'),
            nodeListCount = nodeList.getCount(),
            _hasMultiCluster3 = nodeList.hasMultiCluster();

          if (_hasMultiCluster3 || nodeListCount) {
            return axes.leaves;
          } else {
            return axes.groups;
          }
        } else {
          var hasSplitLeavesColumns = chartObj.systemConf.chart.axes.xaxis.splitLeaves;
          if (hasSplitLeavesColumns) {
            return axes.leaves;
          } else {
            return [{ scale: axes.leafScaleGrid }];
          }
        }
      } else {
        return type === 'y' ? axes.groups : [{ scale: axes.scale }];
      }
    }

    function getAxisData$1(chartObj, type) {var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var axesConfig = chartObj.systemConf.chart.axes;
      return type == 'x' ? axesConfig.xaxis : axesConfig.yaxis[index];
    }

    function getPlotConfig(chartObj) {
      var chartName = chartObj.chartTypes[0].name;
      return chartObj.systemConf.chart.plot.plotoptions[chartName];
    }

    function getFormat(chartObj, type, index, _class) {
      var column = chartObj.dataset.getColumn(type, index),
        datatype = column.datatype,
        formatConf = column[datatype];

      return function (d) {return getFormattedValue(formatConf, d, datatype, chartObj, _class);};
    }

    function getPolarRange(chartObj, type, config) {
      var polarConfig = config || getPolorRangeConfig(chartObj, type),
        reversed = polarConfig.reversed,startAngle = polarConfig.startAngle,endAngle = polarConfig.endAngle;

      return reversed ?
      [validateNullVal(endAngle, 2 * mathPI), validateNullVal(startAngle, 0)] :
      [validateNullVal(startAngle, 0), validateNullVal(endAngle, 2 * mathPI)];
    }

    function getPolorRangeConfig(chartObj, type) {
      var commonPlotOptions = getPlotConfig(chartObj),
        axisData = getAxisData$1(chartObj, type);
      return {
        reversed: axisData.reversed,
        startAngle: commonPlotOptions.startAngle,
        endAngle: commonPlotOptions.endAngle
      };
    }

    /**
     *
     * @param chartObj
     * @param type
     * @param orient
     * @param axisReversed
     * @return {(number)[]|string|{optionsText: [string, string, string, string]}|[]|*[]|number[]}
     * plotBound:{
     *     dimension: 'width or height', //MANDATORY
     *     plotSize: '<rect object>'
     * }
     */

    function plotBoundForScaleRange(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        _scaleType = _parser.scaleType,
        _encodeType = _scale.encode,
        _reversed = _parser.reverse,
        _dimension = operatorC.dimension,
        _plotarea = invokeFunction(operatorC.plotSize, operatorC.defaultPlotSize, this.chartObj),
        _customPlotSize = operatorC.customPlotBound && operatorC.customPlotBound[_dimension],
        _polarConfig = operatorC.polarConfig,
        _boundExtreme = invokeFunction(operatorC.boundExtreme, operatorC.defaultPlotSize, this.chartObj);

      if (_scaleType == POLAR_SCALETYPE) {
        return getPolarRange(NULL$1, _encodeType, _polarConfig);
      }

      if (_encodeType == 'clr') {
        return operatorC.color;
      }

      var plotBound = getPlotSize(NULL$1, _dimension, _plotarea, NULL$1, _customPlotSize);

      var minBound = _dimension == 'width' ? _boundExtreme || 0 : plotBound,
        maxBound = _dimension == 'width' ? plotBound : _boundExtreme || 0;

      var range = [minBound, maxBound];

      if (_reversed) {
        range = range.reverse();
      }
      _parser.tempRange = range;
      this.d3_scale.origRange = simpleClone(range);
      return range;
    }

    var ScaleRegistry = {
      add: function add(name, component) {
        Registry.setComponent(name, component);
      },
      get: function get(name) {return Registry.getComponent(name);}
    };

    function getExtremes(operators) {var _this9 = this;
      var _scale = this,
        _chart = _scale.chartObj,
        _scaleType = _scale.type,
        _encodeType = _scale.encode,
        _reversed = _scale.reverse,
        _dimension = _scale.dimension,
        // _field = _scale.field,
        // _dataIndex = _field.dataIndex,
        _extremes;

      _extremes = operators.map(function (operator) {
        if (isArray$1(operator)) {
          return operator;
        }

        if (isFunction(operator)) {
          return invokeFunction(operator, _this9);
        }

        var appliedOperators = {};

        if (ALLOWED_EXTREMES_OPERATORS.has(operator._type)) {
          appliedOperators[operator._type] = ALLOWED_EXTREMES_OPERATORS.get(operator._type).call(_this9, operator);
          return appliedOperators[operator._type];
        }
      });
      var value = d3_extent(d3_merge(_extremes));
      _scale.config.tempDomain = d3_extent(d3_merge(_extremes));
      _scale.config.extremes = value;
      return value;
    }
    function getSeriesExtremes(operator) {
      var _scale = this,
        _scaleType = _scale.type,
        _encodeType = _scale.encode,
        _reversed = _scale.reverse,
        _dimension = _scale.dimension,
        _encodeId = _scale.id,
        key = _scale.key,
        seriesExtermes = operator.seriesExtermes;

      var values = d3_merge(seriesExtermes[key]);
      var extremes = values.length != 0 ? d3_extent(values) : values.enabled ? [0, 0] : null; // yvalues.enabled for referring that axis is visible or not.If the axis is visible,but all the data contains 0 or null,we dont want to remove axis
      return extremes;
    }

    //x data encode and stack layout indices
    function getExtremesByAccessor(operator) {
      var _scale = this,
        _chart = _scale.chartObj || {},
        _scaleType = _scale.type,
        _encodeType = _scale.encode,
        _reversed = _scale.reverse,
        _dimension = _scale.dimension,
        _getAccessor = operator.accessor,
        _data = operator.data,
        _indices = operator.indices,
        condition = operator.condition;

      var extremesByAccessor;

      extremesByAccessor = _data.map(function (d, i) {
        var extremes;
        var data = d3_merge(d.data),
          seriesIdx = _indices ? _indices[i] : i,
          _accessor = _getAccessor(_encodeType, seriesIdx);

        if (condition) {
          data = data.filter(condition);
        }

        if (operator.isRangeType && operator.isRangeType(seriesIdx)) {
          var mergedYranges = d3_merge(data.map(_accessor, _encodeType, seriesIdx));
          extremes = d3_extent(mergedYranges);
        } else {
          extremes = d3_extent(data, _accessor, _encodeType, seriesIdx);
        }
        return extremes;
      });

      return d3_extent(d3_merge(extremesByAccessor));
    }

    //levelmarker
    //extremesByDataIndices
    function getExtremesByData(operator) {
      var _scale = this,
        _chart = _scale.chartObj,
        _accessor = operator.accessor,
        _data = operator.data || _chart.seriesdata || this.config.data,
        _dataIndices = operator.indices,
        _extents = [],
        extremes;

      _data.forEach(function (d) {
        if (!d.disabled) {
          // var subSeries = d3_merge(d.data || d);
          var subSeries = d.data || d;
          eachData(subSeries, function (point) {
            _dataIndices.map(function (d) {
              _extents = _extents.concat(point[d]);
            });
          });

          // subSeries.forEach(function(point) {
          //     _dataIndices.map(d => {
          //         _extents = _extents.concat(point[d]);
          //     });
          // });
        }
      });

      extremes = d3_extent(_extents);
      return extremes;
    }

    function eachData(data, callback) {
      if (data && isArray$1(data) && data.every(isArray$1)) {
        data.forEach(function (child) {
          eachData(child, callback);
        });
      } else {
        callback(data);
      }
    }
    function getLogDomainExtremes(operators) {
      var _scale = this,
        _extremes;

      _extremes = operators.map(function (operator) {
        if (isArray$1(operator)) {
          return operator;
        }
      });
      var value = d3_extent(d3_merge(_extremes));
      _scale.config.extremes = value;
      return value;
    }

    ScaleRegistry.add('axis.extremes', getExtremes);

    function getStackExtremes(operatorC) {
      var _scale = this,
        _chart = _scale.chartObj,
        _processor = _chart.dataObject,
        _scaleType = _scale.type,
        _encodeType = _scale.encode,
        _reversed = _scale.reverse,
        _dimension = _scale.dimension,
        stackEncode = operatorC.data,
        _stackIndices = operatorC.stackIndices;

      if (_processor.isPercentChart) {
        return [0, 100];
      }

      if (!_stackIndices.length) {
        return [];
      }
      var extents = _stackIndices.map(function (stackIndex) {
        var layout = stackEncode[stackIndex].layout;
        return layout.getExtent();
      });

      return d3_extent(d3_merge(extents));
    }

    function applyCorrectionToExtremes(operatorC) {
      if (operatorC.dataType == 'time') {
        //No need to apply in extremes
        return correctionFactorForTimeData.call(this, operatorC);
      }
      var _scale = this,
        _chart = _scale.chartObj,
        _scaleType = _scale.type,
        _encodeType = _scale.encode,
        _reversed = _scale.reverse,
        _dimension = _scale.dimension,
        // _field = _scale.field,
        // _dataIndex = _field.dataIndex,
        _extremes = _scale.config.extremes,
        _needCorrectionFactor = operatorC._needCorrectionFactor,
        _correctionFactor = operatorC.correction,
        preCorrectionValue = operatorC.preCorrectionValue ? _scale.config.domain.outerPaddingCorrection : 0,
        _correctionValue = operatorC.correctionValue || preCorrectionValue || 0,
        _min = invokeFunction(_scale.config.domain.operators.min, _chart, this, _extremes),
        _max = invokeFunction(_scale.config.domain.operators.max, _chart, this, _extremes);
      var diff = _extremes[1] - _extremes[0];

      if (diff === 0) {
        diff = 1;
      }
      _scale.config.originalDomain = _extremes.slice();
      if (_needCorrectionFactor) {
        _correctionValue = diff * _correctionFactor;
      }

      if (isUndefined(_min)) {
        _min = _scale.config.domain.hasDefaultMin ? 0 : _extremes[0] - _correctionValue || 0;
      }

      if (isUndefined(_max)) {
        _max = _extremes[1] + _correctionValue || 0;
      }
      _scale.config.extremes = [_min, _max];
      return [_min, _max];
    }

    function applyExtraCorrectionFactor(operatorC) {
      //No need to apply in extremes
      var _scale = this,
        _parser = _scale.config,
        _chart = _scale.chartObj;
      var diff = _parser.extremes[1] - _parser.extremes[0];
      var outerPaddingCorrection = diff == 0 ? _chart.plotarea.width / 2 : diff * (_parser.outerPadding || 0);
      _scale.config.domain.outerPaddingCorrection = outerPaddingCorrection;
      return outerPaddingCorrection;
    }

    // export function correctionFactorForNumericData(operatorC){
    //     //No need to apply in extremes
    //     let _scale = this,
    //         _parser = _scale.config,
    //         _chart = _scale.chartObj;
    //     var diff = _parser.extremes[1] - _parser.extremes[0];
    //     var outerPaddingCorrection = diff == 0 ? _chart.plotarea.width / 2 : diff * _parser.outerPadding;
    //     _scale.config.domain.outerPaddingCorrection = outerPaddingCorrection;
    //     return outerPaddingCorrection;
    // }

    function updatebaseline(operatorC) {
      var _scale = this,
        _chart = _scale.chartObj,
        // _processor = _chart.dataObject,
        _key = _scale.key,
        _parser = _scale.config;
      // _processor.saveBaseLine(_key, _parser.extremes, operatorC.definedMin, operatorC.rangeCheck);

      //
      //
      var temp = NULL$1;

      if (_scale.datatype === NUMERIC_DATATYPE) {
        var baseLineValue = operatorC.basevalue,
          stacked = operatorC.stacked;

        temp =
        defined(baseLineValue) && !stacked && (!operatorC.rangeCheck || isWithinRange(baseLineValue, _parser.extremes)) //On zooming only, isWithinRange should be considered
        ? baseLineValue :
        operatorC.definedMin < 0 || _parser.extremes[0] < 0 ?
        0 :
        NULL$1;
      }
      if (!this.config.hasNegativeValue) {
        this.config.hasNegativeValue = [];
      }
      this.config.hasNegativeValue[_scale.key] = temp;
      // processor.hasNegativeValue[index] = temp;
    }

    function updateMinimumBoundValue() {
      var _scale = this,
        _chart = _scale.chartObj,
        // _processor = _chart.dataObject,
        _key = _scale.key,
        _parser = _scale.config,
        _extremes = _parser.extremes,
        hasNegativeValue = _parser.hasNegativeValue[_scale.key];
      var hasDefaultMin = _parser.domain.operators.hasDefaultBase && (hasNegativeValue != null ? hasNegativeValue > 0 : true);

      if (_parser.domain.operators.hasDefaultBase && _extremes[1] - _extremes[0] === 0) {
        _parser.extremes = d3_extent(d3_merge([_extremes, [0]]));
      }
      _scale.config.domain.hasDefaultMin = hasDefaultMin;
      return hasDefaultMin;
    }

    function updateAutoTimeSubfunction(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        subfunction = operatorC.subfunction,
        domain = _parser.extremes;
      var start = new Date(domain[0]),
        end = new Date(domain[1]);

      // #ZC1187
      if (!defined(subfunction) || subfunction == "AUTO") {
        subfunction = getAutoTimeSubFunction(end - start).subFunction;
      }
      _parser.subfunction = subfunction;
      return subfunction;
    }

    //$Id$

    var date_utils = function date_utils(formatConf) {
      formatConf = pick(formatConf, {}); // #ZC1187
      this.startWeekDay = defined(formatConf.startWeekDay) ? formatConf.startWeekDay : 1;
      this.startMonth = defined(formatConf.startMonth) ? formatConf.startMonth : 0;
    };

    date_utils.MILLISEC = 0;
    date_utils.SECOND = 1;
    date_utils.MINUTE = 2;
    date_utils.HOUR = 3;
    date_utils.DATE = 4;
    date_utils.MONTH = 5;

    date_utils.SECOND_TYPE = 'ABSSECOND'; //Seconds wise
    date_utils.MINUTE_TYPE = 'ABSMINUTE'; //Minutes wise
    date_utils.HOUR_TYPE = 'ABSHOUR'; //Hours wise
    date_utils.DAY_TYPE = 'ABSDAY'; //Weekday wise(sunday,monday..)
    date_utils.DATETIME_TYPE = 'DATETIME'; //Date with time wise(18 Sep 2011 01:10:40)
    date_utils.DATE_TYPE = 'DATE'; //Date wise(18 Sep 2011)
    date_utils.ABSWEEK_TYPE = 'ABSWEEK'; //Week number wise
    date_utils.ABSMONTH_TYPE = 'ABSMONTH'; //Month wise
    date_utils.ABSQUARTER_TYPE = 'ABSQUARTER'; //Quarter wise,four quarters for each year(Q1,Q2,Q3,Q4)
    date_utils.ABSYEAR_TYPE = 'YEAR'; //Year wise

    date_utils.D3_WEEKDAY_FNS = [
    d3_timeSunday,
    d3_timeMonday,
    d3_timeTuesday,
    d3_timeWednesday,
    d3_timeThursday,
    d3_timeFriday,
    d3_timeSaturday];

    date_utils.DAY_MILLIS = 24 * 60 * 60 * 1000;

    date_utils.prototype.setZero = function (dateVal, type) {
      var oldVal = 0;
      for (var i = 0; i <= type; i++) {
        switch (i) {
          case date_utils.MILLISEC:
            {
              oldVal += this.getMilliseconds(dateVal);
              this.setMilliseconds(dateVal, 0);
            }
            break;
          case date_utils.SECOND:
            {
              oldVal += this.getSeconds(dateVal);
              this.setSeconds(dateVal, 0);
            }
            break;
          case date_utils.MINUTE:
            {
              oldVal += this.getMinutes(dateVal);
              this.setMinutes(dateVal, 0);
            }
            break;
          case date_utils.HOUR:
            {
              oldVal += this.getHours(dateVal);
              this.setHours(dateVal, 0);
            }
            break;
          case date_utils.DATE:
            {
              oldVal += this.getDate(dateVal) - 1;
              this.setDate(dateVal, 1);
            }
            break;

          case date_utils.MONTH:
            {
              oldVal += this.getMonth(dateVal);
              this.setMonth(dateVal, this.startMonth); // set custom startMonth
            }
            break;
          default:
            {
              throw "unknown type 333: ".concat(type);
            }
            break;}

      }
      return oldVal;
    };

    date_utils.prototype.getBaseValue = function (dateVal, type, isCeil) {
      switch (type) {
        case date_utils.SECOND_TYPE:
        case date_utils.DATETIME_TYPE:
          {
            var oldVal = this.setZero(dateVal, date_utils.MILLISEC);
            if (isCeil && oldVal > 0) {
              this.setSeconds(dateVal, this.getSeconds(dateVal) + 1);
            }
          }
          break;
        case date_utils.MINUTE_TYPE:
          {
            var oldVal = this.setZero(dateVal, date_utils.SECOND);
            if (isCeil && oldVal > 0) {
              this.setMinutes(dateVal, this.getMinutes(dateVal) + 1);
            }
          }
          break;
        case date_utils.HOUR_TYPE:
          {
            var oldVal = this.setZero(dateVal, date_utils.MINUTE);
            if (isCeil && oldVal > 0) {
              this.setHours(dateVal, this.getHours(dateVal) + 1);
            }
          }
          break;
        case date_utils.DAY_TYPE:
        case date_utils.DATE_TYPE:
          {
            var oldVal = this.setZero(dateVal, date_utils.HOUR);
            if (isCeil && oldVal > 0) {
              this.setDate(dateVal, this.getDate(dateVal) + 1);
            }
          }
          break;

        case date_utils.ABSWEEK_TYPE:
          {
            var oldVal = this.setZero(dateVal, date_utils.SECOND);
            var startWeekDay = this.startWeekDay;
            if (isCeil) {
              if (oldVal > 0) {
                this.setDate(dateVal, this.getDate(dateVal) + 1);
              }
              if (startWeekDay < this.getDay(dateVal)) {
                this.setDate(dateVal, this.getDate(dateVal) + (7 - this.getDay(dateVal) + startWeekDay));
              } else {
                this.setDate(dateVal, this.getDate(dateVal) + (startWeekDay - this.getDay(dateVal)));
              }
            } else {
              if (startWeekDay > this.getDay(dateVal)) {
                this.setDate(dateVal, this.getDate(dateVal) - (7 - startWeekDay + this.getDay(dateVal)));
              } else {
                this.setDate(dateVal, this.getDate(dateVal) - (this.getDay(dateVal) - startWeekDay));
              }
            }
          }
          break;

        case date_utils.ABSQUARTER_TYPE:
        case date_utils.ABSMONTH_TYPE:
          {
            var oldVal = this.setZero(dateVal, date_utils.DATE);
            if (isCeil && oldVal > 0) {
              this.setMonth(dateVal, this.getMonth(dateVal) + 1);
            }
          }
          break;

        case date_utils.ABSYEAR_TYPE:
          {
            var oldVal = this.setZero(dateVal, date_utils.MONTH);
            if (isCeil && oldVal > this.startMonth) {
              //set base value based on custom start month not by default 0
              this.setFullYear(dateVal, this.getFullYear(dateVal) + 1);
            }
          }
          break;
        default:{
            throw "unknow type 222: ".concat(type);
          }}

    };

    date_utils.prototype.getTicksList = function (t0, t1, dt, type) {
      var times = new Array();
      var t1Time = t1.getTime();
      var time = t0.getTime();
      var t = new Date(time);

      while (time <= t1Time) {
        times.push(t);
        t = new Date(time);
        switch (type) {
          case date_utils.SECOND_TYPE:
          case date_utils.DATETIME_TYPE:
            {
              t.setTime(t.getTime() + mathFloor(dt) * 1000);
            }

            break;

          case date_utils.MINUTE_TYPE:
            {
              t.setTime(t.getTime() + dt * 60000);
            }
            break;
          case date_utils.HOUR_TYPE:
            {
              t.setTime(t.getTime() + dt * 3600000);
            }
            break;

          case date_utils.DAY_TYPE:
          case date_utils.DATE_TYPE:
            {
              t.setTime(t.getTime() + dt * date_utils.DAY_MILLIS);
            }
            break;
          case date_utils.ABSWEEK_TYPE:
            {
              this.setDate(t, this.getDate(t) + dt);
            }
            break;

            break;
          case date_utils.ABSMONTH_TYPE:
          case date_utils.ABSQUARTER_TYPE:
            {
              this.setMonth(t, this.getMonth(t) + dt);
            }
            break;

          case date_utils.ABSYEAR_TYPE:
            {
              this.setFullYear(t, this.getFullYear(t) + dt);
            }
            break;}

        time = t.getTime();
      }
      return times;
    };

    date_utils.prototype.range = function (minDate, maxDate, tickCount, type, tickInterval) {
      minDate = new Date(minDate.getTime());
      maxDate = new Date(maxDate.getTime());

      this.getBaseValue(minDate, type, false);
      this.getBaseValue(maxDate, type, true);
      switch (type) {
        case date_utils.SECOND_TYPE:

        case date_utils.DATETIME_TYPE:
          {
            // var interval = Math.ceil((maxDate.getTime() - minDate.getTime()) / (tickCount * 1000));
            var minInterval = 1;
            var noOfSec = mathCeil((maxDate.getTime() - minDate.getTime()) / 1000);
            var interval = mathCeil(noOfSec / tickCount) || minInterval;
            interval = getInterval(interval, tickInterval);
            return {
              TYPE: d3_timeSeconds,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;

        case date_utils.MINUTE_TYPE:
          {
            var minInterval = 1;
            var interval = mathCeil((maxDate.getTime() - minDate.getTime()) / (tickCount * 60000)) || minInterval;
            interval = getInterval(interval, tickInterval);
            return {
              // TODO check for using  d3_timeHours instead of d3_timeMinutes.
              TYPE: d3_timeHours,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;
        case date_utils.HOUR_TYPE:
          {
            var minInterval = 1;
            var interval = mathCeil((maxDate.getTime() - minDate.getTime()) / (tickCount * 3600000)) || minInterval;
            interval = getInterval(interval, tickInterval);
            return {
              TYPE: d3_timeHours,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;
        case date_utils.DAY_TYPE:
        case date_utils.DATE_TYPE:
          {
            var minInterval = 1;
            var interval = mathCeil((maxDate.getTime() - minDate.getTime()) / (tickCount * date_utils.DAY_MILLIS)) || minInterval;
            interval = getInterval(interval, tickInterval);
            return {
              TYPE: d3_timeDays,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;

        case date_utils.ABSWEEK_TYPE:
          {
            var minInterval = 1;
            var interval_week = mathCeil((maxDate.getTime() - minDate.getTime()) / (tickCount * date_utils.DAY_MILLIS * 7));
            interval_week = getInterval(interval_week, tickInterval);
            var interval = mathCeil(interval_week) * 7 || minInterval; //interval in weekdays
            return {
              TYPE: d3_timeWeeks,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;

        case date_utils.ABSMONTH_TYPE:
          {
            var minInterval = 1;
            var interval = mathCeil(this.getMonthsDiff(minDate, maxDate) / tickCount) || minInterval;
            interval = getInterval(interval, tickInterval);
            return {
              TYPE: d3_timeMonths,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;
        case date_utils.ABSQUARTER_TYPE:
          {
            var minInterval = 1;
            var interval_month = this.getMonthsDiff(minDate, maxDate) / tickCount || minInterval;
            var quarter = mathCeil(interval_month / 3);
            quarter = getInterval(quarter, tickInterval);
            var interval = quarter * 3;
            return {
              TYPE: d3_timeMonths,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;

        case date_utils.ABSYEAR_TYPE:
          {
            var minInterval = 1;
            var interval = mathCeil((maxDate.getFullYear() - minDate.getFullYear()) / tickCount) || minInterval;
            interval = getInterval(interval, tickInterval);
            return {
              TYPE: d3_timeYears,
              INTERVAL: interval,
              TICKS: this.getTicksList(minDate, maxDate, interval, type)
            };
          }
          break;

        default:{
            throw "UNKNOWN TYPE 111: ".concat(type);
          }}


      function getInterval(actualInterval, userInterval) {
        return userInterval != null && userInterval >= actualInterval ? userInterval : actualInterval;
      }
    };

    date_utils.MAX_DATE = new Date(2008, 8, 29, 23, 23, 23, 999);
    date_utils.prototype.getMaxDate = function (formatConf, specifierIndex) {
      return getFormattedValue(formatConf, date_utils.MAX_DATE, TIME_DATATYPE, null, 'axis', null, null, specifierIndex);
    };

    date_utils.prototype.getMonthsDiff = function (minDate, maxDate) {
      return (this.getFullYear(maxDate) - this.getFullYear(minDate)) * 12 + (this.getMonth(maxDate) - this.getMonth(minDate));
    };

    date_utils.prototype.getYearsDiff = function (minDate, maxDate) {
      return (this.getFullYear(maxDate) - this.getFullYear(minDate)) * 12 + (this.getMonth(maxDate) - this.getMonth(minDate));
    };

    date_utils.prototype.getFullYear = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCFullYear() : date.getFullYear();
    };
    date_utils.prototype.getMonth = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCMonth() : date.getMonth();
    };
    date_utils.prototype.getDay = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCDay() : date.getDay();
    };
    date_utils.prototype.getDate = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCDate() : date.getDate();
    };
    date_utils.prototype.getHours = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCHours() : date.getHours();
    };
    date_utils.prototype.getMinutes = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCMinutes() : date.getMinutes();
    };
    date_utils.prototype.getSeconds = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCSeconds() : date.getSeconds();
    };
    date_utils.prototype.getMilliseconds = function (date) {
      return this.useUTC != null && this.useUTC ? date.getUTCMilliseconds() : date.getMilliseconds();
    };

    date_utils.prototype.setFullYear = function (date, val) {
      return this.useUTC != null && this.useUTC ? date.setUTCFullYear(val) : date.setFullYear(val);
    };
    date_utils.prototype.setMonth = function (date, val) {
      return this.useUTC != null && this.useUTC ? date.setUTCMonth(val) : date.setMonth(val);
    };
    date_utils.prototype.setDate = function (date, val) {
      return this.useUTC != null && this.useUTC ? date.setUTCDate(val) : date.setDate(val);
    };
    date_utils.prototype.setHours = function (date, val) {
      return this.useUTC != null && this.useUTC ? date.setUTCHours(val) : date.setHours(val);
    };
    date_utils.prototype.setMinutes = function (date, val) {
      return this.useUTC != null && this.useUTC ? date.setUTCMinutes(val) : date.setMinutes(val);
    };
    date_utils.prototype.setSeconds = function (date, val) {
      return this.useUTC != null && this.useUTC ? date.setUTCSeconds(val) : date.setSeconds(val);
    };
    date_utils.prototype.setMilliseconds = function (date, val) {
      return this.useUTC != null && this.useUTC ? date.setUTCMilliseconds(val) : date.setMilliseconds(val);
    };

    function updateTimeBaseValue(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        subfunction = _parser.subfunction,
        extremes = _parser.extremes,
        start = new Date(extremes[0]),
        end = new Date(extremes[1]);
      var dateInterval = new date_utils(operatorC.metaConf);
      dateInterval.useUTC = pick(operatorC.metaConf && operatorC.metaConf.useUTC, false);
      dateInterval.getBaseValue(start, subfunction, false);
      dateInterval.getBaseValue(end, subfunction, true);

      _parser.extremes = [start.getTime(), end.getTime()];
      _parser.tempDomain = [start.getTime(), end.getTime()];
      return _parser.extremes;
    }

    //DEMO_LINE_15
    function updateTimeFormatValue(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        subfunction = _parser.subfunction,
        extremes = _parser.extremes,
        start = new Date(extremes[0]),
        end = new Date(extremes[1]);

      _parser.extremes = [start.getTime(), end.getTime()];
      return _parser.extremes;
    }

    function waterfallProcessor(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        _chart = _scale.chartObj,
        _processor = _chart.dataObject,
        _encodeType = _scale.encode,
        _index = _scale.key,
        bound = _processor.processDataForWaterFall(_index);
      _scale.config.extremes = bound;
      return bound;
    }

    function waterfallBound(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        _chart = _scale.chartObj,
        _processor = _chart.dataObject,
        _encodeType = _scale.encode,
        _index = _scale.key,
        bound = _processor.getCorrectionForWaterfall(
        _parser.extremes,
        _encodeType,
        _index,
        _chart,
        _chart.cache.correction['label-y-0'] && _chart.cache.correction['label-y-0'][1]);


      _scale.config.extremes = bound;
      return bound;
    }

    function applyLogConstant(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        _encodeType = _scale.encode,
        _index = _scale.key,
        _extremes = _parser.extremes;
      // SYM LOG SCALE constant for log like spacing near 0 ticks. eg [0.001, 0.01, 0.1, 1, 10]
      var min = d3_min(_extremes);
      if (min > 0 && min < pick(_parser.logBase, 10) && operatorC.allowNonPositiveTicks === false) {
        this.d3_scale.constant = 0.0001;
      } else {
        this.d3_scale.constant = 1;
      }
      // #ZC2812
      // if (actualStart === 'NoData' && actualEnd === 'NoData') {
      //     actualStart = actualEnd = 0;
      // }
    }

    //$Id$

    function evalCorrection(operators, _scale) {var _this10 = this;
      if (!operators._correction) {
        return [0, 0];
      }
      var corrections = operators._correction.map(function (op) {
          if (isArray$1(op)) {
            return op;
          }

          if (isFunction(op)) {
            return invokeFunction(op, _this10);
          }

          return [op, op];
        }),
        correction = [d3_max(corrections, function (_) {return _[0];}), d3_max(corrections, function (_) {return _[1];})],
        domain = _scale.config.domain,
        domainOperators = operators.domainOperators || domain.operators || {};

      if (domainOperators.min || domain.hasDefaultMin) {
        correction[0] = 0;
      }
      if (domainOperators.max) {
        correction[1] = 0;
      }

      return [correction[0] || 0, correction[1] || 0];
    }
    Registry.setComponent('scale.correctionEvaluator', evalCorrection);

    function convertOperatorToBound(operatorC) {
      var scaleComp = this;

      return operatorC.map(function (_) {
        var _type = _._type,key = _.key;
        if (_type) {
          var bound = ScaleRegistry.get(_type + '-correction-evaluator').call(scaleComp, _) || 0;
          cacheBound(key, bound, scaleComp.chartObj);
          return bound;
        } else {
          return _;
        }
      });
    }
    Registry.setComponent('scale.operatorCorrectionMapping', convertOperatorToBound);

    function cacheBound(key, bound, chart) {
      if (!key || !chart) {
        return;
      }

      var tempBound = isArray$1(bound) ? bound : [bound, bound],
        cached = chart.cache.correction;

      cached[key] = cached[key] || [0, 0];
      cached[key] = [mathMax(cached[key][0], tempBound[0]), mathMax(cached[key][1], tempBound[1])];
    }

    //$Id$

    var ALLOWED_OPERATORS = d3_map();

    // ALLOWED_RANGE_OPERATORS.ordinal = d3_map();
    // ALLOWED_RANGE_OPERATORS.numeric = d3_map();
    // ALLOWED_RANGE_OPERATORS.time = d3_map();

    ALLOWED_OPERATORS.set('extremes', getExtremes);
    ALLOWED_OPERATORS.set('logDomain', getLogDomainExtremes);
    ALLOWED_OPERATORS.set('plotBound', plotBoundForScaleRange);
    ALLOWED_OPERATORS.set('waterfallBound', waterfallBound);

    ALLOWED_OPERATORS.set('correctionFactor', applyCorrectionToExtremes);
    ALLOWED_OPERATORS.set('extraCorrectionFactor', applyExtraCorrectionFactor);
    ALLOWED_OPERATORS.set('correctionFactor1', applyCorrectionToExtremes);
    ALLOWED_OPERATORS.set('updateBaseValue', updatebaseline);
    ALLOWED_OPERATORS.set('hasDefaultBaseValue', updateMinimumBoundValue);

    ALLOWED_OPERATORS.set('basevalue', updateTimeBaseValue);
    ALLOWED_OPERATORS.set('subfunction', updateAutoTimeSubfunction);
    ALLOWED_OPERATORS.set('timeFormat', updateTimeFormatValue);

    ALLOWED_OPERATORS.set('logConstant', applyLogConstant);

    ALLOWED_OPERATORS.set('_correction', convertOperatorToBound);

    var ALLOWED_EXTREMES_OPERATORS = d3_map();
    ALLOWED_EXTREMES_OPERATORS.set('extremesByData', getExtremesByData);
    ALLOWED_EXTREMES_OPERATORS.set('extremesByEncode', getSeriesExtremes);
    ALLOWED_EXTREMES_OPERATORS.set('extremesByAccessor', getExtremesByAccessor);
    ALLOWED_EXTREMES_OPERATORS.set('stackExtremes', getStackExtremes);
    ALLOWED_EXTREMES_OPERATORS.set('waterfallProcessor', waterfallProcessor);

    /*
    color scale
     */

    // ALLOWED_OPERATORS.set('colorRanges', ScaleRegistry.get('color.rangeBound'));
    // ALLOWED_OPERATORS.set('mapDistinctRanges', ScaleRegistry.get('color.rangesForDistinctDomain'));
    // ALLOWED_OPERATORS.set('mapArrayRanges', ScaleRegistry.get('color.rangesForArrayDomain'));

    ScaleRegistry.add('scale.allowedOperators', ALLOWED_OPERATORS);
    ScaleRegistry.add('scale.allowedExtremesOperators', ALLOWED_EXTREMES_OPERATORS);

    //
    var
    Scale = /*#__PURE__*/function () {
      function Scale(encode, key, config, chartObj) {_classCallCheck(this, Scale);
        this.encode = encode;
        this.key = key || 0;
        this.config = config;
        this.chartObj = chartObj;
        this.bounds = {};
        this.init();
      }_createClass(Scale, [{ key: "init", value:

        function init() {
          this.scale = NULL$1;
          this.id = "".concat(this.encode, "-").concat(this.key);
          this.d3_scale = {};

          var config = this.getConfig(),
            data = this.chartObj && this.getDataSchema(),
            ranges = config.ranges;

          if (ranges && !isArray$1(ranges[0])) {
            config.ranges = ranges.map(function (r) {return [r];});
          }
          this.datatype = data && data.dataType;
          this.schema = {
            data: data,
            domain: {
              key: data && data.meta.dataindex,
              min: config.minRange,
              max: config.maxRange,
              ranges: config.ranges,
              stops: config.stops,
              base: config.base
            }
          };
        } }, { key: "create", value:

        function create() {
          var scale = this.getScaleType()(),
            config = this.getConfig();

          this.d3_scale.domain = this._parseDomain();
          this.d3_scale.range = this._parseRange();

          this.d3_scale.unknown = 0; // ZC2428

          if (config.clamp) {
            this.d3_scale.clamp = true;
          }

          for (var _ in this.d3_scale) {
            if (scale[_]) {
              scale[_](this.d3_scale[_]);
            } else {
              scale[_] = this.d3_scale[_];
            }
          }

          return this.scale = scale;
        } }, { key: "getScale", value:

        function getScale() {
          if (!this.scale) {
            this.create();
          }

          return this.scale;
        } }, { key: "getScaleType", value:

        function getScaleType() {
          var schema = this.schema && this.schema.data,
            dataType = this.config.dataType || schema.dataType,
            scaleType = this.config.scaleType || schema && schema.meta.scaleType;
          return _getScaleType(dataType, this, scaleType);
        } }, { key: "getConfig", value:

        function getConfig() {
          return this.config;
        } }, { key: "_parseDomain", value:
        function _parseDomain() {var _this11 = this;
          var _scale = this,
            _config = _scale.config,
            _field = _config.field,
            _domainConfig = _config.domain,
            _datatype = _config.type;

          if (isArray$1(_domainConfig)) {
            return _domainConfig;
          }

          if (isFunction(_domainConfig)) {
            invokeFunction(_domainConfig, this);
            return;
          }

          var appliedOperators = {};
          Object.keys(_domainConfig.operators).map(function (operatorKey) {
            if (ALLOWED_OPERATORS.has(operatorKey)) {
              appliedOperators[operatorKey] = ALLOWED_OPERATORS.get(operatorKey).call(
              _this11,
              _domainConfig.operators[operatorKey],
              appliedOperators);

            }
          });
          var evaluator = typeof _domainConfig.evaluator === 'string' ? invokeFunction(_domainConfig.evaluator, _scale) : _domainConfig.evaluator;
          return evaluator.call(this, appliedOperators);
        } }, { key: "_parseRange", value:
        function _parseRange() {var _this12 = this;
          var _scale = this,
            _config = _scale.config,
            _field = _config.field,
            _rangeConfig = _config.range,
            _datatype = _config.type;

          if (isArray$1(_rangeConfig)) {
            return _rangeConfig;
          }

          if (isFunction(_rangeConfig)) {
            invokeFunction(_rangeConfig, this);
            return;
          }
          var appliedOperators = {};
          ALLOWED_OPERATORS.keys().map(function (operator) {
            if (_rangeConfig.operators[operator]) {
              appliedOperators[operator] = ALLOWED_OPERATORS.get(operator).call(_this12, _rangeConfig.operators[operator], appliedOperators);
            }
          });
          var evaluator = typeof _rangeConfig.evaluator === 'string' ? invokeFunction(_rangeConfig.evaluator, _scale) : _rangeConfig.evaluator;
          return evaluator.call(this, appliedOperators);
        } }, { key: "parseDomain", value:
        function parseDomain() {
          var dataOptions = this.schema.data,
            source = invokeFunction(dataOptions.source),
            dataType = dataOptions.dataType,
            schema = this.schema.domain;

          if (dataType === TIME_DATATYPE) {
            schema = toTimestamp(schema, dataOptions.meta);
          }

          var _min = schema.min,
            _max = schema.max,
            _stops = schema.stops,
            _ranges = schema.ranges,
            _base = schema.base;

          if (_ranges) {
            return d3_merge(_ranges);
          }

          if (dataOptions.condition) {
            source = source.filter(dataOptions.condition);
          }

          switch (dataType) {
            case ORDINAL_DATATYPE:{
                return categories(source, this.schema.domain.key);
              }
            case TIME_DATATYPE:
            case NUMERIC_DATATYPE:{
                var rawExtent = extent(source, this.schema.domain.key),
                  domain = rawExtent;

                if (defined(_base)) {
                  domain = d3_extent([].concat(_toConsumableArray(domain), [_base]));
                }

                if (defined(_min)) {
                  domain[0] = _min;
                }

                if (defined(_max)) {
                  domain[domain.length - 1] = _max;
                }

                if (_stops) {
                  var copy_userStops = d3_values(_stops);
                  copy_userStops.sort(d3_ascending);
                  var filteredStops = copy_userStops.filter(function (d) {
                    var condition = true;
                    if (defined(_min)) {
                      condition = condition && d >= _min;
                    }
                    if (defined(_max)) {
                      condition = condition && d <= _max;
                    }
                    return condition;
                  });

                  if (domain[0] < filteredStops[0] || !filteredStops.length) {
                    filteredStops.splice(0, 0, domain[0]);
                  }
                  if (domain[1] > filteredStops[filteredStops.length - 1]) {
                    filteredStops.splice(filteredStops.length, 0, domain[1]);
                  }
                  return filteredStops;
                }

                return domain;
              }}

        } }, { key: "parseRange", value:

        function parseRange() {} }, { key: "getDataSchema", value:

        function getDataSchema() {
          var isCatNull = DataProcessor.helpers.isCatNull;
          var encode = this.encode,
            key = this.key,
            chartObj = this.chartObj,
            processor = chartObj.dataObject,
            parser = chartObj.dataset,
            isCatNullX = isCatNull(parser, 'x'),
            isCatNullY = isCatNull(parser, 'y', 0),
            meta = parser.getColumn(encode, key),
            zEncode = processor.encodes && processor.getEncode(encode, key), //need encodes support for hierarchy processor DEMO_PACKEDBUBBLE_7
            dataType = encode ? chartObj.dataset.getDataType(encode, key) : _dataType(meta);

          return {
            source: zEncode ? d3_merge(zEncode.seriesData.map(function (_) {return d3_merge(_.data);})) : [],
            condition: function condition(d) {return hasGeo(chartObj) ? true : !(isCatNullX(parser.getActualX(d, key)) || isCatNullY(parser.getY(d, key)));},
            meta: simpleClone(meta),
            dataType: dataType
          };
        } }]);return Scale;}();


    function _getScaleType(dataType, scaleIns, scaleType) {
      var _ranges = scaleIns.schema.domain.ranges,
        _encode = scaleIns.encode;

      switch (dataType) {
        case NUMERIC_DATATYPE:{
            if (_ranges || scaleIns.config.scaleType == QUANTILE_SCALETYPE) {
              return colorscale_helpers.quantileScale;
            }

            if (scaleType === SQRT) {
              return d3_scaleSqrt;
            }
            if (scaleType === LOG) {
              return d3_scaleSymlog;
            } else {
              return d3_scaleLinear;
            }
          }
        case ORDINAL_DATATYPE:
          if (scaleIns.config.scaleType === '_ordinal') {
            return d3_scaleOrdinalOrg;
          }

          return _encode == 'x' || _encode == 'y' ? d3_scaleOrdinal : d3_scaleOrdinalOrg;
        case TIME_DATATYPE:
          if (_ranges || scaleIns.config.scaleType == QUANTILE_SCALETYPE) {
            return colorscale_helpers.quantileScale;
          }

          return d3_scaleTime;}

    }

    function _dataType(meta) {
      var useDiscrete = meta.useDiscrete,datatype = meta.datatype;

      if (useDiscrete) {
        return ORDINAL_DATATYPE;
      }

      return datatype || ORDINAL_DATATYPE;
    }

    function toTimestamp(schema, meta) {
      var dataType = _dataType(meta),
        formatConfig = meta[dataType] || {},
        inputFormat = formatConfig.inputformat,
        regexTimeStamp = /timestamp/i,
        convert = function convert(_) {return generateDateVal(_, null, formatConfig, true).getTime();};

      if (!(inputFormat && !regexTimeStamp.test(inputFormat))) {
        return schema;
      }

      var _min = schema.min,
        _max = schema.max,
        _stops = schema.stops,
        _ranges = schema.ranges;

      if (_ranges) {
        _ranges = _ranges.map(function (range) {return range.map(convert);});
      }

      if (_stops) {
        _stops = _stops.map(convert);
      }

      if (defined(_min)) {
        _min = convert(_min);
      }

      if (defined(_max)) {
        _max = convert(_max);
      }

      return _objectSpread(_objectSpread({}, schema), {}, { ranges: _ranges, stops: _stops, min: _min, max: _max });
    }

    function hasGeo(chartObj) {
      // TODO  change chartObj.dataObject.isFlowChartCategory
      return chartObj.isGeoMap || chartObj.mapObj || chartObj.dataObject.isFlowChartCategory;
    }

    ScaleRegistry.add('Scale', Scale);

    var LegendRegistry = {
      add: function add(component) {
        var encode = component.encode,view = component.view;
        Registry.setComponent(_key$1(encode, view), component);
      },
      get: function get(encode, view) {return Registry.getComponent(_key$1(encode, view));}
    };

    function _key$1(encode, view) {
      return "legend-".concat(encode, "-").concat(view);
    }

    //

    function extendScaleParser(defaultParser, customParser) {
      if (isFunction(customParser) || typeof customParser === 'string' && isFunction(getPropVal(window, customParser))) {
        return invokeFunction(customParser, defaultParser);
      }

      if (customParser.extend) {
        defaultParser = mergeJSON$1(defaultParser, customParser, true, true);
      } else {
        if (customParser.domain) {
          if (customParser.domain.extend) {
            defaultParser.domain = mergeJSON$1(defaultParser.domain, customParser.domain, true, false);
          } else {
            defaultParser.domain = customParser.domain;
          }
        }
        if (customParser.range) {
          if (customParser.range.extend) {
            defaultParser.range = mergeJSON$1(defaultParser.range, customParser.range, true, false);
          } else {
            defaultParser.range = customParser.range;
          }
        }
      }
      return defaultParser;
    }

    //
    var
    BaseView = /*#__PURE__*/function () {
      function BaseView(spec) {_classCallCheck(this, BaseView);
        this.spec = spec;
      }_createClass(BaseView, [{ key: "draw", value:

        function draw(element) {
          var markParser = this.encode;
          if (!markParser) {
            return;
          }

          var customParser = this.spec.parser;
          if (customParser) {
            markParser = extendScaleParser(markParser, customParser);
          }

          this.element = element;
          renderDom(markParser, element);
        } }, { key: "create", value:

        function create() {
          var parser = this.constructor.parser;
          if (parser) {
            return this.encode = parser(this.spec);
          }
        } }]);return BaseView;}();


    //nonLinearOrdinalScale.js

    var nonLinearOrdinalScale = function nonLinearOrdinalScale() {
      var range, domain, rangeBands, rangeExtent, ranges, rangeBand;

      function scale(x) {
        if (range) {
          return range.get(x);
        }
        return null;
      }

      scale.domain = function (_) {
        if (!arguments.length) {
          return domain;
        }
        domain = _;
        return scale;
      };

      scale.rangeBand = function (_) {
        if (!arguments.length) {
          return 0; //Dummy rangeband for proper tickTransform and tickExit in d3.v3
        }
        rangeBand = _;
        return scale;
      };

      scale.bandwidth = function (x) {
        if (!rangeBands) {
          return null;
        }
        if (arguments.length) {
          return rangeBands.get(x);
        }
        return rangeBand;
      };

      scale.rangeBands = function (x) {
        if (!arguments.length) {
          return rangeBands;
        }
        if (x == null) {
          return scale;
        }
        ranges = x;
        rangeBands = new d3_map();
        range = new d3_map();
        var i = -1,
          n = x.length;
        while (++i < n) {
          range.set(i, x[i][0]);
          rangeBands.set(i, x[i][1] - x[i][0]);
        }
        return scale;
      };

      scale.discreteWidth = function (x) {
        if (!rangeBands) {
          return null;
        }
        return rangeBands.get(x);
      };

      scale.range = function (_) {
        if (!arguments.length) {
          return rangeExtent;
        }
        rangeExtent = _;
        return scale;
      };

      scale.copy = function () {
        return nonLinearOrdinalScale().
        domain(domain).
        rangeBands(ranges).
        range(rangeExtent);
      };

      return scale;
    };

    /*
    Array list
     */

    function ArrayList() {
      this.list = d3_map();
      this.list1 = d3_map();
      this.count = 0;
    }
    /*
    @param key - Key to be be added to map
    @param value - its optional. By default automatic counter will be used
     */
    ArrayList.prototype.add = function (key, value) {
      var store = pick(value, this.count);
      if (!this.list.has(key)) {
        this.list1.set(store, key);
        this.list.set(key, [store, this.count++]);
      }
    };

    /*
    @param key - used to get the value stored in the list
     */
    ArrayList.prototype.get = function (key) {
      return this.list1.get(key);
    };

    /*
    Used to get the position of the item stored in list
    @param key - item to get position
    @param relative - its optional used to get the value based on the counter
     */
    ArrayList.prototype.indexOf = function (key, relative) {
      var value = this.list.get(key);
      if (value) {
        return relative ? value[1] : value[0];
      }
    };

    ArrayList.prototype.values = function () {
      return this.list.keys();
    };

    function bisectArray(value, array, comparator, end, validator) {
      var insertIdx,
        bisector = d3_bisector(comparator),
        bisect = bisector.left(array, value, 0, end);

      if (validator == '>') {
        insertIdx = bisect > 0 ? array[bisect] > value ? bisect - 1 : bisect : bisect;
      } else if (validator == '<') {
        insertIdx = bisect > 0 ? array[bisect] < value ? bisect - 1 : bisect : bisect;
      } else {
        insertIdx = bisect > 0 ? value > array[bisect - 1] ? bisect - 1 : bisect : bisect;
      }

      return insertIdx;
    }

    //$Id$

    colorscale_helpers.quantileScale = function () {
      var domain = [],
        range = [],
        quantiles = [];

      function scale(x) {
        var index;
        quantiles.forEach(function (d, i) {
          if (x >= d[0] && x <= d[1]) {
            index = i;
          }
        });
        return defined(index) ? range[index] : null;
      }

      scale.domain = function (_) {
        if (arguments.length) {
          domain = _;
          quantiles = [];
          for (var i = 0; i < domain.length; i += 2) {
            quantiles.push([domain[i], domain[i + 1]]);
          }
          return scale;
        }
        return domain;
      };

      scale.range = function (_) {
        if (arguments.length) {
          range = _;
          return scale;
        }
        return range;
      };

      scale.copy = function () {
        return colorscale_helpers.
        quantileScale().
        domain(domain).
        range(range);
      };
      return scale;
    };

    function applyCorrection(operators, _scale) {
      var corrections = evalCorrection(operators, _scale);
      operators.plotBound[1] = operators.plotBound[1] + corrections[0];
    }

    function expressionEvalRangeForLinear(operators) {
      this.d3_scale.origRange = operators.plotBound;
      applyCorrection(operators, this);
      return operators.plotBound;
    }

    ScaleRegistry.add('axis.evalLinearRange', expressionEvalRangeForLinear);

    //$Id$

    function get_threshold_text_orient(orient) {
      return /(left|right)/.test(orient) ? 'bottom' : 'left';
    }

    function overrideThresholdFonts(systemConf, userOptions) {
      for (var attr in userOptions) {
        if (userOptions.hasOwnProperty(attr)) {
          systemConf[attr] = userOptions[attr];
        }
      }

      return systemConf;
    }

    /**
     *
     * @param config
     * @return {Array}
     */
    function getThresholdValues(config) {
      var values = [];
      if (defined(config.threshold)) {
        each(config.threshold, function (threshold) {
          if (threshold.show === true && threshold.values.length) {
            values = values.concat(threshold.values);
          }
        });
      }
      return values;
    }

    //$Id$

    var X_SHOWAS = 'x',
      Y_SHOWAS = 'y',
      Z_SHOWAS = 'z',
      GEO_SHOWAS = 'geo',
      PER_SHOWAS = 'per',
      SPLITPER_SHOWAS = 'splitper',
      MAXPER_SHOWAS = 'maxper',
      PERCENT_SHOWAS = 'percent',
      SPLITPERCENT_SHOWAS = 'splitpercent',
      MAXPERCENT_SHOWAS = 'maxpercent';

    var LABELTYPES_AVAILABLE = d3_set([X_SHOWAS, Y_SHOWAS, Z_SHOWAS, GEO_SHOWAS, PER_SHOWAS, SPLITPER_SHOWAS, MAXPER_SHOWAS, PERCENT_SHOWAS, SPLITPERCENT_SHOWAS, MAXPERCENT_SHOWAS]);

    //$Id$

    function getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index, paneid) {
      var options =
      plotoptions && plotoptions.datalabels ?
      mergeJSON$1(commonPlotOptions.datalabels, plotoptions.datalabels, true) :
      commonPlotOptions.datalabels;
      if (chartObj && chartObj.viewFlow && chartObj.viewFlow.marks._default.label.length) {
        var marks_plot = chartObj.viewFlow.marks._default.label[index],
          markLabelOptions;
        markLabelOptions = marks_plot.spec;
        options = markLabelOptions ? mergeJSON$1(markLabelOptions, options, true) : options;
      }
      if (chartObj) {
        overrideDatalabelShowAs(options, chartObj, index, paneid);
      }

      return options;
    }

    function applyDatalabelFonts(labelseries, dataLabels, chartObj, seriesColor, inner, seriesIndex, isStackLabel) {
      var systemconf = chartObj.systemConf;

      if (isArray$1(seriesColor) && defined(seriesIndex)) {
        seriesColor = seriesColor[seriesIndex];
      }

      var _fontColor = getLabelFontColor(systemconf, seriesColor, dataLabels, chartObj, inner, seriesIndex, isStackLabel, 'fontColor'),
        _strokeColor = getLabelFontColor(systemconf, seriesColor, dataLabels, chartObj, inner, seriesIndex, isStackLabel, 'strokeColor');

      return applyFont(labelseries, [
      { fontColor: _fontColor, strokeColor: _strokeColor }, // Series color
      dataLabels,
      systemconf.chart.plot.datalabels,
      systemconf.chart,
      systemconf.canvas,
      $ZCG]);

    }
    Registry.setComponent('dataLabel.applyFont', applyDatalabelFonts);

    function applyTextShadow4Firefox(stroke) {var strokeWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;var textShadow = arguments.length > 2 ? arguments[2] : undefined;
      if (!($Browser.FIREFOX && textShadow && strokeWidth)) {
        return;
      }

      // ZC2858
      if (stroke === TRANSPARENT) {
        return { stroke: null };
      }

      return {
        stroke: null,
        'text-shadow': strokeInShadow(stroke, strokeWidth, textShadow)
      };
    }

    function strokeInShadow(color, size, shadow) {
      size = parseInt(size / 2);
      var p = shadow.split(/ (?![^(]*\))/),
        ts = "".concat(parseFloat(p[0]) + size, "px ").concat(parseFloat(p[1]) + size, "px ").concat(p[2], " ").concat(p[3] || 'black');

      return "".concat(-size, "px ").concat(-size, "px 0 ").concat(color, ", ").concat(size, "px ").concat(-size, "px 0 ").concat(color, ", ").concat(-size, "px ").concat(size, "px 0 ").concat(color, ", ").concat(size, "px ").concat(size, "px 0 ").concat(color, ", ").concat(ts);
    }

    function getLabelFontColor(
    systemconf,
    seriesColor,
    config,
    chartObj,
    inner,
    seriesIndex,
    isStackLabel)


    {var styleName = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'fontColor';var paneid = arguments.length > 8 ? arguments[8] : undefined;
      /**
       * @param inner is boolean, means function being call from inner-label
       */

      var fontColor = config[styleName];
      if (typeof fontColor === 'function') {
        var userColor = invokeFunction(fontColor, seriesColor, chartObj);
        if (defined(userColor)) {
          return userColor;
        }
      }

      var globalConfig = getPropVal(chartObj.systemConf, 'chart.plot.datalabels') || {},
        mapLabelOptions = getPropVal(chartObj.systemConf, 'map.labels') || {},
        dataLabelColor = chartObj.isGeoMap ? pick(globalConfig[styleName], mapLabelOptions[styleName]) : globalConfig[styleName],
        chart = getChartTypeByIndex(chartObj, paneid, seriesIndex || 0),
        chartNumber = chart.value,
        imagePalletUsed = defined(systemconf.legend.imagePallete),
        color,
        isStackedBar = isBarChartType(chartNumber) && chartObj.dataObject.isstacked(chartNumber) && isStackLabel !== true,
        sankeyInsideLabel = chart.name === SANKEY_CHARTNAME && config.labelPos === 'inside',
        boundBoxColor;

      if (isBoundBoxEnabled(config, chartObj)) {
        //get the boundBox color
        var boundboxOptions = getMergedBoundBoxOptions(config, chartObj);
        boundBoxColor = boundboxOptions.fillColor || seriesColor;
      } else if (sankeyInsideLabel) {
        var nodeOptions = systemconf.chart.plot.plotoptions.sankey.node;
        seriesColor = pick(nodeOptions.fillColor, seriesColor);
      }

      // for constant color
      if (styleName === 'fontColor' && fontColor === UNDEFINED && dataLabelColor === UNDEFINED) {
        if (boundBoxColor && boundBoxColor !== TRANSPARENT) {
          return getContrastColor(boundBoxColor); //#ZC1232
        } else if (inner && imagePalletUsed) {
          return '#444444'; // always returns default color
        } else if (
        inner && chartcategory.innerLabels.indexOf(chartNumber) > -1 ||
        isStackedBar ||
        sankeyInsideLabel ||
        chartcategory.datalabelsInside.indexOf(chartNumber) > -1)
        {
          return getContrastColor(seriesColor);
        }
      }

      color = !imagePalletUsed && (!defined(fontColor) && dataLabelColor === null || fontColor === null) ? seriesColor : fontColor;
      return color || pick(dataLabelColor, systemconf.chart[styleName], systemconf.canvas[styleName], $ZCG[styleName]);
    }

    function isLabelWithinBound(labelbound, plotbound) {
      return !(labelbound.x1 < plotbound.x1 || labelbound.y1 < plotbound.y1 || labelbound.x2 > plotbound.x2 || labelbound.y2 > plotbound.y2);
    }

    function isDatalabelEnabled(dataLabels, chartObj) {
      if (datacount_based_intelligence(chartObj, DATALABELS_LABELTYPE)) {
        var dataSplicer = chartObj.dataSplicer,
          metadata_axes = dataSplicer.getEncode(),
          labelMeta = metadata_axes.label;
        return (
          labelMeta && defined(labelMeta[0]) ||
          getValByPriority([dataLabels, chartObj.systemConf.chart.plot.datalabels], 'show') === true);

      }
      return false;
    }
    Registry.setComponent('dataLabel.isDatalabelEnabled', isDatalabelEnabled);

    function isStacklabelEnabled(stackLabels, chartObj) {
      return (
        chartObj.dataObject.noofBarEnabledSeries &&
        chartObj.dataObject.isstacked() &&
        !chartObj.dataObject.isStackedPercentChart &&
        stackLabels &&
        stackLabels.show);

    }

    function callTrimText(labelText, chartObj, tranform, fontSize, edge, xy) {
      var dx = +tranform[0],
        dy = +tranform[1],
        plotarea = chartObj.plotarea,
        margin = {
          left: -fontSize,
          right: -fontSize,
          top: 0,
          bottom: 0
        },
        pattern = '..',
        orient = BOTTOM_ALIGN;

      edge = edge || {
        left: -dx,
        top: -dy,
        right: plotarea.width - dx,
        bottom: plotarea.height - dy
      };
      labelText.each(function () {
        var bb = bbox(this);
        var textBound = {
          left: bb.x + (xy ? xy[0] : 0),
          top: bb.y + (xy ? xy[1] : 0),
          width: bb.width,
          height: bb.height
        };
        trimText(this, this.textContent, textBound, edge, orient, pattern, margin);
      });
    }

    function overrideDatalabelShowAs(options, chartObj, index, paneid) {
      /* If defaulttheme.showAs ='y' && userdata.showAs = ['<tspan>{{val(0)}}</tspan>', '<tspan style="fill:red">{{val(1)}}</tspan>'], merged sysconf will have "y" only.
       * The following will update the userdata's showAs if presents.
       */
      var cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
        chartName = cType_Obj.name;
      var userDatalabels = isObjectPropDefined(chartObj.userdata, "chart.plot.plotoptions.".concat(chartName, ".datalabels"), true) || {},
        userSeriesSpecificDatalabels =
        isObjectPropDefined(chartObj.seriesdata[index] || chartObj.seriesdata[0], 'plotoptions.datalabels', true) || {},
        userInnerLabel,
        userParentLabel,
        userStackLabel,
        systemConfInnerLabel,
        systemConfParentLabel,
        systemConfStackLabel;

      if (userSeriesSpecificDatalabels.showAs || userDatalabels.showAs) {
        //#ZC1663
        options.showAs = userSeriesSpecificDatalabels.showAs || userDatalabels.showAs || options.showAs;
      }

      if (userInnerLabel = userDatalabels.innerLabel) {
        systemConfInnerLabel = options.innerLabel;
        systemConfInnerLabel.showAs = userInnerLabel.showAs || systemConfInnerLabel.showAs;

        if (userParentLabel = userInnerLabel.parentLabel) {
          systemConfParentLabel = options.innerLabel.parentLabel;
          systemConfParentLabel.showAs = userParentLabel.showAs || systemConfParentLabel.showAs;
        }
      } else if (userStackLabel = userDatalabels.stackLabels) {
        systemConfStackLabel = options.stackLabels;
        systemConfStackLabel.showAs = userStackLabel.showAs || systemConfStackLabel.showAs;
      }
    }

    function getLabelHolder(chartObj) {
      return chartObj.staticPaneSVG.select('.labelholder');
    }

    function getLabelArray(rp, paneid, subIndex) {
      var labelArray = rp.labelArray,
        key = "".concat(paneid || 0);

      if (key.indexOf('_') === -1) {
        key = '0';
      } else if (defined(subIndex)) {
        key += "(".concat(subIndex, ")");
      }

      labelArray[key] = labelArray[key] || [];
      return labelArray[key];
    }

    //stack-grouping.js

    /**
     * [getStackGroupIndex description]
     * @param  {Array} array    stackGroup
     * @param  {Number} index    seriesIndex
     * @param  {Function} accessor [description]
     * @return {Number}          [description]
     */
    function getStackGroupIndex(array, index, accessor) {
      if (!array) {
        return 0;
      }

      return d3_max(array, function (d, j) {
        var value = accessor ? accessor(d, j) : d;
        return arrayIncludes(value, index) ? j : 0;
      });
    }

    function getSeriesIndex4StackLabel(encode) {
      return encode.seriesIndices[encode.seriesIndices.length - 1];
    }

    function hasFixedDatalabels(chartObj) {
      if (!chartObj.dataObject.noofBarEnabledSeries) {
        return;
      }

      var vAlign;
      chartObj.seriesdata.some(function (series, seriesIndex) {
        return (vAlign = getValignforBarLabels(chartObj, seriesIndex, DATALABELS_LABELTYPE)) === FIXEDTOP_ALIGN;
      });

      if (vAlign === FIXEDTOP_ALIGN) {
        return true;
      }

      var stackEncode = chartObj.dataObject.getEncode('stack');
      Object.keys(stackEncode).some(function (d) {
        var encode = chartObj.dataObject.getEncode('stack', d);

        if (!encode) {
          return;
        }

        var stackLabelIndex = getSeriesIndex4StackLabel(encode);
        return (vAlign = getValignforBarLabels(chartObj, stackLabelIndex, STACKLABELS_LABELTYPE)) === FIXEDTOP_ALIGN;
      });
      return vAlign === FIXEDTOP_ALIGN;
    }

    function getValignforBarLabels(chartObj, seriesIndex, labelType) {
      if (!chartObj.dataObject.noofBarEnabledSeries) {
        return;
      }

      var isStackedLabels = labelType === STACKLABELS_LABELTYPE,
        ctype_obj = chartObj.chartTypes[seriesIndex] || chartObj.chartTypes[0], //Hack for pivot cluster chart
        seriesdata = chartObj.seriesdata[seriesIndex] || chartObj.seriesdata[0], //Hack for pivot cluster chart
        commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[ctype_obj.name],
        options = getMergedDatalabelOptions(
        commonPlotOptions,
        isStackedLabels ? NULL$1 : seriesdata.plotoptions,
        chartObj,
        seriesIndex);


      if (isStackedLabels) {
        options = options.stackLabels || {};
      }

      var dataObj = chartObj.dataObject,
        axisrotated = chartObj.axes.rotated,
        stacked = dataObj.isstacked(),
        labelPos = options.labelPos || TOP_ALIGN,
        textDirection = options.textDirection,
        showlabel = isStackedLabels ? isStacklabelEnabled(options, chartObj) : isDatalabelEnabled(options, chartObj);

      if (showlabel) {
        textDirection = !textDirection || stacked && !isStackedLabels ? axisrotated ? VERTICAL_ALIGN : HORIZONTAL_ALIGN : textDirection;
        if (labelType === DATALABELS_LABELTYPE && labelPos === FIXEDTOP_ALIGN) {
          if (stacked || axisrotated && textDirection !== VERTICAL_ALIGN || !axisrotated && textDirection === VERTICAL_ALIGN) {
            labelPos = TOP_ALIGN;
          }
        }
        return labelPos;
      }
    }

    //$Id$

    ALLOWED_OPERATORS.set('bubbleBound', function () {
      return convertOperatorToBoundAndAddDomain.call.apply(convertOperatorToBoundAndAddDomain, [this].concat(Array.prototype.slice.call(arguments), ['marker']));
    });
    ALLOWED_OPERATORS.set('markerBound', function () {
      return 0;
    });
    ALLOWED_OPERATORS.set('labelBound', function () {
      return convertOperatorToBoundAndAddDomain.call.apply(convertOperatorToBoundAndAddDomain, [this].concat(Array.prototype.slice.call(arguments), ['label']));
    });

    function convertOperatorToBoundAndAddDomain() {
      if (!arguments[0].length) {
        return [0, 0];
      }

      var _scale = this,
        mode = arguments[arguments.length - 1],
        bound = convertOperatorToBound.call.apply(convertOperatorToBound, [_scale].concat(Array.prototype.slice.call(arguments))),
        dop = _scale.config.domain.operators || {},
        _chart = _scale.chartObj,
        cached = _chart.cache.correction,
        dataSet = _chart.dataset,
        c = evalCorrection(
        { _correction: bound, domainOperators: mode === 'label' ? { hasDefaultMin: dop.hasDefaultMin } : null },
        _scale).
        slice(0);

      if (mode === 'label') {
        if (!(!_scale.config.domain.hasDefaultMin && !_chart.datalabels.hasFixedPosition)) {
          c[0] = 0;
        }
        if (_scale.schema.data.meta.scaleType === 'log' && !hasFixedDatalabels(_chart)) {
          c[0] = c[1] = 0;
        }
      }
      cached.domainCorrection = cached.domainCorrection || {};

      if (this.config.type === 'ordinal') {
        return c;
      } else {
        var cachedDomainCorrection = cached.domainCorrection["".concat(mode, "-").concat(_scale.id)],
          plotHeight = _chart.plotarea.height,
          corrections =
          cachedDomainCorrection && cached.domainCorrection.measure === plotHeight ?
          cachedDomainCorrection :
          mapCorrectionToDomain(c, _scale, mode);
        cached.domainCorrection["".concat(mode, "-").concat(_scale.id)] = corrections;
        cached.domainCorrection.measure = plotHeight;

        if (mode === 'label') {
          // CXZA_MULTIY_4
          var s = _scale.id.split('-');
          if (dataSet.getColumn(s[0], +s[1]).datatype == 'time' && dataSet.getColumn('x', 0).datatype !== 'ordinal') {
            var duplicateKey = 'label-x-0';
            cached[duplicateKey] = cached["label-".concat(_scale.id)];
            cached.domainCorrection[duplicateKey] = corrections;
          }
        }

        if (corrections[0]) {
          _scale.config.extremes[0] -= corrections[0];
        }
        if (corrections[1]) {
          _scale.config.extremes[1] += corrections[1];
        }

        return corrections;
      }
    }

    function modifyCorrectionOperator(mode, operator, domainOperators) {
      if (!_modularized.scaleCorrection) {
        if (mode !== 'marker') {
          domainOperators["".concat(mode, "Bound")] = operator;
        }
      }
    }

    function bubbleCorrection(scale, bound, _scale) {
      if (_scale.config.type !== 'ordinal') {
        return;
      }

      var _tempRange = scale.range(),
        correction = d3_max([_tempRange[0] - bound[0], bound[1] - _tempRange[1], 0]) * 0.5,
        bubbleBound = [bound[0] - correction, bound[1] + correction],
        maxCorrection = d3_max([bubbleBound[1] - _tempRange[1], -bubbleBound[0], 0]);
      return [maxCorrection, maxCorrection];
    }

    function labelCorrection(_scale, bound) {
      if (_scale.config.type !== 'ordinal') {
        return bound || 0;
      }

      var _parser = _scale.config,
        domain = _parser.domain,
        padding = _parser.padding,
        _tempRange = d3_extent(_parser.tempRange);

      var d3_outerPadding = scale.getOuterPadding(_tempRange, _parser.domain.length, _parser.padding, _parser.outerPadding);
      var scaleObj = d3_scaleOrdinal().
      domain(domain).
      range(_tempRange).
      paddingInner(padding).
      paddingOuter(d3_outerPadding);

      var pad = scaleObj(scaleObj.domain()[0]) - scaleObj.range()[0];
      var correction = bound || 0;
      correction = mathMax(0, correction - pad);
      var textBound = [_tempRange[0] - correction, _tempRange[1] + correction];
      var paddingouter = mathMax(textBound[1] - _tempRange[1], -textBound[0]);
      return paddingouter;
    }

    function changeOuterPadding(operators) {
      var _operators$labelBound = operators.labelBound,labelBound = _operators$labelBound === void 0 ? [0] : _operators$labelBound,_operators$bubbleBoun = operators.bubbleBound,bubbleBound = _operators$bubbleBoun === void 0 ? [0] : _operators$bubbleBoun;
      return d3_max(labelBound) || d3_max(bubbleBound) || 0;
    }

    function _mapCorrectionToDomain(correction, _scale, mode) {
      var _parser = _scale.config,
        domain = _parser.extremes,
        _plotarea = _scale.config.range.operators.plotBound.plotSize,
        _scaleType = _scale.config.scaleType,
        scaleObj = getD3Scale(_scaleType)().domain(domain);

      var _chart = _scale.chartObj,
        _encodeType_duplicate = _scale.datatype == 'time' ? 'x' : _scale.encode, //HARDCODED TYPE,
        orient = _parser.orient || _chart.axes[_encodeType_duplicate].orient, //Unit testcases and HARDCODED ORIENT,
        range = [
        0,
        _scale.config.dataType == 'time' && mode === 'marker' ?
        _plotarea[_parser.range.operators.plotBound.dimension] :
        _plotarea[orient == 'left' ? 'height' : 'width']],

        rangeDiff = range[1] - range[0],
        scaleType = _scale.config.scaleType;
      if (mode === 'label' && scaleType !== 'log') {
        // CXZA_MULTIY_4
        var domainDiff = domain[1] - domain[0];
        return correction.map(function (_) {return domainDiff / (rangeDiff - _) * _;});
      } else {
        return correction.map(function (_, i) {
          var _range = mode === 'marker' ? [0, rangeDiff] : i === 0 ? [_, rangeDiff] : [0, rangeDiff - _];
          scaleObj.range(_range);
          var c =
          scaleType === 'log' ?
          i === 0 ?
          scaleObj.invert(_range[0]) - scaleObj.invert(_range[0] - _) :
          scaleObj.invert(_range[1] + _) - scaleObj.invert(_range[1]) :
          i === 0 ?
          scaleObj.invert(_) - scaleObj.invert(0) :
          scaleObj.invert(rangeDiff) - scaleObj.invert(rangeDiff - _);
          return c || 0;
        });
      }
    }

    //

    // TODO: Remove 'mode' argument at end of Code modularization
    function mapCorrectionToDomain(correction, _scale, mode) {
      if (!_modularized.scaleCorrection) {
        return _mapCorrectionToDomain(correction, _scale, mode);
      } else {
        var _parser = _scale.config,
          domain = _parser.extremes,
          _plotarea = _scale.config.range.operators.plotBound.plotSize,
          _scaleType = isObjectPropDefined(_scale, 'schema.data.meta.scaleType', true),
          scaleObj = getD3Scale(_scaleType)().domain(domain),
          range = [0, _plotarea[_parser.range.operators.plotBound.dimension]];

        return correction.map(function (_, i) {
          scaleObj.range(i === 0 ? [_, range[1]] : [0, range[1] - _]);
          var c = i === 0 ? scaleObj.invert(_) - scaleObj.invert(0) : scaleObj.invert(range[1]) - scaleObj.invert(range[1] - _);
          return c || 0; // FEATURESEVENTS_BAR_22 while legend filter the domain will be ['NoData', 'NoData']
        });
      }
    }

    //$Id$

    function expressionEvalDomainForLinear(operators) {
      var extremes = operators.extremes,
        min = operators.min,
        max = operators.max,
        plotBound = operators.plotBound,
        baseline = operators.baseline;

      if (operators.categories) {
        return operators.categories;
      }

      if (operators.ranges) {
        return operators.ranges;
      }

      if (operators.stops) {
        return operators.stops;
      }

      applyCorrection$1(operators, this);

      //TODO case hardcoded for x and y
      this.d3_scale.originalDomain =
      this.config.dataType == 'numeric' && this.encode == 'y' ? this.config.extremes : this.config.originalDomain;

      this.d3_scale.originalDomain = this.d3_scale.originalDomain || operators.correctionFactor1 || this.config.extremes;
      // this.d3_scale.originalDomain = operators.correctionFactor1 || this.config.extremes; //now applied in correction factor
      this.d3_scale.outerPadding = this.config.outerPadding;

      // this.d3_scale.actualRange//FEATURES_LOGAXIS_15
      this.d3_scale.correction = this.config.domain.outerPaddingCorrection;

      if (this.config.dataType == 'time') {
        convertToDate.call(this);
        this.d3_scale.correction = this.config.domain.outerPaddingCorrection;
      }

      return this.config.extremes;
    }

    function convertToDate() {
      var dateValues = this.d3_scale.originalDomain.map(function (d) {
        return new Date(d);
      });
      this.d3_scale.originalDomain = dateValues;
    }

    function applyCorrection$1(operators, _scale) {
      var corrections = mapCorrectionToDomain(evalCorrection(operators, _scale), _scale);
      // FEATURESEVENTS_BAR_22 while legend filter the domain will be ['NoData', 'NoData']. corrections will be [0,0]
      if (corrections[0]) {
        // _scale.config.extremes[0] -= corrections[0];
        var a = mathMax(corrections[0] - (operators.extremes[0] - _scale.config.extremes[0]), 0);
        _scale.config.extremes[0] -= a;
      }
      if (corrections[1]) {
        // _scale.config.extremes[1] += corrections[1];
        var b = mathMax(corrections[1] - (_scale.config.extremes[1] - operators.extremes[1]), 0);
        _scale.config.extremes[1] += b;
      }
    }

    ScaleRegistry.add('axis.evalLinearDomain', expressionEvalDomainForLinear);

    /**
     *
     * @param index
     * @param correctionFactor
     * @returns {*}
     */
    // import { getMethodFromInstance } from "../../utils/instance-utils";

    DataProcessor.prototype.getMinMaxY = function () {var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var correctionFactor = arguments.length > 1 ? arguments[1] : undefined;var excludeDatalabels = arguments.length > 2 ? arguments[2] : undefined;var applyZoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var systemconf = this.chartObj.systemConf,
        columnInfo = this.dataset.getColumn('y', index),
        rangeOperators = {};
      var orient = getAxisOrient('y', this.chartObj.axes.rotated);
      rangeOperators.plotBound = {
        dimension: orient == BOTTOM_ALIGN || orient == TOP_ALIGN ? 'width' : 'height',
        customPlotBound: this.chartObj.systemConf.chart,
        plotSize: this.chartObj.plotarea,
        defaultPlotSize: this.chartObj.plotarea,
        color: this.chartObj.imagePallete || this.chartObj.seriesColor,
        boundExtreme: 0
      };
      var domainOperators = numericAxisParser('y', index, this.chartObj, correctionFactor, excludeDatalabels, applyZoom, true); //needOnlyExtremes apply for time datatype Y axis
      var parser = {
        type: 'numeric',
        field: columnInfo,
        scaleType: columnInfo.scaleType,
        reverse: pick(this.yaxesData[index], {}).reversed,
        data: [],
        domain: {
          operators: domainOperators,
          evaluator: expressionEvalDomainForLinear
        },
        range: {
          operators: rangeOperators,
          evaluator: expressionEvalRangeForLinear
        }
      };
      if (this.chartObj.viewFlow && this.chartObj.viewFlow.scales[columnInfo.id]) {
        extendScaleParser(parser, this.chartObj.viewFlow.scales[columnInfo.id].conf);
      }
      // if (systemconf.viewParser) {
      //     if (systemconf.viewParser.scale && systemconf.viewParser.scale[columnInfo.name]) {
      //         extendScaleParser(parser, systemconf.viewParser.scale[columnInfo.name]);
      //     }
      // }
      var newScale = new Scale('y', index, parser, this.chartObj);
      var domain = newScale._parseDomain();
      if (!this.yRange[index]) {
        this.yRange[index] = newScale.config.tempDomain;
      }
      this.hasNegativeValue[index] = newScale.config.hasNegativeValue && newScale.config.hasNegativeValue[index];
      return domain;

      /*
      SCALE PARSER
       */
      var processor = this,
        yAxisConfig = processor.yaxesData,
        hasNegativeValue = processor.hasNegativeValue,
        baseline = processor.baseline,
        yRange = processor.yRange,
        chart = processor.chartObj,
        dataSet = processor.dataset,
        stacked = processor.isstacked() || processor.isPercentChart,
        yAxisData = pick(yAxisConfig[index], {}),
        dataType = dataSet.getDataType('y', index),
        columnInfo = dataSet.getColumn('y', index),
        minY = yAxisData.minRange,
        maxY = yAxisData.maxRange,
        correction = 0,
        yEncode = processor.getEncode('y', index),
        axisObj = getAxisObject(chart, 'y', index);

      if (!yEncode) {
        return ['NoData', 'NoData'];
      }

      if (columnInfo.scaleType === LOG) {
        correctionFactor = 0;
        if (defined(axisObj.logDomain)) {
          // save baseline
          processor.saveBaseLine(index, axisObj.logDomain, minY);
          return axisObj.logDomain;
        }
      }

      // var filterFactors = ["zoom"],
      //     rawFactors = ["userdata", "threshold", "levelMarker"],
      //     correctionFactors = ["bubble", "marker", "datalabels"];
      //
      // // Filters
      // filterFactors
      // .some(factor => {
      //     var filteredExtent = getMethodFromInstance(processor, factor)("y", index);
      //
      //     if (filteredExtent) {
      //         return filteredExtent;
      //     }
      // });
      //
      // // Raw data
      // var cache;
      // if (!cache) {
      //     var rawExtent = rawFactors
      //         .map(factor => {
      //             var extent = getMethodFromInstance(processor, factor)("y", index) || [];
      //             return extent;
      //         });
      //
      //     cache = d3_extent(d3_merge(rawExtent));
      // }
      //
      // //Corrections
      // var finalExtent = [];
      // correctionFactors
      // .forEach(factor => {
      //     var correction = getMethodFromInstance(processor, factor)("y", index) || 0;
      //     finalExtent[0] -= correction / 2;
      //     finalExtent[1] += correction / 2;
      // });

      // [**MIGRATION**] zoom --> brush
      // #ZC2016 $index
      if (isObjectPropDefined(chart.systemConf, "chart.brush.y[".concat(index, "]")) && applyZoom) {
        var zoomedY = chart.systemConf.chart.brush.y[index],
          zoomedExtent = [zoomedY.minRange, zoomedY.maxRange];

        processor.saveBaseLine(index, zoomedExtent, null, true);
        return zoomedExtent;
      }

      correctionFactor = pick(correctionFactor, chart.datalabels.hasFixedPosition ? 0.00000001 : 0.05);
      baseline[index] = getPropVal(yAxisData, 'baseline.show') === true ? yAxisData.baseline.value : null;

      if (!yRange[index]) {
        // save the min and max of y at yRange
        var temp;

        if (processor.isWaterfallEnabled) {
          temp = processor.processDataForWaterFall(index);
        } else if (stacked) {
          temp = _updateMinMaxforStackedData(processor, index);
        } else {
          temp = updateminMax(index, processor);
        }

        if (temp) {
          var yAxis = pick(getPropVal(chart.userdata, "chart.axes.yaxis[".concat(index, "]")), {}),
            thresholdData = getThresholdValues(yAxis),
            levelMarkerData = DataProcessor.helpers.hasLevelMarkerData(processor, index) ? processor.overLevelMarker(index) : [];

          temp = temp.concat(thresholdData, levelMarkerData);
          temp = d3_extent(temp);
        }

        yRange[index] = temp;
      }

      var extentY = yRange[index];
      if (isUndefined(extentY)) {
        return ['NoData', 'NoData'];
      }

      processor.saveBaseLine(index, extentY, minY);
      var hasDefaultBase = dataType == NUMERIC_DATATYPE && _hasDefaultBase(yEncode, processor, chart),
        hasDefaultMin = hasDefaultBase && (hasNegativeValue[index] != null ? hasNegativeValue[index] > 0 : true);

      //If extentY = [undefined, undefined], don't change the extent with '0'
      if (hasDefaultBase && extentY[1] - extentY[0] === 0) {
        extentY = d3_extent(d3_merge([extentY, [0]])); // Test_511.json & Test_512.json
      }

      if (processor.isBubbleEnabled && dataType !== TIME_DATATYPE && isUndefined(yAxisData.minRange) && isUndefined(yAxisData.maxRange)) {
        //if 'hasDefaultMin' is present, apply that. so that we can adjust the bubbles within range.
        extentY[0] = hasDefaultMin ? 0 : extentY[0];

        temp = processor.overBubbles(extentY, 'y', index);
        extentY = [extentY[0] - temp[0], extentY[1] + temp[1]];
      }

      if (DataProcessor.helpers.hasMarkerCorrection() && dataType !== TIME_DATATYPE) {
        temp = processor.overMarker(extentY, 'y', index, correctionFactor);
        extentY = [hasDefaultMin ? 0 : extentY[0] - temp[0], extentY[1] + temp[1]];
      }

      var diff = extentY[1] - extentY[0];

      if (diff === 0) {
        diff = 1;
      }

      if (!(processor.isPercentChart || processor.hasLevelMarker || processor.isWaterfallEnabled)) {
        correction = diff * correctionFactor;
      }

      if (isUndefined(minY)) {
        minY = hasDefaultMin ? 0 : extentY[0] - correction;
      }

      if (isUndefined(maxY)) {
        maxY = extentY[1] + correction;
      }

      var correctionOverDatalabels = 0;

      // no need to find correction datalabel,if correction factor is 0
      if (dataType !== 'time' && !excludeDatalabels && (correctionFactor !== 0 || columnInfo.scaleType === LOG)) {
        var ignoreDatalabels = chart.datalabels.hasFixedPosition && defined(yAxisData.maxRange) && yAxisData.maxRange <= extentY[1];
        correctionOverDatalabels = ignoreDatalabels ? 0 : processor.getCorrectionOverDataLabels([minY, maxY], 'y', index);
      }

      if (!hasDefaultMin && !chart.datalabels.hasFixedPosition) {
        minY = minY - correctionOverDatalabels || 0;
      }

      maxY = maxY + correctionOverDatalabels || 0;

      if (processor.isWaterfallEnabled) {
        var domain = processor.getCorrectionForWaterfall([minY, maxY], 'y', index, chart, correctionOverDatalabels);
        minY = domain[0];
        maxY = domain[1];
      }

      return [minY, maxY];
    };

    function updateminMax(index, dataObj) {
      // var yValues = categoriesStore["y"+index];
      var yValues = d3_merge(dataObj.seriesExtermes[index]);
      var minmaxY = yValues.length != 0 ? d3_extent(yValues) : yValues.enabled ? [0, 0] : null; // yvalues.enabled for referring that axis is visible or not.If the axis is visible,but all the data contains 0 or null,we dont want to remove axis
      return minmaxY;
    }

    //PENDING: Stacked area missing subseries
    function _updateMinMaxforStackedData(context, index) {
      var dataset = context.dataset,
        processedseriesData = context.processedseriesData,
        helpers = DataProcessor.helpers;

      var yEncode = context.getEncode('y', index),
        seriesData = yEncode.seriesData,
        seriesIndices = yEncode.seriesIndices;

      if (context.isPercentChart) {
        return [0, 100];
      }
      var extents;

      if (context.pivot) {
        var pivotLayout = context.hierarchical.pivotLayout,
          nodeList = pivotLayout.getRootNodeList('row'),
          layers = pivotLayout.layers,
          hasMultiCluster = nodeList.hasMultiCluster();
        seriesData = objectValues(layers.panes);
      }
      extents = seriesData.map(function (series, i) {
        var seriesIndex = context.pivot ? i : seriesIndices[i],
          seriesAssist = context.seriesAssist[seriesIndex];

        if (arrayIncludes(seriesAssist.layout || [], 'stack')) {
          var stackIndex = context.pivot ? "".concat(series.row, "_").concat(series.column) : seriesAssist.stackIndex,
            layout = context.encodes.stack[stackIndex].layout;

          return layout.getExtent();
        } else {
          var data = d3_merge(series.data), //TODO: merge is not needed if subseries support is removed
            yaxiscolumnorder = helpers.getParsedYAxisOrder(processedseriesData[seriesIndex].yaxiscolumnorder),
            cType = context.allChartTypes[seriesIndex],
            yAccessor = function yAccessor(d) {
              var yVal = dataset.getY(d, yaxiscolumnorder);
              return yVal;
            };

          if (chartcategory.rangePlot.has(cType)) {
            var mergedYranges = d3_merge(data.map(yAccessor));
            return d3_extent(mergedYranges);
          } else {
            return d3_extent(data, yAccessor);
          }
        }
      });

      return d3_extent(d3_merge(extents));
    }

    /**
     * Bar, Area chart has default base as 0
     * @param       {Object}  processor [description]
     * @param       {Object}  chartObj  [description]
     * @return      {Boolean}           [description]
     */
    function _hasDefaultBase(yEncode, processor, chartObj) {
      //handle multiY combinational charts level marker.
      var ismultiY = chartObj.getAxesCount('y') > 1;

      if (ismultiY) {
        var allChartTypes = processor.allChartTypes,
          seriesIndices = yEncode.seriesIndices,
          chartTypes_splitAxes = seriesIndices.map(function (d) {return allChartTypes[d];}),
          check = function check(d) {return isBarChartType(d) && !chartcategory.rangePlot.has(d) || d === charttype.area || d === charttype.stkdarea;};

        return chartTypes_splitAxes.some(check);
      }

      return (
        processor.noofBarEnabledSeries && !processor.noofBoxplotEnabledSeries && !processor.noofBarRangeEnabledSeries ||
        processor.noofAreaEnabledSeries);
      //TODO: remove this variables
    }

    DataProcessor.prototype.ZC_BAR_getRangeY = function (index) {
      var yRange = this.yRange[index] || [];
      return d3_extent(d3_merge([yRange, [0]]));
    };

    //$Id$

    function getKey(mode, encodeType, index) {
      return mode + '-' + encodeType + '-' + index;
    }

    //$Id$

    function labelCorrectionParser(encodeType, index, chart) {
      var key = getKey('label', encodeType, index),
        processor = chart.dataObject,
        encodeData = processor.getEncode(encodeType, index);

      if (!_modularized.scaleCorrection) {
        encodeType = chart.dataset.getColumn(encodeType, index).datatype == 'time' ? 'x' : encodeType;
      }

      if (!encodeData) {
        return [];
      }

      return LabelRegistry.get('preCalculation')(encodeType, encodeData.seriesData, chart, false, key) || [];
    }

    //$Id$

    // TODO: array of series data in font precalculation. data to be a function. user cannot iterate and give the series data
    function bubbleCorrectionParser(encodeType, index, chart) {
      var key = getKey('bubble', encodeType, index),
        operator = [],
        dataSet = chart.dataset,
        processor = chart.dataObject,
        encodeData = processor.getEncode(encodeType, index),
        seriesData = encodeData.seriesData,
        helpers = DataProcessor.helpers,
        margin = 0;

      if (!processor.isBubbleEnabled) {
        return operator;
      }

      seriesData.forEach(function (series, seriesIndex) {
        var disabled = series.disabled,
          yaxiscolumnorder = helpers.getParsedYAxisOrder(series.yaxiscolumnorder),
          isCatNullX = helpers.isCatNull(dataSet, 'x'),
          isCatNullY = helpers.isCatNull(dataSet, 'y', yaxiscolumnorder),
          condition = function condition(d) {return !(!d || d.isDummy || isCatNullX(dataSet.getX(d)) || isCatNullY(dataSet.getY(d, yaxiscolumnorder)));};

        if (
        _modularized.scaleCorrection ? !disabled && isBubbleChartType(getChartTypeByIndex(chart, null, seriesIndex).value) : !disabled)
        {
          series.data.forEach(function (subgroup) {
            operator.push({
              _type: 'marker',
              data: subgroup.filter(condition),
              size: [function (d) {return processor.getXYvalue(null, null, null, null, null, d, 'z');}, margin],
              position: function position(d) {return encodeType === 'x' ? dataSet.getX(d) : dataSet.getY(d, yaxiscolumnorder);},
              scale: getScaleForBubbleCorrection,
              key: key
            });
          });
        }
      });

      return operator;
    }

    function getScaleForBubbleCorrection(_scale) {
      var _chart = _scale.chartObj,
        _config = _scale.config,
        domain,
        range,
        scaleObj;

      if (_scale.config.domain.hasDefaultMin) {
        _scale.config.tempDomain = [0, _scale.config.tempDomain[1]];
        _scale.config.extremes = [0, _scale.config.extremes[1]];
      }
      if (_scale.config.type == 'ordinal') {
        domain = _config.tempDomain || _config.domain;
        range = d3_extent(_config.tempRange); // if (range[0] > range[1]) { range = [range[1], range[0]]; }

        var d3_outerPadding = scale.getOuterPadding(range, _config.domain.length, _config.padding, _config.outerPadding);
        scaleObj = d3_scaleOrdinal().
        domain(domain).
        range(range).
        paddingInner(_config.padding).
        paddingOuter(d3_outerPadding);
      } else {
        domain = _config.tempDomain;
        range = [0, _chart.plotarea[_config.range.operators.plotBound.dimension]];
        scaleObj = getContinuousScale(_chart.dataset, _scale.encode, _scale.key)().
        domain(domain).
        range(range);
      }
      return scaleObj;
    }

    //$Id$

    function markerCorrectionParser(encodeType, index, chart) {
      var key = getKey('marker', encodeType, index),
        operator = [],
        size = d3_max(getMarkerSizes(chart)),
        margin = size ? 0 : 0;

      operator.push({
        _type: 'marker',
        data: [1],
        size: size + margin,
        position: 0,
        key: key
      });

      return operator;
    }

    //$Id$

    var correctionParserMap = {
      label: labelCorrectionParser,
      bubble: bubbleCorrectionParser,
      marker: markerCorrectionParser
    };

    function getCorrectionParser(mode, encodeType, index, chart) {
      var key = getKey(mode, encodeType, index),
        cached = chart.cache.correction;

      // Serve correction operator from cache. If not cached, get the operators
      return cached[key] ? [cached[key]] : correctionParserMap[mode](encodeType, index, chart);
    }

    function getAvailableOperatorsForXAxis(scaleType, needOnlyExtremes, needOnlyCorrection) {
      var defaultOperators = d3_set([
        'brushExtremes',
        'extremes',
        'threshold',
        'bubbleBound',
        'markerBound',
        'fontBound',
        'correctionFactor']),

        correctionOperators = ['correctionFactor', 'extraCorrectionFactor'];

      if (!needOnlyExtremes) {
        defaultOperators.add('extraCorrectionFactor');
      }
      if (needOnlyCorrection) {
        defaultOperators = d3_set(correctionOperators);
      }
      if (scaleType == LOG) {
        defaultOperators.add('logConstant');
      }
      return defaultOperators;
    }
    function getAvailableOperatorsForYAxis(scaleType, needOnlyExtremes, needOnlyCorrection) {
      var defaultOperators = d3_set([
      'baseLine',
      'NodataExtremes',
      'brushExtremes',
      'waterfallProcessor',
      'stackExtremes',
      'seriesExtremes',
      'levelMarker',
      'threshold',
      'min',
      'max',
      'hasDefaultBase',
      'updateBaseValue',
      'hasDefaultBaseValue',
      'bubbleBound',
      'markerBound',
      'correctionFactor',
      'fontBound',
      'waterfallBound']);

      if (needOnlyCorrection) {
        defaultOperators = d3_set(['correctionFactor', 'extraCorrectionFactor']);
      }
      if (scaleType == LOG) {
        defaultOperators.add('logConstant');
      }

      return defaultOperators;
    }
    function getAvailableOperatorsForTimeXAxis(scaleType, needOnlyExtremes, needOnlyCorrection) {
      var extremesOperators = ['brushExtremes', 'seriesExtremes', 'threshold', 'min', 'max', 'correctionFactor', 'timeFormat'],
        correctionOperators = ['extraCorrectionFactor', 'bubbleBound', 'fontBound', 'markerBound', 'subfunction', 'basevalue'],
        defaultOperators = needOnlyExtremes ?
        extremesOperators :
        needOnlyCorrection ?
        correctionOperators :
        d3_merge([extremesOperators, correctionOperators]);
      if (scaleType == LOG) {
        defaultOperators.push('logConstant');
      }
      return d3_set(defaultOperators);
    }
    function getAvailableOperatorsForTimeYAxis(scaleType, needOnlyExtremes, needOnlyCorrection) {
      var extremesOperators = [
        'baseLine',
        'NodataExtremes',
        'brushExtremes',
        'waterfallProcessor',
        'stackExtremes',
        'seriesExtremes',
        'levelMarker',
        'threshold',
        'min',
        'max',
        'updateBaseValue',
        'hasDefaultBaseValue',
        'correctionFactor',
        'waterfallBound',
        'timeFormat'],

        correctionOperators = [
        'extraCorrectionFactor',
        'basevalue',
        'subfunction',
        'bubbleBound',
        'correctionFactor',
        'fontBound',
        'markerBound'],

        defaultOperators = needOnlyExtremes ?
        extremesOperators :
        needOnlyCorrection ?
        correctionOperators :
        d3_merge([extremesOperators, correctionOperators]);
      if (scaleType == LOG) {
        defaultOperators.push('logConstant');
      }
      return d3_set(defaultOperators);
    }
    function numericAxisParser(
    encodeType)








    {var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var chart = arguments.length > 2 ? arguments[2] : undefined;var correctionFactor = arguments.length > 3 ? arguments[3] : undefined;var excludeDatalabels = arguments.length > 4 ? arguments[4] : undefined;var applyZoom = arguments.length > 5 ? arguments[5] : undefined;var needOnlyExtremes = arguments.length > 6 ? arguments[6] : undefined;var minmaxCorrection = arguments.length > 7 ? arguments[7] : undefined;var customExtent = arguments.length > 8 ? arguments[8] : undefined;
      index = index || 0;
      var domainOperators = {};
      //Extremes
      var extremesOperators = [],
        correctionOperators = [];
      var processor = chart.dataObject,
        axisConfig = getAxisData(chart, encodeType, index, null, chart.userdata),
        hasNegativeValue = processor.hasNegativeValue,
        baseline = processor.baseline,
        savedRange = encodeType == 'x' ? processor.xRange : processor.yRange[index],
        dataSet = chart.dataset,
        isPercentChart = processor.isPercentChart,
        stacked = processor.isstacked() || processor.isPercentChart,
        dataType = dataSet.getDataType(encodeType, index),
        columnInfo = dataSet.getColumn(encodeType, index),
        metaConf = columnInfo[columnInfo.datatype],
        subfunction = metaConf && metaConf.subfunction,
        encodeData = processor.getEncode(encodeType, index),
        zoomed = isObjectPropDefined(chart.systemConf, "chart.brush.".concat(encodeType, "[").concat(index, "]")) && applyZoom,
        axisObj = getAxisObject(chart, encodeType, index),
        needOnlyCorrection = defined(customExtent);

      correctionFactor =
      columnInfo.scaleType === LOG ?
      0 :
      encodeType == 'x' ?
      pick(correctionFactor, 0.05) :
      pick(correctionFactor, chart.datalabels.hasFixedPosition ? 0.00000001 : 0.05);
      minmaxCorrection = pick(minmaxCorrection, correctionFactor);

      var defaultOperator = getDefaultOperator(encodeType, dataType, needOnlyExtremes, needOnlyCorrection, columnInfo.scaleType);

      // Pop unnecessary correction
      var toBePopped = getOperatorsForPop(encodeType, index, chart, excludeDatalabels, minmaxCorrection);
      toBePopped.forEach(function (_) {return defaultOperator.remove(_);});

      //NodataExtremes operator
      if (defaultOperator.has('NodataExtremes') && !encodeData) {
        if (needOnlyExtremes) {
          //TODO PARSER check why this special case for needonlyExtremes
          extremesOperators.push(['NoData', 'NoData']);
        } else {
          extremesOperators.push([0, 0]);
        }

        domainOperators.extremes = extremesOperators;
        return domainOperators;
      }

      if (columnInfo.scaleType === LOG) {
        correctionFactor = 0;
        if (defined(axisObj.logDomain)) {
          extremesOperators.push(axisObj.logDomain);
          domainOperators.logDomain = [axisObj.logDomain];

          /*
          Baseline and DefaultBaseValue operators
          */
          if (defaultOperator.has('baseLine')) {
            //saveBaseline FEATURES_LOGAXIS_29
            domainOperators.updateBaseValue = {
              definedMin: domainOperators.min,
              basevalue: processor.baseline[index],
              stacked: stacked,
              rangeCheck: false
            };
          }

          if (defaultOperator.has('logConstant')) {
            domainOperators.logConstant = {
              allowNonPositiveTicks: axisConfig.allowNonPositiveTicks
            };
          }
          return domainOperators;
        }
      }

      // [**MIGRATION**] zoom --> brush
      // #ZC2016 $index
      //Brush extremes operator
      if (defaultOperator.has('brushExtremes')) {
        if (zoomed) {
          var zoomed = chart.systemConf.chart.brush[encodeType][index],
            zoomedExtent = [zoomed.minRange, zoomed.maxRange];
          extremesOperators.push(zoomedExtent);
          domainOperators.extremes = extremesOperators;
          //saveBaseline
          domainOperators.updateBaseValue = {
            definedMin: domainOperators.min,
            basevalue: processor.baseline[index],
            stacked: stacked,
            rangeCheck: true
          };
          return domainOperators;
        }
      }

      domainOperators.baseline = baseline[index] = getPropVal(axisConfig, 'baseline.show') === true ? axisConfig.baseline.value : null;

      if (customExtent) {
        extremesOperators.push(customExtent);
        domainOperators.extremes = extremesOperators;
      } else if (savedRange) {
        extremesOperators.push(savedRange);
        domainOperators.extremes = extremesOperators;
      } else {
        //Waterfall processor operator
        if (defaultOperator.has('waterfallProcessor') && processor.isWaterfallEnabled) {
          extremesOperators.push({
            _type: 'waterfallProcessor'
          });
        }
        //StackExtremes operator
        else if (defaultOperator.has('stackExtremes') && stacked) {
          var stackingIndices = processor.getStackingIndices(index);
          if (stackingIndices.stackIndices.length) {
            extremesOperators.push({
              _type: 'stackExtremes',
              stackIndices: stackingIndices.stackIndices,
              data: processor.encodes.stack
            });
          }
          if (stackingIndices.nonStackseriesIndices.length) {
            extremesOperators.push({
              _type: 'extremesByAccessor',
              indices: stackingIndices.nonStackseriesIndices,
              data: stackingIndices._nonStackData,
              accessor: function accessor(encodeType, seriesIdx) {
                var yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(
                processor.processedseriesData[seriesIdx].yaxiscolumnorder);

                return function (d) {
                  var yVal = encodeType == 'y' ? chart.dataset.getY(d, yaxiscolumnorder) : chart.dataset.getX(d);
                  return yVal;
                };
              },
              isRangeType: function isRangeType(seriesIdx) {
                return chartcategory.rangePlot.has(processor.allChartTypes[seriesIdx]);
              }
            });
          }
        } else {
          if (encodeType == 'x') {
            extremesOperators.push({
              _type: 'extremesByAccessor',
              data: processor.processedseriesData,
              accessor: function accessor(d) {
                return function (d) {
                  return chart.dataset.getX(d);
                };
              }
            });
          } else {
            extremesOperators.push({
              _type: 'extremesByEncode',
              seriesExtermes: processor.seriesExtermes
            });
          }
        }

        {
          /*
          ThresholdExtremes
           */
          if (defaultOperator.has('threshold')) {
            var axisDataKey = encodeType == 'x' ? "chart.axes.".concat(encodeType, "axis") : "chart.axes.".concat(encodeType, "axis[").concat(index, "]"),
              _axisConfig = pick(getPropVal(chart.userdata, axisDataKey), {}),
              thresholdData = getThresholdValues(_axisConfig);
            if (thresholdData && thresholdData.length) {
              extremesOperators.push(thresholdData);
            }
          }

          /*
          LevelMarker Extremes
           */
          if (defaultOperator.has('levelMarker')) {
            if (DataProcessor.helpers.hasLevelMarkerData(processor, index)) {
              var levelMarkerIndices = processor.getLevelMarkerIndices(index);
              if (levelMarkerIndices.indices.length) {
                extremesOperators.push({
                  _type: 'extremesByData',
                  data: processor.getEncode('y', index).seriesData,
                  indices: levelMarkerIndices.indices
                });
                extremesOperators.push([0, 0]);
              }
              if (levelMarkerIndices.values.length || processor.hasLevelMarker) {
                extremesOperators.push(levelMarkerIndices.values);
                extremesOperators.push([0, 0]);
              }
            }
          }
        }

        domainOperators.extremes = extremesOperators;
      }
      domainOperators.min = axisConfig.minRange;
      domainOperators.max = axisConfig.maxRange;

      /*
          Baseline and DefaultBaseValue operators
       */
      if (defaultOperator.has('baseLine')) {
        var hasDefaultBase = dataType == NUMERIC_DATATYPE && _hasDefaultBase(encodeData, processor, chart);
        domainOperators.hasDefaultBase = hasDefaultBase;

        //saveBaseline
        domainOperators.updateBaseValue = {
          definedMin: domainOperators.min,
          basevalue: processor.baseline[index],
          stacked: stacked,
          rangeCheck: false
        };

        //If extentY = [undefined, undefined], don't change the extent with '0'
        //update baseMin Value
        //hasDefaultMin
        domainOperators.hasDefaultBaseValue = {};
      }

      //Correction factors

      /*
      Correction factor
      For time axis, correction factor also applied after extremes
       */
      if (defaultOperator.has('correctionFactor') && dataType == TIME_DATATYPE) {
        domainOperators.correctionFactor1 = {
          _needCorrectionFactor:
          encodeType == 'x' || !(processor.isPercentChart || processor.hasLevelMarker || processor.isWaterfallEnabled),
          correction: 0 //outerpadding 0 for time datatype in minmaxy file
        };
      }

      if (defaultOperator.has('subfunction')) {
        domainOperators.subfunction = {
          subfunction: subfunction
        };
      }

      if (defaultOperator.has('basevalue')) {
        if (!chart.systemConf.chart.axes["".concat(encodeType, "axis")].disableBaseValue && !zoomed && encodeType != 'clr') {
          domainOperators.basevalue = {
            metaConf: metaConf
          };
        }
      }

      /*
          Bubble bound operators
       */
      if (defaultOperator.has('bubbleBound')) {
        if (processor.isBubbleEnabled && isUndefined(axisConfig.minRange) && isUndefined(axisConfig.maxRange)) {
          var operator = getCorrectionParser('bubble', encodeType, index, chart);
          correctionOperators.push.apply(correctionOperators, _toConsumableArray(operator));
          modifyCorrectionOperator('bubble', operator, domainOperators);
        }
      }

      /*
          MarkerBound operator
       */
      if (defaultOperator.has('markerBound')) {
        var _operator = getCorrectionParser('marker', encodeType, index, chart);
        correctionOperators.push.apply(correctionOperators, _toConsumableArray(_operator));
        modifyCorrectionOperator('marker', _operator, domainOperators);
      }

      /*
      Correction factor
      For y axis, correction factor applied before to font bound
       */
      if (defaultOperator.has('extraCorrectionFactor') && dataType == TIME_DATATYPE) {
        domainOperators.extraCorrectionFactor = {
          dataType: dataType,
          _needCorrectionFactor: !(processor.isPercentChart || processor.hasLevelMarker || processor.isWaterfallEnabled),
          correction: correctionFactor
        };
      }

      /*
      Correction factor
      For y axis, correction factor applied before to font bound
       */
      if (defaultOperator.has('correctionFactor') && encodeType == 'y' && dataType !== TIME_DATATYPE) {
        domainOperators.correctionFactor = {
          dataType: dataType,
          _needCorrectionFactor: !(processor.isPercentChart || processor.hasLevelMarker || processor.isWaterfallEnabled),
          correction: correctionFactor
        };
      }

      // no need to find correction datalabel,if correction factor is 0
      /*
      FontBound Operator
       */
      if (defaultOperator.has('fontBound')) {
        var _operator2 = getCorrectionParser('label', encodeType, index, chart);
        correctionOperators.push.apply(correctionOperators, _toConsumableArray(_operator2));
        modifyCorrectionOperator('label', _operator2, domainOperators);
        // condition missing TODO
      }

      //for time datatype, precalculation calculated from outerpaddingCorrection and fontbound
      if (defaultOperator.has('correctionFactor') && dataType == TIME_DATATYPE) {
        domainOperators.correctionFactor = {
          _needCorrectionFactor: false,
          preCorrectionValue: true,
          fontPreCorrection: true
        };
      }
      /*
      Correction factor
      For x axis, correction factor applied next to font bound
       */
      if (defaultOperator.has('correctionFactor') && encodeType == 'x' && dataType !== TIME_DATATYPE) {
        domainOperators.correctionFactor = {
          dataType: dataType,
          correction: minmaxCorrection,
          _needCorrectionFactor: true
        };
      }

      /*
          Log scale
       */
      if (defaultOperator.has('logConstant')) {
        domainOperators.logConstant = {
          allowNonPositiveTicks: axisConfig.allowNonPositiveTicks
        };
      }
      /*
      Waterfall bound operator
       */
      if (defaultOperator.has('waterfallBound') && processor.isWaterfallEnabled) {
        domainOperators.waterfallBound = {
          mode: 'domain'
        };
      }

      // if (!zoomedValue && (extent || type == 'x')) {
      //     var diff = domain[1] - domain[0];
      //     var correction = diff == 0 ? chartObj.plotarea.width / 2 : diff * outerPadding;
      //     domain[0] = hasCustomMinRange ? domain[0] : domain[0] - correction;
      //     domain[1] = hasCustomMaxRange ? domain[1] : domain[1] + correction;
      // }

      //DEMO_LINE_15
      if (defaultOperator.has('timeFormat') && dataType == TIME_DATATYPE) {
        domainOperators.timeFormat = {};
      }
      /*
      Correction factor
      For x axis, correction factor applied before to font bound
       */
      if (defaultOperator.has('extraCorrectionFactor') && dataType == NUMERIC_DATATYPE) {
        domainOperators.extraCorrectionFactor = {};

        domainOperators.correctionFactor1 = {
          _needCorrectionFactor: false,
          preCorrectionValue: true,
          fontCorrectionFactor: true
        };
      }

      domainOperators._correction = _modularized.scaleCorrection ? correctionOperators : [];

      return domainOperators;
    }

    function getDefaultOperator(encodeType, datatype, needOnlyExtremes, needOnlyCorrection, scaleType) {
      if (datatype == TIME_DATATYPE) {
        if (encodeType == 'x') {
          return getAvailableOperatorsForTimeXAxis(scaleType, needOnlyExtremes, needOnlyCorrection);
        }
        return getAvailableOperatorsForTimeYAxis(scaleType, needOnlyExtremes, needOnlyCorrection);
      } else {
        if (encodeType == 'x') {
          return getAvailableOperatorsForXAxis(scaleType, needOnlyExtremes, needOnlyCorrection);
        }
        return getAvailableOperatorsForYAxis(scaleType, needOnlyExtremes, needOnlyCorrection);
      }
    }

    function getOperatorsForPop(encodeType, index, chart, excludeDatalabels, minmaxCorrection) {
      var processor = chart.dataObject,
        dataSet = chart.dataset,
        axisConfig = getAxisData(chart, encodeType, index, null, chart.userdata),
        dataType = dataSet.getDataType(encodeType, index),
        columnInfo = dataSet.getColumn(encodeType, index),
        toBePopped = [];

      if (!(processor.isBubbleEnabled && isUndefined(axisConfig.minRange) && isUndefined(axisConfig.maxRange))) {
        toBePopped.push('bubbleBound');
      }

      if (!(DataProcessor.helpers.hasMarkerCorrection() && dataType !== TIME_DATATYPE)) {
        toBePopped.push('markerBound');
      }

      var labelCheck =
      !processor.isPercentChart &&
      !(processor.isBubbleEnabled && !processor.pieWithAxis) && (
      processor.isAxisCategory || processor.isNonAxisMultiSeriesCategory) &&
      !(axisConfig.minRange != null && axisConfig.maxRange != null);
      if (
      !(
      (minmaxCorrection !== 0 || columnInfo.scaleType === LOG) && (
      encodeType == 'x' || encodeType == 'y' && !excludeDatalabels) &&
      labelCheck))

      {
        toBePopped.push('fontBound');
      }

      if (encodeType === 'y' && processor.isPercentChart && processor.isstacked()) {
        toBePopped.push('bubbleBound', 'markerBound', 'fontBound');
      }

      return toBePopped;
    }

    function isLabelsEnabledForChart(chartObj, type) {
      var systemconf = chartObj.systemConf,
        dataObj = chartObj.dataObject,
        stacked = dataObj.isstacked(),
        hasBarSeries = dataObj.noofBarEnabledSeries,
        isYaxis = type === 'y',
        showLabel,
        showStackLabels;

      showLabel = chartObj.seriesdata.some(function (series, i) {
        if (!series.disabled) {
          var plotoptions = series.plotoptions,
            commonPlotOptions = systemconf.chart.plot.plotoptions[chartObj.chartTypes[i].name],
            dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions);
          return isDatalabelEnabled(dataLabels, chartObj);
        }
      });

      if (isYaxis && hasBarSeries && stacked && !dataObj.isStackedPercentChart) {
        var allChartTypes = dataObj.allChartTypes,
          stackBarEncode = chartObj.dataObject.filterEncode('stack', function (d) {return (
              d.seriesIndices.some(function (seriesIndex) {return isBarChartType(allChartTypes[seriesIndex]);}));});

        if (!stackBarEncode.length) {
          return false;
        }
        var encode = stackBarEncode[0],
          seriesIndex = getSeriesIndex4StackLabel(encode);

        var stackedLabels = systemconf.chart.plot.plotoptions[chartObj.chartTypes[seriesIndex].name].datalabels.stackLabels || {};
        showStackLabels = stackedLabels ? stackedLabels.show : false;
      }

      return showLabel || showStackLabels;
    }

    function dataLabelEnabled(chartInstance) {
      var systemConfig = chartInstance.systemConf,
        totalDataCount = chartInstance.dataObject.totalnoofdatas,
        allowedLabelCount = +systemConfig.canvas.intelligence.dataCount.datalabels;

      if (totalDataCount > allowedLabelCount) {
        return false;
      }

      if (getPropVal(systemConfig.chart, 'plot.datalabels.show') === true) {
        return true;
      }
      var seriesData = chartInstance.seriesdata,
        len = seriesData.length;

      while (len--) {
        var commonPlotOptions = systemConfig.chart.plot.plotoptions[chartInstance.chartTypes[len].name],
          datalabels = commonPlotOptions.datalabels;

        if (defined(seriesData[len].plotoptions)) {
          datalabels = getMergedDatalabelOptions(commonPlotOptions, seriesData[len].plotoptions);
        }
        if (isDatalabelEnabled(datalabels, chartInstance)) {
          return true;
        }
      }
      return false;
    }

    function ordinalAxisRangeParser(type) {var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var chart = arguments.length > 2 ? arguments[2] : undefined;var needCorrections = arguments.length > 3 ? arguments[3] : undefined;var scaleType = arguments.length > 4 ? arguments[4] : undefined;
      index = type === 'y' ? index : 0; // CXZA_MULTIY_4
      var rangeOperators = {},
        correctionOperators = [];

      var orient = getAxisOrient(type, chart.axes.rotated);
      rangeOperators.plotBound = {
        dimension: orient == BOTTOM_ALIGN || orient == TOP_ALIGN ? 'width' : 'height',
        customPlotBound: chart.systemConf.chart,
        plotSize: chart.plotarea,
        defaultPlotSize: chart.plotarea,
        polarConfig: scaleType == POLAR_SCALETYPE ? getPolorRangeConfig(chart, type) : NULL$1,
        color: chart.imagePallete || chart.seriesColor,
        boundExtreme: 0
      };

      if (needCorrections) {
        if (chart.datalabels.moduleExists && dataLabelEnabled(chart) || chart.dataObject.isBubbleEnabled) {
          if (chart.dataObject.isBubbleEnabled) {
            var operator = getCorrectionParser('bubble', type, index, chart);
            correctionOperators.push.apply(correctionOperators, _toConsumableArray(operator));
            modifyCorrectionOperator('bubble', operator, rangeOperators);
          } else if (false) {
            var operator;
          } else {
            // if (!(hasFixedDatalabels(chart) && type === 'x')) {
            var operator = getCorrectionParser('label', type, index, chart);
            correctionOperators.push.apply(correctionOperators, _toConsumableArray(operator));
            modifyCorrectionOperator('label', operator, rangeOperators);
            // }
          }
        }
      }
      rangeOperators._correction = _modularized.scaleCorrection ? correctionOperators : [];
      return rangeOperators;
    }

    //$Id$

    function expressionEvalRangeForOrdinal(operators) {
      var _scale = this,
        outerPadding = _scale.config.outerPadding,
        plotBound = operators.plotBound,
        rangeDiff = mathAbs(plotBound[1] - plotBound[0]),
        correction = rangeDiff * outerPadding;

      if (!_modularized.scaleCorrection) {
        correction += changeOuterPadding(operators);
      } else {
        var maxCorrection = d3_max(evalCorrection(operators, _scale));
        correction = maxCorrection ? mathMax(correction, maxCorrection) : correction; // FEATURES_COMBO_4
      }

      this.d3_scale.origRange = operators.plotBound.slice();
      this.d3_scale.outerPaddingPx = correction;

      var min2Max = plotBound[0] < plotBound[1];
      var minPos = min2Max ? 0 : 1,
        maxPos = min2Max ? 1 : 0;

      //Outerpadding corrections in range
      plotBound[minPos] += correction;
      plotBound[maxPos] -= correction;

      return plotBound;
    }

    ScaleRegistry.add('axis.evalOrdinalRange', expressionEvalRangeForOrdinal);

    //$Id$

    scale.getScale = function (chartObj, dataObj, plotarea, orient, index, dataset, type, extent, noOuterPadding) {var applyZoom = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : true;return function (orient) {
        var scaleObj, newScaleObj, domain;
        var systemconf = chartObj.systemConf;
        var datatype = dataset.getDataType(type, index),
          axis_data = getAxisOptions(chartObj, type, index),
          hierarchical = dataObj.hierarchical;

        /*
         * If hasCustomMinRange or hasCustomMaxRange is present, the correction should not be applied to the scale domain
         * Test cases :- Test_535.json, Test-536.json
         */
        var hasCustomMinRange = defined(axis_data.minRange),
          hasCustomMaxRange = defined(axis_data.maxRange);

        var cType = charttypenames.get(getFirstAxisChartType(chartObj));
        var commonPlotOptions = systemconf.chart.plot.plotoptions[cType];
        var isPolar = cType === 'dial' || cType === 'web' && type === 'x', //isPolarType(chartObj, type, index),
          isHeatmap = cType === 'heatmap',
          hasColorScale = type === 'clr' && colorscale_helpers.isQuantileColorScale(chartObj),
          columnInfo = dataset.getColumn(type, index),
          // [**MIGRATION**] zoom --> brush
          // #ZC2017
          zoomedValue = applyZoom ? getPropVal(systemconf, "chart.brush.".concat(type, "[").concat(index, "]")) : UNDEFINED,
          isLogScale = columnInfo.scaleType === LOG;

        var range = getRange(chartObj, type, orient, axis_data.reversed, index),
          padding = getPadding(),
          outerPadding = getOuterPadding();

        if (type === 'clr') {
          // domain = colorscale_helpers.getColorDomain(chartObj);
          // range = colorscale_helpers.getProcessedColorRange(range, domain, systemconf.legend, chartObj);

          var rangeOperators_clr, domainOperators_clr;

          domainOperators_clr = ScaleRegistry.get('color.domainParser')(type, index, systemconf.legend, chartObj);
          rangeOperators_clr = ScaleRegistry.get('color.rangeParser')(type, index, systemconf.legend, chartObj);
          var parser1 = {
            type: datatype,
            dataType: datatype,
            scaleType: datatype != ORDINAL_DATATYPE && axis_data.ranges && axis_data.ranges.length ? QUANTILE_SCALETYPE : datatype,
            field: columnInfo,
            reverse: axis_data.reversed,
            data: [],
            domain: {
              operators: domainOperators_clr,
              evaluator: ScaleRegistry.get('color.evalDomain')
            },
            range: {
              operators: rangeOperators_clr,
              evaluator: ScaleRegistry.get('color.evalRange')
            },
            padding: padding,
            outerPadding: outerPadding
          };
          if (chartObj.viewFlow && chartObj.viewFlow.scales[columnInfo.id]) {
            extendScaleParser(parser1, chartObj.viewFlow.scales[columnInfo.id].conf);
          }
          // if (systemconf.viewParser) {
          //     if (systemconf.viewParser.scale && systemconf.viewParser.scale[columnInfo.name]) {
          //         extendScaleParser(parser1, systemconf.viewParser.scale[columnInfo.name]);
          //     }
          // }
          var newScaleComp1 = new Scale(type, index, parser1, chartObj);
          newScaleObj = newScaleComp1.getScale();
        }

        switch (datatype) {
          case 'numeric':
          case 'time':
            // if (extent) {
            //     domain = extent;
            // } else if (type === 'x') {
            //     domain = dataObj.getMinMaxX(0, applyZoom);
            // } else if (type === 'y') {
            //     domain = dataObj.getMinMaxY(index, outerPadding, UNDEFINED, applyZoom);
            // }
            // var scaleMode;
            //
            // if (type === 'clr' && axis_data.ranges && axis_data.ranges.length) {
            //     scaleMode = colorscale_helpers.quantileScale;
            // } else {
            //     scaleMode = getContinuousScale(dataset, type, index);
            // }
            //
            // var actualStart = domain[0],
            //     actualEnd = domain[1];
            // if (domain[0] == 'NoData' && domain[1] == 'NoData') {
            //     //for addorremoveaxis
            //     domain = [0, 0];
            // }
            // if (!zoomedValue && (extent || type == 'x')) {
            //     var diff = domain[1] - domain[0];
            //     var correction = diff == 0 ? chartObj.plotarea.width / 2 : diff * outerPadding;
            //     domain[0] = hasCustomMinRange ? domain[0] : domain[0] - correction;
            //     domain[1] = hasCustomMaxRange ? domain[1] : domain[1] + correction;
            // }
            //
            // scaleObj = scaleMode()
            //     .domain(domain)
            //     .range(range);
            //
            // // TODO CXZA_SINGLECOL_2
            //
            // // SYM LOG SCALE constant for log like spacing near 0 ticks. eg [0.001, 0.01, 0.1, 1, 10]
            // if (scaleObj.constant) {
            //     let min = d3_min(domain);
            //     if (min > 0 && min < pick(axis_data.logBase, 10) && axis_data.allowNonPositiveTicks === false) {
            //         scaleObj.constant(0.0001);
            //     } else {
            //         scaleObj.constant(1);
            //     }
            //     // #ZC2812
            //     if (actualStart === 'NoData' && actualEnd === 'NoData') {
            //         actualStart = actualEnd = 0;
            //     }
            // }
            //
            // var originalDomain = [actualStart, actualEnd],
            //     actualRange = originalDomain.map(scaleObj);
            //
            // scaleObj.actualRange = actualRange;
            // scaleObj.origRange = range;
            // scaleObj.originalDomain = originalDomain;
            // scaleObj.correction = correction;

            ////
            /*
                SCALE PARSER
            */
            if (type == 'x' || type == 'y') {
              var domainOperators = {},
                rangeOperators = {};

              var orient = getAxisOrient(type, chartObj.axes.rotated),
                minmaxCorrection = datatype == 'time' ? NULL$1 : type == 'x' ? 0 : outerPadding,
                scaleType = isPolar ?
                POLAR_SCALETYPE :
                axis_data.ranges && axis_data.ranges.length ?
                QUANTILE_SCALETYPE :
                columnInfo.scaleType,
                polarConfig = getPolorRangeConfig(chartObj, type);

              rangeOperators.plotBound = {
                dimension: orient == BOTTOM_ALIGN || orient == TOP_ALIGN ? 'width' : 'height',
                customPlotBound: { width: chartObj.systemConf.chart.width, height: chartObj.systemConf.chart.height },
                plotSize: chartObj.plotarea,
                defaultPlotSize: chartObj.plotarea,
                polarConfig: polarConfig,
                color: chartObj.imagePallete || chartObj.seriesColor,
                boundExtreme: 0
              };

              domainOperators = numericAxisParser(
              type,
              index,
              chartObj,
              outerPadding,
              UNDEFINED,
              applyZoom,
              UNDEFINED,
              minmaxCorrection,
              extent);


              var parser = {
                dataType: datatype,
                orient: datatype == TIME_DATATYPE ? chartObj.axes.x.orient : orient,
                type: datatype,
                scaleType: scaleType,
                field: columnInfo,
                reverse: axis_data.reversed,
                data: [],
                domain: {
                  operators: domainOperators,
                  evaluator: expressionEvalDomainForLinear
                },
                range: {
                  operators: rangeOperators,
                  evaluator: expressionEvalRangeForLinear
                },
                padding: padding,
                outerPadding: outerPadding
              };
              //for log scale
              if (columnInfo.scaleType === LOG) {
                parser.logBase = axis_data.logBase;
              }
              if (chartObj.viewFlow && chartObj.viewFlow.scales[columnInfo.id]) {
                extendScaleParser(parser, chartObj.viewFlow.scales[columnInfo.id].conf);
              }
              // if (systemconf.viewParser) {
              //     if (systemconf.viewParser.scale && systemconf.viewParser.scale[columnInfo.name]) {
              //         extendScaleParser(parser, systemconf.viewParser.scale[columnInfo.name]);
              //     }
              // }
              var newScaleComp = new Scale(type, index, parser, chartObj);
              newScaleObj = newScaleComp.getScale();

              if (type == 'y') {
                //TODO Need to change this dependency from dataobject
                dataObj.hasNegativeValue[index] = newScaleComp.config.hasNegativeValue && newScaleComp.config.hasNegativeValue[index];
              }
            }
            // else {
            //     newScaleObj = newScaleObj;
            // }
            getActualRange(newScaleObj);
            if (extent && datatype == NUMERIC_DATATYPE) {
              if (chartObj.scroll && chartObj.scroll.scrollDomain) {
                chartObj.viewPortExtent = newScaleObj.domain();
                chartObj.scroll.scrollDomain = chartObj.viewPortExtent;
              }
            }
            break;
          case 'ordinal':
            //args for customer will be fields not by encodes or chart types. they can give it as functions. also they can use operators
            // var parser = {
            //     type: 'ordinal',
            //     field: '',
            //     reverse: '',
            //     data: [],
            //     domain: {
            //         extremes: [
            //             {
            //                 data: [],
            //                 encode: ''
            //             }
            //         ],
            //         categories: {
            //             encode: ''
            //         },
            //         min: 'config.minRange',
            //         max: 'config.maxRange',
            //         ranges: 'config.ranges',
            //         stops: 'config.stops',
            //         base: 'config.base'
            //     },
            //     range: {
            //         plotBound: {
            //             dimension: 'width'
            //         },
            //         outerPadding: {}
            //     },
            //     padding: padding
            // };

            //YOU NEED TO AUTOMATE THIS PARSER AND VALUES PROPERLY;
            if (extent) {
              domain = extent;
            } else if (type !== 'clr') {
              var categories = dataObj.getCategories(type, index, applyZoom);
              domain = dataObj.getDomain(categories, type, true);
            }
            //
            // var d3_outerPadding = 0,
            //     origRange = [range[0], range[1]],
            //     outerPaddingPx;
            // //IMPORTANT: Padding is considered for single data. Refer /#/demoCharts/bullet1
            // padding = domain.length === 1 ? 0 : padding;
            //
            // if (outerPadding && !noOuterPadding && !isHeatmap && type !== 'clr' && !isPolar) {
            //     d3_outerPadding = scale.getOuterPadding(range, domain.length, padding, outerPadding);
            //     //bubble and datalabels
            //
            //     var range_correction = getRangeWithOuterPaddingCorrection(
            //         chartObj,
            //         type,
            //         index,
            //         domain,
            //         range,
            //         padding,
            //         outerPadding,
            //         d3_outerPadding
            //     );
            //     range = range_correction.range;
            //     outerPaddingPx = range_correction.outerPaddingPx;
            // }
            //
            // var scaleMode = type === 'clr' ? d3_scaleOrdinalOrg : d3_scaleOrdinal;
            // scaleObj = scaleMode().domain(domain);
            //
            // if (type === 'clr') {
            //     scaleObj.range(range);
            // } else {
            //     scaleObj
            //         .range(range)
            //         .paddingInner(padding)
            //         .paddingOuter(0);
            // }
            // // get and set all the range steps to ke xScale.ordinalRange
            // getOrdinalRange(scaleObj);
            // scaleObj.origRange = origRange;
            // scaleObj.outerPaddingPx = outerPaddingPx || 0;

            ////
            /*
                SCALE PARSER
            */
            //IMPORTANT: Padding is considered for single data. Refer /#/demoCharts/bullet1
            domain = type == 'clr' ? newScaleObj.domain() : domain;
            padding = domain.length === 1 ? 0 : padding;

            if (type == 'x' || type == 'y') {
              var scaleType = isPolarType(chartObj, type, index) ?
                POLAR_SCALETYPE :
                axis_data.ranges && axis_data.ranges.length ?
                QUANTILE_SCALETYPE :
                columnInfo.scaleType,
                needCorrections = outerPadding && !noOuterPadding && !isHeatmap && type !== 'clr' && !isPolar,
                rangeOperators = ordinalAxisRangeParser(type, index, chartObj, needCorrections, scaleType);

              // var orient = getAxisOrient(type, chartObj.axes.rotated);
              // rangeOperators.plotBound = {
              //     dimension: orient == BOTTOM_ALIGN || orient == TOP_ALIGN ? 'width' : 'height'
              // };
              // if (outerPadding && !noOuterPadding && !isHeatmap && type !== 'clr' && !isPolar) {
              //     if (
              //         (chartObj.datalabels.moduleExists && dataLabelEnabled(chartObj)) ||
              //         chartObj.dataObject.isBubbleEnabled ||
              //         DataProcessor.helpers.hasMarkerCorrection()
              //     ) {
              //         if (chartObj.dataObject.isBubbleEnabled) {
              //             rangeOperators.bubbleBound = {
              //                 mode: 'range'
              //             };
              //         } else if (DataProcessor.helpers.hasMarkerCorrection()) {
              //             rangeOperators.markerBound = {
              //                 mode: 'range'
              //             };
              //         } else if (labelRenderer) {
              //             rangeOperators.fontBound = {
              //                 mode: 'range'
              //             };
              //         }
              //     }
              // }

              var parser = {
                dataType: datatype,
                type: datatype,
                scaleType: scaleType,
                field: columnInfo,
                reverse: axis_data.reversed,
                data: [],
                domain: domain,
                range: {
                  operators: rangeOperators,
                  evaluator: expressionEvalRangeForOrdinal
                },
                padding: padding,
                outerPadding: outerPadding
              };
              if (chartObj.viewFlow && chartObj.viewFlow.scales[columnInfo.id]) {
                extendScaleParser(parser, chartObj.viewFlow.scales[columnInfo.id].conf);
              }
              // if (systemconf.viewParser) {
              //     if (systemconf.viewParser.scale && systemconf.viewParser.scale[columnInfo.name]) {
              //         extendScaleParser(parser, systemconf.viewParser.scale[columnInfo.name]);
              //     }
              // }
              var newScaleComp = new Scale(type, index, parser, chartObj);
              if (type !== 'clr') {
                newScaleComp.d3_scale.paddingInner = padding;
                newScaleComp.d3_scale.paddingOuter = 0;
              }
              newScaleObj = newScaleComp.getScale();
            }
            // else {
            //     newScaleObj = newScaleObj;
            // }

            break;
          case 'ordinalNonLinear':{
              // init the scale with the leaf scale;

              var categories = dataObj.getCategories(type, index, applyZoom);
              domain = extent || dataObj.getDomain(categories, type);

              var rowList = hierarchical.pivotLayout.getRootNodeList('row'),
                columnList = hierarchical.pivotLayout.getRootNodeList('column');

              var origRange = [range[0], range[1]],
                rangeList;
              if (type == 'x' && columnList.getCount()) {
                rangeList = columnList.getRangesForBranch(index - columnList.getLeavesCount());
              } else if (type == 'y' && rowList.getCount()) {
                rangeList = rowList.getRangesForBranch(index - rowList.getLeavesCount());
              }

              scaleObj = nonLinearOrdinalScale().
              domain(domain).
              range(range).
              rangeBands(rangeList);

              scaleObj.origRange = origRange;

              newScaleObj = scaleObj;
            }}


        if (chartObj.viewFlow) {
          var axisView = getAxisViewModel(chartObj, type, orient, index);
          if (axisView && axisView.scale) {
            axisView.scale.component = newScaleObj;
          }
        }

        // scaleObj.outerPadding = outerPadding;
        // scaleObj.padding = padding;
        // dataObj.hasNegativeValue[index] = newScaleObj.config.hasNegativeValue[index];
        newScaleObj.outerPadding = outerPadding;
        newScaleObj.padding = padding;

        return newScaleObj;
        /*
            SCALE PARSER
         */
        // return scaleObj;

        function getPadding() {
          if (isPolar || isHeatmap || type != 'x' || !chartObj.dataObject.isAxisCategory) {
            // Pivot with non axis category
            return 0;
          } else {
            var _default = dataObj.noofBarEnabledSeries ?
            0.2 :
            isFacet(chartObj) && Object.keys(dataObj.hierarchical.gridOptions).some(function (_) {return hasColorColumnInNonAxis(chartObj, _);}) ?
            0 :
            0.9;
            return validateNullVal(commonPlotOptions.padding, _default); //default value is 0.2 (Bar, Bullet, Gantt) or 0.9 (Others)
          }
        }

        function getOuterPadding() {
          if (
          isPolar ||
          hasColorScale ||
          isHeatmap ||
          noOuterPadding ||
          !chartObj.dataObject.isAxisCategory && !chartObj.dataObject.isPolarAxisCategory && !chartObj.dataObject.isAxisCategory ||
          isLogScale)
          {
            // Pivot with non axis category
            return 0;
          } else if (type === 'y') {
            return validateNullVal(axis_data.outerPadding, chartObj.datalabels.hasFixedPosition ? 0.00000001 : 0.05);
          } else if (outerPadding != null) {
            return outerPadding;
          } else {
            return validateNullVal(commonPlotOptions.outerPadding, 0.02);
          }
        }
      }(orient);};

    scale.setRowScale = function (chartObj, type, needCorrection) {
      var hierarchical = chartObj.dataObject.hierarchical,
        nodeList,
        nodeListCount,
        hasMultiCluster,
        yaxisObj = chartObj.axes.y,
        dataObject = chartObj.dataObject,
        plotarea = chartObj.plotarea,
        dataset = chartObj.dataset;

      if (hierarchical) {
        nodeList = hierarchical.pivotLayout.getRootNodeList('row');
        nodeListCount = nodeList.getCount();
        hasMultiCluster = nodeList.hasMultiCluster();
      }
      if (hasMultiCluster || nodeListCount) {
        hierarchical.pivotLayout.setRanges('row');

        var rowCount = nodeListCount || 0,
          clustersCount = nodeList.getClustersCount();
        if (rowCount || clustersCount) {
          var firstRowCategoryCount = rowCount ? nodeList.getDomainForBranch(0).length : 1,
            leavesCount = nodeList.getLeavesCount();
          /*
              Generate scale for branches
           */
          for (var j = 0; j < rowCount; j++) {
            if (!yaxisObj.branches[j]) {
              yaxisObj.branches[j] = {};
            }
            var domain = nodeList.getDomainForBranch(j),
              domainValues = dataObject.getDomain(domain, 'y', true);
            yaxisObj.branches[j].scale = scale.getScale(
            chartObj,
            dataObject,
            plotarea,
            yaxisObj.orient,
            j + leavesCount,
            dataset,
            'y',
            domainValues);

          }
          /*
          Generate scales for multi Y axis or clusters
           */
          var yscale = new Array(clustersCount);
          for (var i = 0; i < clustersCount; i++) {
            yscale[i] = scale.getScale(chartObj, dataObject, plotarea, yaxisObj.orient, i, dataset, 'y');
            nodeList.clusters[i].domain = yscale[i].domain();
          }
          var parentLeafRowIndex = 0,
            parentLeafRowScale = rowCount ? yaxisObj.branches[parentLeafRowIndex].scale : null;

          var tempRange = 0,
            co = 0;
          /*
              Generate Leaf scales
           */
          for (var k = 0; k < firstRowCategoryCount; k++) {
            for (var i = 0; i < clustersCount; i++) {
              var axis_data = getAxisOptions(chartObj, 'y', i);
              var ysc = yscale[i];
              var rangeCopy = parentLeafRowIndex ?
              [parentLeafRowScale(k) + parentLeafRowScale.discreteWidth(k), parentLeafRowScale(k)] :
              [tempRange + nodeList.leafSize, tempRange];

              tempRange = tempRange + nodeList.leafSize;
              var correctionFactor = needCorrection ? 0.1 : 0,
                diff = mathAbs(rangeCopy[1] - rangeCopy[0]),
                correction = diff * correctionFactor;
              rangeCopy = [rangeCopy[0] - correction, rangeCopy[1] + correction];

              if (chartObj.axes.rotated && !axis_data.reversed || !chartObj.axes.rotated && axis_data.reversed) {
                rangeCopy = rangeCopy.reverse();
              }
              if (!yaxisObj.leaves[co]) {
                yaxisObj.leaves[co] = {};
              }

              yaxisObj.leaves[co].scale = ysc.copy().range(rangeCopy);
              yaxisObj.leaves[co].scale.origRange = rangeCopy;
              yaxisObj.leaves[co].parentBranchIdx = k;
              co++;
            }
          }
          chartObj.axes.y = yaxisObj;
          return yaxisObj.leaves.concat(yaxisObj.branches);
        }
      }
    };

    scale.setColumnScale = function (chartObj, type) {
      var processor = chartObj.dataObject,
        hierarchical = processor.hierarchical,
        extent = chartObj.viewPortExtent,
        xaxes = chartObj.axes.x,
        dataObject = chartObj.dataObject,
        plotarea = chartObj.plotarea,
        dataset = chartObj.dataset,
        scaleFunc = scale.getScale,
        datatype = dataset.getDataType('x');
      /*
             set leafscale or rangescale for groupbyTime layout
              */
      xaxes.rangeScale = xaxes.scale.copy();
      xaxes.rangeScale.outerPaddingPx = xaxes.scale.outerPaddingPx;
      if (hierarchical.groupByDiscreteTime) {
        var categories = processor.getCategories('x'),
          domainValues = processor.getDomain(categories, 'x');
        xaxes.rangeScale.domain(domainValues);
      }

      var columnList = hierarchical.pivotLayout.getRootNodeList('column'),
        columnCount = columnList.getCount(),
        leafNodes =
        columnCount || datatype == TIME_DATATYPE || datatype == NUMERIC_DATATYPE ?
        columnList.getDomainForCluster(0) :
        dataObject.xaxisData.categories || columnList.getDomainForCluster(0),
        levels = columnCount || 0;
      /*
      set leafscale or rangescale for pivot or layer hierarchy layout
       */
      var domainValues = dataObject.getDomain(leafNodes, 'x', true);

      if (datatype == TIME_DATATYPE || datatype == NUMERIC_DATATYPE) {
        domainValues = columnCount ? d3_extent(domainValues) : xaxes.scale.domain(); // for time datatype, we didn't apply time format in pushToContinousCluster nodes, hence using existing domain
      }
      chartObj.axes.x.leafScaleGrid = hierarchical.categoryTree ?
      scale.getScale(chartObj, dataObject, plotarea, xaxes.orient, null, dataset, 'x', domainValues) :
      chartObj.axes.x.scale;

      if (columnCount) {
        var nodeList = hierarchical.pivotLayout.getRootNodeList('column');
        if (chartObj.systemConf.facets && chartObj.systemConf.facets.config && chartObj.systemConf.facets.config.columns.leafSize) {
          chartObj.dataObject.hierarchical.getDynamicColumnSize(chartObj.axes.x.leafScaleGrid);
          var dynamicDomain = nodeList.getDynamicDomainForCluster(0);
          var xsc1 = scale.getScale(chartObj, dataObject, plotarea, xaxes.orient, null, dataset, 'x', d3_range(dynamicDomain.length));
          var leafRanges = hierarchical.pivotLayout.setRangesForLeaf('column', xsc1);

          var newscaleObj = nonLinearOrdinalScale().
          domain(domainValues).
          range(xsc1.origRange).
          rangeBands(leafRanges).
          rangeBand(xsc1.bandwidth());

          newscaleObj.origRange = xsc1.origRange;
          newscaleObj.outerPaddingPx = xaxes.scale.outerPaddingPx;
          xaxes.rangeScale = newscaleObj;
          xaxes.rangeScale.outerPaddingPx = newscaleObj.outerPaddingPx;
          xaxes.scale = newscaleObj;
          xaxes.scale.outerPaddingPx = newscaleObj.outerPaddingPx;
          chartObj.axes.x.leafScaleGrid = newscaleObj;
          chartObj.axes.x.leafScaleGrid.outerPaddingPx = newscaleObj.outerPaddingPx;
          // chartObj.axes.x.dynamicScale = newscaleObj;
        }
        /*
        Find ranges for column branches
        */
        var rangeScaleUtils = hierarchical.setScaleForRange(chartObj.axes.x.rangeScale);
        hierarchical.pivotLayout.setRanges('column', rangeScaleUtils);
        /*
        Generate scale for column branches
         */
        for (var i = 0; i < levels; i++) {
          if (!xaxes.levels[i]) {
            xaxes.levels[i] = {};
          }
          xaxes.levels[i].scale = scaleFunc(
          chartObj,
          processor,
          plotarea,
          xaxes.orient,
          i + columnList.getLeavesCount(),
          dataset,
          'x',
          extent,
          null);

        }
      }
      /*
         Find leaf scales
          */
      var hasSplitLeavesColumns = chartObj.systemConf.chart.axes.xaxis.splitLeaves,
        reversed = chartObj.systemConf.chart.axes.xaxis.reversed,
        firstColumnCategoryCount = columnList.getLeavesCount();

      if (hasSplitLeavesColumns && columnCount) {
        var uniformLeafScale = chartObj.systemConf.chart.axes.xaxis.uniformLeafScale,
          uniqueDomainList = datatype == ORDINAL_DATATYPE ? columnList.getUniqueDomainForCluster(0) : null;
        var leafScale = scale.getScale(chartObj, dataObject, plotarea, xaxes.orient, null, dataset, 'x', uniqueDomainList);
        var parentLeafColumnIndex = 0,
          parentLeafColumnScale = columnCount ? xaxes.levels[parentLeafColumnIndex].scale : null;
        var isHorizontal = xaxes.orient == 'top' || xaxes.orient == 'bottom',
          plotRangeSign = isHorizontal ? 1 : -1,
          tempRange = isHorizontal ? 0 : plotarea.height,
          co = 0;

        //calculate outerpaddingpx for leafscale
        var leafscale_outerpaddingPX;

        for (var k = 0; k < firstColumnCategoryCount; k++) {
          var domain = datatype == ORDINAL_DATATYPE ? columnList.getDomainForClusterSet(0, k) : null,
            leafSize = uniformLeafScale ? columnList.leafSize : columnList.nonUniformLeafSize[k],
            rangeCopy = [tempRange, tempRange + plotRangeSign * leafSize];
          tempRange = tempRange + plotRangeSign * leafSize;
          var correctionFactor = 0.1,
            diff = mathAbs(rangeCopy[1] - rangeCopy[0]),
            correction = diff * correctionFactor,
            startRangeSign = isHorizontal ? 1 : -1;
          rangeCopy = [rangeCopy[0] + startRangeSign * correction, rangeCopy[1] - startRangeSign * correction];
          if (reversed) {
            rangeCopy = rangeCopy.reverse();
          }
          if (!xaxes.leaves[co]) {
            xaxes.leaves[co] = {};
          }

          var leafScaleCopy = uniformLeafScale ?
          leafScale :
          scale.getScale(chartObj, dataObject, plotarea, xaxes.orient, null, dataset, 'x', domain);

          xaxes.leaves[co].scale = leafScaleCopy.copy().range(rangeCopy);
          xaxes.leaves[co].scale.origRange = rangeCopy;
          xaxes.leaves[co].parentBranchIdx = k;

          if (!leafscale_outerpaddingPX) {
            var leafscale_domain = leafScale.domain(),
              padding = leafScale.padding,
              outerPadding = leafScale.outerPadding;
            var d3_outerPadding = scale.getOuterPadding(rangeCopy, leafscale_domain.length, padding, outerPadding);
            var range_correction = getRangeWithOuterPaddingCorrection(
            chartObj,
            'x',
            0,
            leafscale_domain,
            rangeCopy,
            padding,
            outerPadding,
            d3_outerPadding);

            xaxes.leaves[co].scale.outerPaddingPx = range_correction.outerPaddingPx || 0;
          }
          co++;
        }
        return xaxes.leaves.concat(xaxes.levels);
      }

      return [
      {
        scale: chartObj.axes.x.leafScaleGrid
      }].
      concat(xaxes.levels);
    };
    scale.getEventScale = function (chartObj, dataObj, plotarea, orient, index, dataset, type) {
      var datatype = dataset.getDataType(type, index);
      var scaleObj;
      switch (datatype) {
        default:
          scaleObj = scale.getScale(chartObj, dataObj, plotarea, orient, index, dataset, type); //No I18N ;
      }
      return scaleObj;
    };
    scale.constructor = function (chartObj, orient, scaleFunc, eventscaleFunc) {
      var scaleObj;
      var defaultscaleFunc = scale.getScale,
        defaulteventscaleFunc = scale.getEventScale,
        scaleFunc = pick(scaleFunc, defaultscaleFunc),
        eventscaleFunc = pick(eventscaleFunc, defaulteventscaleFunc);

      switch (orient) {
        case 'left':
          scaleObj = chartObj.axes.rotated ? getxscale() : getyscale();
          break;
        case 'bottom':
          scaleObj = chartObj.axes.rotated ? getyscale() : getxscale();
          break;}

      return scaleObj;

      function getxscale() {
        var processor = chartObj.dataObject,
          hierarchical = processor.hierarchical,
          extent = chartObj.viewPortExtent,
          xaxes = chartObj.axes.x,
          dataObject = chartObj.dataObject,
          plotarea = chartObj.plotarea,
          dataset = chartObj.dataset;

        chartObj.axes.x.scale = scaleFunc(chartObj, dataObject, plotarea, xaxes.orient, 0, dataset, 'x', extent);
        chartObj.axes.x.eventscale =
        eventscaleFunc == null ?
        chartObj.axes.x.scale :
        eventscaleFunc(chartObj, dataObject, plotarea, xaxes.orient, null, dataset, 'x'); //No I18N
        // if(extent){
        //     chartObj.viewPortExtent = chartObj.axes.x.scale.domain();
        //     if(chartObj.scroll.scrollDomain){
        //         chartObj.scroll.scrollDomain = chartObj.viewPortExtent;
        //     }
        // }
        if (defined(hierarchical)) {
          /*
          set leafscale or rangescale for groupbyTime layout
           */
          return scale.setColumnScale(chartObj, 'x');
        }

        return [
        {
          scale: chartObj.axes.x.scale
        }].
        concat(xaxes.levels);
      }

      function getyscale() {
        var processor = chartObj.dataObject,
          hierarchical = processor.hierarchical;
        var splityaxes = hierarchical && hierarchical.categoryTree ? 1 : chartObj.axes.y.count;
        var yaxes = chartObj.axes.y;
        for (var i = 0; i < splityaxes; i++) {
          if (!yaxes.groups[i]) {
            yaxes.groups[i] = {};
          }
          yaxes.groups[i].scale = scaleFunc(
          chartObj,
          chartObj.dataObject,
          chartObj.plotarea,
          chartObj.axes.y.orient,
          i,
          chartObj.dataset,
          'y');

          yaxes.groups[i].eventscale =
          eventscaleFunc == null ?
          yaxes.groups[i].scale :
          eventscaleFunc(chartObj, chartObj.dataObject, chartObj.plotarea, chartObj.axes.y.orient, i, chartObj.dataset, 'y');
        }

        if (hierarchical && hierarchical.categoryTree) {
          var rowList = hierarchical.pivotLayout.getRootNodeList('row'),
            rowCount = rowList.getCount(),
            _hasMultiCluster4 = rowList.hasMultiCluster();

          if (rowCount || _hasMultiCluster4) {
            if (chartObj.axes.rotated) {
              scale.setRowScale(chartObj, 'row', true);
            }
            if (rowCount) {
              return chartObj.axes.y.leaves.concat(chartObj.axes.y.branches);
            }
            return chartObj.axes.y.leaves;
          }
          return chartObj.axes.y.groups;
        }
        return chartObj.axes.y.groups;
      }
    };
    scale.invert = function (
    datatype,
    mousePos,
    scaleObj,
    axisrotated,
    type,
    axisReversed,
    useWithinBound,
    rangeSelection)

    {var checkForEmptySelection = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;
      var actualPos;
      switch (datatype) {
        case 'numeric':
        case 'time':
          var point = type == 'y' ? axisrotated ? mousePos.x : mousePos.y : axisrotated ? mousePos.y : mousePos.x;
          actualPos = scaleObj.invert(point);
          break;
        case 'ordinal':
          var ordinalRange = getOrdinalRange(scaleObj),
            rangeBand = scaleObj.bandwidth(),
            maxBandwidth = scaleObj.maxBandWidth,
            actualWidth = maxBandwidth ? mathMin(rangeBand, maxBandwidth) : rangeBand,
            diffRange = ordinalRange.length > 1 ? mathAbs(ordinalRange[1] - ordinalRange[0]) : 0,
            actualPadding = mathAbs(diffRange - actualWidth),
            padding_maxBandwidth = maxBandwidth && maxBandwidth < rangeBand ? (rangeBand - actualWidth) / 2 : 0,
            sign = axisrotated && !axisReversed ? 1 : -1,
            correction = axisrotated && !axisReversed ? actualWidth : 0,
            validator = axisrotated && !axisReversed ? '<' : '>',
            outspace = 0;
          if (maxBandwidth && scaleObj.bandwidth() > maxBandwidth) {
            outspace = (scaleObj.bandwidth() - maxBandwidth) / 2;
          }

          ordinalRange = ordinalRange.map(function (d) {
            if (rangeSelection) {
              return d + outspace;
            }
            return d + correction + sign * actualPadding / 2;
          });
          var bisectVal = type == 'y' ? axisrotated ? mousePos.x : mousePos.y : axisrotated ? mousePos.y : mousePos.x;
          actualPos = getBisectedValue(mousePos, ordinalRange, type, axisrotated, axisReversed, validator);
          var x = scaleObj.ordinalRange[actualPos] + padding_maxBandwidth;
          if (useWithinBound && !isWithinRange$1(bisectVal, [x, x + actualWidth])) {
            actualPos = null;
          }
          if (rangeSelection) {
            actualPos = adjustActualPos(
            rangeSelection,
            actualPos,
            ordinalRange,
            axisReversed,
            axisrotated,
            actualPadding,
            validator,
            type,
            mousePos,
            checkForEmptySelection);

          }
          break;}

      return actualPos;
    };
    function adjustActualPos(
    rangeSelection,
    actPos,
    ordinalRange,
    axisReversed,
    axisrotated,
    actualPadding,
    validator,
    type,
    mousePos,
    checkForEmptySelection)
    {
      var _s = rangeSelection.range,
        curr_Pos = ordinalRange[actPos],
        next_Pos = ordinalRange[actPos + 1],
        prev_Pos = ordinalRange[actPos - 1],
        barWidth =
        (axisReversed || axisrotated) && !(axisReversed && axisrotated) ?
        ordinalRange[0] - actualPadding - ordinalRange[1] :
        ordinalRange[1] - actualPadding - ordinalRange[0],
        val = type == 'y' ? axisrotated ? mousePos.x : mousePos.y : axisrotated ? mousePos.y : mousePos.x,
        rangeIdx = rangeSelection.index,
        _ = function _(actPos, pos) {
          if (ordinalRange[pos]) {
            return pos;
          }
          return actPos;
        },
        rangeStart = defined(rangeIdx) && !rangeIdx,
        rangeEnd = defined(rangeIdx);
      if (rangeStart) {
        if (axisrotated && !axisReversed) {
          actPos = val < next_Pos + barWidth ? _(actPos, ++actPos) : actPos;
        }
        if (validator === '>') {
          if (!axisrotated && axisReversed) {
            actPos = val > curr_Pos + barWidth ? _(actPos, --actPos) : val < next_Pos ? _(actPos, ++actPos) : actPos;
          } else {
            actPos = val > curr_Pos + barWidth ? _(actPos, ++actPos) : actPos;
          }
        }
      } else if (rangeEnd) {
        if (!axisrotated && axisReversed) {
          actPos = val < curr_Pos && _s[0] < curr_Pos ? _(actPos, ++actPos) : actPos;
        } else if (val < curr_Pos && !axisReversed) {
          actPos = axisrotated ? _(actPos, ++actPos) : prev_Pos ? _(actPos, --actPos) : actPos;
        }
      }
      if (checkForEmptySelection) {
        var _isEmptySelection = isEmptySelection(rangeSelection.range, ordinalRange, actPos, barWidth);
        if (_isEmptySelection) {
          rangeIdx ? actPos = -1 : actPos = 0;
        }
      }
      return actPos;
    }
    function isEmptySelection(selection, ordinalRange, actPos, barWidth) {
      var _s = selection[0], //start
        _e = selection[1], //end
        curr_Pos = ordinalRange[actPos],
        next_Pos = ordinalRange[actPos + 1],
        prev_Pos = ordinalRange[actPos - 1],
        curr_Pos_end = curr_Pos + barWidth,
        next_Pos_end = next_Pos + barWidth,
        prev_Pos_end = prev_Pos + barWidth;
      function isWithin(_d, start, end) {
        if (_d >= start && _d <= end) {
          return true;
        }
        return;
      }
      if (
      isWithin(curr_Pos, _s, _e) ||
      isWithin(curr_Pos_end, _s, _e) ||
      isWithin(next_Pos, _s, _e) ||
      isWithin(next_Pos_end, _s, _e) ||
      isWithin(prev_Pos, _s, _e) ||
      isWithin(prev_Pos_end, _s, _e) ||
      isWithin(_s, curr_Pos, curr_Pos_end) ||
      isWithin(_e, curr_Pos, curr_Pos_end))
      {
        return false;
      }
      return true;
    }

    scale.ordinalSubInvert = function (mousePos, itemPos, scaleObj, primaryScale, axisrotated, type, axisReversed) {
      var rangeBand = scaleObj.bandwidth(),
        range = scaleObj.range(),
        primaryRange = primaryScale.ordinalRange,
        domain = scaleObj.domain(),
        range_diff = range[1] - range[0],
        padding = range_diff - domain.length * rangeBand,
        ordinalRange = domain.map(function (d, i) {
          return primaryRange[itemPos] + i * (rangeBand + padding);
        }),
        insertionPos = getBisectedValue(mousePos, ordinalRange, type, axisrotated, axisReversed);
      return insertionPos;
    };
    function getBisectedValue(mousePos, arr, type, axisrotated, axisReversed, validator) {
      var bisectVal = type == 'y' ? axisrotated ? mousePos.x : mousePos.y : axisrotated ? mousePos.y : mousePos.x,
        orient = getAxisOrient(type, axisrotated),
        defaultReverse = orient == LEFT_ALIGN,
        rangeReversed = axisReversed ? !defaultReverse : defaultReverse,
        comparator = rangeReversed ? d3_descending : d3_ascending,
        endPos = arr.length - 1;
      return bisectArray(bisectVal, arr, comparator, endPos, validator);
    }
    scale.barBandwidth = function (chartObj) {
      var systemconf = chartObj.systemConf,
        dataObj = chartObj.dataObject;
      var temp = getFirstAxisChartType(chartObj),
        allChartTypes = chartObj.dataset.seriesTypes,
        barType =
        dataObj.barChartType || (
        dataObj.noofBarEnabledSeries ?
        allChartTypes.has(charttype.stkdbar) ?
        charttype.stkdbar :
        allChartTypes.has(charttype.bar) ?
        charttype.bar :
        allChartTypes.has(charttype.bullet) ?
        charttype.bullet :
        allChartTypes.has(charttype.waterfall) ?
        charttype.waterfall :
        temp :
        temp);
      dataObj.barChartType = barType;
      var axisView = getAxisViewModel(chartObj, 'x', chartObj.axes.x.orient, 0),
        subBandCount;
      if (axisView && axisView.scale) {
        subBandCount = axisView.scale.conf.subBand;
      }
      var m;
      if (dataObj.isstacked(barType)) {
        //#ZC1346
        var stackTransform = dataObj.getEncode('stack'),
          check = function check(stackData) {return isBarEnabled.call(dataObj, stackData.seriesData[0]);};

        m = dataObj.categoryHierarchy ? 1 : objectValues(stackTransform).filter(check).length || 1; // length = 0 for continuous chart with ordinal scale
      } else if (dataObj.hierarchical && dataObj.hierarchical.pivotLayout.getRootNodeList('row').hasMultiCluster()) {
        m = 1;
      } else {
        m = pick(subBandCount, getBandCount(chartObj));
      }

      var cType = charttypenames.get(temp);
      var isBullet = temp == charttype.bullet;

      var plotBorderOptions = systemconf.chart.plot.border;
      var borderSize = plotBorderOptions.show === true ? plotBorderOptions.size : 0;
      var padding =
      cType == 'gantt' || cType == 'bullet' || cType == 'bar' || cType == 'waterfall' || cType == 'boxplot' || cType == 'barrange' ?
      systemconf.chart.plot.plotoptions[cType].padding || 0.2 :
      0.2;
      var interPadding =
      m == 1 ?
      0 :
      cType == 'bar' || cType == 'gantt' || cType == 'waterfall' || cType == 'boxplot' || cType == 'barrange' ?
      systemconf.chart.plot.plotoptions[cType].interPadding || 0 :
      0;

      var outerPadding = systemconf.chart.plot.plotoptions[cType].outerPadding;
      outerPadding = outerPadding != null && outerPadding !== '' ? outerPadding : 0.02;
      var n = chartObj.axes.x.scale.domain().length; //chart.dataObject.getCategories("x").length;
      var range = !chartObj.axes.rotated ?
        [borderSize, getPlotSize(chartObj, 'width', chartObj.plotarea) - borderSize] :
        [getPlotSize(chartObj, 'height', chartObj.plotarea) - borderSize, borderSize],
        barscale1,
        barscale2;

      outerPadding = scale.getOuterPadding(range, n, padding, outerPadding);

      chartObj.barscale1 = barscale1 = chartObj.axes.x.leaves.length ? chartObj.axes.x.leaves[0].scale : chartObj.axes.x.scale;
      chartObj.barscale2 = barscale2 = d3_scaleOrdinal().
      domain(d3_range(m)).
      range([0, barscale1.bandwidth()]).
      paddingInner(interPadding);

      //setting bandwidth if the actual bandwidth is greater than the maximum bar bandwidth
      // barscale2.rangeBands([0, barscale1.bandwidth()], interPadding);
      var maxBandWidth_cp = invokeFunction(systemconf.chart.plot.plotoptions[cType].maxBandWidth, barscale1, chartObj);
      maxBandWidth_cp = maxBandWidth_cp < 0 ? null : maxBandWidth_cp;
      var maxBandWidth = dataObj.noofBarEnabledSeries && !isBullet ? maxBandWidth_cp || barscale1.bandwidth() : 200;

      barscale1.maxBandWidth = m * maxBandWidth_cp;
      if (!isBullet && barscale2.bandwidth() > maxBandWidth) {
        var outspace = (barscale1.bandwidth() - m * maxBandWidth) / 2;
        barscale2.range([outspace, barscale1.bandwidth() - outspace]).paddingInner(interPadding);
      }
      scale.outspace = barscale2.range()[0];
      return [barscale1, barscale2];
    };

    scale.getOuterPadding = function (range, domainLength, padding, outerPadding) {
      var rangeDiff = mathAbs(range[1] - range[0]);
      var pad = outerPadding * rangeDiff;
      var step = (rangeDiff - 2 * pad) / (domainLength - padding + 2 * 0);
      return pad / step;
    };

    scale.getOrdinalOuterPadding = function (range, domainLength, padding, outerPadding) {
      var rangeDiff = mathAbs(range[1] - range[0]);
      var pad = outerPadding * rangeDiff;
      return pad / 2;
    };

    /**
     *
     * @param scale linear scale
     * @param points tick values
     * @returns {{outerPaddingInPixel, rangeBand: number}}
     */

    scale.getContinuousRangeBand = function (scaleObj, points, index) {
      var ranges = scaleObj.range(),
        firstPointSpan = scaleObj(points[0]),
        currentPointSpan = index && points[index] ? scaleObj(points[index]) : firstPointSpan,
        nextPointSpan = index && points[index + 1] ? scaleObj(points[index + 1]) : scaleObj(points[1] || points[0]),
        rangeBand = points.length == 1 ? (firstPointSpan - (firstPointSpan - ranges[0]) / 2) * 2 : nextPointSpan - currentPointSpan,
        // for axes rotated or axes reversed.
        correction = rangeBand < 0 ? -1 : 1;

      return {
        outerPaddingInPixel: correction * mathMin(mathAbs(firstPointSpan - ranges[0]), mathAbs(rangeBand / 2)),
        rangeBand: rangeBand / 2
      };
    };
    scale.getDiscreteRangeBand = function (scaleObj) {
      var rangeBand = scaleObj.bandwidth(),
        // rangeExtent = scaleObj.range(),
        outerPadding = scaleObj.outerPaddingPx + rangeBand / 2, //(scaleObj.range()[0] - rangeExtent[0])+(rangeBand/2),
        ordinalRange = getOrdinalRange(scaleObj),
        diffBand = scaleObj.domain().length > 1 ? ordinalRange[1] - ordinalRange[0] - rangeBand : 0,
        value_1 = rangeBand / 2 + diffBand / 2;
      return {
        outerPaddingInPixel: mathMin(outerPadding, value_1),
        rangeBand: value_1
      };
    };
    /*
    TODO Need to check both these function differs in value for hierarchy and axis
     */
    scale._getDiscreteRangeBand = function (scaleObj, index) {
      var rangeBand = scaleObj.bandwidth(),
        outerPadding = scaleObj.outerPaddingPx,
        ordinalRange = getOrdinalRange(scaleObj),
        hasOrdinalRange = isArray$1(ordinalRange) && ordinalRange.length > 1,
        startIdx = pick(index, 0),
        endIdx;
      if (hasOrdinalRange && startIdx == ordinalRange.length - 1) {
        //sort the indices in ascending order startIdx to endIdx
        endIdx = startIdx;
        startIdx = startIdx - 1;
      } else {
        endIdx = startIdx + 1;
      }
      // endIdx = hasOrdinalRange && startIdx == ordinalRange.length - 1 ? startIdx - 1 : startIdx + 1,
      var value_1 = hasOrdinalRange ? (ordinalRange[endIdx] - (ordinalRange[startIdx] + rangeBand)) / 2 : 0; // #ZC1156
      return {
        outerPaddingInPixel: mathMin(outerPadding, value_1),
        rangeBand: value_1
      };
    };
    scale.getRangeBand = function (scaleObj, points, index) {
      var rb;
      if (scaleObj.bandwidth) {
        rb = scale.getDiscreteRangeBand(scaleObj);
      } else {
        rb = scale.getContinuousRangeBand(scaleObj, points, index);
      }
      return rb;
    };

    function getCategoryStep(rangeband, padding) {
      return rangeband / (1 - padding);
    }

    function getOuterPaddingInPixel(plotSize, count, padding, userOuterPadding, step) {
      var outerPadding = scale.getOuterPadding(plotSize, count, padding, userOuterPadding),
        outerPaddingPx = 2 * (mathMin(plotSize[0], plotSize[1]) + step * outerPadding);
      return outerPaddingPx;
    }

    function getRangeWithOuterPaddingCorrection(chartObj, type, index, domain, range, padding, userOuterPadding, userOuterPadding_d3) {
      var outerPaddingPx = 0,
        outerPaddingPx_others = 0,
        outerPaddingPx_user = 0;
      var min2Max = range[0] < range[1];
      var minPos = min2Max ? 0 : 1,
        maxPos = min2Max ? 1 : 0;

      // For bubble, datalabels, marker correction
      outerPaddingPx_others = chartObj.dataObject.extendOuterpadding(
      domain,
      range,
      chartObj.systemConf,
      padding,
      userOuterPadding_d3,
      type,
      index);

      outerPaddingPx += outerPaddingPx_others;

      //For user given outerpadding
      var diff = mathAbs(range[1] - range[0]);
      outerPaddingPx_user = diff * userOuterPadding;
      outerPaddingPx += outerPaddingPx_user;

      //Outerpadding corrections in range
      range[minPos] = range[minPos] + outerPaddingPx;
      range[maxPos] = range[maxPos] - outerPaddingPx;

      return { range: range, outerPaddingPx: outerPaddingPx };
    }

    /**
     * it's a function to receive all ranges of a ordinal scale equivalent to d3_ordinal_scale.range() in ~d3.v3
     * @param scaleObj d3 ordinal scale
     * @returns {[Number]}
     */
    function getOrdinalRange(scaleObj) {
      return scaleObj.ordinalRange || (scaleObj.ordinalRange = scaleObj.domain().map(function (d) {return scaleObj(d);}));
    }

    function getActualRange(scaleObj) {
      return scaleObj.actualRange || (scaleObj.actualRange = scaleObj.originalDomain && scaleObj.originalDomain.map(scaleObj));
    }

    function isBarEnabled(series) {
      //Trash
      var helpers = DataProcessor.helpers,
        cType = helpers.getChartType(series.type || this.globalChartType, NUMERIC_DATATYPE);
      return !series.disabled && isBarChartType(cType);
    }

    function getBandCount(chartObj) {
      var dataObj = chartObj.dataObject;
      if (isFacet(chartObj) && dataObj.isCombinationalChart) {
        var gridList = getGridList(chartObj.dataObject);

        return d3_max(gridList, function (grid) {
          var data = grid.data;

          return data.reduce(function (prev, cur) {
            return prev + (isBarEnabled.call(dataObj, cur.node) ? 1 : 0);
          }, 0);
        });
      } else {
        return d3_sum(
        chartObj.seriesdata.map(function (d) {
          if (isBarEnabled.call(dataObj, d)) {
            return d.data.length;
          }
        }));
        // no of series
      }
    }

    /**
     *
     * @param chart
     * @param type
     * @param index
     * @return {{}|{nullAs: number}|*}
     */
    function getAxisOptions(chart, type, index) {
      if (type === 'x') {
        return getAxisData(chart, type, index, false);
      } else if (type === 'clr') {
        return chart.systemConf.legend.colorBand;
      } else {
        if (chart.dataObject.hierarchical) {
          var axisOrder = getLeafAxisOrder(index, null, 'y', chart);
          return chart.systemConf.chart.axes.yaxis[axisOrder];
        }
        return getAxisData(chart, type, index, false);
      }
    }
    function isPolarType(chartObj, type, index) {
      var cType = chartObj.chartTypes[0].name,
        // isPolar = (cType === 'dial' && type === 'y') || (cType === 'web' && type === 'x');
        isPolar = cType === 'dial' && type === 'y' || cType === 'web' && type === 'x' && !chartObj.dataObject.hierarchical;

      if (isPolar) {
        var hierarchical = chartObj.dataObject.hierarchical;
        if (hierarchical) {
          var nodeList = hierarchical.pivotLayout.getRootNodeList(type == 'x' ? 'column' : 'row');
          if (index >= nodeList.getLeavesCount()) {
            isPolar = false;
          }
        }
      }
      return isPolar;
    }
    /**
     *
     * @param chartObj
     * @param type
     * @param orient
     * @param axisReversed
     * @return {(number)[]|string|{optionsText: [string, string, string, string]}|[]|*[]|number[]}
     */
    function getRange(chartObj, type, orient, axisReversed, index) {
      var cType = charttypenames.get(getFirstAxisChartType(chartObj)),
        plotarea = chartObj.plotarea,
        isPolar = cType === 'dial' && type === 'y' || cType === 'web' && type === 'x' && !chartObj.dataObject.hierarchical;

      if (isPolar) {
        var hierarchical = chartObj.dataObject.hierarchical;
        if (hierarchical) {
          var nodeList = hierarchical.pivotLayout.getRootNodeList(type == 'x' ? 'column' : 'row');
          if (index >= nodeList.getLeavesCount()) {
            isPolar = false;
          }
        }
      }

      if (isPolar) {
        return getPolarRange(chartObj, type);
      } else if (type === 'clr') {
        return chartObj.imagePallete || chartObj.seriesColor;
      } else {
        // return fixRangeDirection([0, getPlotSize(chartObj, topBottom ? 'width' : 'height', plotarea)], orient, axisReversed);

        return axisReversed ?
        orient === 'bottom' || orient == 'top' ?
        [getPlotSize(chartObj, 'width', plotarea), 0] :
        [0, getPlotSize(chartObj, 'height', plotarea)] :
        orient === 'bottom' || orient == 'top' ?
        [0, getPlotSize(chartObj, 'width', plotarea)] :
        [getPlotSize(chartObj, 'height', plotarea), 0];
      }
    }

    /**
     *
     * @param dataset
     * @param type
     * @param index
     */
    function getContinuousScale(dataset, type, index) {
      var column = dataset.getColumn(type, index),
        scaleType = column.scaleType || 'linear';

      return getD3Scale(scaleType);
    }

    function getD3Scale(scaleType) {
      var scaleMode;

      if (scaleType === 'log') {
        scaleMode = d3_scaleSymlog;
      } else if (scaleType === 'sqrt') {
        scaleMode = d3_scaleSqrt;
      } else {
        scaleMode = d3_scaleLinear;
      }

      return scaleMode;
    }

    function getFirstAxisChartType(chartObj) {
      var axisChartType = chartObj.chartTypes[0].value;

      if (isFacet(chartObj)) {
        var gridList = getGridList(chartObj.dataObject);

        gridList.some(function (grid) {
          var paneid = "".concat(grid.row, "_").concat(grid.column),
            chartType = getChartTypeByIndex(chartObj, paneid, 0).value;

          if (isCategoryOf(chartObj, chartType, 'axis')) {
            axisChartType = chartType;
            return true;
          }
        });
      }

      return axisChartType;
    }

    /**
     *
     * @param obj tick label object or axis label object
     * @param p plotarea
     * @returns {{vertical: *, horizontal: *}}
     */
    function getMaxTickSize(obj, p) {
      return {
        vertical: perToPx(pick(obj.height, obj.maxHeight, axis.ticks.maxTickSizeRatio_Vert), p.height),
        horizontal: perToPx(pick(obj.width, obj.maxWidth, axis.ticks.maxTickSizeRatio_Hori), p.width)
      };
    }

    /**
     * Check if the formatter is specified to auto
     *
     * @param {Object} formatConf
     * @returns {boolean}
     */

    function hasAutoFormat(formatConf) {var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'axis';
      var format = formatConf != null ? formatConf["".concat(type, "format")] || formatConf.format : null;
      return format && format.specifier === 'auto';
    }

    function distBetweenRotatedRect(rotation, width, height, orient) {
      var ang1 = rotation * (mathPI * 2 / 360);
      var ang2 = (90 - rotation) * (mathPI * 2 / 360);

      if (orient === 'bottom' || orient === 'top') {
        return {
          tickSpacing: mathAbs(height / mathSin(ang1)) + 5,
          baseLen: 0
        };
      } else {
        var len1 = mathAbs(mathSin(ang2) * height);
        var len2 = mathAbs(mathCos(ang2) * height * mathTan(ang1));
        return {
          tickSpacing: len1 + len2 + 5,
          baseLen: mathAbs(mathCos(ang2) * width)
        };
      }
    }

    function doTicksOverlaps(a, b, rotation, orient) {
      var bbox_a = a.getBoundingClientRect(),
        bbox_b = b.getBoundingClientRect();

      if (rotation) {
        var _bbox2 = b.getBBox();
        var spacing = distBetweenRotatedRect(rotation, _bbox2.width, _bbox2.height, orient);

        if (mathAbs(bbox_a.x - bbox_b.x) <= spacing.tickSpacing - 5) {
          return true;
        } else {
          return false;
        }
      } else {
        var bbox1 = {
            x1: bbox_a.left,
            x2: bbox_a.left + bbox_a.width,
            y1: bbox_a.top,
            y2: bbox_a.top + bbox_a.height
          },
          bbox2 = {
            x1: bbox_b.left,
            x2: bbox_b.left + bbox_b.width,
            y1: bbox_b.top,
            y2: bbox_b.top + bbox_b.height
          };
        return doOverlap(bbox1, bbox2);
      }
    }

    function formatTickWrapByMode(tick, mode, maxWidth, maxHeight, fontHeight) {
      if (tick == null) {
        return tick;
      }
      if (mode == 'wrapOnSpace') {
        return tick.split(' ');
      } else if (mode == 'wrapAll') {
        return wordWrap(tick, maxWidth, maxHeight, fontHeight);
      } else {
        return tick;
      }
    }

    /**
     *
     * @param num
     * @param base
     * @param allowNonPositive
     * @return {number}
     */
    function logBase(num) {var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;var allowNonPositive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isNegative = num < 0;

      if (allowNonPositive) {
        if (num === 0) {
          return num;
        }
        num = Math.abs(num);
        if (num < base) {
          num += (base - num) / base;
        }
      }

      var result = fixFloatingPoint(Math.log(num) / Math.log(base), 14);
      return isNegative ? -result : result;
    }

    Registry.setComponent('logUtils.logBase', logBase);

    /**
     *
     * @param num
     * @param base
     * @param allowNonPositive
     * @return {number}
     */
    function logArgument(num) {var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;var allowNonPositive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var isNegative = num < 0;
      var result = Math.pow(base, num);

      if (allowNonPositive) {
        result = Math.pow(base, Math.abs(num));
        if (result < base) {
          result = base * (result - 1) / (base - 1);
        }
        result = isNegative ? -result : result;
      }

      return fixFloatingPoint(result, 12);
    }

    Registry.setComponent('logUtils.logArgument', logArgument);

    /**
     *
     * @param number
     * @param precision
     * @return {number}
     */
    function fixFloatingPoint(number) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;
      return parseFloat(number.toPrecision(precision));
    }

    Registry.setComponent('logUtils.fixFloatingPoint', fixFloatingPoint);

    /**
     *
     * @param num
     * @param base
     * @param allowNonPositiveTicks
     * @return {number}
     */
    function getMagnitude(num) {var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;var allowNonPositiveTicks = arguments.length > 2 ? arguments[2] : undefined;
      var isNegative = num < 0;
      if (allowNonPositiveTicks) {
        num = mathAbs(num);
      }

      var exp = Math.floor(logBase(num, base, allowNonPositiveTicks), 14);

      return isNegative ? -Math.pow(base, exp) : Math.pow(base, exp);
    }

    Registry.setComponent('logUtils.getMagnitude', getMagnitude);

    /**
     *
     * @type {number}
     */
    var INTERVAL_FACTOR = 1.5;

    /**
     *
     * @param domain
     * @param axisSize
     * @param dataMinMax
     * @param usePadding
     * @param axis
     * @param scale
     * @param margin
     * @param styles
     * @param format
     * @param orient
     * @param rotation
     * @param adjustToBase
     * @param addMinMaxLog
     * @param hasFixedPosition
     * @param dataDomain
     * @return {{minorTickValues: [], tickValues: *}|{logDomain: *, minorTickValues: [], tickValues: *}}
     */

    function getLogTicks(
    domain,
    axisSize,
    dataMinMax,
    usePadding,
    axis,
    scale,
    margin,
    styles,
    format,
    orient,
    rotation,
    adjustToBase,
    addMinMaxLog,
    hasFixedPosition,
    dataDomain)
    {
      var minRange = axis.minRange,maxRange = axis.maxRange,userTickInterval = axis.interval,_axis$logBase = axis.logBase,base = _axis$logBase === void 0 ? 10 : _axis$logBase,padding = axis.outerPadding,userTickCount = axis.tickCount,
        minorGridOptions = axis.minorGrid || {},
        subTickMarkOptions = axis.subtickmark || {},
        showMinorGrid = minorGridOptions.show === true,
        allowNonPositiveTicks = axis.allowNonPositiveTicks !== false,
        minorGridCount = minorGridOptions.count,
        minorGridInterval = minorGridOptions.interval,

        subTickCount = showMinorGrid ? pick(minorGridCount, subTickMarkOptions.count) : subTickMarkOptions.count,
        subTickInterval = showMinorGrid ? pick(minorGridInterval, subTickMarkOptions.interval) : subTickMarkOptions.interval,
        calculateMinorTicks = showMinorGrid || subTickCount > 0 || defined(subTickInterval),
        exponentToNumeric = function exponentToNumeric(exp) {return fixFloatingPoint(logArgument(exp, base, allowNonPositiveTicks), 12);};

      var _domain2 = _slicedToArray(domain, 2),min = _domain2[0],max = _domain2[1],
        forceUserTickCount,_dataMinMax = _slicedToArray(
        dataMinMax, 2),dataMin = _dataMinMax[0],dataMax = _dataMinMax[1],
        minPadding = usePadding && !defined(minRange) ? pick(padding, 0.05) : 0,
        maxPadding = usePadding && !defined(maxRange) ? pick(padding, 0.05) : 0,
        tickCount = pick(userTickCount, axisSize / 70),
        minorTickValues = [],
        args,
        tickValues,
        logDomain,
        isSingleTick = min === max;

      // tick count has priority
      // either interval or count
      if (defined(userTickCount) || !userTickInterval) {
        userTickInterval = UNDEFINED;
      }

      if (userTickCount < 4) {
        forceUserTickCount = userTickCount;
        tickCount = userTickCount = 5;
      }

      // get the log of the min max
      var logMin = logBase(min, base, allowNonPositiveTicks),
        logMax = logBase(max, base, allowNonPositiveTicks),
        diff = logMax - logMin || 1;

      // add the padding to the log value
      logMin -= diff * minPadding;
      logMax += diff * maxPadding;

      // Single Tick = test cases = FEATURES_LOGAXIS_45 CXZA & LOGAXIS_19
      if (logMin === logMax || dataDomain[0] === 0 && dataDomain[1] === 0) {
        return { tickValues: dataMinMax, minorTickValues: [] };
      }

      if (defined(adjustToBase)) {
        // Avoid unnecessary ticks because of axis padding
        // EG. for data [0.01] with 0.05% padding it would make -0.03993004518863 and when it is converted to linear number
        // it may be nearest base rounded to -1 which is negative -10
        if ((logMin < 0 || logMax < 0) && allowNonPositiveTicks) {
          if (logMin < adjustToBase && dataMin >= adjustToBase) {
            logMin = adjustToBase;
          } else if (logMax > adjustToBase && dataMax <= adjustToBase) {
            logMax = adjustToBase;
          }
        }
      }

      // construct the arguments
      args = {
        numberMin: min,
        numberMax: max,
        userTickCount: userTickCount,
        tickCount: tickCount,
        logMin: logMin,
        logMax: logMax,
        forceUserTickCount: forceUserTickCount,
        base: base,
        allowNonPositiveTicks: allowNonPositiveTicks,
        axisSize: axisSize,
        tickMultiples: axis.tickMultiples
      };

      // Math.pow(10, 309) is Infinity.
      if (isInfinity(mathPow(base || 10, userTickInterval))) {
        Console.warn("Log axis interval ".concat(userTickInterval, " is too large. Switching to the default interval."));
        userTickInterval = null;
      }

      var interval = pick(userTickInterval, (logMax - logMin) / Math.max(tickCount - 1, 1)),
        tickValuesCopy;
      tickValues = getTickValues(args, interval, styles, orient, scale, format, margin, rotation);
      tickValuesCopy = tickValues.slice(0);
      logDomain = d3_extent(tickValues);

      // #ZC2835 user ranges
      if (defined(minRange)) {
        logDomain[0] = minRange;
        tickValues = tickValues.filter(function (value) {return value >= min;});
      }
      if (defined(maxRange)) {
        logDomain[1] = maxRange;
        tickValues = tickValues.filter(function (value) {return value <= max;});
      }

      var tickValuesWithMinMax = addMinMaxLog(tickValues),
        fixSpace = true;

      if (tickValuesWithMinMax.length !== tickValues.length) {
        tickValues = tickValuesWithMinMax;
        fixSpace = false;
      }

      // get the padded min max
      min = exponentToNumeric(logMin);
      max = exponentToNumeric(logMax);

      // *************** SMART SPACING ******************
      if (
      !defined(userTickCount) &&
      !defined(forceUserTickCount) &&
      !defined(userTickInterval) &&
      fixSpace &&
      !isSingleTick &&
      tickValues.length > 3)
      {
        var _logDomain4 = logDomain,_logDomain5 = _slicedToArray(_logDomain4, 2),tickMin = _logDomain5[0],tickMax = _logDomain5[1],
          magMin = getMagnitude(min, base, allowNonPositiveTicks),
          magMax = getMagnitude(max, base, allowNonPositiveTicks),
          spaceMin = min - mathAbs(magMin) / 10,
          spaceMax = max + mathAbs(magMax) / 10,
          thresholdLimit = 40,

          pos = tickValues.map(scale),
          totalPointDistanceMax = pos[pos.length - 1] - pos[pos.length - 2],
          pointDistanceMax = scale(max),


          pointDistanceMaxRight = pos[pos.length - 1] - pointDistanceMax,


          distanceRightPercentMax = calculatePercentage(pointDistanceMaxRight, totalPointDistanceMax),

          totalPointDistanceMin = pos[1] - pos[0],
          pointDistanceMin = scale(min),

          pointDistanceMinLeft = pointDistanceMin - pos[0],


          distanceLeftPercentMin = calculatePercentage(pointDistanceMinLeft, totalPointDistanceMin);

        if (hasFixedPosition) {
          // ZC2805 data domain
          logDomain = domain;
          tickValues = tickValues.filter(function (value) {return value >= dataDomain[0] && value <= dataDomain[1];});
        } else if (distanceRightPercentMax > thresholdLimit || distanceLeftPercentMin > thresholdLimit) {
          if (distanceRightPercentMax > thresholdLimit && spaceMax < tickMax) {
            logDomain[1] = spaceMax;
          }

          if (distanceLeftPercentMin > thresholdLimit && spaceMin > tickMin) {
            logDomain[0] = spaceMin;
          }
          tickValues = tickValues.filter(function (value) {return value >= logDomain[0] && value <= logDomain[1];});
        }
      } else if (defined(args.useDefaultLogDomain)) {
        if (tickValues.every(function (tick) {return tick > min;})) {
          logDomain[0] = min;
        }

        if (tickValues.every(function (tick) {return tick < max;})) {
          logDomain[1] = max;
        }
      }

      if (calculateMinorTicks && !isSingleTick) {
        // TODO un-comment this line to fix
        // minorTickValues = getMinorTickValues(args, tickValuesCopy, logDomain, subTickCount, subTickInterval);
        // TODO tick values copy
        minorTickValues = getMinorTickValues(args, tickValues, logDomain, subTickCount, subTickInterval);
      }

      return { tickValues: tickValues, minorTickValues: minorTickValues, logDomain: logDomain };
    }

    /**
     *
     * @param args
     * @param interval
     * @param styles
     * @param orient
     * @param scale
     * @param format
     * @param margin
     * @param rotation
     * @param isSubTicks
     * @return {any}
     */
    function getTickValues(args, interval, styles, orient, scale, format, margin, rotation, isSubTicks) {
      args.interval = interval;

      var base = args.base,allowNonPositiveTicks = args.allowNonPositiveTicks,tickCount = args.tickCount,axisSize = args.axisSize,
        exponentToNumeric = function exponentToNumeric(exp) {return fixFloatingPoint(logArgument(exp, base, allowNonPositiveTicks), 12);};

      var tickExponents = getLogTickExponents(args, isSubTicks),
        tickValues = tickExponents.map(exponentToNumeric),
        logDomain = d3_extent(tickValues),
        formatted,
        textDimension = function textDimension(text) {
          var dimension = getTextBound(text, null, null, styles),
            width = getTickWidth('width', dimension, margin, rotation, styles.fontSize, orient),
            height = getTickWidth('height', dimension, margin, rotation, styles.fontSize, orient);

          return {
            width: width,
            height: height
          };
        };

      tickValues = d3_set(tickValues).
      values().
      map(Number).
      sort(d3_ascending);

      if (!isSubTicks) {
        formatted = format(tickValues);

        // scale
        scale.domain(logDomain);
        if (tickValues.length > tickCount && rotation === 'auto') {
          rotation = 45;
        }

        var bounds = tickValues.map(function (tick, i) {
          var x = 0,
            y = 0;
          if (orient === 'top' || orient === 'bottom') {
            x = scale(tick);
          } else {
            y = scale(tick);
          }

          return _objectSpread(_objectSpread({}, textDimension(formatted[i])), {}, { x: x, y: y, tick: formatted[i] });
        });

        if (rectOverlapsWithAnother(bounds)) {
          // when the tick overlaps with another tick, we double the interval and re-generate the values;
          return getTickValues(args, interval * INTERVAL_FACTOR, styles, orient, scale, format, margin);
        }
      }

      return tickValues;
    }

    Registry.setComponent('logTicks.getLogTickValues', getTickValues);

    /**
     *
     * @param rect1
     * @param rect2
     * @return {boolean}
     */
    function overlapsWith(rect1, rect2) {
      return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.height + rect1.y > rect2.y);

    }

    function rectOverlapsWithAnother(bounds) {
      var visibleTicks = [],
        overlaps = false;

      bounds.forEach(function (tick, i) {
        if (overlaps) {
          return;
        }
        if (!visibleTicks.length) {
          visibleTicks.push(tick);
        } else {
          if (!(overlaps = visibleTicks.some(function (visibleLabel) {return overlapsWith(tick, visibleLabel);}))) {
            visibleTicks.push(tick);
          }
        }
      });
      return overlaps;
    }

    /**
     *
     * @param args
     * @param tickValues
     * @param logDomain
     * @param minorGridCount
     * @param minorGridInterval
     * @return {*[]}
     */
    function getMinorTickValues(args, tickValues, logDomain, minorGridCount) {var minorGridInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'auto';
      var minorTickValues = [],_logDomain6 = _slicedToArray(
        logDomain, 2),min = _logDomain6[0],max = _logDomain6[1],
        minorTickInterval = minorGridInterval === 'auto' ? args.interval / 5 : minorGridInterval;

      if (minorGridCount > 0) {
        tickValues.forEach(function (value, index, array) {
          if (index) {
            var _min2 = mathMin(array[index - 1], value),
              _max2 = mathMax(array[index - 1], value),
              diff = _max2 - _min2,
              interval = diff / (minorGridCount + 1),
              steps = d3_range(_min2, _max2, interval);

            minorTickValues = [].concat(_toConsumableArray(minorTickValues), _toConsumableArray(steps));
          }
        });
      } else {
        var _args3 = args,base = _args3.base,allowNonPositiveTicks = _args3.allowNonPositiveTicks,
          exponentToNumeric = function exponentToNumeric(exp) {return fixFloatingPoint(logArgument(exp, base, allowNonPositiveTicks), 12);};

        args = _objectSpread({}, args);
        args.interval = minorTickInterval;
        args.isMinorGrid = true;

        tickValues.forEach(function (value, index) {
          if (index) {
            args.logMin = logBase(tickValues[index - 1], base, allowNonPositiveTicks);
            args.logMax = logBase(tickValues[index], base, allowNonPositiveTicks);

            var steps = getLogTickExponents(args, true);
            minorTickValues = [].concat(_toConsumableArray(minorTickValues), _toConsumableArray(steps));
          }
        });
        minorTickValues = minorTickValues.map(exponentToNumeric);
      }

      return minorTickValues.filter(function (d) {return !arrayIncludes(tickValues, d) && d >= min && d <= max;});
    }

    Registry.setComponent('logTicks.getMinorTickValues', getMinorTickValues);

    /**
     *
     * @param args
     * @param isSubTicks
     * @return {*[]}
     */
    function getLogTickExponents(args, isSubTicks) {
      var tickValues,
        logMin = args.logMin,logMax = args.logMax,tickCount = args.tickCount,interval = args.interval,base = args.base,allowNonPositiveTicks = args.allowNonPositiveTicks,userTickCount = args.userTickCount,isMinorGrid = args.isMinorGrid,tickMultiples = args.tickMultiples,
        isIntermediate = false;

      if (interval >= 0.5) {
        interval = Math.round(interval);
        tickValues = getNiceLinearTicks(logMin, logMax, interval);
      } else if (interval >= 0.1) {
        isIntermediate = true;
        tickValues = getIntermediateLogTicks(logMin, logMax, interval, base, allowNonPositiveTicks, isMinorGrid);
      } else {
        // #ZC2802
        var numberMin = logArgument(logMin, base, allowNonPositiveTicks),
          numberMax = logArgument(logMax, base, allowNonPositiveTicks),
          diffs = numberMax - numberMin,
          numericInterval = diffs / tickCount,
          // DEMO_AREA_3 - decimal places fix
          mag = numericInterval > 1 ? getMagnitude(numericInterval, base, allowNonPositiveTicks) : getMagnitude(numericInterval, base),
          multiples = tickMultiples || [1, 2, 2.5, 5, 10];

        if (userTickCount > 0) {
          tickValues = getLinearTicksByCount([numberMin, numberMax], tickCount);
          args.useDefaultLogDomain = true;
        } else {
          numericInterval = pick(args.autoSubTickInterval, nearestTickInterval(numericInterval, mag, multiples));
          tickValues = getNiceLinearTicks(numberMin, numberMax, numericInterval);
        }
        tickValues = tickValues.map(function (d) {return logBase(d, base, allowNonPositiveTicks);});

        if (!isSubTicks) {
          args.autoSubTickInterval = numericInterval / 5;
        }
      }

      // fix the min and max
      args.interval = interval;
      args.logMin = tickValues[0];
      args.logMax = tickValues[tickValues.length - 1];

      if (!isSubTicks && args.userTickCount > 0 && tickValues.length !== args.userTickCount) {
        // fix the user tick count
        args.extent = args.extent || d3_extent(tickValues);
        tickValues = getTickValuesByUserTickCount(tickValues, args, isIntermediate);
        tickValues = [].concat(_toConsumableArray(tickValues), _toConsumableArray(args.extent));
      }

      return tickValues;
    }

    Registry.setComponent('logTicks.getLogTickExponents', getLogTickExponents);
    /**
     *
     * @param logMin
     * @param logMax
     * @param interval
     * @param base
     * @param allowNonPositiveTicks
     * @param isMinorGrid
     * @return {[]}
     */

    function getIntermediateLogTicks(logMin, logMax, interval, base, allowNonPositiveTicks, isMinorGrid) {
      var roundedMin = mathFloor(logMin),
        roundedMax = mathCeil(logMax),
        intermediateFactors,
        pos,
        skip,
        tickValues = [],
        filter = false,
        ticks = [];

      if (interval > 0.3) {
        intermediateFactors = [1, 2, 4];
        // 0.2 equals five minor ticks per 1, 10, 100 etc
      } else if (interval > 0.15) {
        intermediateFactors = [1, 2, 4, 6, 8];
      } else {
        // 0.1 equals ten minor ticks per 1, 10, 100 etc
        intermediateFactors = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      }

      for (var i = roundedMin; i <= roundedMax + 1 && !skip; i++) {
        for (var j = 0; j < intermediateFactors.length && !skip; j++) {
          var val = void 0,
            checkMax = true;

          // #ZC2866 $ i + 1 in case of negative
          if (isMinorGrid && allowNonPositiveTicks && i < 0) {
            val = fixFloatingPoint(logArgument(i + 1, base, allowNonPositiveTicks)) * intermediateFactors[j];
            checkMax = false;
          } else {
            val = fixFloatingPoint(logArgument(i, base, allowNonPositiveTicks)) * intermediateFactors[j];
          }

          pos = logBase(val, base, allowNonPositiveTicks);

          if (pos >= roundedMin && pos <= roundedMax) {
            tickValues.push(pos);
            ticks.push(val);
          }

          if (checkMax && pos >= logMax) {
            skip = true;
          }
        }
      }

      // fix less than base both side
      if (ticks.some(function (v) {return v >= 0 && v <= base;})) {
        var positions = intermediateFactors.map(function (f) {return logBase(f, base, allowNonPositiveTicks);});
        tickValues = tickValues.concat(positions);
        filter = true;
      }

      if (ticks.some(function (v) {return v <= 0 && v >= -base;})) {
        var _positions = intermediateFactors.map(function (f) {return -logBase(f, base, allowNonPositiveTicks);});
        tickValues = tickValues.concat(_positions);
        filter = true;
      }

      if (filter) {
        tickValues = tickValues.filter(function (v) {return v >= roundedMin && v <= roundedMax;});
      }

      tickValues.sort(d3_ascending);

      var last = null;
      for (var _i23 = 0; _i23 < tickValues.length; _i23++) {
        var current = tickValues[_i23];
        if (current > logMin) {
          break;
        }
        last = current;
      }

      if (defined(last)) {
        tickValues = tickValues.splice(tickValues.lastIndexOf(last));
      }

      return tickValues;
    }

    Registry.setComponent('logTicks.getIntermediateLogTickExponents', getIntermediateLogTicks);
    /**
     *
     * @param tickValues
     * @param args
     * @return {*}
     */
    function getTickValuesByUserTickCount(tickValues, args, isIntermediate) {
      var tickInterval = args.interval,tickCount = args.tickCount,forceUserTickCount = args.forceUserTickCount,min = args.logMin,max = args.logMax,base = args.base,allowNonPositiveTicks = args.allowNonPositiveTicks,extent = args.extent;
      var currentTickCount = tickValues && tickValues.length,
        minValue = 0;

      var getIntermediateValue = function getIntermediateValue(side) {
        var v = side === -1 ? tickValues[tickValues.length - 1] + tickInterval : tickValues[0] - tickInterval,
          val = logArgument(fixFloatingPoint(v), base, allowNonPositiveTicks),
          mag = getMagnitude(val, base, allowNonPositiveTicks),
          v2 = side === -1 ? Math.ceil(val / mag) * mag : Math.floor(val / mag) * mag;

        return logBase(fixFloatingPoint(v2), base, allowNonPositiveTicks);
      };

      if (currentTickCount < tickCount) {
        while (tickValues.length < tickCount) {
          if (tickValues.length % 2 || minValue === min) {
            // to the end
            if (isIntermediate) {
              tickValues.push(getIntermediateValue(-1));
            } else {
              tickValues.push(fixFloatingPoint(tickValues[tickValues.length - 1] + tickInterval));
            }
          } else {
            if (isIntermediate) {
              tickValues.unshift(fixFloatingPoint(getIntermediateValue(1)));
            } else {
              // to the start
              tickValues.unshift(fixFloatingPoint(tickValues[0] - tickInterval));
            }
          }
        }
      } else if (currentTickCount > tickCount) {
        // double the interval and generate the ticks
        // args.interval *= INTERVAL_FACTOR;
        // tickValues = getLogTickExponents(args);

        tickValues = filterCategories(tickValues, tickCount);
      }

      if (defined(forceUserTickCount) && tickValues.length !== forceUserTickCount) {
        var _d3_extent3 = d3_extent(tickValues),_d3_extent4 = _slicedToArray(_d3_extent3, 2),_min3 = _d3_extent4[0],_max3 = _d3_extent4[1],
          _center = tickValues[Math.round(tickValues.length / 2)];

        if (forceUserTickCount === 2) {
          tickValues = [_min3, _max3];
        } else {
          tickValues = [_min3, _center, _max3];
        }
        args.forceUserTickCount = null;
      }

      tickValues = tickValues.filter(function (value) {return value >= extent[0] && value <= extent[1];});
      return tickValues;
    }

    Registry.setComponent('logTicks.getTickValuesByUserTickCount', getTickValuesByUserTickCount);

    /**
     *
     * @param min
     * @param max
     * @param interval
     * @return {*}
     */
    function getNiceLinearTicks(min, max, interval) {
      var roundedLogMin = fixFloatingPoint(Math.floor(min / interval) * interval),
        roundedLogMax = fixFloatingPoint(Math.ceil(max / interval) * interval),
        // d3 inclusive the interval for last tick
        maxInclusiveCorrection = interval / 2;

      return d3_range(roundedLogMin, roundedLogMax + maxInclusiveCorrection, interval);
      // return getLinearTicksByInterval([roundedLogMin, roundedLogMax + maxInclusiveCorrection], interval);
    }

    Registry.setComponent('logTicks.getNiceLinearTicks', getNiceLinearTicks);

    function isInfinity(number) {
      return number === Infinity || number === -Infinity;
    }

    //tick-labels.js

    /**
     *
     * @param {Object} obj
     * @returns {{top, right, bottom, left}}
     */

    function getRotation(obj) {
      var alignmentMode = obj.alignMode,
        isRotateMode = obj.alignMode && obj.alignMode.indexOf('rotate') != -1,
        isOldRotateMode = defined(obj.rotation),
        rotation = 0,
        hasPriorityOrder,
        autoRotation = 45,
        hasDefinedAutoRotation;
      if (isRotateMode) {
        var rotationExtract = /\(([^)]+)\)/.exec(alignmentMode);
        rotation = rotationExtract ? parseInt(rotationExtract[1]) : 'auto';
      } else if (isOldRotateMode && !defined(obj.alignMode)) {
        rotation = obj.rotation == 'auto' ? obj.rotation : parseInt(obj.rotation);
        alignmentMode = 'rotate', isRotateMode = true;
      } else if (Array.isArray(alignmentMode) && alignmentMode.length) {
        hasPriorityOrder = true;
        alignmentMode.some(function (d) {
          if (d.indexOf('rotate') != -1) {
            alignmentMode = 'rotate';
            isRotateMode = true;
            var rotationExtract = /\(([^)]+)\)/.exec(d);
            rotation = 'auto';
            hasDefinedAutoRotation = rotationExtract;
            autoRotation = rotationExtract ? parseInt(rotationExtract[1]) : autoRotation;
            return true;
          }
        });
      } else if (!defined(obj.alignMode)) {
        alignmentMode = 'rotate(0)', isRotateMode = true;
      }
      return {
        alignmentMode: alignmentMode,
        isRotateMode: isRotateMode,
        rotation: rotation,
        hasPriorityOrder: hasPriorityOrder,
        hasDefinedAutoRotation: hasDefinedAutoRotation,
        autoRotation: autoRotation
      };
    }

    /**
     *
     * @param {Array} categories
     * @param {Number} expectedCount
     * @param {Number} interval
     * @param {Boolean} filterByIndices
     * @returns {Array}
     */

    function filterCategories(categories, expectedCount, interval, filterIndex) {
      var actualCount = categories.length;
      expectedCount = mathRound(expectedCount);
      interval = interval || mathCeil(actualCount / mathAbs(expectedCount));
      var temp = 0;
      var tickvalues = [],
        tickvalueIndices = filterIndex ? [] : null,
        tickvalueNodes = filterIndex ? [] : null;
      var isHierarchyData = filterIndex ? defined(categories[0].index) : false;
      while (temp < actualCount) {
        if (filterIndex) {
          if (isHierarchyData) {
            tickvalues.push(categories[temp].value);
            tickvalueIndices.push(categories[temp].index);
            tickvalueNodes.push(categories[temp]);
          } else {
            tickvalues.push(categories[temp]);
            tickvalueIndices.push(temp);
            tickvalueNodes.push({ value: categories[temp], index: temp });
          }
        } else {
          tickvalues.push(categories[temp]);
        }
        temp = temp + interval;
      }

      if (filterIndex) {
        return {
          nodes: tickvalueNodes,
          ticks: tickvalues,
          indices: tickvalueIndices
        };
      } else {
        return tickvalues;
      }
    }

    /**
     *
     * @param formattedTickValues
     * @param tickConfig
     * @param columnInfo
     * @param {Chart} chart
     * @param {Number} columnIndex
     * @param {Number} levelIndex
     * @returns {{tickValues: Array, styles: Array, userRawTicks: Array}}
     */
    function getCustomTickValues(formattedTickValues, tickConfig, columnInfo, chart, columnIndex, levelIndex) {
      var parentArray = [],
        parentStyles = [],
        userTickValues = [];

      var userColumnInfo = {
        data: [columnInfo]
      };
      columnInfo.columnindex = pick(columnInfo.columnindex, columnIndex);

      formattedTickValues.forEach(function (d, i) {
        var userInput = invokeFunction(tickConfig.showAs, d, tickConfig, userColumnInfo, chart, i, levelIndex),
          childArray = [],
          styles = [];

        if (isArray$1(userInput)) {
          parentArray.push(childArray);
          parentStyles.push(styles);
        } else {
          childArray = parentArray;
          styles = parentStyles;
        }
        userTickValues.push(userInput);

        if (defined(userInput)) {
          // if (isArray(userInput)) {
          //     userInput = userInput.join('\n');
          // }
          // var sandBox = document.createElement('div');
          // sandBox.innerHTML = userInput;

          // let userInputWrapped = `<zc-temp>${userInput}</zc-temp>`,
          // sandBox = new DOMParser().parseFromString(userInputWrapped, 'text/xml');
          var sandBox = SVGDOMParser(userInput);

          var tspan = parseSVGElementsToArray(sandBox, 'tspan'),
            images = parseSVGElementsToArray(sandBox, 'image,img');

          if (tspan.length) {
            tspan.forEach(function (t) {
              childArray.push(t.textContent.trim());
              var style = t.style || {},
                attributes = t.attributes || {};
              styles.push({
                fontSize: style.fontSize && parseFloat(style.fontSize),
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                x: attributes.x,
                y: attributes.y,
                dy: attributes.dy
              });
            });
          } else if (!images.length) {
            childArray.push(userInput);
          }

          if (images.length) {
            toArray(sandBox.querySelectorAll('image,img')).forEach(function (t) {
              var style = t.style || {},
                attributes = t.attributes || {};
              childArray.push({
                width: +t.getAttribute('width'),
                height: +t.getAttribute('height')
              });
              styles.push({
                y: t.getAttribute('y'),
                dy: t.getAttribute('dy')
              });
            });
          }
          sandBox = null;
        }
      });

      return {
        tickValues: parentArray,
        styles: parentStyles,
        userRawTicks: userTickValues
      };
    }

    /**
     *
     * @param {Array} ticks formatted tick values
     * @param {Array} ticksOriginal raw tick values
     * @param {Number} fontSize font-size of the tick label
     * @param {String} fontFamily font-family of the tick label
     * @param {{fontFamily: string, fontSize: number, fontStyle: string}} styles
     * @param {Boolean} calculateAsArea
     * @returns {{actualVal: *, formattedVal: String}}
     */

    function getLongestTick$1(ticks, ticksOriginal, fontSize, fontFamily, styles, calculateAsArea, checkWhiteSpace) {
      /**
       * @type {CanvasRenderingContext2D} tempCanvasContext
       */
      tempCanvasContext.save();
      tempCanvasContext.font = "".concat(fontSize, "px ").concat(fontFamily);

      var temp = 0,
        longest = null,
        original = null,
        style,
        hasWhiteSpace,
        index;

      styles = pick(styles, []);

      if (!defined(ticksOriginal)) {
        ticksOriginal = [];
      }

      var check = function check(label, i) {
        var bound = getTextBound(label, fontSize, fontFamily, styles[i]),
          width = bound.width;

        if (calculateAsArea) {
          width = bound.width * bound.height;
        }
        if (checkWhiteSpace && !hasWhiteSpace) {
          hasWhiteSpace = label.indexOf(' ') != -1;
        }
        if (width > temp) {
          temp = width;
          longest = label;
          original = ticksOriginal[i];
          style = styles[i];
          index = i;
        }
      };
      ticks.forEach(check);
      tempCanvasContext.restore();
      return {
        actualVal: original,
        formattedVal: longest,
        style: style,
        index: index,
        hasWhiteSpace: hasWhiteSpace
      };
    }

    /**
     * returns a transform string
     *
     * @param {Number} rotate in degree's
     * @param {Number} x
     * @param {Number} y
     * @returns {string}
     */
    function generateTransform(rotate, x, y) {
      return "rotate(".concat(rotate, " ").concat(x || 0, " ").concat(y || 0, ")");
    }

    /**
     * returns the size of the tick label in horizontally or vertically
     *
     * @param {String} side "width" | "height"
     * @param {Object} dimension
     * @param {Object} margin
     * @param {Number} rotation in degree's
     * @param tickFontSize
     * @param orient
     * @returns {number}
     */

    function getTickWidth(side, dimension, margin, rotation, tickFontSize, orient) {
      var space = 0;
      if (side === 'height') {
        space = Math.abs(tickFontSize + margin.top + margin.bottom);
      } else {
        if (rotation > 0) {
          space = distBetweenRotatedRect(rotation, dimension.width, tickFontSize, orient).tickSpacing + margin.left + margin.right;
        } else {
          space = dimension.width + margin.left + margin.right;
        }
      }
      return space;
    }

    /**
     *
     * @param {String} orient
     * @param {Object} tickMargin
     * @param {Object} tickMarkConfig
     * @returns {{x: number, y: number}}
     */

    function getTickMargin(orient, tickMargin, tickMarkConfig, subTickMarkConfig, tickLabelConfig, isInlineToPlot, isInline, supportSubticks) {
      var tickMarkSize = pick(tickMarkConfig.size, 6),
        margin = getTickPadding(orient, tickMargin, isInline),
        x = orient === 'left' || orient === 'right' ? 'x' : 'y',
        y = orient === 'left' || orient === 'right' ? 'y' : 'x',
        k = orient === 'top' || orient === 'left' ? -1 : 1,
        k = isInlineToPlot ? -k : k,
        prop = {};

      if (supportSubticks && (subTickMarkConfig.count > 0 || defined(subTickMarkConfig.interval))) {
        tickMarkSize = mathMax(tickMarkSize, pick(subTickMarkConfig.size, 3));
      }

      prop[y] = 0;
      prop[x] = k * (margin + tickMarkSize);

      return prop;
    }

    /**
     * returns a empty dimension.
     * @returns {{}}
     */
    function getEmptyBBox() {
      var t = {};
      t.x = t.y = t.width = t.height = 0;
      return t;
    }

    function addMinmaxToTickValues(tickvalues, axisticklabeldata, chartObj, type, axisorder, orient) {
      var dataObject = chartObj.dataObject;
      var minmaxlabelsdata = axisticklabeldata.minmaxlabels || {};
      if (minmaxlabelsdata.show === true) {
        var newScale = scale.getScale(chartObj, dataObject, chartObj.plotarea, orient, axisorder, chartObj.dataset, type); //Scale with actual outerPadding
        var domain = newScale.domain();
        if (validateNullVal(minmaxlabelsdata.excludeIntervals, true)) {
          tickvalues = domain;
        } else {
          if (domain[0] !== tickvalues[0]) {
            tickvalues.splice(0, 0, domain[0]);
          }
          if (domain[1] !== tickvalues[tickvalues.length - 1]) {
            tickvalues.push(domain[1]);
          }
        }
      }
      return tickvalues;
    }

    function nearestNiceMin(minDomain, remaining, magnitude, interval) {
      var arr = [1, 2, 5, 10],
        len = arr.length;
      var actualMin = minDomain + remaining / 2;
      actualMin = +actualMin.toFixed(12);
      var diff, nearestMin;
      for (var j = 0; j < len; j++) {
        var a1 = magnitude / arr[j],
          curMin;
        if (minDomain % a1) {
          curMin = minDomain - minDomain % a1 + a1;
        } else {
          curMin = minDomain;
        }

        var curDiff = mathAbs(actualMin - curMin);
        if (curDiff < diff || diff == null) {
          diff = curDiff;
          nearestMin = curMin;
        }
      }
      if (nearestMin == null || nearestMin < minDomain) {
        var e = mathFloor(mathLog(interval) / mathLN10);
        if (e < 0) {
          nearestMin = +minDomain.toFixed(mathAbs(mathMin(0, e)));
        }
        nearestMin = minDomain;
      }
      nearestMin = nearestMin > minDomain ? nearestMin : minDomain;
      return nearestMin;
    }

    function nearestTickInterval(actualInterval, magnitude, multiples, type) {
      var curDiff,
        prevDiff = null,
        curInterval,
        nearestInterval = magnitude;

      multiples = multiples ?
      multiples :
      type == 'integer' ?
      [1, 1.2, 1.5, 1.75, 1.8, 1.85, 1.9, 1.95, 2, 2.2, 2.5, 3, 3.5, 4, 4.5, 5, 6, 7, 8, 9, 10] :
      [1, 1.2, 1.5, 1.75, 1.8, 1.85, 1.9, 1.95, 2, 2.2, 2.5, 3, 3.5, 4, 4.5, 5, 6, 7, 8, 9, 10];

      for (var i = 0; i < multiples.length; i++) {
        curInterval = multiples[i] * magnitude;
        if (!type || type == 'integer' && curInterval % 1 === 0) {
          curDiff = mathAbs(actualInterval - curInterval);
          prevDiff = prevDiff == null ? curDiff : prevDiff;
          if (curDiff < prevDiff && curInterval <= actualInterval) {
            prevDiff = curDiff, nearestInterval = curInterval;
          }
        }
      }
      return nearestInterval;
    }

    /**
     * Axis Label Rendering
     *
     * @param {Object} axisConfig
     * @param {Object} otherInfo
     * @param {String} orient
     * @param {Object} parent
     * @constructor
     */

    var AxisLabel = function AxisLabel(axisConfig, otherInfo, orient, parent) {
      this.axis = axisConfig;
      this.config = axisConfig.label;
      this.axisRect = otherInfo.bound;
      this.parentNode = parent.isD3Selection ? parent : d3_select(parent);
      this.orient = orient;
      this.systemConfig = otherInfo.systemConf;
      this.chart = otherInfo.chartObj;
      this.axisType = otherInfo.type;
      this.order = otherInfo.axisOrder;
      this.plotRect = otherInfo.plotRect;
      this.show = !otherInfo.hide;
      this.tickObj = otherInfo.tickObj;
      if (this.show) {
        this.add();
      } else {
        this.element = appendEle(this.parentNode, 'text', [], '.', 'class', 'axislabel'); // a empty selection
      }
    };

    AxisLabel.prototype = {
      add: function add() {
        var label = this;
        var formattedeValue = getFormattedValue({}, label.config.text, 'ordinal', this.chart, 'axis');
        var axisAreaDim = getAxisAreaDim(this.axisType, this.order, this.orient, this.chart, this.plotRect);
        label.group = appendEle(label.parentNode, 'g', [1], '.', 'class', 'axislabelgroup');
        label.element = appendEle(label.group, 'text', [1], '.', 'class', 'axislabel');
        label.text = label.config.text;
        label.element.text(formattedeValue);
        label.rect = null;
        label.transformLabel(NULL$1, axisAreaDim);
      },

      remove: function remove() {
        var label = this;
        label.rect = null;
        label.element = appendEle(label.parentNode, 'text', [], '.', 'class', 'axislabel'); // remove it
      },

      setStyles: function setStyles() {
        var label = this,
          systemConfig = label.systemConfig;
        applyFont(label.element, [label.config, systemConfig.chart, systemConfig.canvas, $ZCG]);
      },

      getBBox: function getBBox() {
        var label = this;
        if (!defined(label.rect)) {
          if (label.element.isD3Selection && !label.element.empty() && label.parentNode.style('display') !== NONE) {
            label.rect = bbox(label.element); // calculate and cache.
          } else {
            return getEmptyBBox();
          }
        }
        return label.rect;
      },

      transformLabel: function transformLabel(axisBound, plotBound, side) {
        var label = this;

        if (label.show !== true) {
          return label.remove();
        }

        if (label.element.empty() && label.show === true || label.text !== label.config.text) {
          return label.add();
        }
        var formattedeValue = getFormattedValue({}, label.config.text, 'ordinal', this.chart, 'axis');
        label.element.text(formattedeValue);
        label.setStyles();

        var rotations = {
            top: 0,
            right: 90,
            bottom: 0,
            left: 270
          },
          systemConfig = label.systemConfig,
          textAnchor = 'middle', // it is middle for all angle
          orient = pick(side, label.orient),
          rotate = rotations[orient],
          x,
          y,
          axisRect = pick(axisBound, this.axisRect),
          plotRect = pick(plotBound, this.plotRect),
          tickLabelConfig = label.axis.ticklabel,
          axisLabelConfig = label.config,
          tickMargin = getMargin(tickLabelConfig),
          labelMargin = getMargin(axisLabelConfig),
          fontSize = parseFloat(
          utils.getVal(getValByPriority([label.config, systemConfig.chart, systemConfig.canvas, $ZCG], 'fontSize')));


        // reset BBox
        if (label.fontSize !== fontSize) {
          label.rect = null;
        } else {
          label.fontSize = fontSize;
        }

        // if axis rotated is called;
        label.element.attr('dy', '-0.25em');
        var isInline = this.tickObj.isInline,
          isInwardToPlot = this.tickObj.inlineToPlot,
          isOutwardToPlot = isInline && !isInwardToPlot,
          offset = isOutwardToPlot ? 0 : tickMargin[orient];

        switch (orient) {
          case 'top':{
              var tickLength = isInwardToPlot ? 0 : axisRect.height + offset;
              x = plotRect.width / 2;
              y = tickLength + labelMargin.bottom;
              applyTransform(rotate, x, -y);
              break;
            }

          case 'right':{
              // label.element.attr("dy", "-0.25em");
              var tickLength = isInwardToPlot ? 0 : axisRect.width + offset;
              x = plotRect.height / 2;
              y = tickLength + labelMargin.left;
              applyTransform(rotate, x, -y);
              break;
            }
          case 'bottom':{
              var tickLength = isInwardToPlot ? 0 : axisRect.height + offset;
              x = plotRect.width / 2;
              y = tickLength + labelMargin.top;

              // apply baseline
              label.element.attr('dy', '0.91em');
              applyTransform(rotate, x, y);
              break;
            }
          case 'left':{
              // label.element.attr("dy", "-0.25em");
              var tickLength = isInwardToPlot ? 0 : axisRect.width + offset;
              x = tickLength + labelMargin.right;
              y = plotRect.height / 2;
              applyTransform(rotate, -x, y, -x, y);
              break;
            }}


        function applyTransform(rotate, x, y, xTransform, yTransform) {
          xTransform = pick(xTransform, 0);
          yTransform = pick(yTransform, 0);

          label.element.attrs({
            x: x,
            y: y,
            transform: generateTransform(rotate, xTransform, yTransform),
            'text-anchor': textAnchor
          });
        }
      }
    };

    /**
     *
     * @param {String} type x or y
     * @param axisInfo
     * @param plotRect
     * @param helpers
     * @param tickCount
     * @constructor
     */

    var Ticks = function Ticks(type, axisInfo, plotRect, helpers, tickCount) {
      this.type = type;
      this.config = axisInfo.ticklabel;
      this.axis = axisInfo;
      this.plotRect = plotRect;
      this.helpers = helpers;

      this.tickCount = tickCount; // for web chart

      // max size
      this.maxSize = function () {
        return getMaxTickSize(this.config, this.plotRect);
      };
      this.cache = {};
    };

    Ticks.prototype = {
      getScale: function getScale() {
        var tick = this,
          chart = tick.helpers.chart,
          helpers = tick.helpers;
        var hierarchical = chart.dataObject.hierarchical;
        var axisorder = chart.dataObject.categoryHierarchy && tick.type == 'y' ? 0 : helpers.axisOrder;
        var scaleObj = scale.getScale(
        chart,
        chart.dataObject,
        tick.plotRect,
        helpers.orient,
        axisorder,
        chart.dataset,
        tick.type,
        tick.extent);

        if (chart.dataObject.categoryHierarchy) {
          var rowList = hierarchical.pivotLayout.getRootNodeList('row'),
            columnList = hierarchical.pivotLayout.getRootNodeList('column'),
            rowCount = rowList.getCount(),
            _hasMultiCluster5 = rowList.hasMultiCluster(),
            leafSize = rowList.leafSize,
            axisOrder = getLeafAxisOrder(helpers.axisOrder || 0, null, 'y', chart),
            axis_data = chart.systemConf.chart.axes.yaxis[axisOrder],
            hasSplitLeavesColumns = chart.systemConf.chart.axes.xaxis.splitLeaves;
          if (_hasMultiCluster5 && tick.type == 'y') {
            if (rowCount) {
              var parentLeafRowScale = chart.axes.y.branches[0].scale;
              var rangeCopy = [
              parentLeafRowScale(helpers.axisOrder) + parentLeafRowScale.discreteWidth(helpers.axisOrder),
              parentLeafRowScale(helpers.axisOrder)];

              if (chart.axes.rotated && !axis_data.reversed || !chart.axes.rotated && axis_data.reversed) {
                rangeCopy = rangeCopy.reverse();
              }
              return scaleObj.copy().range(rangeCopy);
            } else {
              var rangeCopy = [helpers.axisOrder * leafSize + leafSize, helpers.axisOrder * leafSize];
              if (chart.axes.rotated) {
                rangeCopy = rangeCopy.reverse();
              }
              return scaleObj.copy().range(rangeCopy);
            }
          } else if (tick.type == 'x' && hasSplitLeavesColumns) {
            var rangeCopy = [helpers.axisOrder * columnList.leafSize, helpers.axisOrder * columnList.leafSize + columnList.leafSize];
            return scaleObj.copy().range(rangeCopy);
          }
        }
        return scaleObj;
      },

      getTicks: function getTicks(plotArea, needCount, helper) {
        var tick = this,
          helpers = pick(helper, tick.helpers),
          chart = helpers.chart,
          systemConf = chart.systemConf,
          dataObject = chart.dataObject,
          plotRect = tick.plotRect = pick(plotArea, tick.plotRect),
          axisObj = tick.axis,
          type = tick.type,
          userTickInterval = axisObj.interval,
          userTickCount = axisObj.tickCount,
          range,
          domain,
          tickInterval = axisObj.interval,
          tickCount = pick(needCount, 0),
          extent = helper.extent,
          tickValues = extent,
          categoriesList,
          filterByIndex,
          tickValueIndices,
          dontFilter,
          formattedTickValues,
          axisOrder = helpers.axisOrder,
          axisRotated = helpers.axisRotated,
          dataType = chart.dataset.getDataType(type, axisOrder),
          metaData = chart.systemConf.metadata,
          columnIndex = chart.dataset.getColumnIdx(type, axisOrder),
          columnInfo = metaData.columns[columnIndex],
          originalDataType = metaData.columns[columnIndex].datatype,
          hierachical = dataObject.hierarchical,
          isMergedAxis = type == 'y' && !hierachical ? metaData.axes.y[axisOrder].length > 1 : false,
          currentMetaData = metaData.columns[columnIndex],
          formatConfig = pick(
          isMergedAxis && type == 'y' ? merged_axis_column_intersect(axisOrder, chart) : currentMetaData[originalDataType],
          {}),

          formattingSubFunction = formatConfig.subfunction,
          formattingFunction = type === 'y' && chart.dataObject.isPercentChart ? getFormattedValueByPercent : getFormattedValue,
          margin = getMargin(tick.config),
          isInline = isTickInnerOrient(tick.axis, type, chart),
          inlineToPlot = isInline ? checkTickInlineAlignWithInPlot(type, helpers.orient, systemConf) : false,
          scaleType = columnInfo.scaleType,
          isLogScale = scaleType === LOG,
          tickMargin = getTickMargin(
          helpers.orient,
          margin,
          tick.axis.tickmark,
          tick.axis.subtickmark,
          tick.axis.ticklabel,
          inlineToPlot,
          isInline,
          isLogScale),

          axisSize,
          tickFontSize = parseFloat(utils.getVal(getValByPriority([tick.config, systemConf.chart, systemConf.canvas, $ZCG], 'fontSize'))),
          tickFontFamily = utils.getVal(getValByPriority([tick.config, systemConf.chart, systemConf.canvas, $ZCG], 'fontFamily')),
          rotationConfig = getRotation(tick.config),
          tickAlignmentMode = rotationConfig.alignmentMode,
          tickRotateMode = rotationConfig.isRotateMode,
          tickRotation = rotationConfig.rotation,
          tickAutoRotation = rotationConfig.autoRotation,
          hasDefinedAutoRotation = rotationConfig.hasDefinedAutoRotation,
          longestTick,
          side = isRotatedChart(type, axisRotated) ? 'height' : 'width',
          hierarchical = chart.dataObject.hierarchical,
          isCategoryHierarchy = hierarchical && hierarchical.categoryTree,
          isAutoRotation = isTickAutoRotate(chart, this.type, axisOrder, tickRotation),
          isBranchAxisType = isCategoryHierarchy ? isBranchAxis(type, axisOrder, chart) : type == 'x' && axisOrder > 0,
          rotation = isBranchAxisType ? 0 : tickRotation, //isAutoRotation || isHierarchy ? 0 : +tick.config.rotation,
          //
          firstChartName = chart.chartTypes[0].name,
          commonPlotOptions = chart.systemConf.chart.plot.plotoptions[firstChartName],
          outerPadding = dataObject.isAxisCategory ? commonPlotOptions.outerPadding || 0 : 0,
          pad = dataObject.isAxisCategory ? commonPlotOptions.padding || 0.2 : 0,
          //
          longestFormattedString = null,
          plotSize = getPlotSize(helpers.chart, side, plotRect),
          padding = type === 'x' ? plotSize * outerPadding * 2 : 0,
          dimension,
          space,
          customTickInfo = {},
          maxTickSize = helper.maxTickSize || this.maxSize(),
          hasTimeGroupBy =
          isArray$1(formatConfig.groupby) && formatConfig.groupby.length > 0 ||
          formatConfig.groupby === 'AUTO' && formattingSubFunction !== 'YEAR',
          minorTickValues,
          axisInfo = getAxisObject(chart, type, axisOrder);

        var specifierIndex = hasTimeGroupBy ? axisOrder : null,
          existingScale,
          behaviours = getPropVal(chart, 'behaviouralEvents.eventManager.behaviours') || {},
          zoomedPlotSize = null,
          hasSmoothEffect =
          behaviours.PLOT_ZOOM || behaviours.CHART_SCROLL && chart.scroll && chart.scroll.settings.smooth && type === 'x';

        if (hasTimeGroupBy && formatConfig.groupby === 'AUTO') {
          //#ZC1015
          formatConfig.AUTO_GROUP_ORDER = DataProcessor.HierarchicalTimeDataAdapter.getAutoGroupOrder(formattingSubFunction).reverse();
        }

        if (behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL) {
          // let axisInfo = getAxisObject(chart, type, axisOrder);
          existingScale = axisInfo.scale;

          // #ZC2133
          // for scroll apply only x axis
          if (type === 'x' && behaviours.CHART_SCROLL) {
            // #ZC2287 $chart.viewPortExtent first
            extent = chart.viewPortExtent || axisInfo.domain || extent;
          } else {
            extent = axisInfo.domain || extent;
          }

          tickValues = hasSmoothEffect ? null : extent;

          var newRange = existingScale.range();
          zoomedPlotSize = plotSize = mathAbs(newRange[1] - newRange[0]);
          padding = type === 'x' ? plotSize * outerPadding * 2 : 0;

          if (dataType === 'time' && isArray$1(extent) && existingScale) {
            if (extent[0] instanceof Date) {
              extent = extent.map(function (d) {return d.getTime();});
            }

            var diff = mathAbs(extent[1] - extent[0]),
              correction = diff * existingScale.outerPadding;

            extent[0] = extent[0] + correction;
            extent[1] = extent[1] - correction;
          }
        }

        if (!isAutoRotation) {
          if (rotation < 0) {
            rotation = 360 - mathAbs(rotation);
          } else if (rotation >= 360) {
            rotation = mathAbs(rotation) % 360;
          }
        }
        if (tickAutoRotation) {
          if (tickAutoRotation < 0) {
            tickAutoRotation = 360 - mathAbs(tickAutoRotation);
          } else if (tickAutoRotation > 360) {
            tickAutoRotation = mathAbs(tickAutoRotation) % 360;
          }
        }
        var rowList, columnList, leavesCount, clustersCount, splitLeavesColumn, gridSize;

        if (hierarchical) {
          rowList = hierarchical.pivotLayout.getRootNodeList('row'),
          columnList = hierarchical.pivotLayout.getRootNodeList('column'),
          leavesCount = rowList.getLeavesCount(),
          clustersCount = rowList.getClustersCount();
          splitLeavesColumn = columnList.splitColumnLeaves;
        }

        switch (dataType) {
          case 'numeric':{
              var encodeOrder =
                type == 'y' && isCategoryHierarchy ? rowList.hasMultiCluster() ? helpers.axisOrder : 0 : helpers.axisOrder,
                // order = type == 'y' && hierarchical ? hierarchical.leafRows.hasMulti && helpers.axisOrder <  hierarchical.leafRows.totalCount ? (helpers.axisOrder % hierarchical.leafRows.count) : 0 : helpers.axisOrder;
                order =
                type == 'y' && isCategoryHierarchy ?
                rowList.hasMultiCluster() && helpers.axisOrder < leavesCount ?
                helpers.axisOrder % clustersCount :
                0 :
                helpers.axisOrder;

              // clear the existing domain
              axisInfo.logDomain = null;

              domain = defined(extent) ?
              extent :
              type === 'x' ?
              dataObject.getMinMaxX() //TODO need to pass UNDEFINED correction as same as minmax-y
              : dataObject.getMinMaxY(order, UNDEFINED, chart.datalabels.hasFixedPosition);

              var correction4Datalabels;
              if (type === 'y' && chart.datalabels.hasFixedPosition) {
                var rangeCorrections_datalabels = chart.cache.correction,
                  id = "label-".concat(type, "-").concat(helpers.axisOrder),
                  labelCorrection = 0;

                if (isUndefined(rangeCorrections_datalabels[id])) {
                  var yEncode = dataObject.getEncode('y', helpers.axisOrder);
                  labelCorrection = LabelRegistry.get('preCalculation')(type, yEncode.seriesData, chart) || 0;
                  rangeCorrections_datalabels[id] = [labelCorrection, labelCorrection];
                } else {
                  labelCorrection = rangeCorrections_datalabels[id][1] || 0;
                }
                correction4Datalabels = labelCorrection;
              } else {
                correction4Datalabels = 0;
              }
              var height;
              if (type == 'y' && isCategoryHierarchy && leavesCount) {
                var rangeCopy = [helpers.axisOrder * rowList.leafSize + rowList.leafSize, helpers.axisOrder * rowList.leafSize];
                gridSize = height = mathAbs(rangeCopy[1] - rangeCopy[0]);
              }
              if (type == 'x' && isCategoryHierarchy && splitLeavesColumn) {
                var rangeCopy = [
                helpers.axisOrder * columnList.leafSize,
                helpers.axisOrder * columnList.leafSize + columnList.leafSize];

                gridSize = height = mathAbs(rangeCopy[1] - rangeCopy[0]);
              }
              // define axis size and range
              if (side === 'height') {
                axisSize = (height || plotRect.height) - correction4Datalabels;
                tickCount = tickCount || mathRound(axisSize / 40);
                range = [axisSize, 0];
              } else {
                axisSize = (height || plotRect.width) - correction4Datalabels;
                tickCount = tickCount || mathRound(axisSize / 100);
                range = [0, axisSize];
              }

              // define tick interval
              if (defined(userTickCount)) {
                tickInterval = (domain[1] - domain[0]) / userTickCount;
              }

              var calculatedInterval = (domain[1] - domain[0]) / userTickInterval;
              var useTickInterVal = defined(userTickInterval) && calculatedInterval < axisSize;

              // numeric scale
              // var scaleObj =
              //     existingScale ||
              //     d3_scaleLinear()
              //         .domain(domain)
              //         .range(range);
              var scaleObj =
              existingScale ||
              getContinuousScale(chart.dataset, type, axisOrder)().
              domain(domain).
              range(range);

              // get ticks
              if (isLogScale) {
                if (scaleObj.constant) {
                  var min = d3_min(domain);
                  if (min > 0 && min < pick(axisObj.logBase, 10) && axisObj.allowNonPositiveTicks === false) {
                    scaleObj.constant(0.0001);
                  } else {
                    scaleObj.constant(1);
                  }
                }

                // #ZC2805 $domain changed to $dataMinMax
                var dataMinMax = type === 'x' ? dataObject.getMinMaxX(0) : dataObject.getMinMaxY(order, 0),
                  addBaseline = !arrayIncludes(dataMinMax),
                  domainCopy = dataMinMax.slice(0),
                  logDomain,
                  usePadding = !(dataObject.isPercentChart || dataObject.hasLevelMarker || dataObject.isWaterfallEnabled),
                  adjustToBase = null,
                  _yEncode = dataObject.getEncode('y', order);

                // FEATURES_LOGAXIS_45
                if (dataMinMax[0] === 0 && dataMinMax[1] === 0) {
                  columnInfo.scaleType = null;
                  domain =
                  type === 'x' ?
                  dataObject.getMinMaxX(0) :
                  dataObject.getMinMaxY(order, UNDEFINED, chart.datalabels.hasFixedPosition);
                  columnInfo.scaleType = LOG;
                }

                // type y case CXZA_LEGEND_26
                if (
                _yEncode &&
                _hasDefaultBase(_yEncode, chart.dataObject, chart) &&
                addBaseline &&
                type === 'y' &&
                !defined(axisObj.minRange))
                {
                  adjustToBase = 0;
                  domainCopy.push(0);
                  domainCopy = d3_extent(domainCopy);
                }

                var formatFunc = function formatFunc(tickValues) {
                  return formatArray(
                  tickValues,
                  formattingFunction,
                  formatConfig,
                  chart,
                  originalDataType,
                  'axis',
                  specifierIndex,
                  tickAlignmentMode,
                  maxTickSize,
                  tickFontSize);

                };

                var addMinMaxLog = function addMinMaxLog(tickValues) {
                  axisInfo.logDomain = d3_extent(tickValues);
                  return addMinmaxToTickValues(tickValues, tick.config, chart, type, helpers.axisOrder, helpers.orient);
                };
                // fix all negative
                var _getLogTicks2 = getLogTicks(
                domainCopy,
                axisSize,
                dataMinMax,
                usePadding,
                axisObj,
                scaleObj.copy(),
                margin,
                {
                  fontSize: tickFontSize,
                  fontFamily: tickFontFamily
                },
                formatFunc,
                helpers.orient,
                tickRotation,
                adjustToBase,
                addMinMaxLog,
                chart.datalabels.hasFixedPosition,
                domain);tickValues = _getLogTicks2.tickValues;minorTickValues = _getLogTicks2.minorTickValues;logDomain = _getLogTicks2.logDomain;


                axisInfo.logDomain = logDomain;
              } else {
                if (useTickInterVal) {
                  tickValues = getLinearTicksByInterval(domain, tickInterval, axisObj.maxRange);
                } else if (+userTickCount > 0) {
                  tickValues = getLinearTicksByCount(domain, userTickCount, axisObj.maxRange, formattingSubFunction);
                } else if (formattingSubFunction === 'integer') {
                  tickValues = getLinearTicksBySubFunction(domain, null, axisObj.maxRange);
                } else {
                  tickValues = scaleObj.ticks(tickCount);
                }
              }

              // add min max label if needed
              // #ZC2808
              tickValues = addMinmaxToTickValues(tickValues, tick.config, chart, type, helpers.axisOrder, helpers.orient);
              tickCount = tickValues.length; //(this.config.zigzag) ? tickValues.length/2 : tickValues.length;
              break;
            }
          case 'ordinalNonLinear':
          case 'ordinal':{
              var visibleTickCount,
                size = tickFontSize,
                hierarchical = dataObject.hierarchical,
                calculatePlotWidth;
              // #ZC1188
              //filterByIndex = (defined(hierarchical) && originalDataType == ORDINAL_DATATYPE && type == "x" && axisOrder == 0) || dataObject.isWaterfallEnabled, //TODO waterfall
              filterByIndex =
              defined(hierarchical) && hierarchical.categoryTree && type == 'x' && !splitLeavesColumn && axisOrder == 0 ||
              dataObject.isWaterfallEnabled; //TODO waterfall
              // #ZC1765
              calculatePlotWidth = systemConf.chart.width === 'auto' || systemConf.chart.height === 'auto';
              dontFilter = calculatePlotWidth;

              var filterTicksIndexes = null;
              if (dataObject.isWaterfallEnabled && defined(existingScale) && isArray$1(tickValues)) {
                filterTicksIndexes = tickValues;
              }

              if (!defined(tickValues)) {
                tickValues = dataObject.getCategories(type, helpers.axisOrder).slice(0);
              }
              if (filterByIndex && defined(hierarchical)) {
                // tickValues = dataObject.hierarchical.leaves.key.list;
                tickValues = columnList.getClusterNodes(0);
              }

              if (originalDataType === TIME_DATATYPE && !defined(formattingSubFunction)) {
                // set sub function
                var info = getAutoTimeSubFunction(tickValues[tickValues.length - 1] - tickValues[0]);
                formattingSubFunction = formatConfig.subfunction = info.subFunction;
              }

              tickCount = tickValues.length;

              dimension = {};
              dimension.width = dimension.height = tickFontSize;
              space = getTickWidth(side, dimension, margin, rotation, tickFontSize, helpers.orient);
              plotSize = splitLeavesColumn ? columnList.leafSize : plotSize;
              gridSize = splitLeavesColumn ? columnList.leafSize : null;
              visibleTickCount = mathRound((plotSize - padding) / space); // for initial filter.

              if (visibleTickCount < tickCount && side === 'width') {
                if (rotation || tick.config.rotation > 0) {
                  space =
                  distBetweenRotatedRect(tickAutoRotation, tickFontSize, size, helpers.orient).tickSpacing +
                  margin.left +
                  margin.right;
                }
              }
              if (!isBranchAxisType && !dontFilter) {
                if (userTickCount < tickCount) {
                  tickValues = filterCategories(tickValues, userTickCount, null, filterByIndex);
                } else if (defined(tickInterval)) {
                  tickValues = filterCategories(tickValues, tickCount, tickInterval, filterByIndex);
                } else if (visibleTickCount < tickCount) {
                  tickValues = filterCategories(tickValues, visibleTickCount, null, filterByIndex);
                }
              }

              if (filterByIndex) {
                categoriesList = tickValues.nodes || tickValues;
                tickValueIndices = tickValues.indices;
                tickValues = tickValues.ticks || dataObject.getCategories(type, helpers.axisOrder, true, filterTicksIndexes).slice(0);
              }

              tickCount = tickValues.length; //(this.config.zigzag) ? tickValues.length/2 : tickValues.length;

              break;
            }

          case 'time':{
              var isAutoFormat = hasAutoFormat(formatConfig);

              if (isAutoFormat) {
                // TODO check with axis
                var timeScale =
                existingScale ||
                scale.getScale(chart, dataObject, plotRect, helpers.orient, helpers.axisOrder, chart.dataset, type, extent);
                tickValues = timeScale.ticks();
                formattedTickValues = tickValues.map(function (d) {
                  return timeScale.tickFormat()(d);
                });
                tickCount = tickValues.length;
              } else {
                var start, end, dateInterval;
                domain = defined(extent) ?
                extent :
                type === 'x' ?
                dataObject.getMinMaxX(0) :
                dataObject.getMinMaxY(helpers.axisOrder, 0);

                start = new Date(domain[0]);
                end = new Date(domain[1]);

                // #ZC1187
                if (!defined(currentMetaData[originalDataType])) {
                  currentMetaData[originalDataType] = formatConfig;
                }

                if (!defined(formattingSubFunction) || formattingSubFunction === 'AUTO') {
                  // set sub function
                  var info = getAutoTimeSubFunction(end - start);
                  formattingSubFunction = formatConfig.subfunction = info.subFunction;
                }

                // get the date utils 1326
                dateInterval = new date_utils(formatConfig);
                dateInterval.useUTC = formatConfig.useUTC === true;

                longestFormattedString = dateInterval.getMaxDate(formatConfig, specifierIndex); // save it
                longestFormattedString = formatTickWrapByMode(
                longestFormattedString,
                tickAlignmentMode,
                maxTickSize.horizontal,
                maxTickSize.vertical,
                tickFontSize);

                dimension = getTextBound(longestFormattedString, tickFontSize, tickFontFamily);
                space = getTickWidth(side, dimension, margin, rotation, tickFontSize, helpers.orient);

                plotSize = splitLeavesColumn ? columnList.leafSize : plotSize;
                gridSize = splitLeavesColumn ? columnList.leafSize : plotSize;

                tickCount = (plotSize - padding) / space;
                // tickCount = (this.config.zigzag) ? tickCount/2 : tickCount;
                // get the date range
                var dateRange = dateInterval.range(start, end, mathCeil(tickCount), formattingSubFunction, tickInterval, chart);
                // add min max tick
                tickValues = addMinmaxToTickValues(dateRange.TICKS, tick.config, chart, type, helpers.axisOrder, helpers.orient);

                tickCount = dateRange.TICKS.length; //(this.config.zigzag) ? dateRange.TICKS.length/2 : dateRange.TICKS.length;

                break;
              }
            }}


        if (dataType === 'ordinalNonLinear') {
          var formattedTickValues = isAutoFormat ?
          formattedTickValues :
          formatArray(
          tickValues,
          formattingFunction,
          formatConfig,
          chart,
          originalDataType,
          'axis',
          specifierIndex,
          tickAlignmentMode,
          maxTickSize,
          tickFontSize);

          // get custom tick labels
          if (defined(tick.config.showAs)) {
            customTickInfo = getCustomTickValues(tickValues, tick.config, columnInfo, chart, columnIndex, axisOrder);
            formattedTickValues = customTickInfo.tickValues;
            customTickInfo.length = formattedTickValues.length;
          }
          var longestTick = getLongestTick$1(formattedTickValues, tickValues, tickFontSize, tickFontFamily, customTickInfo.styles);

          // Pivot non-axis chart
          if (!chart.dataObject.isAxisCategory) {
            var _recalculateSide =
              type === 'x' && (axisRotated ? 'height' : 'width') || type === 'y' && (axisRotated ? 'width' : 'height'),
              _toRecalculate = systemConf.chart[_recalculateSide] === 'auto';

            if (!defined(longestFormattedString)) {
              longestFormattedString = longestTick.formattedVal;
            }

            // calculate number of tick can be fit.
            var tickBound = getTextBound(longestFormattedString, tickFontSize, tickFontFamily, longestTick.style, true);
            var labelSize = getMaxTickSize(tick.config, chart.chartarea);
            tickBound.width = mathMin(tickBound.width, labelSize.horizontal);
            tickBound.height = mathMin(tickBound.height, labelSize.vertical);

            if (_toRecalculate) {
              tick.recalculatePlotSize(helpers.chart, plotSize, tickBound, side, tickCount, margin, pad, outerPadding, 'x');
            }

            if (_toRecalculate && hierarchical) {
              var nodeList = hierarchical.pivotLayout.getRootNodeList('row'),
                nodeListCount = nodeList.getCount(),
                _leavesCount2 = nodeList.getLeavesCount(),
                leafSize = nodeList.leafSize;
              if (nodeListCount) {
                var _dimension2 = { width: 0, height: 0 };
                _dimension2[side] = leafSize;
                tick.recalculatePlotSize(chart, plotSize, _dimension2, side, _leavesCount2, margin, pad, outerPadding, 'y');
              }
            }
          }

          return {
            rawTickValues: tickValues,
            formatterTickValues: formattedTickValues,
            longestTickValue: longestTick,
            scale: tick.getScale(),
            longestTickDimension: getTextBound(longestTick.formattedVal, tickFontSize, tickFontFamily),
            margin: margin,
            tickMargin: tickMargin,
            rotation: rotation,
            customTickInfo: customTickInfo,
            mode: tickAlignmentMode,
            isInline: isInline,
            inlineToPlot: inlineToPlot,
            maxTickSize: maxTickSize
          };
        }

        // get a scale
        scaleObj = existingScale || tick.getScale();

        //
        var actualRange = scaleObj.actualRange;
        var isSingleTick = actualRange && actualRange[0] === actualRange[1];
        if (isSingleTick) {
          tickValues = [scaleObj.invert(actualRange[0])];

          // ZC2839
          if (isLogScale) {
            tickValues = tickValues.map(function (d) {return fixFloatingPoint(d);});
          }
        }

        // chartType viewport filtering
        // #ZC2068 $hasSmoothEffect
        if (chart.renderVisiblePointsOnly && !filterByIndex) {
          tickValues = filterTickFromViewport(tickValues);
        }
        tickCount = tickValues.length;

        // format the values and get the longest tick value.
        formattedTickValues = isAutoFormat ?
        formattedTickValues :
        formatArray(
        tickValues,
        formattingFunction,
        formatConfig,
        chart,
        originalDataType,
        'axis',
        specifierIndex,
        tickAlignmentMode,
        maxTickSize,
        tickFontSize);


        // get custom tick labels
        if (defined(tick.config.showAs)) {
          customTickInfo = getCustomTickValues(tickValues, tick.config, columnInfo, chart, columnIndex, axisOrder);
          formattedTickValues = customTickInfo.tickValues;
          customTickInfo.length = formattedTickValues.length;
        }

        longestTick = getLongestTick$1(formattedTickValues, tickValues, tickFontSize, tickFontFamily, customTickInfo.styles);

        // uncomment the bellow condition to use the default longest date.
        if (!defined(longestFormattedString)) {
          longestFormattedString = longestTick.formattedVal;
        }

        // calculate number of tick can be fit.
        var tickBound = getTextBound(longestFormattedString, tickFontSize, tickFontFamily, longestTick.style, true);
        var labelSize = getMaxTickSize(tick.config, chart.chartarea);
        tickBound.width = mathMin(tickBound.width, labelSize.horizontal);
        tickBound.height = mathMin(tickBound.height, labelSize.vertical);
        // #ZC1765
        if (calculatePlotWidth) {
          tick.recalculatePlotSize(helpers.chart, plotSize, tickBound, side, tickCount, margin, pad, outerPadding, 'x');
        }

        if ((systemConf.chart.width === 'auto' || systemConf.chart.height === 'auto') && hierarchical && type == 'y') {
          var _nodeList2 = hierarchical.pivotLayout.getRootNodeList('row'),
            _nodeListCount2 = _nodeList2.getCount(),
            domainLength = _nodeListCount2 ? _nodeList2.getDomainForBranch(0).length : 0,
            _leavesCount3 = _nodeList2.getLeavesCount(),
            _leafSize = _nodeList2.leafSize;
          if (_nodeListCount2 && axisOrder == domainLength - 1) {
            var _dimension3 = { width: 0, height: _leafSize };
            tick.recalculatePlotSize(chart, plotSize, _dimension3, side, _leavesCount3, margin, pad, outerPadding, 'y');
          }
        }

        var bestFitTickModel = getMaxTickCount(tickCount);
        var mode = bestFitTickModel.mode,
          maxTickCount = bestFitTickModel.maxTickCount;
        rotation = bestFitTickModel.rotation;

        if (!isSingleTick && (tickCount > maxTickCount || bestFitTickModel.recalculate)) {
          // time data need a re-calculation of tick values after rotation

          if (dataType === TIME_DATATYPE) {
            if (isAutoFormat) {
              timeScale =
              existingScale ||
              scale.getScale(chart, dataObject, plotRect, helpers.orient, helpers.axisOrder, chart.dataset, type, null);

              // #ZC2211 only if
              var reduceAutoTick = tickCount > maxTickCount && tickRotateMode && rotation === 0;

              tickValues = timeScale.ticks(reduceAutoTick ? maxTickCount * 0.5 : maxTickCount);

              if (tickCount > maxTickCount && !reduceAutoTick) {
                // change the rotation manually as there are no control
                // over calculating ticks in auto format to avoid overlapping
                rotation = tickAutoRotation;
              }
              formattedTickValues = tickValues.map(function (d) {return timeScale.tickFormat()(d);});
              longestTick = getLongestTick$1(formattedTickValues, tickValues, tickFontSize, tickFontFamily, customTickInfo.styles);
            } else {
              dateRange = dateInterval.range(start, end, maxTickCount, formattingSubFunction, tickInterval, chart);
              tickValues = addMinmaxToTickValues(dateRange.TICKS, tick.config, chart, type, helpers.axisOrder, helpers.orient);
              formattedTickValues = formatArray(
              tickValues,
              formattingFunction,
              formatConfig,
              chart,
              originalDataType,
              'axis',
              specifierIndex,
              tickAlignmentMode,
              maxTickSize,
              tickFontSize);

            }
          } else if (maxTickCount < tickCount) {
            // filter ticks if needed
            if (filterByIndex) {
              tickValues = filterCategories(categoriesList || tickValues, maxTickCount, null, filterByIndex);
              tickValueIndices = tickValues.indices, tickValues = tickValues.ticks;
            } else {
              tickValues = filterCategories(tickValues, maxTickCount);
              if (tick.config.showAs) {
                // TODO have convert multiple object to single object to reduce loop.
                customTickInfo.styles = filterCategories(customTickInfo.styles, maxTickCount);
                customTickInfo.userRawTicks = filterCategories(customTickInfo.userRawTicks, maxTickCount);
              }
            }

            formattedTickValues = filterCategories(formattedTickValues, maxTickCount);
            longestTick = getLongestTick$1(formattedTickValues, tickValues, tickFontSize, tickFontFamily, customTickInfo.styles);
          }
        }

        // time data group by
        if (originalDataType === TIME_DATATYPE && hasTimeGroupBy) {
          if (hasTimeGroupBy && !defined(dataObject.hierarchical)) {
            dataObject.hierarchical = new DataProcessor.HierarchicalTimeDataAdapter(
            chart,
            tickValues,
            formatConfig.groupby,
            dataType !== TIME_DATATYPE,
            columnInfo);

          } else if (hasTimeGroupBy) {
            dataObject.hierarchical.update(tickValues);

            /*
            Find ranges for column branches
            */
            var rangeScaleUtils = dataObject.hierarchical.setScaleForRange(chart.axes.x.rangeScale);
            hierarchical.pivotLayout.setRanges('column', rangeScaleUtils);
          }
        }

        if (defined(customTickInfo.styles) || formatConfig && formatConfig.format && formatConfig.format.breakSpace) {
          longestTick = getLongestTick$1(formattedTickValues, tickValues, tickFontSize, tickFontFamily, customTickInfo.styles, true);
        }

        var textDimension = getTextBound(longestFormattedString, tickFontSize, tickFontFamily, longestTick.style);

        return {
          rawTickValues: tickValues,
          formatterTickValues: formattedTickValues,
          longestTickValue: longestTick,
          scale: scaleObj,
          longestTickDimension: textDimension,
          margin: margin,
          tickMargin: tickMargin,
          rotation: rotation,
          mode: mode,
          isInline: isInline,
          inlineToPlot: inlineToPlot,
          tickValueIndices: tickValueIndices,
          customTickInfo: customTickInfo,
          maxTickSize: maxTickSize,
          minorTickValues: minorTickValues
        };

        /**
         *
         * @param ticks
         * @return {*}
         */
        function filterTickFromViewport(ticks) {
          // $span instead of plotarea because sometime during resize, the plotarea changes before range
          // and the tick values gets filtered out
          var span = mathAbs(scaleObj.origRange[1] - scaleObj.origRange[0]),
            correction = scaleObj.bandwidth ? scaleObj.bandwidth() / 2 : 0,
            r = [-correction, span - correction];

          return ticks.filter(function (t) {
            var pos = scaleObj(t);
            return pos !== null && pos >= r[0] && pos <= r[1];
          });
        }
        // now handle over flow of the formatted ticks and return;

        function getMaxTickCount(tickCount) {
          if (tickAlignmentMode === 'auto') {
            //First check for normal ticks with rotation as 0
            var maxCount_Rotate_0 = 0;
            //second check for zigzag only for ordinal datatype, for numeric and time datatype go for rotation with 45
            if (maxCount_Rotate_0.maxTickCount < tickCount) {
              var maxCount_zigzag =
              dataType == ORDINAL_DATATYPE ?
              getMaxTickCountByZigzag(tickBound) :
              getMaxTickCountByRotation(tickBound, tickAutoRotation, true);
              //third for tick rotation with 45
              if (maxCount_zigzag.maxTickCount < tickCount) {
                var maxCount_Rotate_45 = getMaxTickCountByRotation(tickBound, tickAutoRotation, true);
                //fourth for ticks with white space
                if (maxCount_Rotate_45.maxTickCount < tickCount && longestTick.hasWhiteSpace) {
                  return getMaxTickCountByWrapOnSpace(tickBound);
                } else {
                  return maxCount_Rotate_45;
                }
              } else {
                return maxCount_zigzag;
              }
            } else {
              return maxCount_Rotate_0;
            }
          } else if (tickRotateMode) {
            return getMaxTickCountByRotation(tickBound);
          } else if (tickAlignmentMode == 'zigzag') {
            return getMaxTickCountByZigzag(tickBound);
          } else if (tickAlignmentMode == 'wrapOnSpace') {
            return getMaxTickCountByWrapOnSpace();
          } else if (tickAlignmentMode == 'wrapAll') {
            return getMaxTickCountByWrapAll();
          }
        }

        function getMaxTickCountByBounds(rotation, customBounds, customType) {
          var tickArea,
            temp,
            padding = 0,
            countForAngle,
            bounds;

          var length = getPlotSize(helpers.chart, side, tick.plotRect, gridSize);
          if (customType === 'x') {
            padding = length * outerPadding * 2;
          }

          tickArea = length - padding;
          countForAngle = !!rotation;
          bounds = customBounds || tickBound;
          if (countForAngle) {
            if (side === 'height' && (rotation === 90 || rotation === 270)) {
              return tickArea / (bounds.width + mathAbs(margin.top) + mathAbs(margin.bottom));
            }

            var r = rotation % 90;
            var angleCheck = side === 'height' ? r > 0 : r > 0 || rotation === 90 || rotation === 270;

            if (angleCheck) {
              var distBwTicks = distBetweenRotatedRect(rotation, bounds.width, bounds.height, helpers.orient);
              return tickArea / (distBwTicks.tickSpacing + mathAbs(margin.left) + mathAbs(margin.right));
            }
          }

          if (side === 'height') {
            temp = bounds.height + mathAbs(margin.top) + mathAbs(margin.bottom);
          } else {
            temp = bounds.width + mathAbs(margin.left) + mathAbs(margin.right);
          }
          return tickArea / temp;
        }

        function getMaxTickCountByRotation(tickBoundgetMaxTickCountByRotation, customRotation, recalculate) {
          var rotation_new = defined(customRotation) ? customRotation : rotation,
            categoryHierarchy = chart.dataObject.categoryHierarchy;
          var count;
          if (rotation_new === 'auto') {
            rotation = 0;
            count = getMaxTickCountByBounds(rotation, tickBound, type);
            if (!isSingleTick && count < tickCount) {
              if (side === 'width') {
                // isBranchAxisType = chart.dataObject.pivot && type == 'x' && isBranchAxis(type, axisOrder, chart),
                if (
                !hasDefinedAutoRotation && (
                categoryHierarchy && type == 'x' && !isBranchAxisType && hasBranchAxis(type, helpers.chart) ||
                !categoryHierarchy && type == 'x' && helpers.chart.axes.x.count > 1))
                {
                  rotation = 90; //For hierarchy auto rotate 90
                } else {
                  rotation = tickAutoRotation;
                }

                count = getMaxTickCountByBounds(rotation, tickBound, null); //For auto rotation calculation customType should be null
                recalculate = true;
              } else {
                recalculate = true;
              }
            } else {
              recalculate = false;
            }
          } else {
            count = getMaxTickCountByBounds(rotation_new, tickBound, type);
            rotation = rotation_new;
          }
          return {
            mode: 'rotate',
            rotation: rotation,
            maxTickCount: count,
            recalculate: recalculate
          };
        }
        function getMaxTickCountByZigzag(tickBound) {
          var count = getMaxTickCountByBounds(0, tickBound, type); //For zigzag rotation is 0

          return {
            mode: 'zigzag',
            rotation: 0,
            maxTickCount: count * 2
          };
        }

        function getMaxTickCountByWrapOnSpace() {
          if (tickAlignmentMode == 'auto') {
            formattedTickValues = formattedTickValues.map(function (d, i) {
              return d.split(' ');
            });
            var longestTick = getLongestTick$1(formattedTickValues, tickValues, tickFontSize, tickFontFamily, customTickInfo.styles);
            if (!defined(longestFormattedString)) {
              longestFormattedString = longestTick.formattedVal;
            }

            // calculate number of tick can be fit.
            var tickBound = getTextBound(longestFormattedString, tickFontSize, tickFontFamily, longestTick.style, true);
          }

          var count = getMaxTickCountByBounds(rotation, tickBound, type);

          return {
            mode: 'wrapOnSpace',
            maxTickCount: count,
            rotation: rotation
          };
        }

        function getMaxTickCountByWrapAll() {
          var count = getMaxTickCountByBounds(rotation, tickBound, type);

          return {
            mode: 'wrapAll',
            maxTickCount: count,
            rotation: rotation
          };
        }
      },

      recalculatePlotSize: function recalculatePlotSize(chartObj, oldPlotSize, tickSize, side, tickCount, margin, padding, outerPadding, type) {
        var categoryThickness = getPropVal(chartObj.systemConf, 'chart.scroll.categoryThickness') || tickSize[side],
          v,
          p;
        if (side === 'height') {
          categoryThickness += margin.top + margin.bottom;
          v = categoryThickness * tickCount;
          oldPlotSize = [v, 0];
        } else {
          categoryThickness += margin.left + margin.right;
          v = categoryThickness * tickCount;
          oldPlotSize = [0, v];
        }
        p = type == 'x' ? getOuterPaddingInPixel(oldPlotSize, tickCount, padding, outerPadding, categoryThickness) : 0;
        v += p;
        chartObj.systemConf.chart[side] = v;
      }
    };

    axis.Ticks = Ticks;
    axis.AxisLabel = AxisLabel;

    axis.Ticks.prototype.ticklabelFitModels = function (tickValues, maxTickCount) {
      var bestFitMode = {};
      var actualTickCount = tickValues.length;
      bestFitMode.zigzag = {}, bestFitMode.rotate = {};
      if (actualTickCount > maxTickCount) {
        if (actualTickCount * 2 < maxTickCount) {
          bestFitMode.type = 'zigzag';
        } else {
          bestFitMode.type = 'rotate';
        }
      } else {
        bestFitMode.type = 'default';
      }
      return bestFitMode;
    };

    function formatArray(array, formatter, formatConf, chart, dataType, type, specifierIndex, tickAlignmentMode, maxSize, fontSize) {
      var needTickConfigWrap = tickAlignmentMode == 'wrapOnSpace' || tickAlignmentMode == 'wrapAll';
      return array.map(function (value) {
        var formattedValue;
        formattedValue = formatter(formatConf, value, dataType, chart, type, null, null, specifierIndex);
        formattedValue = needTickConfigWrap ?
        formatTickWrapByMode(formattedValue, tickAlignmentMode, maxSize.horizontal, maxSize.vertical, fontSize) :
        formattedValue;
        return formattedValue;
      });
    }

    function getLinearTicksByCount(domain, count, customStop, intervalType) {
      if (count === 1) {
        step = getLinearStep(domain, 1);
        min = Math.ceil(domain[0] / step) * step;
        return [min];
      } else {
        var tickInterval = (domain[1] - domain[0]) / count,
          min,
          max,
          remaining,
          m = count - 1,
          span = domain[1] - domain[0],
          step = span / m,
          power = mathFloor(mathLog(step) / mathLN10),
          magnitude = mathPow(10, power),
          ticks;

        magnitude = magnitude * Math.floor(step / magnitude);
        magnitude = +magnitude.toFixed(12); //To avoid floating point error (e.g):1.7000000000000002

        var nicedInterval = nearestTickInterval(tickInterval, magnitude, null, intervalType);

        if (intervalType == 'integer' && nicedInterval < 1) {
          return getLinearTicksBySubFunction(domain, count, customStop);
        }
        min = domain[0];
        max = domain[1];
        remaining = span - nicedInterval * m;

        // if (remaining < nicedInterval && Math.floor((span / m) / magnitude) > 1) {
        //     nicedInterval -= magnitude;
        //     remaining = span - (nicedInterval * m);
        // }

        var mag_remaining = mathPow(10, mathFloor(mathLog(remaining) / mathLN10) + 1);
        min = nearestNiceMin(min, remaining, mag_remaining, nicedInterval);
        min = +min.toFixed(12); //To avoid floating point error (e.g):1.7000000000000002
        max = min + nicedInterval * count;
        max = +max.toFixed(12); //Test_559,560

        max = max > domain[1] ? +domain[1] : max;
        ticks = d3_range(min, max, nicedInterval);
        if (defined(customStop)) {
          ticks = addMaxStopToTicks(ticks, nicedInterval, customStop);
        }
        return ticks;
      }
    }

    function getLinearStep(domain, count) {
      var m = defined(count) ? count : 10,
        span = domain[1] - domain[0],
        step = mathPow(10, mathFloor(mathLog(span / m) / mathLN10)),
        err = m / span * step;
      if (err <= 0.15) {
        step *= 10;
      } else if (err <= 0.35) {
        step *= 5;
      } else if (err <= 0.75) {
        step *= 2;
      }
      return step;
    }

    function getLinearTicksByInterval(domain, tickInterval, customStop) {
      var count = mathFloor((domain[1] - domain[0]) / tickInterval),
        min,
        ticks;

      if (count) {
        var step = getLinearStep(domain, count);
        min = mathCeil(domain[0] / step) * step;

        if (min - domain[0] > tickInterval) {
          var s = mathPow(10, mathFloor(mathLog(tickInterval) / mathLN10)),
            q = mathFloor((min - domain[0]) / s);
          min -= q * s;
        }
      } else {
        var span = domain[1] - domain[0],
          s = mathPow(10, mathFloor(mathLog(span) / mathLN10));
        min = domain[0] - domain[0] % s + s;
      }

      ticks = d3_range(min, domain[1], tickInterval);
      if (defined(customStop)) {
        ticks = addMaxStopToTicks(ticks, tickInterval, customStop);
      }
      return ticks;
    }

    function getLinearTicksBySubFunction(domain, count, customStop) {
      var ticks,
        interval = getNiceStep(domain, count);
      ticks = d3_range(getNiceMin(domain, 1), domain[1], interval);
      if (defined(customStop)) {
        ticks = addMaxStopToTicks(ticks, interval, customStop);
      }
      return ticks;
    }

    function getNiceMin(domain, minStep) {
      var step = getLinearStep(domain);
      if (defined(minStep)) {
        // Test_525.json
        step = mathMax(minStep, step);
      }
      return mathCeil(domain[0] / step) * step;
    }

    function getNiceStep(domain, count) {
      return mathCeil(getLinearStep(domain, count));
    }

    function addMaxStopToTicks(ticks, interval, stopValue) {
      if (ticks[ticks.length - 1] + interval <= stopValue) {
        ticks.push(ticks[ticks.length - 1] + interval);
      }
      return ticks;
    }

    function getEntries(scale, dataType, count, subfunction, defaultReverse) {
      var domain = scale.domain(),
        entries;

      if (dataType === TIME_DATATYPE) {
        entries = scale.ticks(count);
        entries = entries.length < count ? scale.ticks(count * 2) : entries;
        entries = filterCategories(entries, count);
        updateEntriesByDomain(entries, domain);

        return entries;
      } else {
        if (subfunction === 'integer') {
          entries = getLinearTicksBySubFunction(domain, mathMax(count - 1, 1));
          entries = addMaxDomain(entries, domain);
        } else {
          entries = getLinearTicksByCount(domain, count);
          updateEntriesByDomain(entries, domain);
        }

        return entries.map(function (_) {return +_.toFixed(12);}).sort(defaultReverse ? d3_descending : d3_ascending);
      }
    }

    function getTickCount(config, scale, view) {
      var count = getUserTickCount(config, scale, view);

      if (!count) {
        var range = scale.range(),
          domain = scale.domain(),
          minCount = domain[0] === domain[domain.length - 1] ? 1 : 3;
        count = mathMax(minCount, mathRound((range[range.length - 1] - range[0]) / 20));
        count = isNumber(count) ? count : minCount;
      }

      return count > 1 ? count + 0.1 : count; //Why 0.1? => DOC_GEOBUBBLEPIE_1
    }

    function getUserTickCount(config, scale, view) {
      var typeConfig = config[view],
        userTickCount = (typeConfig.axis || typeConfig).tickCount;

      if (userTickCount) {
        return invokeFunction(userTickCount, scale, config);
      }
    }

    function addMaxDomain(entries, domain) {
      var entriesLength = entries.length,
        maxDomain = domain[domain.length - 1];

      if (entriesLength > 1) {
        if (domain[domain.length - 1] - entries[entriesLength - 1] < (entries[entriesLength - 1] - entries[entriesLength - 2]) / 2) {
          entries[entriesLength - 1] = maxDomain;
        } else {
          entries.push(maxDomain);
        }
      } else {
        entries.push(maxDomain);
      }

      return entries;
    }

    function updateEntriesByDomain(entries, domain) {
      entries[0] = domain[0];
      entries[entries.length - 1] = domain[domain.length - 1];
    }

    //
    var
    BaseLegend = /*#__PURE__*/function (_BaseView) {_inherits(BaseLegend, _BaseView);var _super2 = _createSuper(BaseLegend);function BaseLegend() {_classCallCheck(this, BaseLegend);return _super2.apply(this, arguments);}_createClass(BaseLegend, [{ key: "resize", value:
        function resize(width, height) {
          var bound = this.spec.bound;
          bound.maxWidth = width;
          bound.maxHeight = height;

          this.create();
          this.draw(this.element);
        } }, { key: "viewScaleComponent", value:

        function viewScaleComponent() {
          var spec = this.spec,
            config = spec.config,scaleComponent = spec.scaleComponent,view = spec.view,
            scale = scaleComponent.getScale(),
            range = scale.range(),
            domain = scale.domain(),
            size = range[range.length - 1],
            domainSchema = scaleComponent.schema.domain,_scaleComponent$schem =
            scaleComponent.schema.data,meta = _scaleComponent$schem.meta,dataType = _scaleComponent$schem.dataType,
            originalDataType = meta.datatype,
            formatConfig = meta[originalDataType] || {},
            _ranges = domainSchema.ranges,
            _stops = domainSchema.stops,
            userTickCount = getUserTickCount(config, scale, view),
            tickCount = getTickCount(config, scale, view),
            defaultReverse = view === LIST_LEGEND_TYPE,
            ticks,
            labels,
            viewScale;

          // Handling subfunction = 'AUTO' && format.specifier = 'auto'
          if (dataType === TIME_DATATYPE) {
            updateTimeMeta(formatConfig, domain);
          }

          if (dataType === ORDINAL_DATATYPE) {
            if (!config.ranges) {
              config.ranges = domain.map(function (d) {return [d];});
            }
          }

          if (_ranges || dataType === ORDINAL_DATATYPE) {
            ticks = dataType === ORDINAL_DATATYPE ? domain : _ranges || domain; // For ordinal, the ticks should be 1D array
            viewScale = d3_scaleOrdinalOrg().
            domain(ticks).
            range(range);
          } else {
            ticks = _stops ? domain : getEntries(scale, dataType, tickCount, formatConfig.subfunction, defaultReverse);
            viewScale = scale;
          }

          if (userTickCount) {
            labels = filterCategories(ticks, userTickCount);
          }

          return {
            ticks: ticks,
            labels: labels || ticks,
            scale: viewScale,
            bound: { width: size, height: size },
            labelData: _ranges && ticks._dummy && ticks.length === 1 && ticks[0][0] === ticks[0][1] ? [[ticks[0][0]]] : null // ZC2548
          };
        } }]);return BaseLegend;}(BaseView);


    function updateTimeMeta(formatConfig, domain) {
      var subfunction = formatConfig.subfunction,
        autoFormat = hasAutoFormat(formatConfig, 'legend');

      if (!defined(subfunction) || subfunction === 'AUTO' || autoFormat) {
        var info = getAutoTimeSubFunction(domain[1] - domain[0]);
        formatConfig.subfunction = info.subFunction;
      }

      if (autoFormat) {
        (formatConfig.legendformat || formatConfig.format).specifier = null;
      }
    }

    //
    // import { getActiveDomain } from '../colorband/colorband-brush-tooltip-content';
    // import { arrayFindIndex } from '../../utils/array-utils';
    // import { jsonStringify, isWithinRange } from '../../utils/zcutils';
    var
    ColorLegend = /*#__PURE__*/function (_BaseLegend) {_inherits(ColorLegend, _BaseLegend);var _super3 = _createSuper(ColorLegend);function ColorLegend() {_classCallCheck(this, ColorLegend);return _super3.apply(this, arguments);}_createClass(ColorLegend, [{ key: "create", value:
        function create() {
          this.encode = getlegend(this.spec.chartObj, this.spec);
        } }, { key: "draw", value:

        function draw(parent) {
          this.parent = parent;
          var isContinousLegend = legend_helpers.isContinousLegend(this.spec.chartObj);
          if (isContinousLegend) {
            _get(_getPrototypeOf(ColorLegend.prototype), "draw", this).call(this, parent);
            return;
          }

          this.encode(parent.datum(this.spec.config));
        } }, { key: "resize", value:

        function resize(width, height) {
          if (!width && !height) {
            return;
          }

          var bound = this.spec.bound,_getMaxToResize =
            getMaxToResize(width, height, bound),w = _getMaxToResize.w,h = _getMaxToResize.h;
          bound.maxWidth = w;
          bound.maxHeight = h;

          this.create();
          this.draw(this.parent);
        } }]);return ColorLegend;}(BaseLegend);


    function createColorAxis(chartObj) {
      var isQuantileColorScale = colorscale_helpers.isQuantileColorScale(chartObj);
      if (isQuantileColorScale) {
        var userData = chartObj.userdata,
          _config7 = chartObj.systemConf.legend,
          dataType = chartObj.dataset.getDataType('clr');

        if (dataType === ORDINAL_DATATYPE) {
          userData.legend = userData.legend || {};
          userData.legend.colorBand = userData.legend.colorBand || {};
          if (!userData.legend.colorBand.ranges) {
            _config7.colorBand.ranges = userData.legend.colorBand.ranges = colorscale_helpers.getCategories(chartObj);
          }
        }

        var userRanges = _config7.colorBand.ranges;
        if (userRanges && userRanges.length) {
          userData.legend.colorBand.ranges = _config7.colorBand.ranges = getRawRanges(_config7, chartObj, true); //for  [10,20,30,40] ranges where the ranges are not array, it is mandatory to convert it to array and save it in userdata and systemconf for performing legend highlight, filter and redraw after legend filter
        }

        _config7.ranges = _config7.colorBand.ranges;

        // Legend type switch with filter.range
        // if (!legend_helpers.isContinousLegend(chartObj)) {
        //     let userRanges = config.colorBand.ranges;
        //
        //     if (config.filter.range) {
        //         let activeDomain = getActiveDomain(config, chartObj),
        //             activeIndices = activeDomain.map(_ => arrayFindIndex(userRanges, range => jsonStringify(_) === jsonStringify(range)));
        //
        //         userRanges.forEach((item, i) => (item.disabled = !isWithinRange(i, activeIndices)));
        //         config.filter.range = null;
        //     }
        // }

        var colorScale = scale.getScale(chartObj, chartObj.dataObject, null, null, null, chartObj.dataset, 'clr'),
          colorScale_domain = colorScale.domain(),
          indexScale = colorScale.copy();
        indexScale.range(
        colorscale_helpers.getProcessedColorRange(d3_range(colorScale_domain.length), colorScale_domain, _config7, chartObj));


        var axisObj = chartObj.axes.clr || {};
        axisObj.scaleType = 'quantile';
        axisObj.dataType = dataType;
        axisObj.scale = colorScale;
        axisObj.indexScale = indexScale;
        axisObj.schema = { data: { meta: _objectSpread(_objectSpread({}, chartObj.dataset.getColumn('clr')), {}, { columnindex: chartObj.dataset.getColumnIdx('clr') }) } };
        axisObj.component = axisObj.component || axis.get(); //#ZC1310
        chartObj.axes.clr = axisObj;
      } else {
        chartObj.axes.clr = {};
      }
    }

    function getlegend(chartObj, spec) {
      var legComp = chartObj.legend.component = legend.discrete.get(spec);

      var legend_comp = legComp.
      chartarea(chartObj.chartarea).
      systemconf(chartObj.systemConf).
      color(chartObj.seriesColor).
      chartObj(chartObj);
      return legend_comp;
    }

    //

    function collect(chartObj) {
      var legendHighlight = Registry.getComponent('LegendHighlight'),
        legendConfig = chartObj.systemConf.legend,
        SUPPORTED =
        !chartObj.dataObject.hasZaxis || isHeatMapChartType(chartObj.chartTypes[0].value) || chartObj.dataObject.isFlowChartCategory ?
        [] :
        ['z'],
        legendMeta = [],
        renderFunc = function renderFunc(domMode, id) {var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1];
          var isSvg = domMode === SVG_ELEMENT,
            eleType = isSvg ? 'g' : DIV_ELEMENT,
            isLastElement = function isLastElement(d, i, list) {return i === list.length - 1;}, // Overview chart: on redraw 2 set of legends are drawn. legends are drawn for overview div too
            parent = chartObj.container.selectAll("".concat(eleType, ".legendarea")).filter(isLastElement);

          parent.style('display', NULL$1);
          return createElement(eleType, ".zc-legend-".concat(id), data, parent);
        },
        renderTo = function renderTo(domMode, id, data) {
          var oppDomMode = domMode === SVG_ELEMENT ? 'html' : SVG_ELEMENT;
          renderFunc(oppDomMode, id, []); // remove opposite element
          var element = renderFunc(domMode, id, data);

          if (id.indexOf('z') > -1 || id.indexOf('shape') > -1 || id.indexOf('clr') > -1 && domMode === SVG_ELEMENT) {
            applyFont(element, [chartObj.systemConf.canvas, $ZCG], domMode !== SVG_ELEMENT);
          }

          return element;
        },
        dataSplicer = chartObj.dataSplicer,
        encodes = dataSplicer.getEncode();

      if (defined(chartObj.dataset.getColumnIdx('shape'))) {
        SUPPORTED.push('shape');
      }

      //Remove----
      createColorAxis(chartObj);
      var categoryHierarchy = chartObj.dataObject.categoryHierarchy,
        colorLegendLength = 1;

      if (categoryHierarchy) {
        var hierarchical = chartObj.dataObject.hierarchical,
          pivotLayout = hierarchical.pivotLayout,
          layers = pivotLayout.layers,
          colorLegendLength = layers.groups.length;
      }
      var _ = 'clr';
      // if (encodes[_]) {
      //     encodes[_].forEach((index, key) => {
      // let id = `${_}-${key}`,
      //     id1 = `${_}-${key1}`,
      //     config = legendConfig;

      for (var i = 0; i < colorLegendLength; i++) {
        var id = "".concat(_, "-").concat(i),
          _config8 = legendConfig,
          view = _legendType(_, { config: _config8, dataType: chartObj.axes.clr.dataType }),
          domMode = LegendRegistry.get('clr', view).domMode,
          parser = isObjectPropDefined(chartObj.systemConf, "viewParser.legend.".concat(id), true);

        if (i > 1 && legendConfig.color) {
          if (!legendConfig.color[0]) ;
          legendConfig.color[i] = _config8 =
          legendConfig.color[i] != null ? mergeJSON(legendConfig.color[i], legendConfig.color[0], false) : legendConfig.color[0];
        }

        var meta = {
          id: id,
          config: _config8,
          renderTo: renderTo,
          parser: parser,
          order: i,
          encode: _,
          globalFont: chartObj.systemConf.canvas,
          scaleComponent: chartObj.axes.clr,
          area: chartObj.chartarea,
          bound: getLegendBound(_config8, chartObj.chartarea),
          format: _format(chartObj.dataset.getColumn('clr'), chartObj, domMode),
          enabled: isLegendEnabled(_config8, chartObj),
          view: legend_helpers.isContinousLegend(chartObj) ? 'band' : 'list',
          effect: getChartEffect(_config8, chartObj),
          callbackArgs: [chartObj],
          highlightManager: new legendHighlight(chartObj, chartObj.svg, { encode: 'clr', config: _config8, order: i }),
          chartObj: chartObj //remove
        };
        legendMeta.push(meta);
      }
      //     });
      // }
      //----Remove

      SUPPORTED.forEach(function (_) {
        if (encodes[_]) {
          encodes[_].forEach(function (index, key) {
            var id = "".concat(_, "-").concat(key),
              scaleComponent = arrayFind(chartObj.scales, function (_) {return _.id === id;}),
              config = getLegendConfig(_, key, chartObj),
              view = _legendType(_, { config: config, dataType: scaleComponent.schema.data.dataType }),
              domMode = LegendRegistry.get(_, view).domMode,
              parser = isObjectPropDefined(chartObj.systemConf, "viewParser.legend.".concat(id), true);

            var meta = {
              id: id,
              scaleComponent: scaleComponent,
              config: config,
              renderTo: renderTo,
              view: view,
              parser: parser,
              encode: _,
              globalFont: chartObj.systemConf.canvas,
              area: chartObj.chartarea,
              bound: getLegendBound(config, chartObj.chartarea),
              format: _format(scaleComponent.schema.data.meta, chartObj, domMode),
              enabled: isLegendEnabled(config, chartObj, _),
              effect: getChartEffect(config, chartObj),
              highlightManager: new legendHighlight(chartObj, chartObj.svg, { encode: _, config: config }),
              callbackArgs: [chartObj]
            };

            if (!legendConfig.singleLayout) {
              legendMeta.push(meta);
            }
          });
        }
      });

      chartObj.legend.isSingleLayout = legendConfig.singleLayout || legendMeta.length <= 1; //Remove
      legendMeta[0].bound.adjust = !chartObj.legend.isSingleLayout;

      return legendMeta;
    }

    function render(meta) {
      var encode = meta.encode,id = meta.id,enabled = meta.enabled,highlightManager = meta.highlightManager,config = meta.config,effect = meta.effect,
        renderer = LegendRegistry.get(encode, meta.view);

      if (renderer !== noOperation) {
        var component = new renderer(meta),
          element = meta.renderTo(renderer.domMode, id, [config]);

        element.style('display', enabled ? NULL$1 : NONE);

        if (enabled) {
          clearDom(element, meta);
          component.create();
          component.draw(element);

          // Filter effects
          applyEffect(element, { effect: effect });
        }

        return { enabled: enabled, element: element, component: component, meta: meta, id: id, highlightManager: highlightManager };
      }
    }

    function _legendType(encode, options) {
      var config = options.config,dataType = options.dataType;

      if (config.type) {
        return config.type;
      }

      switch (encode) {
        case 'z':
        case 'size':
          return config.ranges || dataType === ORDINAL_DATATYPE ? 'list' : 'nested';
        case 'color':
        case 'clr':
          return config.ranges || dataType === ORDINAL_DATATYPE ? 'list' : 'band';
        case 'shape':
          return 'list';}

    }

    function _format(meta, chartObj, domMode) {
      if (!meta) {
        return;
      }

      var dataType = meta.datatype,
        formatConf = meta[dataType],
        arraySeperator = '-',
        toDecode = domMode === SVG_ELEMENT;

      return function (d) {return getFormattedValue(formatConf, d, dataType, chartObj, 'legend', toDecode, arraySeperator);};
    }

    function clearDom(element, meta) {
      var view = meta.view,
        prevView = element.attr('zc-view');

      if (prevView && view !== prevView) {
        element.selectAll('*').remove();
      }
      element.attr('zc-view', view);
    }

    function updatePlotOption(chartObj, newSystemConf) {
      var plotoptions = newSystemConf.chart.plot.plotoptions;
      for (var i = 0; i < chartObj.distinctChartTypes.length; i++) {
        setDefaultOptions(chartObj.distinctChartTypes[i], plotoptions, chartObj.globalProp);
      }
    }

    function updateExistingPlotComponents(chartObj) {
      var isSingleSourceEventCharts = chartcategory.singleSourceEvent;

      var nonAxis = chartcategory.nonaxis;
      var nonAxisMultiSeriesCategory = chartcategory.nonaxismultiseries;

      var nonAxisCharts = nonAxis.concat(nonAxisMultiSeriesCategory);
      var polarAxis = chartcategory.polarAxis;
      var oldchart = chartObj.oldChartTypes;

      chartObj.chartTypes.map(function (d, i) {
        if (
        !(nonAxisCharts.indexOf(oldchart[i].value) != -1) && nonAxisCharts.indexOf(d.value) != -1 ||
        polarAxis.indexOf(oldchart[i].value) != -1)
        {
          removeAxis(chartObj);
          removeAxisLabels(chartObj, i);
          removeThreshold(chartObj);
          removePlotAreaBorder(chartObj);
        }
        if (isSingleSourceEventCharts.indexOf(d.value) === -1) {
          chartObj.eventHandler.removeTracker();
        }
        removeDataLabels(chartObj);
      });
    }

    function removeAxis(chartObj) {
      var svg = chartObj.svg;
      svg.selectAll('.x-axis').
      selectAll('g').
      remove();
      svg.selectAll('.y-axis').
      selectAll('g').
      remove();
    }

    function removeAxisLabels(chartObj, i) {
      setPropVal(chartObj.axes, 'x.axisLabel', null);
      setPropVal(chartObj.axes, 'y.groups[' + i + '].axisLabel', null);
    }

    function removeThreshold(chartObj) {
      var staticPane = chartObj.staticPaneSVG;
      staticPane.
      selectAll('.threshold').
      selectAll('g').
      remove();
    }

    function removePlotAreaBorder(chartObj) {
      var staticPane = chartObj.staticPaneSVG;
      staticPane.
      selectAll('.plotareaBorder-property').
      selectAll('line').
      remove();
    }

    function removeDataLabels(chartObj) {
      chartObj.staticPaneSVG.
      selectAll('.labelholder').
      selectAll('g').
      remove();
    }

    function checkChartTypeEquality(fromChartTypes, toChartTypes) {
      var result = true;
      if (fromChartTypes === undefined) {
        return result;
      }
      if (fromChartTypes.length != toChartTypes.length) {
        return false;
      }
      fromChartTypes.map(function (d, i) {
        if (toChartTypes[i].name != d.name) {
          result = false;
        }
      });
      return result;
    }

    var GROUP_SELECTOR = d3_map();

    GROUP_SELECTOR.set('bar', 'series_');
    GROUP_SELECTOR.set('pie', 'group');
    GROUP_SELECTOR.set('funnel', 'group');
    GROUP_SELECTOR.set('pyramid', 'group');
    GROUP_SELECTOR.set('scatter', 'series_');
    GROUP_SELECTOR.set('line', 'series_');
    GROUP_SELECTOR.set('area', 'series_');

    var pathModifier = d3_map();

    pathModifier.set('bar', function (paths_old) {
      return paths_old;
    });
    pathModifier.set('pie', function (paths_old) {
      return paths_old;
    });
    pathModifier.set('funnel', function (paths_old) {
      var newModifiedPaths = [];
      paths_old.map(function (d) {
        var id = d.getAttribute('id');
        if (id.indexOf('funnel') != -1) {
          newModifiedPaths.push(d);
        }
      });
      return newModifiedPaths.reverse();
    });

    pathModifier.set('scatter', function (paths_old) {
      var newModifiedPaths = [];
      paths_old.map(function (d) {
        var className = d.getAttribute('class');
        if (className.indexOf('outer') != -1) {
          newModifiedPaths.push(d);
        }
      });
      return newModifiedPaths;
    });

    pathModifier.set('pyramid', function (paths_old) {
      var pyramidSectionCount = paths_old.length / 4;
      var newArray = [],
        pyramidSection = 0;
      for (var i = 0; i < pyramidSectionCount; i++) {
        var combinedPath = paths_old[pyramidSection + 2].getAttribute('d') + ' ' + paths_old[pyramidSection + 3].getAttribute('d'); //directly viewable paths in pyramidsection
        combinedPath = combinedPath.replace(/[^\d. ]/g, '');
        var patharray = combinedPath.split(' ');

        var finalPathh = "M".concat(patharray[6], " ").concat(patharray[7], " L").concat(patharray[4], " ").concat(patharray[5], " L").concat(patharray[14], " ").concat(patharray[15], " L").concat(
        patharray[12], " ").concat(
        patharray[13], " L").concat(patharray[2], " ").concat(patharray[3], " L").concat(patharray[0], " ").concat(patharray[1]);

        paths_old[pyramidSection].setAttribute('d', finalPathh);
        newArray.push(paths_old[pyramidSection]);
        pyramidSection = pyramidSection + 4;
      }
      return newArray.reverse();
    });

    function collectExistingSeriesInfo(chartObj, chart_types) {
      var oldseries = d3_map();
      chart_types.map(function (d, i) {
        var seriesInfo = {};
        var isMultiColoring = chartObj.renderer[i].commonRendererProp().params.commonPlotOptions.multiColoring;
        seriesInfo.isAxisCategory = chartObj.isAxisCategory;
        seriesInfo.seriesIndex = i;
        seriesInfo.chartType = d.name;
        seriesInfo.pathData = collectExistingPath(chartObj, seriesInfo.isAxisCategory, d.name, i);
        seriesInfo.color = collectExistingColor(chartObj, seriesInfo.isAxisCategory, isMultiColoring, seriesInfo.pathData, i);
        seriesInfo.plotarea = chartObj.plotarea;
        seriesInfo.transformationInfo = collectTransformationInfo(chartObj, seriesInfo.isAxisCategory, d.name, i);
        oldseries.set(i, seriesInfo);
      });
      chartObj.oldSeriesInfo = oldseries;
    }

    var transformGroupSelector = d3_map();
    transformGroupSelector.set('bar', '.zc_bar');
    transformGroupSelector.set('pie', '.zc_pie');
    transformGroupSelector.set('funnel', '.zc_funnel');
    transformGroupSelector.set('pyramid', '.pyramidsection');
    transformGroupSelector.set('scatter', '.scatter');

    function collectTransformationInfo(chartObj, isAxisCategory, chartType, i) {
      var seriesholder = chartObj.svg.selectAll('.seriesholder'),
        selectorIndex = isAxisCategory ? i : '',
        transformedGroups = transformGroupSelector.get(chartType),
        transformationInfo = [];

      seriesholder.
      selectAll(".".concat(chartType).concat(GROUP_SELECTOR.get(chartType)).concat(selectorIndex)).
      selectAll(transformedGroups).
      each(function () {
        var transform = this.getAttribute('transform');
        if (transform) {
          var x = Number(transform.slice(transform.indexOf('(') + 1, transform.indexOf(',') - 2)),
            y = Number(transform.slice(transform.indexOf(',') + 1, transform.indexOf(')') - 2));
          transformationInfo.push({ x: x, y: y });
        } else {
          transformationInfo.push({ x: 0, y: 0 });
        }
      });
      return transformationInfo;
    }

    function collectExistingPath(chartObj, isAxisCategory, chartType, i) {
      var seriesholder = chartObj.svg.selectAll('.seriesholder');
      var paths_old = [];
      var selectorIndex = isAxisCategory ? i : '';
      seriesholder.
      selectAll(".".concat(chartType).concat(GROUP_SELECTOR.get(chartType)).concat(selectorIndex)).
      selectAll('path').
      each(function () {
        paths_old.push(this);
      });
      return pathModifier.get(chartType)(paths_old);
    }

    function collectExistingColor(chartObj, isAxisCategory, isMultiColoring, oldPaths, i) {
      var colors_old,
        selectorIndex = isAxisCategory ? i : '';
      if (isAxisCategory && isMultiColoring || !isAxisCategory) {
        colors_old = oldPaths.map(function (d, i) {
          return getRawColor(chartObj, i, d, selectorIndex);
        });
      } else {
        colors_old = oldPaths.map(function (d) {
          return getRawColor(chartObj, 0, d, selectorIndex);
        });
      }
      return colors_old;
    }

    function getOffsetValue(chartObj, index) {
      var oldSeriesData = chartObj.oldSeriesInfo.get(index);
      if (!chartObj.isAxisCategory) {
        if (!chartObj.isAxisCategory && !oldSeriesData.isAxisCategory) {
          return {
            x: oldSeriesData.plotarea.centerX - chartObj.plotarea.centerX,
            y: oldSeriesData.plotarea.centerY - chartObj.plotarea.centerY
          };
        } else {
          return {
            x: -chartObj.plotarea.centerX + (oldSeriesData.plotarea.left - chartObj.plotarea.left),
            y: -chartObj.plotarea.centerY - (chartObj.plotarea.top - oldSeriesData.plotarea.top)
          };
        }
      } else {
        if (chartObj.isAxisCategory && oldSeriesData.isAxisCategory) {
          return {
            x: oldSeriesData.plotarea.left - chartObj.plotarea.left,
            y: oldSeriesData.plotarea.top - chartObj.plotarea.top
          };
        } else {
          return {
            x: -(chartObj.plotarea.left - oldSeriesData.plotarea.left) + oldSeriesData.plotarea.centerX,
            y: -(chartObj.plotarea.top - oldSeriesData.plotarea.top) + oldSeriesData.plotarea.centerY
          };
        }
      }
    }

    //

    function generateRanges(config, schema, scale, view) {
      var _schema$data = schema.data,dataType = _schema$data.dataType,meta = _schema$data.meta,_schema$domain =
        schema.domain,ranges = _schema$domain.ranges,stops = _schema$domain.stops,
        configRanges = config.ranges,
        subFunction = getSubFunction(meta),
        scale_domain = scale.domain();

      if (view !== LIST_LEGEND_TYPE || ranges || dataType === ORDINAL_DATATYPE) {
        if (configRanges && configRanges._dummy) ;
        return;
      }

      // If no change in scale domain and subfunction, just return the ranges(reason: after legend filter if chart dimension differs on redraw, new set of ranges are created in where disabled property is removed)
      var _cache = configRanges && configRanges._cache;
      if (_cache && _cache.subFunction === subFunction && jsonStringify(_cache.domain) === jsonStringify(scale_domain)) {
        return configRanges;
      }

      var count = getTickCount(config, scale, view),
        ticks = stops ? scale_domain : getEntries(scale, dataType, count + 1, subFunction),
        generated = ticks.length === 1 ? [[ticks[0], ticks[0]]] : d3_pairs(ticks); // ZC2548

      generated._dummy = true;
      generated._cache = { subFunction: subFunction, domain: scale_domain };

      // Adding the disabled property on redraw
      if (configRanges && jsonStringify(configRanges) === jsonStringify(generated)) {
        configRanges.forEach(function (_, i) {return generated[i].disabled = _.disabled;});
      }

      return generated;
    }

    function getSubFunction(meta) {
      var dataType = meta.datatype,
        formatConfig = meta[dataType] || {};

      return formatConfig.subfunction;
    }

    /**
     *
     * @constructor
     */

    function VizLayout(container, userData) {
      this.container = container;
      this.userdata = userData;

      this.oldRenderer = [];
      this.dataset = {};
      this.dataObject = {};
      this.canvasarea = {};
      this.chartarea = {};
      this.legendarea = {};

      this.legend = {
        color: [
        {
          component: null
        }],

        component: null
      };
      this.renderer = [];
      this.svg = null;
      this.cache = {};
      this.subrenderer = [];
      this.datalabels = {
        moduleExists: labelRenderer
      };
      this.prepareLayout();
      this.renderVisiblePointsOnly = false;
    }

    VizLayout.prototype.prepareLayout = function () {
      var chart = this;

      var currentChartId = addViewCount();
      chart.id = "ZC_".concat(currentChartId);
      chart.idNumeric = currentChartId;

      try {
        var data = this.userdata;

        chart.createHelperElements();
        chart.handleHiddenContainer();

        chart.chartWidth = chart.getChartDimension('width');
        chart.chartHeight = chart.getChartDimension('height');
        VizLayout.helpers.initializeChartHolders(chart);
        chart.setCanvasDimension();

        // get all chart types
        chart.chartTypes = DataProcessor.helpers.getAllChartTypes(data, 'object');

        chart.chartFontProp = {};
        chart.globalProp = setGlobalPropByUserdata(
        data,
        {
          width: chart.canvasarea.width,
          height: chart.canvasarea.height
        },
        chart.chartFontProp);


        chart.themeoptions = chart.getThemeOptions(chart.globalProp);

        // If metadata is unavailable, get default metadata
        if (!data.metadata && !chart.userdata._viewParser) {
          setDefaultOptions('metadata', data);
        }

        chart.defsLocation = getDefsLocation();

        chart.svg.append('defs');
        // chart.processUserData(chart.themeoptions);
        // chart.setChartDimension();
        // VizLayout.helpers.constructChartGroups(chart);
      } catch (err) {
        VizLayout.helpers.handleErrors(chart, err);
      }
    };

    var chartBasicHelpers = {
      /**
       *
       * @return {d3.selection}
       */
      getPatternSvg: function getPatternSvg() {
        var chart = this,
          patternSvg = chart.patternSVG;

        if (!defined(patternSvg)) {
          var rootBody = getRootBody(chart.container.node());
          patternSvg = chart.patternSVG = d3_select(rootBody).select('svg.svgPattern');
        }
        return patternSvg;
      },

      /**
       *
       * @return {number}
       */
      getDocumentIndex: function getDocumentIndex() {
        var chart = this;

        if (!defined(chart.DOCUMENT_INDEX)) {
          chart.DOCUMENT_INDEX = _getDocumentIndex(this.container.node());
        }
        return chart.DOCUMENT_INDEX;
      },

      /**
       *
       */
      getBaseContainer: function getBaseContainer() {
        var chart = this,
          index = chart.getDocumentIndex();

        if (!defined(chart.BASE_HELPER_CONTAINER)) {
          chart.BASE_HELPER_CONTAINER = DOCUMENT_OBJECT_HOLDER[index].BASE_HELPER_CONTAINER;
        }
        return chart.BASE_HELPER_CONTAINER;
      },

      /**
       *
       */
      createHelperElements: function createHelperElements() {
        var chart = this,
          rootBody = getRootBody(chart.container.node()),
          patternSvg = d3_select(rootBody).select('svg.svgPattern'),
          isEmptyPatternSvg = patternSvg.empty();

        if (!isEmptyPatternSvg) {
          chart.patternSVG = patternSvg;
        } else {
          var rootDocument = getRootNode(rootBody);
          var parent = d3_select(rootBody);
          var baseContainer = chart.baseContainer = appendEle(parent, 'div', [1], '.', 'class', '__baseZC_Container__');
          baseContainer.styles({
            position: 'absolute',
            left: BASE_CONTAINER_POSITION + PX,
            top: BASE_CONTAINER_POSITION + PX
          });

          chart.patternSVG = appendEle(baseContainer, 'svg', [1], '.', 'class', 'svgPattern').attrs({
            version: '1.1',
            xmlns: d3_namespaces.svg
          });

          appendEle(chart.patternSVG, 'defs', [1]);

          /**
           *
           * settings document index and important params
           */
          if (DOCUMENT_OBJECT_HOLDER) {
            var DOCUMENT_COUNT = 0; //Need to check TODO MODULARIZE
            var documentIndex = DOCUMENT_COUNT++;
            rootDocument.ZC_DOCUMENT_INDEX = documentIndex;
            DOCUMENT_OBJECT_HOLDER[documentIndex] = {
              BASE_HELPER_CONTAINER: chart.baseContainer,
              EFFECTS: {},
              ANIMATION: {},
              CANVASPATTERN: {}
            };
          }
        }
      },

      /**
       * Handles if the container is not visible or a virtual element in document.
       * @param {Boolean} normalize to restore the cloned element
       */
      handleHiddenContainer: function handleHiddenContainer(normalize) {
        var chart = this,
          container = chart.container;

        if (normalize && defined(chart.originalContainer)) {
          chart.originalContainer.node().appendChild(chart.d3container.node()); // place the cloned element under the original element.
          chart.container.remove(); // remove the cloned element.
          chart.container = chart.originalContainer; // restore the tween element.

          delete chart.isHiddenCoainer; // delete the temp variable.
          delete chart.originalContainer; // delete the temp variable.
        } else {
          var containerNode = container.node();

          if (isHidden(containerNode)) {
            var containerClone = containerNode.cloneNode(0), // clone the parent node.
              baseHelperContainer = chart.getBaseContainer();

            baseHelperContainer.node().appendChild(containerClone); // append to visible element.
            containerClone.style.setProperty('display', 'block', 'important'); // ensure its properly visible.

            chart.isHiddenCoainer = true;
            chart.originalContainer = container; // save the original container
            chart.container = d3_select(containerClone); // set pointer to our cloned element as main container.
          }
        }
      },

      /**
       *
       */
      updateCanvasArea: function updateCanvasArea() {
        var chart = this,
          systemConfig = chart.systemConf;

        chart.container.selectAll('div.d3container').styles({
          position: 'relative',
          width: chart.getChartDimension('width') + PX,
          height: chart.getChartDimension('height') + PX
          // "-webkit-transform" : "scale(1)",
          // "transform" : "scale(1)"
        });

        var canvas = chart.chartParentElement = chart.container.selectAll('div.canvas-component');
        canvas.styles({
          position: 'relative',
          width: "".concat(chart.canvasarea.width, "px"),
          height: "".concat(chart.canvasarea.height, "px")
        });

        var canvasProp = chart.container.selectAll('div.canvas-property');
        canvasProp.styles({
          position: 'absolute',
          width: "".concat(chart.canvasarea.width, "px"),
          height: "".concat(chart.canvasarea.height, "px")
        });
        chart.updateCommonBBSProp(canvasProp, null, systemConfig.canvas, 'canvas');
      },

      /**
       *
       * @param globalProp
       * @return {*}
       */
      getThemeOptions: function getThemeOptions(globalProp) {
        var chart = this,
          allDistinctSeriesTypes = chart.distinctChartTypes || getDistinct(getAllSeriesTypes(chart.userdata)),
          theme = isObjectPropDefined(chart.userdata, 'canvas.theme', true),
          userTheme,
          defaultThemeConfig;

        defaultThemeConfig = new defaultTheme(globalProp);
        allDistinctSeriesTypes.forEach(function (d) {return setDefaultOptions(d, defaultThemeConfig.chart.plot.plotoptions, globalProp);});
        var themeObj = chartThemes[theme] || window.$ZC && $ZC[theme];
        if (themeObj) {
          userTheme = new themeObj(globalProp);
          return mergeJSON$1(defaultThemeConfig, userTheme, true, true);
        }
        chart.distinctChartTypes = allDistinctSeriesTypes;
        return defaultThemeConfig;
      },

      /**
       * it returns the dimension of the inner box (excluding padding).
       * for hidden container returns static dimension.
       *
       * @param {"width"|"height"} property
       * @returns {Number} returns width or height
       */

      getChartDimension: function getChartDimension(property) {
        var chart = this,
          temp = {
            width: 960,
            height: 400
          };

        if (!chart.isHiddenCoainer) {
          temp[property] = getStyle(chart.container, property, true);
        }
        return temp[property];
      },

      /**
       *
       * @param width
       * @param height
       */

      setCanvasDimension: function setCanvasDimension(width, height) {
        var chart = this;

        if (!width && !height) {
          width = chart.getChartDimension('width');
          height = chart.getChartDimension('height');
        }

        this.canvasarea = {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0,
          width: width,
          height: height
        };
      },

      /**
       *
       */
      setChartDimension: function setChartDimension() {
        var chart = this,
          systemConfig = chart.systemConf;
        var borderOptions = systemConfig.canvas.border;
        var borderSize_canvas = borderOptions.show ?
        validateValWithinLimit(borderOptions, 'size', 0, 10, chart.canvasarea.width, chart.canvasarea.height) :
        0;
        chart.titlearea = {
          left: chart.canvasarea.left + borderSize_canvas,
          top: chart.canvasarea.top + borderSize_canvas,
          right: chart.canvasarea.right - borderSize_canvas,
          bottom: chart.canvasarea.bottom - borderSize_canvas,
          width: chart.canvasarea.width - 2 * borderSize_canvas,
          height: chart.canvasarea.height - 2 * borderSize_canvas
        };
        chart.chartarea = simpleClone(chart.titlearea);
        chart.plotarea = Object.create(chart.chartarea);
      },

      /**
       *
       */

      applyChartProperties: function applyChartProperties() {
        var chart = this,
          systemConfig = chart.systemConf,
          chartHeight = chart.chartHeight;

        var title = systemConfig.canvas.title,
          subtitle = systemConfig.canvas.subtitle,
          credits = systemConfig.credits || {};
        var showTitle = title.show && dimension_based_intelligence(chart, 'title', chartHeight),
          showSubtitle = subtitle.show && dimension_based_intelligence(chart, 'subtitle', chartHeight),
          showCredits = credits.enabled === true && dimension_based_intelligence(chart, 'credits', chartHeight);
        if (showCredits) {
          var defaultCreditOptions = setDefaultOptions('credits', chart.systemConf, chart.globalProp);
          // mergeJSON(chart.systemConf.credits, defaultCreditOptions, true, true);
          chart.drawTitle(chart.systemConf.credits, 'credits');
        }
        if (showTitle) {
          title.vAlign === 'bottom' && subtitle.vAlign === 'bottom' && subtitle.show ?
          chart.drawTitle(systemConfig.canvas.subtitle, 'subtitle') :
          chart.drawTitle(systemConfig.canvas.title, 'title');
        }
        if (showSubtitle) {
          subtitle.vAlign === 'bottom' && title.vAlign === 'bottom' && title.show ?
          chart.drawTitle(systemConfig.canvas.title, 'title') :
          chart.drawTitle(systemConfig.canvas.subtitle, 'subtitle');
        }

        chart.staticPaneSVG.
        selectAll('g.plotareaBorder-property').
        selectAll('line', 'path').
        style('border', ''); //reset plot area border color

        chart.updatePlotArea();
      },

      updatePlotArea: function updatePlotArea() {
        var chart = this,
          systemConfig = chart.systemConf;

        chart.chartarea = simpleClone(chart.titlearea);
        chart.plotarea = simpleClone(chart.chartarea);

        var plotOptions = systemConfig.chart;
        var mLeft = parseFloat(plotOptions.marginLeft),
          mRight = parseFloat(plotOptions.marginRight),
          mTop = parseFloat(plotOptions.marginTop),
          mBottom = parseFloat(plotOptions.marginBottom);
        // If margin values were greater than chart container width and height, reset to 0
        var mLeft_corr = mLeft + mRight > chart.plotarea.width ? 0 : mLeft,
          mRight_corr = mLeft + mRight > chart.plotarea.width ? 0 : mRight,
          mTop_corr = mTop + mBottom > chart.plotarea.height ? 0 : mTop,
          mBottom_corr = mTop + mBottom > chart.plotarea.height ? 0 : mBottom;
        chart.plotarea.left += mLeft_corr;
        chart.plotarea.right += mRight_corr;
        chart.plotarea.bottom += mBottom_corr;
        chart.plotarea.top += mTop_corr;
        chart.plotarea.width = chart.plotarea.width - mLeft_corr - mRight_corr;
        chart.plotarea.height = chart.plotarea.height - mBottom_corr - mTop_corr;
      },

      /**
       *
       * @param data
       * @param type
       */
      drawTitle: function drawTitle(data, type) {
        var chart = this,
          svg = chart.svg,
          systemConfig = chart.systemConf,
          floating = defined(data.x) && defined(data.y),
          location = window.location;

        var margin = {
          top: validateNullVal(data.marginTop, 0),
          right: validateNullVal(data.marginRight, 0),
          bottom: validateNullVal(data.marginBottom, 0),
          left: validateNullVal(data.marginLeft, 0)
        };

        var titlearea = svg.selectAll("g.chart".concat(type));
        var titleAlign = floating ?
        {
          x: data.x + margin.left,
          y: data.y + margin.top,
          dy: '1',
          textAnchor: data.hAlign === 'left' ? 'start' : data.hAlign === 'right' ? 'end' : 'middle'
        } :
        VizLayout.helpers.align(data.hAlign, data.vAlign, chart.titlearea, margin);

        // var titleBox = appendEle(titlearea, "rect", [data], ".", "class", (type+"Box"));
        var imageUrl = data.imageUrl;
        var isTextBox = !defined(imageUrl);
        var element = isTextBox ? data.text === '' ? NONE : 'text' : 'image';

        if (element !== NONE) {
          var title = appendEle(titlearea, element, [data], '.', 'class', type);
          if (defined(data.href)) {
            var click = function click() {
              var isValidURL = validateURL(data.href);
              if (isValidURL) {
                var target = data.target;
                if (target === 'newtab' || target === 'newwindow') {
                  window.open(data.href, 'popUpWindow', target === 'newwindow' ? 'status=yes' : '');
                } else {
                  location.href = data.href;
                }
              } else {
                Console.log('invalid URL for credits');
              }
            };
            var mouseHandlers = {
                click: click
              },
              touchHandlers = {
                tap: click
              };
            attachevents(title, mouseHandlers, touchHandlers);
          }

          if (isTextBox) {
            var userdataCanvasFontColor = chart.userdata.canvas ? chart.userdata.canvas.fontColor : null;

            title.
            attrs({
              x: titleAlign.x,
              y: titleAlign.y,
              dy: "".concat(titleAlign.dy, "em"),
              'text-anchor': titleAlign.textAnchor
            }).
            styles({
              cursor: defined(data.href) ? POINTER : 'auto',
              display: 'block'
            }).
            text(decodeHTML(data.text));

            if (data.tooltip === true) {
              addSVGtitleEle(title);
            }

            applyFont(title, [
            {
              fontColor:
              type === 'subtitle' && !defined(data.fontColor) && !defined(userdataCanvasFontColor) ?
              '#CCCCCC' :
              data.fontColor || userdataCanvasFontColor
            },
            data,
            systemConfig.canvas,
            $ZCG]);

          } else {
            title.
            attrs({
              x: titleAlign.x + (data.hAlign === 'right' ? -data.imageWidth : 0),
              y: titleAlign.y + (data.vAlign === 'bottom' ? -data.imageHeight : 0),
              width: data.imageWidth,
              height: data.imageHeight,
              'xlink:href': data.imageUrl
            }).
            styles({
              cursor: defined(data.href) ? POINTER : 'auto',
              display: 'block'
            });
          }

          //validate for long text value
          var titlenode = bbox(title.node());
          var textBounds = {
              left: floating ? data.x + margin.left : titlenode.x,
              top: floating ? data.y + margin.top : titlenode.y,
              width: titlenode.width,
              height: titlenode.height
            },
            edge = {
              left: margin.left,
              top: margin.top,
              right: chart.titlearea.width - margin.right,
              bottom: chart.titlearea.height
            };
          trimText(title.node(), decodeHTML(data.text), textBounds, edge, 'bottom', '..', {
            left: 5,
            right: 5,
            top: 5,
            bottom: 5
          });

          if (!floating) {
            var nodeHeight = titlenode.height + margin.bottom + margin.top;
            if (data.vAlign === 'top') {
              chart.titlearea.top += nodeHeight;
              chart.titlearea.height -= nodeHeight;
            }
            if (data.vAlign === 'bottom') {
              chart.titlearea.height -= nodeHeight;
            }
          }
        }

        titlearea.selectAll(element === NONE ? 'text,image' : element === 'image' ? 'text' : 'image').style('display', NONE);
      },

      /**
       * // BBS -->Border,Background,Shadow for canvas area, chartarea
       * @param ele
       * @param subEle
       * @param data
       * @param type
       */

      updateCommonBBSProp: function updateCommonBBSProp(ele, subEle, data, type) {
        var chart = this,
          systemConfig = chart.systemConf,
          border = data.border || {},
          background = data.background || {},
          shadow = data.shadow || {},
          useGradient = getPropVal(background, 'gradients.show') === true,
          borderEle;

        //background
        ele.styles({
          'background-color': background.color,
          opacity: background.alpha
        });

        if (defined(background.imageUrl)) {
          // Image url
          if (type == 'plotarea' && chart.plot.hasBgAspectRatio) {
            background.imagePosition = 'initial';
            background.imageSize = ["".concat(systemConfig.chart.width, "px"), "".concat(systemConfig.chart.height, "px")];
          }
          var styles = VizLayout.helpers.getStyles4Image(background);
          ele.styles(styles);
        } else if (useGradient) {
          // Gradient
          var styles = VizLayout.helpers.getStyles4Gradients(background);
          ele.styles(styles);
        }

        //border
        if (border.show === true && type === 'canvas') {
          borderEle = type === 'plotarea' ? subEle : ele;

          //border size validation
          var borderSize =
          type === 'canvas' ?
          validateValWithinLimit(systemConfig.canvas.border, 'size', 0, 10, chart.canvasarea.width, chart.canvasarea.height) :
          validateValWithinLimit(systemConfig.chart.plot.border, 'size', 0, 10, chart.plotarea.width, chart.plotarea.height);
          borderSize = pick(borderSize, 2);
          borderEle.styles({
            border: "".concat(borderSize, "px ").concat(border.style, " ").concat(border.color),
            'border-radius': "".concat(pInt(border.radius), "px")
          });
          borderEle.node().border = {
            size: borderSize,
            clr: border.color
          }; //bkpinfo
        } else {
          borderEle = type === 'plotarea' ? subEle : ele;
          if (type !== 'plotarea') {
            borderEle.style('border', '');
          }
        }

        //shadow
        if (shadow.show === true) {
          // only for canvas area
          var shadowstyle = "".concat(shadow.x, "px ").concat(shadow.y, "px ").concat(shadow.blur, "px ").concat(shadow.color);
          // var shadowstyle = [shadow.x, shadow.y, shadow.blur, shadow.color].join(PX);

          if (shadow.inset === true) {
            shadowstyle += ' inset';
          }

          ele.style('box-shadow', shadowstyle);
        } else {
          ele.style('box-shadow', '');
        }
      },

      /**
       *
       */
      updatePlotareaProp: function updatePlotareaProp() {
        var chart = this,
          systemConfig = chart.systemConf,
          container = chart.d3container,
          plotareaProp = chart.plotareaPropertyElement,
          plotareaBorderProp = chart.staticPaneSVG.selectAll('g.plotareaBorder-property'),
          imgLeft = chart.plotarea.left,
          imgTop = chart.plotarea.top,
          imgWidth = chart.plotarea.width,
          imgHeight = chart.plotarea.height,
          imgRight = chart.plotarea.left + chart.plotarea.width,
          imgBottom = chart.plotarea.top + chart.plotarea.height,
          plotareaBgData = systemConfig.chart.plot.background;

        if (plotareaBgData.image && plotareaBgData.image.x) {
          var scale_x = chart.axes.x.scale,
            scaleDomain_x = scale_x.domain(),
            min = invokeFunction(plotareaBgData.image.x.min, scaleDomain_x, scale_x, chart),
            max = invokeFunction(plotareaBgData.image.x.max, scaleDomain_x, scale_x, chart);
          if (defined(min)) {
            imgLeft = scale_x(min) + chart.plotarea.left;
          }
          if (defined(max)) {
            imgRight = scale_x(max) + chart.plotarea.left;
          }

          imgWidth = imgRight - imgLeft;
        }
        if (plotareaBgData.image && plotareaBgData.image.y) {
          var scale_y = chart.axes.y.groups[0].scale,
            scaleDomain_y = scale_y.domain(),
            _min4 = invokeFunction(plotareaBgData.image.y.min, scaleDomain_y, scale_y, chart),
            _max4 = invokeFunction(plotareaBgData.image.y.max, scaleDomain_y, scale_y, chart);
          if (defined(_min4)) {
            imgBottom = scale_y(_min4) + chart.plotarea.top;
          }
          if (defined(_max4)) {
            imgTop = scale_y(_max4) + chart.plotarea.top;
          }
          imgHeight = imgBottom - imgTop;
        }

        var styles = {
          position: 'absolute',
          left: "".concat(imgLeft, "px"),
          top: "".concat(imgTop, "px"),
          width: "".concat(imgWidth, "px"),
          height: "".concat(imgHeight, "px"),
          'pointer-events': NONE,
          'box-sizing': 'border-box'
        };
        // for adding prefix css
        styles["".concat($Browser.prefix.css, "box-sizing")] = 'border-box';

        chart.plotareaPropertyElement.styles(styles);
        plotareaBorderProp.attrs({
          transform: "translate(".concat(chart.plotarea.left, ",").concat(chart.plotarea.top, ")")
        });
        chart.updateCommonBBSProp(plotareaProp, plotareaBorderProp, systemConfig.chart.plot, 'plotarea');
      },

      /**
       *
       */

      drawPlotareaClippath: function drawPlotareaClippath() {
        var chart = this,
          systemConfig = chart.systemConf;
        chart.staticPaneSVG.
        selectAll('g.highlightergroup').
        attr('filter', chart.filterEffectsID ? "url(".concat(chart.defsLocation, "#").concat(chart.filterEffectsID, ")") : null);

        if (systemConfig.chart.clip === NONE) {
          return;
        }

        //If the plot is zoomed, dont consider the marker size for clipPath
        var zoomedX = isObjectPropDefined(systemConfig, 'chart.zoom.x') || defined(chart.scrolledX),
          zoomedY = isObjectPropDefined(systemConfig, 'chart.zoom.y') || defined(chart.scrolledY),
          axisrotated = chart.axes.rotated,
          ms = getMarkerSize(chart), //ms -> Marker Size
          x = (axisrotated ? zoomedY : zoomedX) ? chart.plotarea.left : -ms.left + chart.plotarea.left,
          y = (axisrotated ? zoomedX : zoomedY) ? chart.plotarea.top : -ms.top + chart.plotarea.top,
          width = chart.plotarea.width + ((axisrotated ? zoomedY : zoomedX) ? 0 : ms.left + ms.right),
          height = chart.plotarea.height + ((axisrotated ? zoomedX : zoomedY) ? 0 : ms.top + ms.bottom);

        var properties = {
            name: 'rect',
            id: chart.id,
            x: x,
            y: y,
            width: width,
            height: height
          },
          args = {
            chartObj: chart
          };
        var clipID = effects.get(effects.svg_clips, 'rect', properties, args),
          clipIDSelector =
          'g.seriesClippathholder, g.labelClippathholder, g.zcMapClipHighlight, g.thresholdClippathholder, g.zc-fade-overlay-clip-holder';
        clipIDSelector =
        chart.dataObject.noofGanttEnabledSeries || chart.dataObject.hasWhiskers ? "".concat(
        clipIDSelector, ",g.qualitativeGroupHolder") :
        clipIDSelector;

        chart.container.selectAll(clipIDSelector).attr('clip-path', "url(".concat(chart.defsLocation, "#").concat(clipID, ")"));

        // #ZC1772, #ZC1771
        // add clip path to highlight group handles scroll
        var scroll_clip_id = "highlight_group_clip_".concat(chart.id),
          plotBound = {
            x: properties.x + (chart.scrolledX || 0),
            y: properties.y + (chart.scrolledY || 0),
            width: width,
            height: height
          };
        svg_clips.rect(plotBound, scroll_clip_id, null, null, null, chart);

        var selector = 'g#zcscatterCliphighlight, g#zcareaCliphighlight, g#zcbarCliphighlight, g.zcMapClipHighlight';
        selector += isFacet(chart) ? ', g.zcnonaxisCliphighlight' : ''; // ZC2879
        chart.staticPaneSVG.selectAll(selector).attr('clip-path', "url(".concat(chart.defsLocation, "#").concat(scroll_clip_id, ")"));
      },

      /**
       *
       */

      getChartSeriesColor: function getChartSeriesColor() {
        var chart = this,
          systemConfig = chart.systemConf,
          colors = [],
          legend_data = systemConfig.legend;

        if (legend_data.colors) {
          if (!isArray$1(legend_data.colors)) {
            var legendColors = [];
            for (var key in legend_data.colors) {
              if (legend_data.colors.hasOwnProperty(key)) {
                legendColors.push(legend_data.colors[key]);
              }
            }
            colors = legendColors;
          } else {
            colors = legend_data.colors;
          }
        } else if (legend_data.colorPallete) {
          if (legend_data.colorPallete.type === 'monochrome') {
            colors = legutil.getMonochromeColorPallette(legend_data.colorPallete.options.monochrome);
          } else {
            colors =
            legutil.colorpallete.get(legend_data.colorPallete.options.multicolor) || legutil.colorpallete.get('flat-ui-colors');
          }
        }

        if (legend_data.imagePallete) {
          chart.patternImageSizes = [];
          var imagePallete = legutil.imagePallete.get(legend_data.imagePallete);
          chart.imagePallete = imagePallete;

          var defaultSize = legend_data.imagePallete === 'stripes' ? null : 50;
          var tempImage = appendEle(chart.getPatternSvg(), 'image', [1], '.', 'class', 'tempImage');

          imagePallete.map(function (d, i) {
            tempImage.attr('xlink:href', d);

            var bb = bbox(tempImage.node());

            chart.patternImageSizes[i] = [defaultSize || bb.width || 3, defaultSize || bb.height || 3];
          });
          tempImage.remove();
        }
        if (legend_data.patterns) {
          chart.patternPallete = legend_data.patterns;
        } else if (legend_data.patternPallete) {
          var patternPallete = legutil.patternPallete.get(legend_data.patternPallete);
          if (!defined(patternPallete) && isArray$1(legend_data.patternPallete) && legend_data.patternPallete.length) {
            patternPallete = legend_data.patternPallete;
          }
          chart.patternPallete = patternPallete;
        }

        /*
         * setting seriesdata color
         */
        if (defined(colors)) {
          var colors_copy = colors.slice(0, colors.length),
            count = 0;

          chart.seriesColor = colors_copy;
          chart.mainSeriesColor = colors_copy;

          if (!colorscale_helpers.isQuantileColorScale(chart)) {
            //#ZC916
            chart.seriesdata.map(function (d, i) {
              if (defined(d.color)) {
                chart.seriesColor[i] = d.color;
              } else if (!chart.seriesColor[i]) {
                chart.seriesColor[i] = colors[count++ % colors.length]; //ZC1788
              }
            });
          }
        }

        if (chart.dataObject.categoryHierarchy) {
          chart.dataObject.hierarchical.setGridOptions();
        }
      },

      /**
       *
       * @param newSystemConf
       */

      resetdata: function resetdata(newSystemConf, changeChartType) {
        var chart = this;
        chart.chartWidth = chart.getChartDimension('width');
        chart.chartHeight = chart.getChartDimension('height');
        chart.setCanvasDimension();
        // if(chart.scroll){
        //     chart.scroll.lastScroll = null
        // }
        chart.oldChartTypes = chart.chartTypes;
        chart.chartTypes = DataProcessor.helpers.getAllChartTypes(newSystemConf, 'object');
        if (changeChartType && !checkChartTypeEquality(chart.oldChartTypes, chart.chartTypes)) {
          if (chart.systemConf.chart.plot.morph.enabled) {
            chart.oldSeriesInfo = {};
            chart.oldSeriesInfo.isAxisCategory = chart.isAxisCategory;
            collectExistingSeriesInfo(chart, chart.oldChartTypes);
          }
          chart.distinctChartTypes = getDistinct(getAllSeriesTypes(chart.userdata));
          updatePlotOption(chart, newSystemConf);
          if (!(chart.seriesAddRemoveDetails && chart.seriesAddRemoveDetails.seriesAddRemovePhase)) {
            chart.svg.
            selectAll('.seriesholder').
            selectAll('g').
            remove();
            chart.renderer = [];
            updateExistingPlotComponents(chart);
          }
        }
        if (chart.userdata.seriesdata && chart.userdata.seriesdata.chartdata) {
          newSystemConf.seriesdata.chartdata = chart.userdata.seriesdata.chartdata;
        }

        chart.processUserData(newSystemConf, true);
        chart.setChartDimension();
        chart.globalProp = setGlobalPropByUserdata(
        newSystemConf,
        {
          width: chart.canvasarea.width,
          height: chart.canvasarea.height
        },
        chart.chartFontProp);

        chart.events = {};
        if (chart.dataObject) {
          chart.dataObject.formattedData = {
            x: [],
            y: []
          };
        }
      },

      /**
       *
       */
      destroy: function destroy() {
        var chart = this;

        if (chart.destroying) {
          return;
        }
        invokeFunction(isObjectPropDefined(chart.systemConf, 'canvas.events.destroy', true), d3_event(), chart);

        if (chart.eventHandler) {
          clearTimeout(chart.eventHandler.mouseouttimer);
          clearTimeout(chart.eventHandler.mousemovetimer);
          clearTimeout(chart.eventHandler.tooltipElement.timeout);
          chart.eventHandler.tooltipElement.destroy();
        }
        chart.timerObj.forEach(function (d) {
          clearTimeout(d);
          clearInterval(d);
        });

        // remove the container reference
        chart.container.datum(null);
        chart.container = chart.baseContainer = chart.BASE_HELPER_CONTAINER = chart.patternSVG = chart.originalContainer = null;

        if (chart.dataObject.isAxisCategory || chart.dataObject.isPolarAxisCategory) {
          // remove axis
          destroyObjectProperties(chart.axes.x);
          chart.axes.y.groups.forEach(function (yAxis) {return destroyObjectProperties(yAxis);});
        }

        // remove label array #ZC3245
        chart.renderer.forEach(function (renderer) {return destroyObjectProperties(renderer.commonRendererProp().params.labelArray);});

        // remove all renderer
        chart.renderer.forEach(function (renderer) {return destroyObjectProperties(renderer, chart);});

        // #ZC2766 destroy the behavioural events
        if (chart.behaviouralEvents) {
          destroyObjectProperties(chart.behaviouralEvents.eventManager.brushResetButton, chart);
          each(chart.behaviouralEvents.eventManager.behaviours, function (behaviour) {
            destroyObjectProperties(behaviour);
          });
          destroyObjectProperties(chart.behaviouralEvents, chart);
        }

        destroyObjectProperties(chart.eventHandler, chart);
        destroyObjectProperties(chart.dataObject, chart);
        destroyObjectProperties(chart.cache);
        destroyObjectProperties(chart);

        chart.destroying = true;
      },

      /**
       *
       */

      redraw: function redraw(changeChartType) {
        var chart = this,
          systemConfig = chart.systemConf;

        chart.updating = true;
        chart.phase = 'redraw';
        chart.viewPortExtent = null;

        chart.svg.styles({
          width: chart.getChartDimension('width') + PX,
          height: chart.getChartDimension('height') + PX
        });
        chart.staticPaneSVG.styles({
          width: chart.getChartDimension('width') + PX,
          height: chart.getChartDimension('height') + PX
        });
        chart.resetdata(systemConfig, changeChartType);
        VizLayout.helpers.constructChartGroups(chart);
        chart.render(true);
        chart.phase = null;
      },

      drawPlotBorder: function drawPlotBorder() {
        var chart = this,
          borderConfig = chart.systemConf.chart.plot.border,
          borderElement = chart.staticPaneSVG.selectAll('g.plotareaBorder-property');

        if (defined(borderConfig) && borderConfig.show === true) {
          var borderEle = borderElement.selectAll('path.plotBorderPath'),
            borderSize = validateValWithinLimit(borderConfig, 'size', 0, 10, chart.plotarea.width, chart.plotarea.height),
            tickArea = pick(chart.tickarea, { left: 0, right: 0, top: 0, bottom: 0 }),
            bleft = -tickArea.left || 0.5,
            bTop = -tickArea.top || 0.5,
            bWidth = chart.plotarea.width + tickArea.right + tickArea.left,
            bHeight = chart.plotarea.height + tickArea.bottom + tickArea.top,
            radius = getBorderRadius(borderConfig.radius),
            rectAttr = roundedRect(bleft, bTop, bWidth, bHeight, radius, false, false);

          borderSize = borderSize == null || borderSize === '' ? 2 : borderSize;

          borderEle.
          styles({
            'stroke-width': borderSize,
            stroke: borderConfig.color,
            'stroke-dasharray': getDashArray(borderConfig.style, borderSize),
            fill: NONE,
            'pointer-events': NONE
          }).
          attrs({
            d: rectAttr
          });
          borderElement.selectAll('line').style('stroke', TRANSPARENT);
        }
      },

      /**
       *
       * @param data
       * @param ele
       */
      handleNoData: function handleNoData(data, ele) {
        this.clearChart();
        var chart = this,
          systemConfig = chart.systemConf,
          nodatawrap = pick(ele, chart.wrap.selectAll('g.nodatahandler'));

        if (defined(data.htmlEl)) {
          var customHandler = appendEle(chart.container.selectAll('div.canvas-component'), 'div', [1], '.', 'class', 'nodatahandler');
          customHandler.style('position', 'absolute').html(data.htmlEl);

          var node = customHandler.node();
          customHandler.styles({
            left: "".concat(pick(data.x, (chart.chartWidth - node.offsetWidth) / 2), "px"),
            top: "".concat(pick(data.y, (chart.chartHeight - node.offsetHeight) / 2), "px")
          });
        } else if (defined(data.imageUrl)) {
          var image = appendEle(nodatawrap, 'image', [1]);
          image.attrs({
            x: data.x || chart.chartarea.width / 2 - 50,
            y: data.y || chart.chartarea.height / 2 - 50,
            width: 100,
            height: 100,
            'xlink:href': data.imageUrl
          });
        } else if (defined(data.text)) {
          var text = appendEle(nodatawrap, 'text', [data], '.', 'class', 'nodata');
          text.attrs({
            x: data.x || chart.chartarea.width / 2,
            y: data.y || chart.chartarea.height / 2,
            'text-anchor': 'middle'
          }).text(decodeHTML(data.text || 'No Data'));
          applyFont(text, [data, systemConfig.canvas, $ZCG]);
        }
      },

      /**
       *
       * @param data
       * @param ele
       */

      clearNoData: function clearNoData(data, ele) {
        var chart = this,
          systemConfig = chart.systemConf,
          nodatawrap = pick(ele, chart.wrap.selectAll('g.nodatahandler'));

        if (defined(data.htmlEl)) {
          var customHandler = appendEle(chart.container.selectAll('div.canvas-component'), 'div', [], '.', 'class', 'nodatahandler');
        } else if (defined(data.imageUrl)) {
          var image = appendEle(nodatawrap, 'image', []);
        } else if (defined(data.text)) {
          var text = appendEle(nodatawrap, 'text', [], '.', 'class', 'nodata');
        }
      },

      /**
       *
       * Remove chart elements
       *
       */

      clearChart: function clearChart(data, ele, keepChartGroup) {
        var chart = this;

        if (!keepChartGroup) {
          appendEle(chart.wrap, 'g', [], '.', 'class', 'chartgroup');
        }
        appendEle(chart.staticPaneSVG, 'g', [], '.', 'class', 'plotareaBorder-property');
        appendEle(chart.staticPaneSVG, 'g', [], '.', 'class', 'labelClippathholder');
        appendEle(chart.staticPaneSVG, 'g', [], '.', 'class', 'qualitativeGroupHolder');
        appendEle(chart.container, 'div', [], '.', 'class', 'legendgroup');
        appendEle(chart.staticPaneSVG, 'g', [], '.', 'class', 'legendarea');
        appendEle(chart.container, 'div', [], '.', 'class', 'zcnotes');
        //canvas
        appendEle(chart.container, 'canvas', [], '.', 'class', 'zc-canvas');
        appendEle(chart.container, 'canvas', [], '.', 'class', 'zc-labelholder-canvas');
        if (chart.eventHandler && (chart.isAxisCategory || chart.dataObject.isPolarAxisCategory || chart.isGeoMap)) {
          // Remove event listenener for chart with nodata on redraw
          // drawBorderBox(chart.eventHandler.trackerElement, { width: 0, height: 0 });
          chart.positionEventTrackerElement(null, {});
        }
      },

      /**
       *
       * @param container
       */

      showLoading: function showLoading(container) {
        var chart = this,
          systemConfig = chart.systemConf;

        var data = systemConfig.loader;
        if (data.enabled === true && data.type !== NONE) {
          var loader = appendEle(this.container.selectAll('div.d3container'), 'div', [1], '.', 'class', 'loading');
          loader.style('position', 'absolute').html(VizLayout.helpers.getLoader(chart, data));
          applyFont(loader, [data, systemConfig.chart, systemConfig.canvas, $ZCG], true);
          var node = loader.node();
          loader.styles({
            left: "".concat(chart.chartarea.width / 2 - node.offsetWidth / 2, "px"),
            top: "".concat(chart.chartarea.height / 2 - node.offsetHeight / 2, "px")
          });
        }
      },

      hideLoading: function hideLoading() {
        this.container.selectAll('div.loading').remove();
      },

      /**
       *
       */
      fixLegendPosition: function fixLegendPosition() {
        // Not handled multi legends
        var chart = this,
          legendArea = chart.legendarea,
          legendConfig = chart.systemConf.legend;

        if (legendConfig.enabled === true) {
          var pos = getLegendPosition(chart.plotarea, chart, false),
            isContinuousLegend = legend_helpers.isContinousLegend(chart);

          if (legendArea.adjust === 'y') {
            if (isContinuousLegend) {
              var translate = getSvgTransform(legendArea.element.node()).translate;
              legendArea.element.attr('transform', "translate(".concat(translate[0], ",").concat(pos[1], ")"));
            } else {
              legendArea.element.style('top', pos[1] + PX);
            }
          }
        }
      },

      createEventGroups: function createEventGroups(update) {
        var chart = this,
          systemConfig = chart.systemConf,
          plotInitStyles = { opacity: 0, 'pointer-events': NONE },
          initStyles = _objectSpread(_objectSpread({}, plotInitStyles), {}, { fill: NONE });

        var eventgroup = chart.eventWrap = chart.staticPaneSVG.selectAll('g.eventgroup').styles({
          'pointer-events': 'visible'
        });

        // To apply chart effects to highlighters, seperate group has been created. to avoid effect on reset text button
        var highlighterGroup = appendEle(eventgroup, 'g', [1], '.', 'class', 'highlightergroup');

        var areaClipPath = highlighterGroup.append('g').attr('id', 'zcareaCliphighlight'),
          areahighlight = areaClipPath.append('g').attr('id', 'zcareahighlight');

        var barClipPath = highlighterGroup.append('g').attr('id', 'zcbarCliphighlight'),
          barhighlight = barClipPath.append('g').attr('id', 'zcbarhighlight');

        if (systemConfig.tooltip.crosshair) {
          var crosshairEle = appendEle(highlighterGroup, 'g', [1], '.', 'class', 'crosshair');
          crosshairEle.style('visibility', 'hidden');
          appendEle(crosshairEle, 'line', [1], '.', 'class', 'x-crosshair');
          appendEle(crosshairEle, 'line', [1], '.', 'class', 'y-crosshair');
        }

        var scatterClipPath = highlighterGroup.append('g').attr('id', 'zcscatterCliphighlight'),
          scatterhighlight = scatterClipPath.append('g').attr('id', 'zcscatterhighlight');

        var plotHighlight = createElement('g', '.zcplothighlight', [1], highlighterGroup);
        plotHighlight.styles(plotInitStyles);

        var nonAxisClipPath = createElement('g', '.zcnonaxisCliphighlight', [1], highlighterGroup),
          nonAxisHighlight = createElement('g', '.zcnonaxishighlight', [1], nonAxisClipPath);
        nonAxisHighlight.styles(initStyles);
        //if (chart.dataObject.isHierarchy) {
        var hierarchyHighlight = createElement('g', '#zchierarchyhighlight', [1], highlighterGroup);
        hierarchyHighlight.styles(initStyles);
        //}
      },

      //
      positionEventTrackerElement: function positionEventTrackerElement(tracker) {var plotArea = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getPlotBoundingRect(this, true);
        var chart = this,
          group = chart.eventHandler.trackerGroup,
          plotarea = chart.plotarea,
          isWidthScroll = chart.scrolledX,
          isHeightScroll = chart.scrolledY,
          hasDefaultScroll = isWidthScroll || isHeightScroll;

        // group should always have the plot area transform
        group.attr('transform', "translate(".concat(plotarea.left || 0, " ").concat(plotarea.top || 0, ")"));

        tracker = pick(tracker, chart.eventHandler.trackerElement);

        // transform the parent
        // for div scroll apply the transform to the rect
        // # ZC2036
        if (hasDefaultScroll) {
          tracker.attr('transform', "translate(".concat(chart.scrolledX || 0, " ").concat(chart.scrolledY || 0, ")"));
        } else {
          tracker.attr('transform', "translate(".concat(plotArea.left || 0, " ").concat(plotArea.top || 0, ")"));
        }

        drawBorderBox(tracker, plotArea);
      },

      /**
       *
       * @param {"x"|"y"|"xy"} type
       * @param {"zoom"|"brush"} module
       * @private
       */
      __enableZoomBrush: function __enableZoomBrush(type, module) {
        var chart = this,
          key = "PLOT_".concat(module.toUpperCase()),
          behaviouralEvents = chart.behaviouralEvents,
          behaviours = behaviouralEvents.eventManager.behaviours;

        var enable = function enable() {
          // merge the default options.
          chart.systemConf.chart[module].enabled = true;
          chart.systemConf.chart[module].type = type;
          behaviouralEvents.initiateBehaviour(key);
        };

        // TODO disable
        // const disable = () => {
        //     chart.systemConf.chart[module].enabled = false;
        //     chart[key].destroy();
        //     delete chart[key];
        // };

        if (!behaviours[key]) {
          enable();
        } else if (behaviours[key] && behaviours[key].instance.options.type !== type) {
          enable();
        }
      },

      __enableZoom: function __enableZoom(type) {
        this.__enableZoomBrush(type, 'zoom');
      },

      __enableBrush: function __enableBrush(type) {
        this.__enableZoomBrush(type, 'brush');
      },

      /**
       *
       * @param {number} step
       */
      zoomStep: function zoomStep(step) {
        var type = this.isGeoMap ? 'xy' : getPropVal(this.systemConf, 'chart.zoom.type') || 'x';
        this.__enableZoom(type);
        this.behaviouralEvents.eventManager.behaviours.PLOT_ZOOM.instance.step(step);
      },

      parseScale: function parseScale() {
        var chartObj = this,
          dataSplicer = chartObj.dataSplicer,
          metadata = dataSplicer.getEncode(),
          rangeCreation = ['z', 'shape'],
          SUPPORTED = chartObj.dataObject.hasZaxis ? ['z'] : [],
          encodes = {},
          scales = [],
          getBaseConfig = function getBaseConfig(encode) {
            if (encode === 'size' || encode === 'color' || encode === 'shape') {
              return chartObj.systemConf.legend;
            }
          },
          getConfig = function getConfig(_, key) {
            var encode = _ === 'z' ? 'size' : _ === 'clr' ? 'color' : _,
              baseConfig = getBaseConfig(encode);

            setDefaultOptions(encode, baseConfig, chartObj.globalProp);
            return baseConfig[encode][key] || baseConfig[encode];
          };

        if (defined(chartObj.dataset.getColumnIdx('shape'))) {
          SUPPORTED.push('shape');
        }

        SUPPORTED.forEach(function (_) {
          if (metadata[_]) {
            encodes[_] = d3_range(metadata[_].length);
          }
        });

        for (var _ in encodes) {
          encodes[_].forEach(function (key) {
            var _parser = Registry.getComponent("".concat(_ === 'z' ? 'size' : _, ".parser"));
            if (_parser != noOperation) {
              var _config9 = getConfig(_, key),
                ranges = _config9.ranges,stops = _config9.stops,minRange = _config9.minRange,maxRange = _config9.maxRange,base = _config9.base,nullAs = _config9.nullAs;

              if (ranges && !isArray$1(ranges[0])) {
                ranges = ranges.map(function (r) {return [r];});
                _config9.ranges = ranges;
              }

              if (ranges && ranges._dummy) {
                ranges = null;
                // config.ranges = null;
              }

              var parser = _parser(_, key, chartObj, _objectSpread(_objectSpread({}, _config9), {}, { ranges: ranges })),
                scaleComponent = new Scale(_, key, _objectSpread({ ranges: ranges, stops: stops, minRange: minRange, maxRange: maxRange, base: base, nullAs: nullAs }, parser), chartObj); // TODO: check this
              scales.push(scaleComponent);
            }
          });
        }

        scales.forEach(function (_) {return _.getScale();});
        scales.forEach(function (_, i) {
          var encode = _.encode,key = _.key;
          if (arrayIncludes(rangeCreation, encode)) {
            var _scale4 = _.getScale(),
              schema = _.schema,
              _config10 = getLegendConfig(encode, key, chartObj),
              view = _legendType(encode, { config: _config10, dataType: schema.data.dataType }),
              newRanges = generateRanges(_config10, schema, _scale4, view);

            if (newRanges) {
              _config10.ranges = newRanges;
              schema.domain.ranges = newRanges;

              var _parser = Registry.getComponent("".concat(encode === 'z' ? 'size' : encode, ".parser"));
              var ranges = _config10.ranges,stops = _config10.stops,minRange = _config10.minRange,maxRange = _config10.maxRange,base = _config10.base,nullAs = _config10.nullAs,
                parser = _parser(encode, key, chartObj, _config10),
                scaleComponent = new Scale(encode, key, _objectSpread({ ranges: ranges, stops: stops, minRange: minRange, maxRange: maxRange, base: base, nullAs: nullAs }, parser), chartObj);
              scaleComponent.create();
              scales[i] = scaleComponent;
            }
          }
        });
        chartObj.scales = scales;
      },

      handleLegendEvents: function handleLegendEvents() {
        var chart = this,
          _legendEvents = Registry.getComponent('LegendEvents');

        if (!_legendEvents._empty) {
          if (chart.legendEvents) {
            chart.legendEvents.update();
          } else {
            chart.legendEvents = new _legendEvents(chart);
          }
        }

        if (isFacet(chart)) {
          var disabledOpacity = pick(isObjectPropDefined(chart.systemConf, 'legend.selectAllBox.disabledOpacity', true), 0.3);
          legend_helpers.fadeChart(null, chart, disabledOpacity);
        }
      },

      _isAxisCategory: function _isAxisCategory() {
        var dataObject = this.dataObject,preProcessor = this.preProcessor,
          hierarchical = dataObject.hierarchical,
          plotOptions = this.systemConf.chart.plot.plotoptions[this.distinctChartTypes && this.distinctChartTypes[0]]; //this plotOptions are used to check if axis is enabled in treemap or not
        //since combinational chart is not possible using treemap - directly taken this.distinctChartTypes[0]
        return (
          dataObject.isAxisCategory ||
          hierarchical && hierarchical.facetRendering ||
          preProcessor && preProcessor.hierarchical && preProcessor.hierarchical.facetRendering ||
          plotOptions && plotOptions.axis && plotOptions.axis.enabled);

      }
    };

    var createHelperElements = chartBasicHelpers.createHelperElements;

    extend(VizLayout.prototype, chartBasicHelpers);

    /************************** Helpers ****************/

    VizLayout.helpers = {
      initializeChartHolders: function initializeChartHolders(chart) {
        var container = chart.container,
          width_style,
          height_style;

        var d3container = container.selectAll('div.d3container');
        if (!d3container.empty()) {
          // If user going to create a new chart in the same container again, destroy the previous chart object
          var prevChartObj = d3container.datum();
          if (prevChartObj && prevChartObj.destroy) {
            prevChartObj.destroy();
          }

          d3container.remove();
        }

        width_style = chart.getChartDimension('width');
        height_style = chart.getChartDimension('height');

        d3container = chart.d3container = appendEle(container, 'div', [chart], '.', 'class', 'd3container');
        var styles = {
          width: "".concat(width_style, "px"),
          height: "".concat(height_style, "px"),
          position: 'relative',
          left: '0px',
          top: '0px',
          'box-sizing': 'border-box',
          '-moz-user-select': NONE,
          '-webkit-user-select': NONE,
          '-ms-user-select': NONE,
          'user-select': NONE
        };
        // for adding prefix css
        styles["".concat($Browser.prefix.css, "box-sizing")] = 'border-box';
        d3container.styles(styles);

        //CANVASPROP - canvas area properties-border,background,shadow
        appendEle(d3container, 'div', [1], '.', 'class', 'canvas-property');
        //PLOTAREA PROP - plotarea background prop
        chart.plotareaPropertyElement = appendEle(d3container, 'div', [1], '.', 'class', 'plotarea-property');

        // Overview container for scroll
        appendEle(chart.d3container, 'div', [1], '.', 'class', 'zcoverview');

        //main canvas area - svg
        var canvas = appendEle(d3container, 'div', [1], '.', 'class', 'canvas-component');
        canvas.style('-webkit-tap-highlight-color', TRANSPARENT);

        var tooltipElement = appendEle(chart.getBaseContainer(), 'div', [1], '#', 'id', "zctooltip".concat(chart.idNumeric));
        tooltipElement.node().isTooltipContainer = true;

        chart.tooltip = {
          element: tooltipElement
        };
        chart.tooltip.element.styles({
          position: 'fixed',
          display: 'inline-block',
          visibility: 'hidden',
          'white-space': 'nowrap',
          'background-color': 'white',
          border: '1px solid',
          '-webkit-tap-highlight-color': TRANSPARENT
        });

        var SVGposition = VizLayout.helpers.positionSVG(chart);
        chart.svg = appendEle(canvas, 'svg', [1], '.', 'class', 'svgarea', SVGposition);
        chart.staticPaneSVG = appendEle(canvas, 'svg', [chart], '.', 'class', 'static', SVGposition).style('pointer-events', NONE);

        canvas.append(DIV_ELEMENT).attr('class', 'legendarea');
        chart.notes = canvas.append('div').attr('class', 'zcnotes');
      },

      removeChartHolders: function removeChartHolders(chart) {
        var container = chart.container;
        container.
        select('div.d3container') //No I18N
        .remove();

        container.
        select('div.zc-staticPane') //No I18N
        .remove();
        container.
        select('div.zc-chartPane') //No I18N
        .remove();
      },

      /**
       *
       * @param hAlign
       * @param vAlign
       * @param box
       * @param margin
       * @returns {{}}
       */

      align: function align(hAlign, vAlign, box, margin) {
        var attr = {};
        //hAlign
        if (hAlign === 'center') {
          attr.x = box.width / 2 + margin.left;
          attr.textAnchor = 'middle';
        } else if (hAlign === 'left') {
          attr.x = box.left + margin.left;
          attr.textAnchor = 'start';
        } else if (hAlign === 'right') {
          attr.x = box.width + box.left - margin.right;
          attr.textAnchor = 'end';
        }
        //vAlign
        if (vAlign === 'top') {
          attr.y = box.top + margin.top;
          attr.dy = 1;
        } else if (vAlign === 'bottom') {
          attr.y = box.height + box.top - margin.bottom;
          attr.dy = -0.21;
        }
        return attr;
      },

      getLoader: function getLoader(chart, data) {
        var htmlEl = data.htmlEl,
          imageUrl = data.imageUrl,
          type = data.type,
          text = data.text,
          colors = data.colors;
        if (htmlEl) {
          return htmlEl;
        } else if (imageUrl) {
          return "<img src=".concat(imageUrl, " height=").concat(data.imageHeight, " width=").concat(data.imageWidth, ">");
        } else {
          var html = '',
            ele = null;
          if (type) {
            var loaderDiv = chart.container.selectAll('div.loading');
            colors = colors && colors.length ? colors : null;
            ele = ZCloader(loaderDiv, {
              type: type,
              colors: colors
            });

            var XMLS = new XMLSerializer();
            html = XMLS.serializeToString(ele); // Converting DOM node into a string
          }
          if (text) {
            html += "<p style=position:relative;display:inline-block>".concat(text, "</p>");
          }
          return html;
        }
      },

      constructChartGroups: function constructChartGroups(chart) {
        var svg = chart.svg,
          systemConfig = chart.systemConf,
          chartHeight = chart.chartHeight,
          chartWidth = chart.chartWidth;
        //Title area
        var istitle = systemConfig.canvas.title.show === true && dimension_based_intelligence(chart, 'title', chartHeight);
        appendEle(svg, 'g', groupdata(istitle), '.', 'class', 'charttitle');

        //Subtitle area
        var issubtitle = systemConfig.canvas.subtitle.show === true && dimension_based_intelligence(chart, 'subtitle', chartHeight);
        appendEle(svg, 'g', groupdata(issubtitle), '.', 'class', 'chartsubtitle');
        //Credit Area
        var iscredits =
        systemConfig.credits && systemConfig.credits.enabled === true && dimension_based_intelligence(chart, 'credits', chartHeight);
        appendEle(svg, 'g', groupdata(iscredits), '.', 'class', 'chartcredits');

        var wrap;

        if (chart.isGeoMap && chart.geo.isCanvasMode && chart.dataObject.hasPointChart) {
          wrap = chart.wrap = createElement('g', '.xychart', [1], chart.staticPaneSVG, ':first-child');
        } else {
          wrap = chart.wrap = appendEle(svg, 'g', [1], '.', 'class', 'xychart');
        }

        if (chart.nochartdata) {
          appendEle(wrap, 'g', [1], '.', 'class', 'nodatahandler');
        } else {
          appendEle(wrap, 'g', [0], '.', 'class', 'nodatahandler');
          var chartgroup = appendEle(wrap, 'g', [chart.seriesdata], '.', 'class', 'chartgroup');

          var isxaxis = isObjectPropDefined(systemConfig, 'chart.axes.xaxis.show', true) === true;
          //xaxisgroup
          appendEle(chartgroup, 'g', groupdata(isxaxis), '.', 'class', 'x-axis');
          //yaxisgroup
          appendEle(chartgroup, 'g', [chart.seriesdata], '.', 'class', 'y-axis');

          // Underlay threshold - So that threshold range will render first and then plot will be rendered
          appendEle(chartgroup, 'g', [chart.seriesdata], '.', 'class', 'threshold');

          var seriesClipgroup = appendEle(chartgroup, 'g', [chart.seriesdata], '.', 'class', 'seriesClippathholder'); //#ZC1502

          //series group
          var seriesgroup = appendEle(seriesClipgroup, 'g', [chart.seriesdata], '.', 'class', 'seriesholder');
          chart.filterEffectsID = getChartEffects(chart);
          var effectValue = chart.filterEffectsID ? "url(".concat(chart.defsLocation, "#").concat(chart.filterEffectsID, ")") : null;
          seriesgroup.attr('filter', effectValue);

          var labelClipgroup = appendEle(chart.staticPaneSVG, 'g', [chart.seriesdata], '.', 'class', 'labelClippathholder'); //#ZC1502

          var onlyBarChart = false;
          if (chart.dataObject) {
            onlyBarChart =
            chart.dataObject && chart.dataObject.noofBarEnabledSeries && !chart.dataObject.isCombinationalChart ||
            chart.dataObject.isHierarchy ||
            chart.dataObject.isFlowChartCategory; // For bar charts, the element should be before the highlighting element
          }

          if (!onlyBarChart) {
            appendEle(labelClipgroup, 'g', [chart.seriesdata], '.', 'class', 'labelholder');
          }

          //thgroup
          var thresholdClipG = appendEle(chart.staticPaneSVG, 'g', [chart.seriesdata], '.', 'class', 'thresholdClippathholder');
          appendEle(thresholdClipG, 'g', [chart.seriesdata], '.', 'class', 'threshold');

          // Qualitative group (without clip path)
          var qualitativeGroup = appendEle(chart.staticPaneSVG, 'g', [1], '.', 'class', 'qualitativeGroupHolder');
          appendEle(qualitativeGroup, 'g', [1], '.', 'class', 'qualitativeGroup');

          //plotarea border properties,as border has to be drawn over axis tickmarks // also below the event rect
          var plotBorder = appendEle(chart.staticPaneSVG, 'g', [1], '.', 'class', 'plotareaBorder-property');
          var isplotBorder = systemConfig.chart.plot.border.show === true;
          appendEle(plotBorder, 'path', groupdata(isplotBorder), '.', 'class', 'plotBorderPath');

          //eventgroup
          appendEle(chart.staticPaneSVG, 'g', [1], '.', 'class', 'eventgroup');

          if (onlyBarChart) {
            //labelgroup
            labelClipgroup.raise();
            var labelgroup = appendEle(labelClipgroup, 'g', [chart.seriesdata], '.', 'class', 'labelholder');
            labelgroup.style('pointer-events', NONE);
          }

          // Dummy rect added for filter - ISSUE : http://www.inkscapeforum.com/viewtopic.php?t=18611
          var dummyRectangleForFilters = appendEle(seriesgroup, 'rect', [1], '.', 'class', 'dummy-rect-filter');
          dummyRectangleForFilters.style('pointer-events', NONE);

          VizLayout.helpers.createLegendArea(chart);
        }

        function groupdata(show) {
          return show ? [1] : [];
        }
      },

      handleErrors: function handleErrors(chart, err) {
        // [IE Fix $err.stack & Console.error]
        err = err.stack ? err.stack : err;
        Console.error ? Console.error(err) : Console.log(err);

        // console.log("Oops! Sorry something went wrong to render the chart...")
        // console.log("Error message : " + err.message);
        // Console.log(err.stack);

        chart.breakOnErr = true;
        if (isObjectPropDefined(chart.systemConf, 'canvas.events')) {
          invokeFunction(chart.systemConf.canvas.events.onerror, d3_event(), chart, err);
        }
      },

      positionSVG: function positionSVG(chart) {
        return {
          width: chart.getChartDimension('width') + PX,
          height: chart.getChartDimension('height') + PX,
          position: 'absolute',
          top: 0,
          left: 0
        };
      },

      createLegendArea: function createLegendArea(chart) {
        var isContinousLegend = legend_helpers.isContinousLegend(chart),
          elementContinuous = createElement('g', '.legendarea', [1], chart.staticPaneSVG),
          elementDiscrete = chart.container.selectAll("".concat(DIV_ELEMENT, ".legendarea"));

        // applyFont(elementContinuous, [chart.systemConf.canvas, $ZCG]);
        // applyFont(elementDiscrete, [chart.systemConf.canvas, $ZCG], true);

        if (isContinousLegend) {
          var dataObject = chart.dataObject,
            onlyBarChart =
            dataObject && (dataObject.noofBarEnabledSeries && !dataObject.isCombinationalChart || dataObject.isHierarchy);

          if (onlyBarChart) {
            elementContinuous.raise();
          }

          elementDiscrete.style('display', NONE);
          chart.legendarea.element = elementContinuous;
        } else {
          elementContinuous.style('display', NONE);
          chart.legendarea.element = elementDiscrete;
        }
      },
      getChartId: function getChartId(chart) {
        return chart.id;
      },
      setChartId: function setChartId(chart) {
        var currentId = chart.id;
      },

      getStyles4Gradients: function getStyles4Gradients(options) {
        var gradients = options.gradients || {};

        if ($Browser.IE === 1 && $Browser.VERSION.indexOf('9.') === 0) {
          var stopColor = gradients.stopColor ? gradients.stopColor.map(rgb2hex) : ['black', 'white']; // IE needs hex color code

          if (gradients.type === 'linear') {
            var filter = "progid:DXImageTransform.Microsoft.gradient(startColorstr=".concat(stopColor[0], ", endColorstr=").concat(stopColor[1], ")");

            return { filter: filter };
          } else {
            var filter = 'progid:DXImageTransform.Microsoft.Alpha(opacity=0, finishopacity=100, style=2)';

            return {
              filter: filter,
              'background-color': stopColor[1]
            };
          }
        } else {
          var prefix = $Browser.WEBKIT ? '-webkit-' : $Browser.FIREFOX ? '-moz-' : $Browser.IE ? '-ms-' : '',
            gradient,
            gradientColors = '';

          if (!defined(gradients.useCSS)) {
            if (defined(gradients.stopColor)) {
              gradients.stopColor.map(function (d, i) {
                var offset = defined(gradients.stopOffset) && defined(gradients.stopOffset[i]) ? " ".concat(gradients.stopOffset[i]) : '';
                gradientColors = gradientColors + (i === 0 ? "".concat(d, " ").concat(offset) : ",".concat(d).concat(offset));
              });
            }
            if (gradients.type === 'radial') {
              gradient = "radial-gradient(".concat(gradientColors, ")");
            } else if (gradients.type === 'linear') {
              gradient = "linear-gradient(".concat(gradientColors, ")");
            }
          } else {
            gradient = gradients.useCSS;
          }

          return {
            'background-image': prefix + gradient
          };
        }
      },

      getStyles4Image: function getStyles4Image(options) {
        return {
          'background-image': "url(".concat(options.imageUrl, ")"),
          'background-repeat': options.imageRepeat,
          'background-position': options.imagePosition,
          'background-size': options.imageSize
        };
      }
    };

    defaultTheme.credits = function (userProp) {
      return {
        enabled: false,
        imageWidth: 150,
        imageHeight: 50,
        hAlign: 'right', //left, center, "right"
        vAlign: 'bottom', //top, middle, bottom
        text: 'Zoho Reports',
        target: 'newtab', //newtab || newwindow || null
        marginTop: 0,
        marginRight: 10,
        marginBottom: 10,
        marginLeft: 0,
        fontSize: userProp.fontL1Size.l4
      };
    };

    /**
     *
     * @param selection
     * @param chartScale
     * @param type
     * @param datatype
     * @param rotated
     * @param reversed
     * @return {*[]}
     * @constructor
     */
    function SelectionToDomain(selection, chartScale) {var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'x';var datatype = arguments.length > 3 ? arguments[3] : undefined;var rotated = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;var reversed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      if (!isArray$1(selection)) {
        return chartScale.originalDomain;
      }
      var domain,_selection$map =
        selection.map(function (x0, i) {
          var a = { x: 0, y: 0 };
          a[fixBrushDirection(type, rotated)] = x0;
          return scale.invert(datatype, a, chartScale, rotated, type, reversed, null, { index: i, range: selection });
        }),_selection$map2 = _slicedToArray(_selection$map, 2),inverted_0 = _selection$map2[0],inverted_1 = _selection$map2[1];

      if (inverted_0 > inverted_1) {var _ref9 =
        [inverted_1, inverted_0];inverted_0 = _ref9[0];inverted_1 = _ref9[1];
      }

      if (datatype === ORDINAL_DATATYPE) {
        domain = chartScale.domain().slice(inverted_0, inverted_1 + 1, 0);
      } else {
        domain = constrainDomain([inverted_0, inverted_1], chartScale.originalDomain, chartScale.outerPadding);
      }
      return domain;
    }

    /**
     *
     * @param axisType
     * @param rotated
     * @return {*}
     */
    function fixBrushDirection(axisType, rotated) {
      var dir_opposite_map = { x: 'y', y: 'x' };
      if (rotated) {
        return dir_opposite_map[axisType] || axisType;
      }
      return axisType;
    }

    function constrainDomain(domain, ordinalDomain) {var outerPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var isDate = domain[0] instanceof Date;

      if (isDate) {
        domain = domain.map(function (t) {return t.getTime();});
        ordinalDomain = ordinalDomain.map(function (t) {return t.getTime();});
      }

      var _domain3 = domain,_domain4 = _slicedToArray(_domain3, 2),start = _domain4[0],end = _domain4[1],_ordinalDomain2 =
        ordinalDomain,_ordinalDomain3 = _slicedToArray(_ordinalDomain2, 2),startLimit = _ordinalDomain3[0],endLimit = _ordinalDomain3[1],
        startDiff = (end - startLimit) * outerPadding,
        newStart = startLimit - startDiff,
        newEnd = endLimit + (endLimit - start) * outerPadding,

        s0 = mathMax(start, newStart),
        s1 = mathMin(end, newEnd);

      // fix if beyond start limit
      if (end < startLimit) {
        s0 = startLimit - (s0 - startLimit) * 0.001;
        s1 = startLimit + (startLimit - s1) * 0.001;
      }

      // fix if beyond end limit
      if (start > endLimit) {
        s0 = endLimit + (endLimit - s0) * 0.001;
        s1 = endLimit - (s1 - endLimit) * 0.001;
      }

      if (isDate) {var _map =
        [s0, s1].map(function (t) {return new Date(t);});var _map2 = _slicedToArray(_map, 2);s0 = _map2[0];s1 = _map2[1];
      }

      return [s0, s1];
    }

    /**
     *
     * @param range
     * @param originalRange
     * @return {number[]}
     */
    function constrainRange(range, originalRange) {
      var _originalRange = _slicedToArray(originalRange, 2),start = _originalRange[0],end = _originalRange[1];
      if (originalRange[0] < originalRange[1]) {
        range = [mathMin(range[0], start), mathMax(range[1], end)];
      } else {
        range = [mathMax(range[0], start), mathMin(range[1], end)];
      }
      return range;
    }

    var CHART_DOMAIN_HELPERS = {
      /**
       *
       * @param chart
       * @param range
       * @param type
       * @param index
       * @param chartScale
       * @return {*[]}
       */
      CALCULATE_DOMAIN: function CALCULATE_DOMAIN(chart, range, type, index, chartScale) {
        var datatype = chart.dataset.getDataType(type, index),
          rotated = chart.axes.rotated,
          reversed,
          baseScale;

        if (range === null) {
          if (type === 'x') {
            baseScale = chart.axes.x.baseScale;
          } else if (type === 'y') {
            baseScale = chart.axes.y.groups[index].baseScale;
          }
          return baseScale.domain();
        }

        if (type === 'x') {
          chartScale = pick(chartScale, chart.axes.x.scale);
          reversed = chart.systemConf.chart.axes.xaxis.reversed;
        } else {
          chartScale = pick(chartScale, chart.axes.y.groups[index].scale);
          reversed = chart.systemConf.chart.axes.yaxis[index].reversed;
        }
        var _t = SelectionToDomain(range, chartScale, type, datatype, rotated, reversed);
        if (!_t.length) {
          var _d = getEmptyDomain(range, chartScale, type, datatype, rotated, reversed, chart);
          chart.emptySelectionDomain = _d ? _d : chart.emptySelectionDomain;
        }
        return _t;
      },

      /**
       *
       * @param selection
       * @param domainType
       * @param brushType
       * @param index
       * @param chart
       * @return {*[]}
       */
      GET_DOMAIN: function GET_DOMAIN(selection, domainType, brushType) {var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var chart = arguments.length > 4 ? arguments[4] : undefined;
        if (brushType === 'xy' && isArray$1(selection)) {
          if (fixBrushDirection(domainType, chart.axes.rotated) === 'x') {
            selection = [selection[0][0], selection[1][0]];
          } else {
            selection = [selection[0][1], selection[1][1]];
          }
        }
        return this.CALCULATE_DOMAIN(chart, selection, domainType, index);
      },

      /**
       *
       * @param selection
       * @param domainTypes
       * @param brushType
       * @param chart
       * @return {{}}
       */
      GET_DOMAIN_INFO: function GET_DOMAIN_INFO(selection, domainTypes, brushType, chart) {var _this13 = this;
        var domainInfo = {};

        domainTypes = splat(domainTypes);

        if (arrayIncludes(domainTypes, 'x')) {
          var domain = this.GET_DOMAIN(selection, 'x', brushType, 0, chart);
          domainInfo.x = [{ domain: domain, index: 0, dataType: chart.dataset.getDataType('x', 0) }];
        }

        if (arrayIncludes(domainTypes, 'y')) {
          domainInfo.y = [];
          chart.axes.y.groups.forEach(function (axis, index) {
            if (!axis.disabled) {
              domainInfo.y.push({
                domain: _this13.GET_DOMAIN(selection, 'y', brushType, index, chart),
                index: index,
                dataType: chart.dataset.getDataType('y', index)
              });
            }
          });
        }

        return domainInfo;
      },

      /**
       *
       * @param chart
       * @param domainX
       * @param domainY
       * @return {[]}
       * @constructor
       */
      DOMAIN_TO_DATA: function DOMAIN_TO_DATA(chart, domainX, domainY) {
        var xScale = chart.axes.x.scale,
          yScale = chart.axes.y.groups[0].scale,
          xRange,
          yRange,
          points = [];

        if (isArray$1(domainX)) {
          domainX = firstAndLastItem(domainX);
          xRange = domainX.map(xScale).sort(d3_ascending);
        }

        if (isArray$1(domainY)) {
          domainY = firstAndLastItem(domainY);
          yRange = domainY.map(yScale).sort(d3_ascending);
        }

        chart.renderer.filter(function (renderer) {
          var series = renderer.seriesdataAfterUpdate;

          series.forEach(function (subSeries) {
            var filteredPoints = subSeries.filter(function (point) {
              return CHART_DOMAIN_HELPERS.POINT_WITHIN_RANGE(point, xRange, yRange, chart);
            });
            points = points.concat(filteredPoints);
          });
        });
        return points;
      },

      /**
       *
       * @param point
       * @param xRange
       * @param yRange
       * @param chart
       * @param yIndex
       * @return {*}
       * @constructor
       */
      POINT_WITHIN_RANGE: function POINT_WITHIN_RANGE(point, xRange, yRange, chart) {var yIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var xScale = chart.axes.x.scale,
          yScale = chart.axes.y.groups[yIndex].scale;

        var withinRange = function withinRange(d) {
          var xPass = true,
            yPass = true;

          if (isArray$1(xRange)) {
            var xValue = xScale(chart.dataset.getX(d));
            xPass = xValue >= xRange[0] && xValue <= xRange[1];
          }

          if (isArray$1(yRange)) {
            var yValue = yScale(chart.dataset.getY(d, yIndex));
            yPass = yValue >= yRange[0] && yValue <= yRange[1];
          }

          return xPass && yPass;
        };

        return withinRange(point);
      },

      /**
       *
       * @param point
       * @param chart
       * @return {*}
       * @constructor
       */
      POINT_WITHIN_DOMAIN: function POINT_WITHIN_DOMAIN(point, chart) {
        var domainInfo = chart.plotBrush.domainInfo,
          xRange;

        var domain = domainInfo.x[0].domain;
        domain = [domain[0], domain[domain.length - 1]];

        if (isArray$1(domain)) {
          xRange = domain.map(chart.axes.x.scale).sort(d3_ascending);
        }

        return CHART_DOMAIN_HELPERS.POINT_WITHIN_RANGE(point, xRange, null, chart);
      },

      /**
       *
       * @param domains
       * @param chart
       * @constructor
       */
      FILTER_CHART: function FILTER_CHART(domains, chart) {
        //Reset cache for data
        chart.cache.data = {};
        chart.cache.search = {};

        if (chart.datalabels.hasFixedPosition) {
          each(domains, function (info, type) {
            chart.cache.correction['bubble-' + type + '-' + (info.index || 0)] = null;
            if (chart.cache.correction.domainCorrection) {
              chart.cache.correction.domainCorrection['marker-' + type + '-' + (info.index || 0)] = null;
            }
          });
        } else {
          // chart.cache.correction = {};
          for (var attr in chart.cache.correction) {
            if (attr.indexOf('bubble') > -1) {
              var s = attr.split('-');
              if (chart.dataset.getDataType(s[1], +s[2]) === 'ordinal') {
                chart.cache.correction[attr] = null;
              }
            }
          }
          for (var attr in chart.cache.correction.domainCorrection) {
            if (attr.indexOf('marker') > -1) {
              var _s2 = attr.split('-');
              if (chart.dataset.getDataType(_s2[1], +_s2[2]) === 'ordinal') {
                chart.cache.correction.domainCorrection[attr] = null;
              }
            }
          }
        }

        // chart.cache.correction.domainCorrection = {};
        //reset bullet events
        chart.eventHandler.bulletEvents = null;
        if (chart.updateScale) {
          each(domains, function (info, type) {
            splat(info).forEach(function (info, i) {
              chart.updateScale(null, type, info.domain, info.index, info.range, true);
            });
          });

          chart.plot.renderer.draw(true, false);
          if (!chart.dataObject.flattenPoints) {
            chart.dataObject.flattenData();
          }

          //Need to update the event params. Becoz axes.eventscale is a new scale now
          // chart.eventHandler && chart.eventHandler.updateParams(chart, false);
          chart.drawPlotareaClippath();
          chart.updatePlotareaProp();
          chart.positionEventTrackerElement();

          chart.drawThreshold(true);
        }
      }
    };

    function getEmptyDomain(selection, chartScale) {var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'x';var datatype = arguments.length > 3 ? arguments[3] : undefined;var rotated = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;var reversed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;var chart = arguments.length > 6 ? arguments[6] : undefined;
      var _selection$map3 = selection.map(function (x0, i) {
          var a = { x: 0, y: 0 };
          a[fixBrushDirection(type, rotated)] = x0;
          return scale.invert(datatype, a, chartScale, rotated, type, reversed, null, { index: i, range: selection }, false);
        }),_selection$map4 = _slicedToArray(_selection$map3, 2),inverted_0 = _selection$map4[0],inverted_1 = _selection$map4[1],
        _scale = chart.axes.x.scale,
        _d = _scale.domain();
      if (inverted_0 === inverted_1) {
        if (!_d[inverted_0 - 1] || !_d[inverted_0 + 1]) {
          _d[inverted_0 - 1] ? inverted_1 = null : inverted_0 = null;
        }
      }
      if (!_d.length) {
        return null;
      }
      return {
        start: _d[inverted_0],
        end: _d[inverted_1]
      };

      return;
    }

    //$Id$

    var charts = function charts(containers, datas, dimension) {
      var isMulti = isArray$1(containers) && isArray$1(datas),
        isOverview = datas.__$overview;
      if (isMulti) {
        return getMultiCharts(containers, datas);
      } else {
        var chartObj = getChartObject(containers, datas);
        if (isOverview) {
          adjustOverviewDim(chartObj, dimension);
        }
        if (chartObj) {
          chartObj.draw();
        }
        return chartObj;
      }
    };

    var maps = function maps(containers, data) {
      if (!containers.isD3Selection) {
        containers = d3_select(containers);
      }

      return getMapObject(containers, data);
    };

    function getMapObject(containers, data) {
      var mapObj = new maps.GeoMap(containers, data);
      return mapObj;
    }
    /*
     * This is the actual chart object init method
     * here the data is binded with respective selected container
     * Note: Only the chart object is initialized here, but the chart generation or rendering will not happen.
     * */
    function getChartObject(container, data) {
      if (!container.isD3Selection) {
        container = d3_select(container);
      }

      if (!isElementOnDocument(container.node())) {
        // if (!document.body.contains(container.node())) {
        this.console.warn('No container');
        return null;
      }

      var dataObj = container.datum(data);
      var chart = null;

      /*
       * Each chart instance is instantiated with chartRendered flag false
       * chart.initialize is defined in chart-constructor.js
       * */
      dataObj.each(function (data) {
        var chartHolder = d3_select(this);
        chart = charts.get(chartHolder, data); // get chartobj
        chart.showLoading(chartHolder);
      });
      return chart;
    }
    /*
     * when it is multi charts instantiation, the chart rendering is queued here.
     */
    function getMultiCharts(containers, datas) {
      if (!(isArray$1(containers) && isArray$1(datas))) {
        return;
      }

      var chartObjs = containers.map(function (container, i) {
        return getChartObject(container, datas[i]);
      });

      var executedChartObjs = [];
      //unexecutedChartObjs are reversed just for the convenience of using Array.pop() method to remove first rendered chart object.
      var clonedObjs = chartObjs.slice();
      var unexecutedChartObjs = clonedObjs.reverse();
      drawEfficiently(unexecutedChartObjs, executedChartObjs, chartObjs);
      return chartObjs;
    }

    function drawEfficiently(unexecutedChartObjs, executedChartObjs, chartObjs) {
      var len = unexecutedChartObjs.length,
        chartObj = unexecutedChartObjs[len - 1];

      // all charts are rendered
      if (!len) {
        chartObjs.chartRendered = true;
      }

      if (len > 0 && chartObj.drawStarted != true && isElementOnDocument(chartObj.container.node())) {
        chartObj.draw();
        chartObj.drawStarted = true;
        checkStatusNCallNext(unexecutedChartObjs, executedChartObjs, chartObjs);
      }
    }

    /*
     * Executed/rendered chart objects are popped and pushed to the executed object list.
     * Waits till next chart object is rendered.
     * */
    function checkStatusNCallNext(unexecutedChartObjs, executedChartObjs, chartObjs, timer) {
      var len = unexecutedChartObjs.length,
        chartObj = unexecutedChartObjs[len - 1];

      if (chartObj.chartRendered || chartObj.breakOnErr) {
        executedChartObjs.push(unexecutedChartObjs.pop());
        drawEfficiently(unexecutedChartObjs, executedChartObjs, chartObjs);
      } else {
        if (timer != null) {
          clearTimeout(timer);
        }

        var timer = setTimeout(function () {
          checkStatusNCallNext(unexecutedChartObjs, executedChartObjs, chartObjs, timer);
        }, 10);
      }
    }

    function adjustOverviewDim(chartObj, _dimension) {
      var _canvas = chartObj.canvasarea,
        _chart = chartObj.chartarea,
        _title = chartObj.titlearea;

      _canvas.width = _dimension.width;
      _chart.width = _dimension.width;
      _title.width = _dimension.width;
      _canvas.height = _dimension.height;
      _chart.height = _dimension.height;
      _title.height = _dimension.height;
    }var

    DataSplicer = /*#__PURE__*/function () {
      function DataSplicer(data, systemConf, chart) {_classCallCheck(this, DataSplicer);
        this.data = data;
        this.systemConf = systemConf;
        this.chart = chart;
      }_createClass(DataSplicer, [{ key: "getColumns", value:
        function getColumns() {
          return this.data.metadata.columns;
        } }, { key: "getEncode", value:
        function getEncode() {
          return this.data.metadata.axes;
        } }, { key: "getAxisConfig", value:
        function getAxisConfig(type, order) {
          if (defined(order)) {
            return type == 'y' ? this.systemConf.chart.axes.yaxis[order] || this.systemConf.chart.axes.yaxis[0] : this.systemConf.chart.axes.xaxis;
          }
          return type == 'y' ? this.systemConf.chart.axes.yaxis : this.systemConf.chart.axes.xaxis;
        } }, { key: "getPlotConfig", value:
        function getPlotConfig(data, index) {
          return data.plotoptions;
        } }, { key: "rotated", value:
        function rotated() {
          return this.data.chart.axes.rotated;
        } }, { key: "getPropValue", value:
        function getPropValue(key, value, from) {} }]);return DataSplicer;}();


    Registry.setComponent('dataSplicer', DataSplicer);var

    DataSplicer4ViewParser = /*#__PURE__*/function (_DataSplicer) {_inherits(DataSplicer4ViewParser, _DataSplicer);var _super4 = _createSuper(DataSplicer4ViewParser);
      function DataSplicer4ViewParser(data, systemConf, chart) {var _this14;_classCallCheck(this, DataSplicer4ViewParser);
        _this14 = _super4.call(this, data, systemConf, chart);
        _this14.axisConfig = {
          x: new Array(0),
          y: new Array(0)
        };return _this14;
      }_createClass(DataSplicer4ViewParser, [{ key: "getColumns", value:
        function getColumns() {
          if (this.data.columns) {
            return this.data.columns;
          }
          return _get(_getPrototypeOf(DataSplicer4ViewParser.prototype), "getColumns", this).call(this);
        } }, { key: "getEncode", value:
        function getEncode() {
          if (this.data.encoding) {
            return this.data.encoding;
          }
          return _get(_getPrototypeOf(DataSplicer4ViewParser.prototype), "getEncode", this).call(this);
        } }, { key: "getAxisConfig", value:
        function getAxisConfig(type, order) {
          order = pick(order, 0);
          var layout = getAxisLayout(null, type, this.chart.axes.rotated);
          if (this.chart.viewFlow) {
            var axisView = this.chart.viewFlow.axes[layout],
              axisConfig_merged = this.axisConfig[type][order];
            //if new parser does not initialize axis parser or axis spec
            if (!axisView) {
              return _get(_getPrototypeOf(DataSplicer4ViewParser.prototype), "getAxisConfig", this).call(this, type, order);
            }
            if (!defined(order)) {
              return axisView;
            }
            if (!axisView[order]) {
              return _get(_getPrototypeOf(DataSplicer4ViewParser.prototype), "getAxisConfig", this).call(this, type, order);
            }
            if (axisConfig_merged) {
              return axisConfig_merged;
            } else {
              var oldConfig = _get(_getPrototypeOf(DataSplicer4ViewParser.prototype), "getAxisConfig", this).call(this, type, order);
              if (type == 'y' && order > 0) {
                if (oldConfig.merged) {
                  this.axisConfig[type][order] = mergeJSON$1(axisView[order].conf.spec, oldConfig, false, false);
                } else {
                  return {}; //dummy
                }
              }
              this.axisConfig[type][order] = mergeJSON$1(axisView[order].conf.spec, oldConfig, false, false);
            }
            return this.axisConfig[type][order];
          }
        } }, { key: "getPlotConfig", value:
        function getPlotConfig(data, index) {
          return data.spec;
        } }, { key: "rotated", value:
        function rotated() {
          return this.rotated;
        } }, { key: "getPropValue", value:
        function getPropValue(key, value, from) {} }]);return DataSplicer4ViewParser;}(DataSplicer);


    Registry.setComponent('dataSplicer4ViewParser', DataSplicer4ViewParser);

    //$Id$

    var bubblepieUtils = {};

    /*
     * @param {Array} piedata
     * @param {Number} dataindex
     * @return {Array} piedata without zero valued pies
     * #ZC991 (legend filter: if nothing to visible and X is not available in the xscale.domain(), the pie should be filtered out)
     */
    bubblepieUtils.filterBySum = function (piedata, dataindex) {
      var accessor = function accessor(prev, cur) {
        return prev + (cur.disabled ? 0 : mathAbs(cur[dataindex] || 0));
      };

      return piedata.filter(function (d) {
        return d.reduce(accessor, 0) > 0; //If pie.total > 0. That means something is there to visualize
      });
    };

    bubblepieUtils.getKey = function (d, seriesIndex, chartObj, position) {
      if (!position) {
        var dataset = chartObj.dataset,
          yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder((chartObj.seriesdata[seriesIndex] || {}).yaxiscolumnorder); // TODO check with yaxiscolumnorder

        position = [dataset.getX(d), dataset.getY(d, yaxiscolumnorder)];
      }

      return chartObj && hasColorColumnInNonAxis(chartObj) ? "x(".concat(position[0], ")") : "x(".concat(position[0], ") y(").concat(position[1], ")");
    };

    function getCluster(d, chart) {
      if (!d) {
        return [];
      }

      var pieRenderer = chart.renderer[d.rendererIndex].subrenderer[d.subSeriesIndex],
        key = bubblepieUtils.getKey(d, d.seriesIndex, chart);
      return pieRenderer[key].data.map(function (_) {return _.data;}).filter(function (_) {return !_.dummy;});
    }

    Registry.setComponent('rendererUtils.bubblePie.getCluster', getCluster);

    //stackedTotal.js

    function getStackedTotal(chartObj, seriesPos, d, showAs) {
      var stackGroupIdx = getStackGroupIndex(chartObj.dataObject.getStackGroup(), seriesPos),
        rp = chartObj.renderer[seriesPos].commonRendererProp().params,
        dataset = chartObj.dataset,
        X = dataset.getX(d),
        Y = dataset.getY(d, rp.yaxiscolumnorder || 0),
        total;

      var curStackExtent = chartObj.dataObject.
      getEncode('stack', stackGroupIdx).
      layout.getAllExtents().
      filter(function (d) {return d[0] == X;});

      if (showAs === PERCENT_SHOWAS || showAs === PER_SHOWAS) {
        total = curStackExtent.reduce(function (prev, cur) {
          return prev + mathAbs(cur[1]);
        }, 0);
      } else {
        total = curStackExtent[Y < rp.hasNegValue && curStackExtent[1] ? 1 : 0][1];
      }
      return total;
    }

    //$Id$

    var dataparser = function dataparser() {};
    Registry.setComponent('defaultDataParser', dataparser);

    dataparser.get = function (data, chartObj) {
      var dataSplicer = chartObj.dataSplicer,
        metadata = data.metadata,
        columns = dataSplicer.getColumns(),
        axes = dataSplicer.getEncode();
      var seriesdata = data.seriesdata.chartdata;

      // data processor helpers
      var dataProcessorHelpers = DataProcessor.helpers,
        getParsedYAxisOrder = dataProcessorHelpers.getParsedYAxisOrder;

      axes = sortAxesObject();
      var dataObject,
        columnInfo_clr = columns[axes.clr] || {};
      var colTypeOrder = columns.map(function (d, i) {
        return getColTypeOrder(i);
      });

      var dataset = {
        xidx: columns[axes.x].dataindex,
        yidx: function yidx(order) {
          var columnidx = order instanceof Array ? axes.y[order[0]][order[1] || 0] : axes.y[order][0];
          return columns[columnidx].dataindex;
        },
        zidx: (columns[axes.z] || {}).dataindex,
        shapeidx: (columns[axes.shape] || {}).dataindex,
        tooltipidx: function tooltipidx(index) {
          return axes.tooltip != null ? columns[index].dataindex : null;
        },
        clridx: columnInfo_clr.levelindex ? null : columnInfo_clr.dataindex
      };
      dataset.setDataObj = function (obj) {
        dataObject = obj;
      };
      dataset.getX = function (d) {
        if (
        defined(dataObject) && (
        dataObject.categoryHierarchy &&
        dataObject.hierarchical.pivotLayout.columns.count &&
        !dataObject.hierarchical.pivotLayout.columns.splitColumnLeaves ||
        dataObject.isWaterfallEnabled))
        {
          //TODO waterfall
          return d.index;
        } else {
          return this.getActualX(d);
        }
      },
      dataset.getY = function (d, yaxiscolumnorder, range) {
        /*
         * Meta data for y should be in array
         * Axis order may be array of objects or an object
         */
        try {
          var curYidx = this.yidx(yaxiscolumnorder);
          var yVal = d[curYidx] === undefined ? null : range == null ? d[curYidx] : d[curYidx][range];

          return yVal;
          // eslint-disable-next-line no-empty
        } catch (err) {}
      },
      dataset.getZ = function (d) {
        return d[this.zidx];
      },
      dataset.getClr = function (d) {
        return d[this.clridx];
      },
      dataset.getGroupByValues = function (d, indices) {
        if (indices == null || indices.length == 0) {
          return null;
        }
        return indices.reduce(function (prev, cur, i) {
          return defined(d[cur]) ? prev + d[cur] : prev;
        }, '');
      };

      dataset.getActualX = function (d) {
        return d[this.xidx];
      };

      dataset.getDataType = function (type, index, seriestypes) {
        var dataSplicer = chartObj.dataSplicer,
          metadata_axes = dataSplicer.getEncode();

        seriestypes =
        seriestypes ||
        dataset.seriesTypes.values().map(function (d) {
          return +d;
        });
        var hierarchical = dataObject && dataObject.hierarchical,
          isBranchType;
        if (hierarchical) {
          if (hierarchical.pivot) {
            var tag = type == 'x' ? 'column' : 'row',
              nodeList = dataObject.hierarchical.pivotLayout.getRootNodeList(tag),
              leavesCount = nodeList.getLeavesCount();
            isBranchType = index > leavesCount - 1;
          } else {
            isBranchType = type === 'x' && index > 0;
          }
        }
        if (isBranchType) {
          return 'ordinalNonLinear';
        }

        var datatype = null;
        if (metadata_axes[type] != null) {
          var columnidx = this.getColumnIdx(type, index);
          var columnInfo = columns[columnidx];
          datatype = columnInfo.datatype;
          //ordinal cases:
          var ordinalType =
          type == 'x' && (
          dataObject && dataObject.isPolarAxisCategory ||
          seriestypes.indexOf(charttype.bar) != -1 ||
          seriestypes.indexOf(charttype.stkdbar) != -1 ||
          seriestypes.indexOf(charttype.bullet) != -1 ||
          seriestypes.indexOf(charttype.gantt) != -1 ||
          seriestypes.indexOf(charttype.boxplot) != -1 ||
          seriestypes.indexOf(charttype.barrange) != -1 ||
          seriestypes.indexOf(charttype.web) != -1) ||
          type === 'clr' && data.legend._dummy; //ZC2635

          var isHeatmap = seriestypes.indexOf(charttype.heatmap) != -1 && (type === 'x' || type === 'y');
          datatype = ordinalType || columnInfo.useDiscrete || isHeatmap ? ORDINAL_DATATYPE : datatype;
        }
        return datatype;
      };

      dataset.getColumnIdx = function (type, order) {
        var columnidx;
        var dataSplicer = chartObj.dataSplicer,
          metadata_axes = dataSplicer.getEncode(),
          metadata_columns = dataSplicer.getColumns();
        var axes = metadata_axes[type];
        if (type == 'y') {
          if (dataObject && dataObject.hierarchical && dataObject.hierarchical.pivotLayout.rows.count) {
            var rowList = dataObject.hierarchical.pivotLayout.getRootNodeList('row');
            if (order > rowList.getLeavesCount() - 1) {
              metadata_columns.filter(function (d, i) {
                if (d.levelindex == chartObj.axes.y.count - 1 - order) {
                  columnidx = i;
                }
              });
            } else {
              columnidx = axes[0][0];
            }
          } else {
            columnidx = order instanceof Array && order.length == 2 ? axes[order[0]][order[1]] : axes[order][0];
          }
        } else if (type == 'tooltip') {
          columnidx = axes[order];
        } else if (type == 'x' && order > 0) {
          if (dataObject && dataObject.hierarchical && dataObject.hierarchical.pivot) {
            var columnList = dataObject.hierarchical.pivotLayout.getRootNodeList('column'),
              _rowList = dataObject.hierarchical.pivotLayout.getRootNodeList('row'),
              rowCount = _rowList.getBranchesCount() || 0;
            if (order > columnList.getLeavesCount() - 1) {
              metadata_columns.filter(function (d, i) {
                if (d.levelindex == rowCount + chartObj.axes.x.count - 1 - order) {
                  columnidx = i;
                }
              });
            } else {
              columnidx = axes[0];
            }
          } else {
            metadata_columns.filter(function (d, i) {
              if (d.levelindex == chartObj.axes.x.count - order) {
                columnidx = i;
              }
            });
          }

          columnidx = pick(columnidx, axes[0]);
        } else {
          columnidx = axes == null ? null : axes[0];
        }
        return columnidx;
      };

      dataset.getColumn = function (type, yaxiscolumnorder) {
        var columnidx = this.getColumnIdx(type, yaxiscolumnorder);
        return columns[columnidx];
      };

      dataset.getColumnName = function (colidx, toDecode) {
        return (toDecode != false ? decodeHTML : encodeHTML)(columns[colidx].columnname);
      };

      dataset.getCustomizedVal = function (
      chartObj,
      colidx,
      seriespos,
      subseriespos,
      itempos,
      d,
      type,
      color,
      toDecode,
      subseriesLength,
      yrangePos)
      {
        if (isUndefined(toDecode)) {
          toDecode = !/(tooltip|legend)/.test(type);
        }

        var isSankey = chartObj.chartTypes[0].name === SANKEY_CHARTNAME;

        return colidx.toString().replace(CUSTOM_VALUE_PATTERN, function () {
          var matchedString = arguments[0],
            valIndex = arguments[1], //INDEX value of {{val(INDEX)}}
            colIndex = arguments[2], //INDEX value of {{col(INDEX)}}
            perIndex = arguments[3], //INDEX value of {{per(INDEX)}}
            splitPerIndex = arguments[4], //INDEX value of {{splitper(INDEX)}}
            maxPerIndex = arguments[5],
            valIndex_1 = arguments[7], //Value at array position
            dataindex = arguments[8]; //yrangepos
          var idx = valIndex || colIndex || perIndex || splitPerIndex || maxPerIndex || dataindex;
          if (matchedString.indexOf('{{clr}}') != -1) {
            // theme color based on series color
            return color;
          }
          if (columns[idx] != null) {
            var dataPoint =
            type === STACKLABELS_LABELTYPE || isSankey ?
            d :
            dataset.getDataPoint(chartObj, idx, seriespos, subseriespos, itempos, d);
            if (dataPoint != null) {
              var operation = matchedString.match(/[a-z]+/gi)[0];
              switch (operation) {
                case 'col':
                  return dataset.getColumnName(colIndex, toDecode); //return columnname
                case 'valatpos':
                case 'val':
                  var isRangeDefined = defined(dataindex),
                    yArrayIndex = yrangePos;
                  if (isRangeDefined) {
                    valIndex = valIndex_1, yArrayIndex = dataindex;
                  }
                  var val = dataset.getDataPointValue(
                  chartObj,
                  dataPoint,
                  valIndex,
                  seriespos,
                  false,
                  type,
                  subseriespos,
                  toDecode,
                  subseriesLength,
                  yArrayIndex);


                  if (
                  [DATALABELS_LABELTYPE, STACKLABELS_LABELTYPE, INNERLABEL_LABELTYPE, PARENTLABELS_LABELTYPE].indexOf(type) >
                  -1)
                  {
                    val = val || ''; //Test_437.json
                  }
                  return val; //return value
                case PER_SHOWAS:
                case SPLITPER_SHOWAS:
                case MAXPER_SHOWAS:
                  return dataset.getDataPointValue(
                  chartObj,
                  dataPoint,
                  perIndex || splitPerIndex || maxPerIndex,
                  seriespos,
                  operation,
                  type,
                  subseriespos,
                  toDecode,
                  subseriesLength);
                //return the percentage of value (percentage of Y value is only supported now)
              }
            } else {
              return '';
            }
          } else {
            return matchedString;
          }
        });
      };

      dataset.getYaxisColumnIndexBySeriesIndex = function (chartObj, seriesIndex) {
        var yaxiscolumnorder = (seriesdata[seriesIndex] || seriesdata[0]).yaxiscolumnorder || [0, 0];
        return isArray$1(yaxiscolumnorder) ? axes.y[yaxiscolumnorder[0]][yaxiscolumnorder[1] || 0] : axes.y[yaxiscolumnorder][0];
      };

      dataset.getDataPoint = function (chartObj, colidx, seriespos, subseriespos, itempos, d) {
        //seriesdataAfterUpdate refers seriesdata without null data,till now handled only in bar chart
        colidx = +colidx;
        var dataPoint = null,
          colInfo = columns[colidx] || {},
          type = colTypeOrder[colidx] && colTypeOrder[colidx].type,
          curSeriesPos = seriespos,
          hierarchyCondition = true;

        if (type === 'y' && this.getYaxisColumnIndexBySeriesIndex(chartObj, seriespos) !== colidx) {
          //For Multi y charts, show the respective series only
          return dataPoint; // why we are returning null data point for multi y charts
        }

        if (chartObj.dataObject.isHierarchy) {
          var rendererIndex = getRendererIndex(d, chartObj);
          var getProcessedNodeFunc = chartObj.renderer[rendererIndex].getProcessedNode;
          var node = getProcessedNodeFunc ? getProcessedNodeFunc(d) : d;
          var facets = chartObj.userdata.facets;
          hierarchyCondition =
          axes.clr && axes.clr[0] === colidx && node.depth === 1 ||
          chartObj.systemConf.metadata.axes.y[0].indexOf(colidx) !== -1 ||
          node.children && (
          colInfo.levelindex === node.depth - 1 ||
          isArray$1(colInfo.levelindex) && colInfo.levelindex.indexOf(node.depth - 1) !== -1) ||
          !node.children && (colInfo.levelindex == null || colInfo.dataindex != null) ||
          arrayIncludes(facets && facets.rows || [], colidx) ||
          arrayIncludes(facets && facets.columns || [], colidx);
        } else if (chartObj.dataObject.isFlowChartCategory) {
          dataPoint = d.point;
        }

        if (curSeriesPos != null && hierarchyCondition) {
          var _rendererIndex2 = getRendererIndex(
          d,
          chartObj,
          chartObj.isAxisCategory || chartObj.dataObject.isPolarAxisCategory ? curSeriesPos : 0);

          var renderer = chartObj.renderer[_rendererIndex2];
          var seriesdataAfterUpdate = d ?
          null :
          renderer != null && renderer.seriesdataAfterUpdate != null ?
          renderer.seriesdataAfterUpdate[subseriespos] :
          seriesdata[curSeriesPos].data[subseriespos];
          dataPoint = d || seriesdataAfterUpdate[itempos];
        }
        return dataPoint;
      };

      dataset.getDataPointValue = function (
      chartObj,
      dataPoint,
      colidx,
      seriespos,
      percent,
      type,
      subseriespos,
      toDecode,
      subseriesLength,
      yrangePos)
      {
        if (colidx != null) {
          colidx = +colidx;
        }

        if (isUndefined(toDecode)) {
          toDecode = !/(tooltip|legend)/.test(type);
        }

        var colInfo = columns[colidx] || {},
          datatype = colInfo.datatype,
          levelindex = colInfo.levelindex,
          dataindex = colInfo.dataindex,
          node;
        var format = colInfo[datatype];
        if (dataPoint != null) {
          if (chartObj.dataObject.isHierarchy) {
            var rendererIndex = getRendererIndex(dataPoint, chartObj);
            var renderer = chartObj.renderer[rendererIndex];
            var getProcessedNodeFunc = renderer && renderer.getProcessedNode;
            node = getProcessedNodeFunc ? getProcessedNodeFunc(dataPoint) : dataPoint;
          }

          if (
          (axes.clr != null || type === 'legend') &&
          colidx == axes.clr &&
          !(chartObj.dataObject.isHierarchy && type !== 'legend' && colInfo.dataindex != null))
          {
            //Eventhough clrIdx is not specified in metadata, the seriesname will be returned correctly
            if (defined(this.clridx) && colorscale_helpers.isQuantileColorScale(chartObj)) {
              if (type === 'legend') {
                var arraySeperator = '-';
                return getFormattedValue(format, dataPoint, datatype, chartObj, type, toDecode, arraySeperator);
              }
              return getFormattedValue(format, this.getClr(dataPoint), datatype, chartObj, type, toDecode);
            } else {
              var actualData = dataPoint.paneid ?
              DataProcessor.helpers.getSeriesdata(chartObj, dataPoint.paneid, seriespos) :
              seriesdata[seriespos];
              return getFormattedValue(
              format,
              dataPoint.seriesname || actualData && actualData.seriesname,
              datatype,
              chartObj,
              type,
              toDecode);

            }
          } else if (defined(levelindex) && chartObj.dataObject.hierarchical && datatype == 'ordinal') {
            var nodeValue = chartObj.dataObject.hierarchical.getNodeValueByColumnIdx(dataPoint, colidx, levelindex);

            if (nodeValue) {
              return getFormattedValue(format, nodeValue, datatype, chartObj, type, toDecode);
            } else {
              return '';
            }
          } else if (
          chartObj.dataObject.isHierarchy && (
          levelindex === node.depth - 1 || isArray$1(levelindex) && levelindex.indexOf(node.depth - 1) !== -1))
          {
            var val = !node.children && colInfo.dataindex != null ? dataPoint[dataindex] : dataPoint.seriesname;
            return getFormattedValue(format, val, datatype, chartObj, type, toDecode);
          } else {
            var value;
            var yidx = this.getColumnIdx(
            'y',
            getParsedYAxisOrder((chartObj.seriesdata[seriespos] || chartObj.seriesdata[0]).yaxiscolumnorder));

            var arraySeperator = colidx == yidx || chartObj.dataObject.hasWhiskers ? ' - ' : undefined;
            var formatFn = percent ? getFormattedValueByPercent : getFormattedValue;
            if (subseriesLength) {
              //subserieslength - to iterate all subseries y value to show for tooltip shared series info
              var cumval = 0;
              for (var j = 0; j < subseriesLength; j++) {
                // var dp = dataparser.getDataPoint(chartObj, yidx, seriespos, j, itempos);
                cumval += dataset.getDataPointUnformattedValue(
                datatype,
                seriespos,
                j,
                colidx,
                dataPoint,
                type,
                percent,
                dataindex,
                yrangePos);

              }
              value = cumval;
            } else {
              value = dataset.getDataPointUnformattedValue(
              datatype,
              seriespos,
              subseriespos,
              colidx,
              dataPoint,
              type,
              percent,
              dataindex,
              yrangePos);

            }

            if (value === '' && percent) {
              return value;
            }
            return formatFn(format, value, datatype, chartObj, type, toDecode, arraySeperator);
          }
        }
        return null;
      };
      dataset.getDataPointUnformattedValue = function (
      datatype,
      seriespos,
      subseriespos,
      colidx,
      dataPoint,
      type,
      percent,
      dataindex,
      yrangePos)
      {
        var value;
        if (chartObj.dataObject.isHierarchy) {
          var rendererIndex = getRendererIndex(dataPoint, chartObj);
          var renderer = chartObj.renderer[rendererIndex];
          var getProcessedNodeFunc = renderer && renderer.getProcessedNode,
            node = getProcessedNodeFunc ? getProcessedNodeFunc(dataPoint) : dataPoint;
        }
        if (percent) {
          var total = datatype == NUMERIC_DATATYPE ? getTotal(chartObj, seriespos, subseriespos, colidx, dataPoint, percent, type) : null;
          if (total != null) {
            value =
            (type == STACKLABELS_LABELTYPE ?
            dataPoint :
            chartObj.dataObject.isHierarchy && node.children && defined(node.value) ?
            node.value :
            chartObj.dataObject.isPercentChart ?
            dataPoint.y :
            dataPoint[dataindex]) /
            total *
            100;
            value = value || 0; //if total=0 and y=0, the 'val' holds NaN
            return value;
          } else {
            return '';
          }
        }
        var yidx = this.getColumnIdx('y', getParsedYAxisOrder((chartObj.seriesdata[seriespos] || chartObj.seriesdata[0]).yaxiscolumnorder));
        value =
        chartObj.dataObject.isHierarchy && node.children && colidx == yidx && defined(node.value) ?
        node.value :
        type == STACKLABELS_LABELTYPE ?
        dataPoint :
        defined(yrangePos) ?
        dataPoint[dataindex][yrangePos] :
        dataPoint[dataindex];
        return value;
      };

      dataset.getMetaInfoObj = function (chartObj, data, seriespos) {
        var axes = chartObj.systemConf.metadata.axes,
          columns = chartObj.systemConf.metadata.columns,
          seriesdata = chartObj.systemConf.seriesdata.chartdata,
          seriespos = chartObj.isAxisCategory || chartObj.isNonAxisMultiSeriesCategory ? seriespos : 0,
          dataWithMetadata = [];
        var yindex = (seriesdata[seriespos] || seriesdata[0]).yaxiscolumnorder || [0, 0]; //yaxiscolumnorder is not mandatory
        var yColIdx = yindex instanceof Array ? axes.y[yindex[0]][yindex[1] || 0] : axes.y[yindex][0];
        if (data instanceof Array) {
          data.forEach(function (d, i) {
            var colidx = columns.indexOf(
            columns.filter(function (c, j) {
              return c.dataindex == i && (dataset.yidx(yindex) != i || dataset.yidx(yindex) == i && yColIdx == j);
            })[0]);

            dataWithMetadata.push(getColObj(colidx, d));
          });
        }

        if (axes.clr != null) {
          var clrColIdx = axes.clr instanceof Array ? axes.clr[0] : axes.clr;
          dataWithMetadata.push(getColObj(clrColIdx, seriesdata[seriespos].seriesname));
        }
        return dataWithMetadata;

        function getColObj(colidx, value) {
          var obj = simpleClone(columns[colidx] || {});
          obj.value = value;
          obj.columnindex = colidx;
          return obj;
        }
      };

      dataset.processMetaData = function () {
        var legendIndex = getPropVal(metadata, 'axes.clr');

        if (defined(legendIndex)) {
          legendIndex = legendIndex[0];
        }

        function process(metadata, i) {
          var type;

          if (i === legendIndex) {
            return;
          }

          if (!defined(metadata.datatype)) {
            var data = dataset.getDataByColumnIndex(metadata.dataindex);
            type = dataset.findDataType(data);
            metadata.datatype = type;
          }
          if (defined(type) && !defined(metadata[type])) {
            metadata[type] = {};
          }
        }
        columns.forEach(process);
      };

      dataset.getDataByColumnIndex = function (index) {
        var data = null,
          found = false;
        chartObj.seriesdata.some(function (series) {
          return series.data.some(function (subSeries) {
            return subSeries.some(function (point) {
              if (defined(point)) {
                found = defined(point[index]);
                if (found) {
                  data = point[index];
                }
                return found;
              }
            });
          });
        });
        return data;
      };

      dataset.findDataType = function (data) {
        if (typeof data === 'number') {
          if (data > 365 * 24 * 3600 * 1000) {
            return TIME_DATATYPE;
          }
          return NUMERIC_DATATYPE;
        }
        return ORDINAL_DATATYPE;
      };

      // init
      dataset.processMetaData();
      // handle meta data.

      function getColTypeOrder(colidx) {
        var axesType,
          order = [];
        for (var type in axes) {
          if (axes.hasOwnProperty(type)) {
            var val = type == 'y' ? d3_merge(axes[type]) : axes[type];
            if (val.indexOf(colidx) != -1) {
              if (type == 'y') {
                axes[type].map(function (d, i) {
                  var index = d.indexOf(colidx);
                  if (index != -1) {
                    order.push(i);
                    order.push(index);
                  }
                });
              }
              axesType = type;
              return {
                type: axesType,
                order: order
              };
            }
          }
        }
      }

      function sortAxesObject() {
        var newaxes = {},
          keysSorted = Object.keys(axes).sort(function (a, b) {
            return b.length > a.length ? -1 : b.length < a.length ? 1 : 0; // (a.length > b.length) is incorrect in SAFARI
          });
        keysSorted.forEach(function (d) {
          newaxes[d] = axes[d];
        });
        return newaxes;
      }

      return dataset;
    };

    function getTotal(chartObj, seriespos, subseriespos, colidx, dataPoint, showAs, type) {
      colidx = +colidx;
      var axes = chartObj.systemConf.metadata.axes,
        yaxes = axes.y,
        index = -1,
        isBubblePie = isMultiPieChartType(chartObj.chartTypes[seriespos].value),
        stacked = chartObj.dataObject.isstacked(chartObj.chartTypes[seriespos].value);
      if (stacked && !chartObj.dataObject.isPercentChart && /(datalabels|tooltip)/.test(type)) {
        return getStackedTotal(chartObj, seriespos, dataPoint, showAs);
      }

      if (isArray$1(yaxes) || chartObj.isGeoMap) {
        if (isArray$1(yaxes)) {
          if (isArray$1(yaxes[0])) {
            yaxes.forEach(function (d, i) {
              index = index == -1 && d.indexOf(colidx) > -1 ? i : index;
            });
          } else {
            index = yaxes.indexOf(colidx) > -1 ? 0 : -1;
          }
        }

        if (index != -1 || isBubblePie) {
          var total;
          if (isBubblePie) {
            var key = bubblepieUtils.getKey(dataPoint, seriespos, chartObj);
            var pieRenderer = chartObj.subrenderer[subseriespos || 0][key];
            total = pieRenderer.total;
          } else if (chartObj.isAxisCategory || chartObj.dataObject.isPolarAxisCategory) {
            var yscale = chartObj.axes.y.groups[index].scale;
            if (showAs === MAXPER_SHOWAS || !yscale) {
              var domain = chartObj.dataObject.ZC_BAR_getRangeY(index);
              total = chartObj.dataset.getY(dataPoint, index) < 0 ? -domain[0] : domain[1];
            } else {
              var domain = yscale.domain();
              total = domain[1];
            }
          } else {
            if (chartObj.isNonAxisMultiSeriesCategory) {
              var rendererIndex = getRendererIndex(dataPoint, chartObj);
              var renderer = chartObj.renderer[rendererIndex];
              if (showAs === PER_SHOWAS) {
                return renderer.total;
              } else if (renderer.extentY) {
                return renderer.extentY[1];
              } else {
                var getProcessedNodeFunc = renderer.getProcessedNode;
                var node = getProcessedNodeFunc ? getProcessedNodeFunc(dataPoint) : dataPoint;
                total = node._parent ? node._parent.value : node.parent.value;
              }
            } else if (type === 'legend') {
              var curSeriesData = chartObj.seriesdata[0],
                yDataIndex = chartObj.dataset.yidx(DataProcessor.helpers.getParsedYAxisOrder(curSeriesData.yaxiscolumnorder));
              total = curSeriesData.data[0].reduce(function (prev, cur) {
                var yVal = cur.disabled ? 0 : mathAbs(cur[yDataIndex] || 0);
                return prev + yVal;
              }, 0);
            } else {
              var _rendererIndex3 = getRendererIndex(dataPoint, chartObj);
              total = chartObj.renderer[_rendererIndex3].total;
            }
          }
          return !total && total !== 0 ? null : total;
        }
      }
      return null;
    }

    function getRendererIndex(d, chartObj) {var seriesIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (isFacet(chartObj) && (d && d.data && d.data.paneid || d && d.paneid)) {
        var panes = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList('layer').panes,
          paneIndex = panes[d.paneid].index;

        return getCurrentRendererIndex(panes, paneIndex);
      }

      return seriesIndex;
    }

    //pre-data-processor.js

    function PreProcessor(chart) {
      this.chart = chart;
      this.data = chart.systemConf;
      this.initialize();
    }

    PreProcessor.prototype.initialize = function () {
      var processor = this,
        chart = processor.chart,
        data = processor.data,
        dataSplicer = chart.dataSplicer,
        metadata_axes = dataSplicer.getEncode(),
        metadata_columns = dataSplicer.getColumns(),
        xColumnIndex = metadata_axes.x,
        xDataType = metadata_columns[xColumnIndex].datatype,
        dataProcessorHelpers = DataProcessor.helpers,
        isDiscrete = chartcategory.discrete.some(function (d) {
          return chart.chartTypes.indexOf(d) !== -1;
        }),
        cType = dataProcessorHelpers.getChartType(null, null, 0, chart.systemConf),
        chartValue = cType.value,
        chartName = cType.name,
        facetHierarchy = data.facets && data.facets.hierarchy;

      // check if the data has hierarchy
      var isAllowedHierarchyCharts =
      isBarChartType(chartValue) ||
      isAreaChartType(chartValue) ||
      isScatterChartType(chartValue) ||
      isPointChartType(chartValue) ||
      chartName === 'line' ||
      data.facets &&
      ['pie', 'funnel', 'pyramid', 'dial', 'web', 'packedbubble', 'treemap', 'sunburst', 'wordcloud'].indexOf(chartName) > -1;

      if (this.isHierarchyLayout() && isAllowedHierarchyCharts || facetHierarchy) {
        processor.hierarchical = new DataProcessor.HierarchicalOrdinalDataAdapter(this.chart);
        processor.isLayerHierarchy = !processor.hierarchical.pivot;
        processor.isPivot = processor.hierarchical.pivot;
        processor.isAxisCategoricalPivot = true;
        // update the chart data
        processor.chart.seriesdata = this.hierarchical.getSeries();
        if (this.hierarchical.pivot) {
          chart.chartTypes = DataProcessor.helpers.getAllChartTypesFromSeriesdata(
          processor.chart.userdata,
          processor.chart.seriesdata,
          'object');

        }
      }
      var plotoptions = chart.systemConf.chart.plot.plotoptions[chartName];
      chart.isAxisedHierarchyChart = plotoptions && plotoptions.axis && plotoptions.axis.enabled;
      if (processor.hierarchical && processor.hierarchical.facetRendering) {
        var gridList = getGridList(processor);
        gridList.forEach(function (grid) {
          var gridDataLikeSystemConfig = {
            seriesdata: { chartdata: grid.data.map(function (_) {return _.node;}), type: chart.systemConf.seriesdata.type }
          };
          if (isNestedHierarchy(chart, gridDataLikeSystemConfig)) {
            processor.isHierarchy = true;
            var dataAdapterObj = new (Registry.getComponent('hierarchyDataAdapter'))(grid.data, processor);
            grid.data = dataAdapterObj.getData();
          }
        });
      } else if (isNestedHierarchy(chart) && !chart.isAxisedHierarchyChart) {
        processor.isHierarchy = true;
        var dataAdapterObj = new (Registry.getComponent('hierarchyDataAdapter'))(chart.seriesdata, processor);
        chart.seriesdata = dataAdapterObj.getData();
      }

      // process the time data
      processor.processTimeData();

      // sort if defined
      if (_requireXDataSorting && (xDataType === NUMERIC_DATATYPE || xDataType === TIME_DATATYPE && !isDiscrete)) {
        processor.sortData(xColumnIndex, xDataType);
      }
    };

    /**
     * Checks if the series has hierarchy
     * @return {boolean}
     */

    PreProcessor.prototype.isHierarchyLayout = function () {
      var processor = this,
        chart = processor.chart,
        series = chart.systemConf.seriesdata.chartdata;

      return series.some(PreProcessor.helpers.hasInnerSeries);
    };

    /**
     *
     */

    PreProcessor.prototype.processTimeData = function () {
      var processor = this,
        chart = processor.chart,
        timeDataInfo,
        timeDataIndices,
        timeDataInputFormat,
        hasTimeInputFormat,
        series = chart.seriesdata;

      timeDataInfo = PreProcessor.helpers.time.getDataInfo(processor.data, null, chart);
      timeDataIndices = timeDataInfo.indices;
      timeDataInputFormat = timeDataInfo.formatConf;

      hasTimeInputFormat = timeDataInputFormat.some(function (d) {
        return defined(d) && defined(d.inputformat);
      });

      if (timeDataIndices && timeDataIndices.length && hasTimeInputFormat) {
        var func = isNestedHierarchy(chart) ? loopHierarchy : loopFlatten;
        func(series, function (d) {return PreProcessor.helpers.time.applyFormats(d, timeDataInfo);});
      }
    };

    /**
     *
     * @param xColPos
     * @return {*}
     */

    PreProcessor.prototype.sortData = function (xColPos) {
      var processor = this,
        chart = processor.chart,
        data = processor.data,
        series = chart.seriesdata;

      series.forEach(function (currentSeries) {
        var currentData = currentSeries.data,
          dataIndex = data.metadata.columns[xColPos].dataindex;

        if (DataProcessor.helpers.is3D(currentData)) {
          if (isArray$1(currentData)) {
            currentData.forEach(function (subgroup) {
              PreProcessor.helpers.linear.sort(subgroup, dataIndex);
            });
          }
        } else {
          PreProcessor.helpers.linear.sort(currentData, dataIndex);
        }
      });
      return data;
    };

    function isNestedHierarchy(chartObj, data) {
      data = pick(data, chartObj.systemConf);
      var chartType = DataProcessor.helpers.getChartType(null, NUMERIC_DATATYPE, 0, data);
      return arrayIncludes(chartcategory.hierarchy, chartType);
    }

    /**
     * Loop flat data
     * @param  {Array} data
     * @param  {Function} hook
     */
    function loopFlatten(series, callbacks) {
      series.forEach(function (d) {
        var currentData = d.data;
        if (isArray$1(currentData)) {
          var is3DArray = DataProcessor.helpers.is3D(currentData);
          currentData.forEach(function (subgroup, j) {
            if (is3DArray && isArray$1(subgroup)) {
              subgroup.forEach(function (dataPoint) {return executeCallBacks(callbacks, dataPoint);});
            }
            if (!is3DArray) {
              executeCallBacks(callbacks, subgroup);
            }
          });
        }
      });
    }

    /**
     * Loop hierarchy data
     * @param  {Array} data
     * @param  {Function} hook
     */
    function loopHierarchy(parent, callbacks) {
      parent.forEach(function (d) {
        if (isArray$1(d[0])) {
          loopHierarchy(d, callbacks);
        } else {
          executeCallBacks(callbacks, d);
        }
      });
    }

    function executeCallBacks(callbacks, d) {
      callbacks = splat(callbacks);
      callbacks.forEach(function (callback) {return callback(d);});
    }

    //$Id$

    var tooltip_content = {};
    tooltip_content.getContentTemplate = function (chartObj, customTemplate, customIndices, forPrecalculation) {
      var systemConf = chartObj.systemConf,
        dummyData = chartObj.userdata.seriesdata.chartdata[0].data[0] || {},
        dataSplicer = chartObj.dataSplicer,
        metadata_axes = dataSplicer.getEncode(),
        metadata_columns = dataSplicer.getColumns(),
        meta_tooltip = invokeFunction(
        customIndices || metadata_axes.tooltip || d3_range(metadata_columns.length),
        null,
        dummyData),
        //HACK NOT getting hovered data this time, hence added dummy data
        meta_yaxes = metadata_axes.y && d3_merge(metadata_axes.y) || [],
        tooltipConfig = systemConf.tooltip,
        maxWidth = perToPx(tooltipConfig.maxWidth || '40%', chartObj.chartarea.width),
        sharedSeriesInfo = tooltip_helpers.hasSharedSeries(chartObj),
        isColumnView = tooltipConfig.view === 'column',
        foundYColumnIndex,
        template = [],
        content;

      if (!customTemplate) {
        if (defined(systemConf.tooltip.theme) && isObjectPropDefined(window.$ZC, 'tooltip.getTheme')) {
          meta_tooltip = chartObj.tooltip.content;
        } else if (sharedSeriesInfo) {
          var tooltipSharedInfo = d3_map();
          chartObj.seriesdata.forEach(function (series, seriesIndex) {
            tooltip_content.updateSharedInfo(chartObj, tooltipSharedInfo, seriesIndex);
          });
          meta_tooltip = tooltip_content.getRawSharedContent(chartObj, tooltipSharedInfo, meta_tooltip);
        }

        meta_tooltip.forEach(function (colidx, i) {
          var temp,
            val,
            col = val = '';
          if (metadata_columns[colidx]) {
            // For column index
            if (meta_yaxes.length > 1 && meta_yaxes.indexOf(colidx) > -1 && !sharedSeriesInfo) {
              if (foundYColumnIndex) {
                return;
              } else {
                foundYColumnIndex = true;
                meta_tooltip.forEach(function (d) {
                  if (meta_yaxes.indexOf(d) > -1) {
                    col += "{{col(".concat(d, ")}}");
                    val += "{{val(".concat(d, ")}}");
                  }
                });
              }
            } else {
              col = "{{col(".concat(colidx, ")}}");
              val = "{{val(".concat(colidx, ")}}");
            }

            temp = [col, val];
          } else {
            // For custom string
            temp = colidx;
          }
          template.push(temp);
        });
      } else {
        template = customTemplate;
      }

      if (isColumnView) {
        content = template.reduce(function (prev, cur) {
          var str;
          if (isArray$1(cur)) {
            str = "<tr style='vertical-align: top;'><td style='max-width:".concat(maxWidth * 0.4, "px;'>").concat(
            cur[0], ": </td><td style='max-width:").concat(
            maxWidth * 0.6, "px;'><b>").concat(cur[1], "</b></td></tr>");
          } else {
            str = "<tr style='vertical-align: top;'><td style='max-width:".concat(maxWidth, "px;'>").concat(cur, "</td></tr>");
          }
          return prev + str;
        }, '');
        content = "<table cellspacing='0' cellpadding='0' border='0' style='border-spacing: 5px;'><tbody>".concat(content, "</tbody></table>");
      } else {
        content = template.reduce(function (prev, cur, i) {
          var str;
          if (isArray$1(cur)) {
            str = "".concat(cur[0], " : ").concat(cur[1]);
          } else {
            str = cur;
          }
          return prev + str + (i == template.length - 1 ? '' : '<br>');
        }, '');
      }

      if (forPrecalculation) {
        content = content.replace(/{{clr}}/g, 'black'); // height is not precalculated correctly as tooltip theme3 ignores border-bottom: 2px solid {{clr}}
      }

      return content;
    };

    tooltip_content.updateSharedInfo = function (chartObj, tooltipSharedInfo, seriespos) {
      var dataset = chartObj.dataset,
        clrIdx = dataset.getColumnIdx('clr'),
        yidx = dataset.getColumnIdx('y', (chartObj.seriesdata[seriespos] || chartObj.seriesdata[0]).yaxiscolumnorder || [0, 0]),
        repeat_pattern = "{{val(".concat(
        chartObj.dataObject.pieWithAxis && !chartObj.dataObject.isCombinationalChart ?
        tooltip_helpers.getPieColumnIndex(chartObj) :
        yidx, ")}}");


      tooltipSharedInfo.y_val_pattern = tooltipSharedInfo.y_val_pattern || '';
      tooltipSharedInfo.y_col_pattern = tooltipSharedInfo.y_col_pattern || '';

      if (tooltipSharedInfo.y_val_pattern.indexOf(repeat_pattern) == -1) {
        tooltipSharedInfo.y_val_pattern += repeat_pattern;
        tooltipSharedInfo.y_col_pattern +=
        chartObj.ismultiy || isUndefined(clrIdx) ?
        tooltipSharedInfo.y_col_pattern != '' ?
        '' :
        '{{val(null)}}' : "{{val(".concat(
        clrIdx, ")}}");
      }
    };

    tooltip_content.getRawSharedContent = function (chartObj, tooltipSharedInfo, meta_tooltip) {
      var metadata = chartObj.systemConf.metadata,
        metadata_axes = metadata.axes,
        metadata_columns = metadata.columns,
        meta_yaxes = d3_merge(metadata_axes.y),
        dataset = chartObj.dataset,
        content = [],
        curPattern = '',
        pieIdx =
        chartObj.dataObject.pieWithAxis && !chartObj.dataObject.isCombinationalChart ?
        tooltip_helpers.getPieColumnIndex(chartObj) :
        NULL$1,
        hasCustomTooltip = meta_tooltip.some(function (d) {
          CUSTOM_VALUE_PATTERN.lastIndex = 0; // #ZC1256 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test
          return typeof d === 'string' && CUSTOM_VALUE_PATTERN.test(d);
        }),
        hasRepeatPattern = function hasRepeatPattern(yidx) {
          var repeatIndex = defined(pieIdx) ? pieIdx : yidx;
          return (isArray$1(curPattern) ? curPattern : [curPattern]).some(function (cur) {
            return (
              typeof cur === 'string' && (
              cur.indexOf("{{val(".concat(repeatIndex, ")}}")) != -1 || cur.indexOf("{{per(".concat(repeatIndex, ")}}")) != -1));

          });
        },
        repeat = chartObj.isAxisCategory;

      if (!hasCustomTooltip) {
        var x_pattern = "{{val(".concat(dataset.getColumnIdx('x'), ")}}"),
          y_pattern = tooltipSharedInfo.y_val_pattern,
          clr_pattern = '{{clr}}',
          clr_val_pattern = tooltipSharedInfo.y_col_pattern,
          x_val = x_pattern,
          y_val = ["<div style='margin-right:0.2em;display:inline-block;vertical-align:middle;border-radius: 50%;padding:0.4em;background:".concat(
          clr_pattern, "''></div>").concat(clr_val_pattern),
          y_pattern];


        content.push(x_val);
        if (chartObj.dataObject.pieWithAxis && !chartObj.dataObject.isCombinationalChart) {
          content.push(["{{col(".concat(dataset.getColumnIdx('y', 0), ")}}"), "{{val(".concat(dataset.getColumnIdx('y', 0), ")}}")]);
          content.push(["{{col(".concat(dataset.getColumnIdx('z'), ")}}"), "{{val(".concat(dataset.getColumnIdx('z'), ")}}")]);
        }

        if (repeat) {
          chartObj.seriesdata.forEach(function () {
            content.push(d3_values(y_val));
          });
        } else {
          content.push(d3_values(y_val));
        }
      } else {
        meta_tooltip.forEach(function (pattern, i) {
          if (defined(metadata_columns[pattern])) {
            pattern = ["{{col(".concat(pattern, ")}}"), "{{val(".concat(pattern, ")}}")];
          }
          curPattern = pattern;

          if ((isArray$1(pattern) || typeof pattern === 'string') && meta_yaxes.some(hasRepeatPattern)) {
            if (repeat) {
              chartObj.seriesdata.forEach(function () {
                content.push(isArray$1(pattern) ? d3_values(pattern) : pattern);
              });
            } else {
              content.push(pattern);
            }
          } else {
            content.push(pattern);
          }
        });
      }
      return content;
    };

    var tooltip_block_helpers = {};
    tooltip_block_helpers.MAXHEIGHT_BLOCK = '50%';
    tooltip_block_helpers.updatePlotarea4BlockTooltip = function (chartObj) {
      var tooltipConfig = chartObj.systemConf.tooltip,
        blockConfig = tooltipConfig.block || {},
        tooltipPosition = tooltipConfig.position || 'relative';

      if (tooltipConfig.enabled && tooltipPosition === 'block') {
        if (isUndefined(tooltipConfig.height) && !tooltipConfig.content) {
          var tooltipObj = events.tooltip(chartObj.tooltip.element, chartObj.systemConf, chartObj);
          tooltipObj.initialize();
          chartObj.tooltip.element.selectAll('div#tooltipcontent').html(tooltip_content.getContentTemplate(chartObj, NULL$1, NULL$1, true));
          chartObj.tooltip.preCalculatedHeight = chartObj.tooltip.element.node().clientHeight;
        } else {
          chartObj.tooltip.preCalculatedHeight = '20%';
        }

        var plotarea = chartObj.plotarea;
        chartObj.tooltip.blockarea = simpleClone(plotarea);
        var vAlign = blockConfig.vAlign || TOP_ALIGN,
          borderWidth = pick(tooltipConfig.borderWidth, 1),
          parsedBorderWidth = parseShortHandValue(borderWidth),
          borderWidthTop = parsedBorderWidth.top,
          borderWidthRight = parsedBorderWidth.right,
          borderWidthBottom = parsedBorderWidth.bottom,
          borderWidthLeft = parsedBorderWidth.left,
          chartarea = chartObj.chartarea,
          availableWidth = chartarea.width - borderWidthLeft - borderWidthRight,
          availableHeight = chartarea.height,
          dim = tooltip_helpers.getSize(tooltipConfig, [availableWidth, availableHeight], ['100%', chartObj.tooltip.preCalculatedHeight]),
          h = mathMin(dim.h, perToPx(tooltip_block_helpers.MAXHEIGHT_BLOCK, availableHeight)) + borderWidthTop + borderWidthBottom;

        if (vAlign === CENTER_ALIGN) {
          //#ZC1071
          vAlign = TOP_ALIGN;
        }

        plotarea.height -= h;
        plotarea[vAlign] += h;
      }
    };

    //data-processor-polyfill.js

    function addProcessorPolyfills(processor) {
      var proto = processor.prototype;

      // Available polyfills
      var polyfills = {
        getAxisRotated: function getAxisRotated() {
          return _getAxisRotated(this.data);
        },
        isstacked: function isstacked() {
          return false;
        }
      };

      // Apply polyfills if method not present
      for (var method in polyfills) {
        if (!proto[method]) {
          proto[method] = polyfills[method];
        }
      }
    }

    var MARKER_COMPONENT = 'zc-marker';

    function tooltip_c(mouse, selectionManager) {
      var point = selectionManager.nearest || selectionManager.selectionSet[0]; //For sharedseries hovering out of the plotarea, 'nearest' will return null, hence considering selectionSet also
      initTooltip(this.chart);
      var tooltip = this.chart.eventHandler.tooltipElement,
        tooltipEnabled = this.chart.systemConf.tooltip.enabled === true,
        tooltipShared = tooltip_helpers.hasSharedSeries(this.chart);
      var type = this.chart.eventHandler.getPointType(point),
        datatype = this.chart.dataset.getDataType('x'),
        containsBarchart = this.chart.dataObject.noofBarEnabledSeries > 0,
        tooltipShared = tooltip_helpers.hasSharedSeries(this.chart),
        isOrdinal = datatype === ORDINAL_DATATYPE && (containsBarchart || tooltipShared);
      if (tooltipEnabled && type == 'series') {
        var tooltipPos = getTooltipPosition(
        getEventObject(this.chart.eventHandler.targetEvent),
        mouse,
        point._x,
        point._y,
        this.chart,
        point,
        this.chart.eventHandler.rotated,
        tooltipShared,
        this.chart.eventHandler.tooltipSharedInfo,
        isOrdinal,
        this.chart.eventHandler.isPolarAxisCategory,
        isMultiPieChartType(getChartTypeByIndex(this.chart, point.paneid, point.seriesIndex).value) &&
        this.chart.subrenderer[point.subSeriesIndex][bubblepieUtils.getKey(point, point.seriesIndex, this.chart)].fillColorFunc);

        if (!tooltipPos.helpers.d.paneid) {
          tooltipPos.helpers.d.paneid = point.paneid;
        }
        tooltipPos.helpers.nearest = selectionManager.nearest;
        tooltip.show(this.chart, tooltipPos, null, true, tooltipPos.helpers);
      } else if (tooltipEnabled && this.chart.isGeoMap) {
        this.chart.eventHandler.mapEvents.showTooltip(mouse, point.point, this.chart.eventHandler.targetEvent, point);
      } else if (tooltipEnabled && (point.type == 'marker' || point.type == 'levelMarker')) {
        var tooltipPosition = getTooltipPosition(
          getEventObject(this.chart.eventHandler.targetEvent),
          mouse,
          0,
          0,
          this.chart,
          point,
          this.chart.eventHandler.rotated,
          tooltipShared,
          {},
          true,
          false,
          false),

          text = this.chart.eventHandler.bulletEvents.getTooltipContent(point, 0);
        tooltipPosition.helpers.inheritColors = true;
        tooltipPosition.helpers.itemIndex = point.sortedItemIndex;
        tooltipPosition.helpers.seriesIndex = point.sortedItemIndex;
        tooltipPosition.helpers.chartType = point.chartType;
        tooltip.show(this.chart, tooltipPosition, text, false, tooltipPosition.helpers);
      } else if (point.type == MARKER_COMPONENT) {
        var tooltipPos = getTooltipPosition(
        getEventObject(this.chart.eventHandler.targetEvent),
        mouse,
        point._x,
        point._y,
        this.chart,
        point,
        this.chart.eventHandler.rotated,
        tooltipShared,
        this.chart.eventHandler.tooltipSharedInfo,
        isOrdinal,
        false,
        null);

        var _tooltipContent = isObjectPropDefined(this.chart.cache, "parser.".concat([point.__key], ".parser.event.tooltipContent"), true); // TODO: enhance
        var tooltipContent = invokeFunction(_tooltipContent, point, point.itemIndex, this.chart);
        tooltip.show(this.chart, tooltipPos, tooltipContent, true, tooltipPos.helpers);
      }
    }
    function initTooltip(chart) {
      if (!chart.eventHandler.tooltipElement) {
        chart.eventHandler.tooltipElement = events.tooltip(chart.tooltip.element, chart.systemConf, chart);
        chart.eventHandler.tooltipElement.initialize();
        var tooltip = chart.eventHandler.tooltipElement;

        chart.eventHandler.addListeners(chart.eventHandler.tooltipElement.element, 'tooltip');

        // click able tooltip
        if (chart.systemConf.tooltip.pointerEvents === 'auto') {
          tooltip.element.on('mouseenter', function () {
            chart.eventHandler.mouseOnTooltip = true;
          });

          tooltip.element.on('mouseleave', function () {
            chart.eventHandler.mouseOnTooltip = false;
            var handlers = chart.eventHandler.handlers;
            handlers.mouseout.call(this);
          });
        }

        var scrollEventName =
        'onwheel' in document.createElement('div') ? 'wheel' : document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
        var parentNode = chart.container.node(),
          lastPosition = null;
        chart.d3container.on(scrollEventName, function () {
          var currentPosition = parentNode.getBoundingClientRect();
          if (lastPosition) {
            if (lastPosition.left !== currentPosition.left || lastPosition.top !== currentPosition.top) {
              tooltip.hide(tooltip.element);
            }
          }
          lastPosition = currentPosition;
        });
      }
    }

    function updateTooltip(chart) {
      chart.eventHandler.tooltipElement = events.tooltip(chart.tooltip.element, chart.systemConf, chart);
      chart.eventHandler.tooltipElement.initialize();
    }

    function checkMouseInTooltip(targetEle, relatedTargetEle, tooltipObj) {
      var tooltipEle = tooltipObj.element;
      if (
      relatedTargetEle != NULL$1 &&
      tooltipObj !== NULL$1 && (
      targetEle == tooltipEle.node() ||
      targetEle == tooltipEle.selectAll('div#tooltipcontent').node() ||
      targetEle == tooltipEle.selectAll('div#zctooltipafter').node() ||
      targetEle == tooltipEle.selectAll('div#zctooltipbefore').node() ||
      relatedTargetEle == tooltipEle.node() ||
      relatedTargetEle == tooltipEle.selectAll('div#tooltipcontent').node() ||
      relatedTargetEle == tooltipEle.selectAll('div#zctooltipafter').node() ||
      relatedTargetEle == tooltipEle.selectAll('div#zctooltipbefore').node()))
      {
        return true;
      }

      return false;
    }

    Registry.setComponent('events.controllers.tooltip', tooltip_c);

    function addClipToTracker(chart) {
      var clipID;
      if (isFacet(chart)) {
        var desc = '',
          gridList = getGridList(chart.dataObject);

        gridList.forEach(function (grid) {
          var bound = renderer_helpers.getBound(chart, grid.data[0]),
            x = bound.x,y = bound.y,width = bound.width,height = bound.height,polar = bound.polar,
            chartType = chart.dataObject.hierarchical.gridOptions["".concat(grid.row, "_").concat(grid.column)].chartTypes[0].value;

          if (isCategoryOf(chart, chartType, 'polarAxis')) {
            var r = polar.radius;
            x += polar.x;
            y += polar.y;

            desc += "M".concat(x - r, " ").concat(y, " A").concat(r, " ").concat(r, " 0 0 1 ").concat(x + r, " ").concat(y, " A").concat(r, " ").concat(r, " 0 0 1 ").concat(x - r, " ").concat(y, " ");
          } else if (arrayIncludes(chartcategory.singleSourceEvent, chartType)) {
            desc += "M".concat(x, " ").concat(y, " L").concat(x + width, " ").concat(y, " L").concat(x + width, " ").concat(y + height, " L").concat(x, " ").concat(y + height, " Z ");
          }
        });

        var properties = { d: desc, name: 'pivotpolarClip', id: chart.id };

        clipID = effects.get(effects.svg_clips, 'polygon', properties, { chartObj: chart });
      } else if (isCategoryOf(chart, null, 'polarAxis')) {
        var plotarea_approx = chart.plotarea_approx,
          properties = {
            name: 'polarClip',
            id: chart.id,
            // #ZC2280
            cx: plotarea_approx.x,
            cy: plotarea_approx.y,
            r: mathMax(0, plotarea_approx.radius)
          },
          args = {
            chartObj: chart
          };

        clipID = effects.get(effects.svg_clips, CIRCLE_ELEMENT, properties, args);
      }

      chart.eventHandler.trackerElement.attr('clip-path', clipID ? "url(".concat(chart.defsLocation, "#").concat(clipID, ")") : null);

      if (!window.PointerEvent && chart.plot.renderer.mode === 'canvas') {
        //ZC1533 pointer-events: none is not working in ie9, ie10
        pointerEventsNonePolyfill(chart.container.selectAll('canvas.zc-labelholder-canvas,canvas.highlight-canvas,canvas.zc-canvas'));
      }
    }var

    BehaviouralEventManager = /*#__PURE__*/function () {
      function BehaviouralEventManager(chart) {_classCallCheck(this, BehaviouralEventManager);
        this.chart = chart;
        this.behaviours = {};
      }

      /**
       *
       * @param name
       * @param behaviour
       * @return {*}
       */_createClass(BehaviouralEventManager, [{ key: "getBehaviouralEventInstance", value:
        function getBehaviouralEventInstance(name, behaviour) {
          var manager = this,
            instanceHolder;

          if (behaviour) {
            var behaviourClassConstructor = Registry.getComponent(behaviour._constructor),
              args = Registry.getComponent(behaviour._arguments);

            instanceHolder = manager.behaviours[name] || {};
            instanceHolder.instance = new behaviourClassConstructor(args(manager.chart));
            manager.behaviours[name] = instanceHolder;
            return instanceHolder;
          }
        } }, { key: "dataFinder", value:

        function dataFinder(behaviourInstance, finderMap) {
          behaviourInstance.dataFinder = finderMap;
        } }, { key: "setListenerTypes", value:

        function setListenerTypes(behaviourInstance, listenerTypes) {
          behaviourInstance.listenerTypes = listenerTypes;
        } }, { key: "getData", value:

        function getData(behaviourInstance, eventType, mousePos) {
          var manager = this,
            finder = behaviourInstance.dataFinder,
            selectionManager = { point: null };

          if (finder[eventType]) {
            selectionManager.point = finder[eventType].apply(manager, [behaviourInstance, eventType, mousePos]);
          }
          return selectionManager;
        } }, { key: "attachListeners", value:

        function attachListeners(behaviourInstance, listeners) {
          var manager = this;
          var listenerTypes = behaviourInstance.listenerTypes,
            instance = behaviourInstance.instance;

          each(listeners, function (listeners, type) {
            if (listenerTypes.has(type)) {
              splat(listeners).forEach(function (listener) {
                instance.on(type, function () {
                  listener.apply(manager, [behaviourInstance].concat(Array.prototype.slice.call(arguments)));
                });
              });
            }
          });
        }

        /**
         *
         * @param behaviourEvent
         * @param type
         * @return {[]}
         */ }, { key: "getBehaviours", value:
        function getBehaviours(behaviourEvent, type) {
          var behaviours = [],
            defaultBehaviours = behaviourEvent.defaultBehaviour[type],
            customBehaviours = behaviourEvent.customBehaviour && behaviourEvent.customBehaviour[type];

          if (customBehaviours) {
            behaviours = _toConsumableArray(splat(customBehaviours).map(function (b0) {return { type: 'custom', behaviour: b0 };}));
          }

          if (defaultBehaviours) {
            behaviours = [].concat(_toConsumableArray(behaviours), _toConsumableArray(splat(defaultBehaviours).map(function (b0) {return { type: 'default', behaviour: b0 };})));
          }

          return behaviours;
        }

        /**
         *
         * @param behaviourEvent
         * @param listeners
         * @param type
         * @param event
         */ }, { key: "setBehaviours", value:
        function setBehaviours(behaviourEvent, listeners) {var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';var event = arguments.length > 3 ? arguments[3] : undefined;
          behaviourEvent["".concat(type, "Behaviour")] = listeners;
        } }, { key: "associateBehaviours", value:

        function associateBehaviours(behaviourEvent, type, point, mouse, event) {
          var manager = this,
            behaviours = manager.getBehaviours(behaviourEvent, type),
            allowDefault = true;

          if (isArray$1(behaviours) && behaviours.length) {
            behaviours.forEach(function (b) {
              if (b.type === 'custom') {
                invokeFunction(true, b.behaviour, manager, behaviourEvent, point, mouse, event);
                allowDefault = event.allowDefault;
              } else if (allowDefault) {
                b.behaviour.apply(manager, [behaviourEvent, point, mouse, event]);
              }
            });
          }
        } }, { key: "detachListeners", value:

        function detachListeners() {} }]);return BehaviouralEventManager;}();


    /**
     *
     * @param chart
     * @constructor
     */

    function ZCChartScroll(chart) {
      return chart.scroll;
    }

    function ZCChartScrollArguments(chart) {
      return chart;
    }

    Registry.setComponent('ZCChartScroll', ZCChartScroll);
    Registry.setComponent('ZCChartScrollArguments', ZCChartScrollArguments);

    var CHART_BEHAVIOURAL_EVENT_MAPPINGS = {
      PLOT_ZOOM: {
        _property: 'chart.zoom',
        _feature_name: 'zoom',
        _handlers: function _handlers(chart) {return chart.isGeoMap ? '_mapZoomHandlers' : '_chartZoomHandlers';},
        _behavior: {
          _constructor: 'ZoomD3',
          _arguments: '_getPlotZoomArguments'
        }
      },
      PLOT_BRUSH: {
        _property: 'chart.brush',
        _feature_name: 'brush',
        _handlers: function _handlers(chart) {return chart.isGeoMap ? '_mapBrushHandlers' : '_chartBrushHandlers';},
        _behavior: {
          _constructor: 'BrushD3',
          _arguments: '_getPlotBrushArguments'
        }
      },
      CHART_SCROLL: {
        _property: 'chart.scroll',
        _feature_name: 'scroll',
        _handlers: '_chartScrollHandlers',
        _behavior: {
          _constructor: 'ZCChartScroll',
          _arguments: 'ZCChartScrollArguments'
        }
      }
    };

    var LEGEND_BEHAVIOURAL_EVENT_MAPPINGS = {
      LEGEND_SIZE_SLIDER_BRUSH: {
        _property: 'legend.size',
        _feature_name: 'brush',
        _handlers: '_legendSizeSliderBrushHandlers',
        _id: 'z-0',
        _behavior: {
          _constructor: 'BrushD3',
          _arguments: '_getLegendSizeSliderBrushArguments'
        }
      },
      LEGEND_COLOR_BAND_BRUSH: {
        _property: 'legend',
        _feature_name: 'brush',
        _handlers: '_legendColorBandBrushHandlers',
        _id: 'clr-0',
        _behavior: {
          _constructor: 'BrushD3',
          _arguments: '_getLegendColorBandBrushArguments'
        }
      }
    };var

    BehaviouralEvents = /*#__PURE__*/function () {
      function BehaviouralEvents(chart) {_classCallCheck(this, BehaviouralEvents);
        this.chart = chart;
        this.eventManager = new BehaviouralEventManager(chart);
        this.init();
      }_createClass(BehaviouralEvents, [{ key: "init", value:

        function init() {var _this15 = this;
          var behaviourEvent = this,
            chart = behaviourEvent.chart,
            _initBehaviour = function _initBehaviour(behaviourMap, name, map) {
              behaviourEvent.initiateBehaviour(name, map);
            };

          each(CHART_BEHAVIOURAL_EVENT_MAPPINGS, _initBehaviour);
          each(LEGEND_BEHAVIOURAL_EVENT_MAPPINGS, _initBehaviour);

          each(this.eventManager.behaviours, function (behaviour) {
            if (behaviour && behaviour._init) {
              behaviour._init.call(_this15, behaviour);
            }
          });
        } }, { key: "update", value:

        function update() {var _this16 = this;
          each(this.eventManager.behaviours, function (behaviour) {
            //#ZC2320 $behaviour &&
            if (behaviour && behaviour._update) {
              behaviour._update.call(_this16, behaviour);
            }
          });
          this.init();
        } }, { key: "initiateBehaviour", value:

        function initiateBehaviour(name) {var map = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CHART_BEHAVIOURAL_EVENT_MAPPINGS;
          var manager = this.eventManager,
            chart = manager.chart,
            systemConfig = chart.systemConf,
            behaviourMap = map[name],
            rootObject = getPropVal(systemConfig, behaviourMap._property) || {},
            customBehaviours = rootObject.actions,
            handlers = Registry.getComponent(getVal(behaviourMap._handlers, [chart])),
            isSupported = defined(handlers) && handlers !== noOperation && handlers.SUPPORTED(chart, behaviourMap._id);

          if (isSupported && rootObject.enabled) {
            // TODO CLEANUP [renderVisiblePointsOnly]
            // if any behaviour is enabled, we render only the visible points
            // for default scroll we render all the points
            var isChartBehaviour = map === CHART_BEHAVIOURAL_EVENT_MAPPINGS;
            if (!defined(chart.systemConf.chart.width) && !chart.renderVisiblePointsOnly && isChartBehaviour) {
              chart.renderVisiblePointsOnly = rootObject.renderVisiblePointsOnly !== false;
            }

            // set the options
            setDefaultOptions(behaviourMap._feature_name, systemConfig.chart, chart.globalProp);

            var behaviouralInstance = manager.getBehaviouralEventInstance(name, getVal(behaviourMap._behavior, [chart]));

            // checking a key
            if (handlers.BEHAVIOUR) {
              behaviouralInstance._init = handlers.INIT;
              behaviouralInstance._update = handlers.UPDATE;
              // set listeners and behaviours
              // can be initialized directly
              manager.setBehaviours(behaviouralInstance, handlers.BEHAVIOUR);
              manager.dataFinder(behaviouralInstance, handlers.DATA_FINDER);
              manager.setListenerTypes(behaviouralInstance, handlers.LISTENER_TYPES);
              manager.attachListeners(behaviouralInstance, handlers.LISTENER);

              // set the custom behaviour if defined
              if (customBehaviours = rootObject.actions) {
                manager.setBehaviours(behaviouralInstance, customBehaviours, 'custom');
              }
            }
          } else if (defined(manager.behaviours[name])) {
            manager.behaviours[name].destroy && manager.behaviours[name].destroy();
            manager.behaviours[name] = null;
            delete manager.behaviours[name];
          }
        } }]);return BehaviouralEvents;}();


    Registry.setComponent('BehaviouralEvents', BehaviouralEvents);

    function getZoomBound(selection, type) {
      var bound = selection;

      if (type === 'x') {
        bound = [
        [selection[0], 0],
        [selection[1], 0]];

      } else if (type === 'y') {
        bound = [
        [0, selection[0]],
        [0, selection[1]]];

      }

      return bound;
    }

    /**
     *
     * @param behaviourEventInstance
     * @param selectionManager
     * @param selection
     * @constructor
     */
    function ApplyBrushSelectionOnPlot(behaviourEventInstance, selectionManager, selection) {
      var eventManager = this,
        behaviours = eventManager.behaviours,
        chart = eventManager.chart,
        brushInstance = behaviourEventInstance.instance,
        brushOptions = chart.systemConf.chart.brush,
        domainInfo = selectionManager.point,
        hasSmoothScroll = chart.scroll && chart.scroll.settings.smooth;

      if (!selection) {
        return;
      }

      if (behaviours.PLOT_ZOOM) {
        var bound = getZoomBound(selection, brushInstance.options.type),
          plotZoom = behaviours.PLOT_ZOOM.instance,
          transform = plotZoom.getTransform();

        plotZoom.zoomToBounds(bound.map(function (b0) {return transform.invert(b0);}));
      } else {
        // TODO plot brush with scroll smooth
        if (!hasSmoothScroll) {
          saveBrushPosition(domainInfo, brushOptions, chart);
        }
        CHART_DOMAIN_HELPERS.FILTER_CHART(domainInfo, chart);
      }

      // update the plot brush area with the plot area
      // because after applying brush the plot area might change.
      brushInstance.updateExtent([
      [0, 0],
      [chart.plotarea.width, chart.plotarea.height]]);

    }

    function saveBrushPosition(domainList, settings, chart) {
      each(domainList, function (list, type) {
        each(list, function (info, index) {
          if (info.domain) {
            // #ZC2016
            var axisInfo = getAxisObject(chart, type, index),
              key = "".concat(type, "[").concat(index, "]"),
              z = getPropVal(settings, key),
              domain = splat(info.domain);

            if (!defined(z)) {
              setPropVal(settings, key, z = {});
            }

            if (info.dataType === ORDINAL_DATATYPE) {
              z.categories = domain;
            } else {
              z.minRange = domain[0];
              z.maxRange = domain[1];
            }
            axisInfo.domain = info.domain || axisInfo.baseScale.domain();
          }
        });
      });
    }

    /**
     *
     * @param chart
     * @param domain
     * @param axisType
     * @param index
     * @param selection
     * @return {*}
     */
    function getIdentity(chart, domain, axisType) {var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var selection = arguments.length > 4 ? arguments[4] : undefined;
      var rotated = chart.axes.rotated,
        brushedRange = selection || domainToActualRange(chart, domain, index, axisType);

      var dirType = {
        x: rotated ? 'y' : 'x',
        y: rotated ? 'x' : 'y'
      };

      var brushSize = brushedRange[1] - brushedRange[0],
        side = dirType[axisType] === 'x' ? 'width' : 'height',
        zoomScale = chart.plotarea[side] / brushSize,
        x = 0,
        y = 0;

      if (side === 'height') {
        y = -brushedRange[0];
      } else {
        x = -brushedRange[0];
      }

      return d3_zoomIdentity.scale(zoomScale).translate(x, y);
    }

    /**
     *
     * @param chart
     * @param domain
     * @param index
     * @param axisType
     * @param fixPadding
     * @param useBaseScale
     * @param scale0
     * @return {(number|*)[]}
     */
    function domainToActualRange(chart, domain, index, axisType, fixPadding) {var useBaseScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;var scale0 = arguments.length > 6 ? arguments[6] : undefined;
      domain = [domain[0], domain[domain.length - 1]];
      var axisObj = getAxisObject(chart, axisType, index) || {},
        scale = axisObj.scale,baseScale = axisObj.baseScale,
        range;

      scale = pick(scale0, useBaseScale ? baseScale : scale);
      range = domain.map(scale).sort(d3_ascending);

      if (scale.bandwidth) {
        // #ZC2251 $scale0
        range = fixBandRange(scale, scale0 || baseScale || scale, range, fixPadding, chart.axes.rotated);
      }

      return range;
    }

    /**
     *
     * @param scale
     * @param baseScale
     * @param plannerRange
     * @param fixPadding
     * @param rotated
     * @return {(number|*)[]}
     */
    function fixBandRange(scale, baseScale, plannerRange) {var fixPadding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;var rotated = arguments.length > 4 ? arguments[4] : undefined;
      var ordinalRange = getOrdinalRange(baseScale).
        slice(0).
        sort(d3_ascending),
        innerPadding = (ordinalRange[1] - ordinalRange[0] - baseScale.bandwidth()) / 2,
        outerPadding = scale.outerPaddingPx;

      if (fixPadding === false) {
        innerPadding = outerPadding = 0;
      }

      var size = baseScale.bandwidth(),
        start = ordinalRange[0] === plannerRange[0] ? plannerRange[0] - outerPadding : plannerRange[0] - innerPadding,
        end =
        ordinalRange[ordinalRange.length - 1] === plannerRange[1] ?
        plannerRange[1] + size + outerPadding :
        plannerRange[1] + size + innerPadding;

      return [start, end];
    }

    /**
     *
     * @param eventManager
     * @param domain
     * @param type
     * @param seriesIndex
     * @param scale
     * @param transition
     * @private
     */
    function _ZoomToDomain(eventManager, domain, type, seriesIndex, scale, transition) {
      var chart = eventManager.chart,
        plotZoom = eventManager.behaviours.PLOT_ZOOM,
        bound,
        range = type.split('').map(function (axisType, i) {
          return domainToActualRange(chart, isArray$1(domain[0]) ? domain[i] : domain, seriesIndex, axisType);
        });

      if (type !== 'xy') {
        range = range[0];
      }

      bound = getZoomBound(range, fixBrushDirection(type, chart.axes.rotated));
      plotZoom.instance.zoomToBounds(bound, scale, transition);
    }

    /**
     *
     * @param eventManager
     * @param domain
     * @param type
     * @param seriesIndex
     * @param scale
     * @param transition
     * @private
     */
    function _BrushToDomain(eventManager, domain, type, seriesIndex, scale, transition) {
      var chart = eventManager.chart,
        plotBrush = eventManager.behaviours.PLOT_BRUSH,
        plotZoom = eventManager.behaviours.PLOT_ZOOM,
        range = type.split('').map(function (axisType, i) {
          return domainToActualRange(chart, isArray$1(domain[0]) ? domain[i] : domain, seriesIndex, axisType, defined(plotZoom), false);
        });

      if (type === 'xy') {
        // range to selection
        range = [[range[0][0], range[1][0]], [range[0][1], range[1][1]]];
      } else {
        range = range[0];
      }

      plotBrush.instance.setSelection(range);
    }

    function updateScaleForPivot(chart, row, column) {
      var updateRows = pick(row, true),
        updateColumns = pick(column, true);
      //update rows, columns scale

      var rotated = chart.axes.rotated,
        dataObject = chart.dataObject,plotarea = chart.plotarea,systemConf = chart.systemConf,axes = chart.axes,dataset = chart.dataset;
      //update leafSize
      var defaultRefDim_row = axes.rotated ? 'width' : 'height',
        customDim_row =
        systemConf.chart[defaultRefDim_row] == 'auto' ? null : systemConf.chart[defaultRefDim_row] || plotarea[defaultRefDim_row],
        defaultRefDim_col = axes.rotated ? 'height' : 'width',
        customDim_col =
        systemConf.chart[defaultRefDim_col] == 'auto' ? null : systemConf.chart[defaultRefDim_col] || plotarea[defaultRefDim_col];
      dataObject.hierarchical.pivotLayout.leafSize(customDim_row, customDim_col);

      //update row scale
      if (updateRows) {
        scale.setRowScale(chart, 'row', true);
      }

      //update column scale
      if (updateColumns) {
        chart.axes.x.scale = scale.getScale(chart, dataObject, plotarea, axes.x.orient, 0, dataset, 'x', chart.viewPortExtent);
        scale.setColumnScale(chart, 'column');
      }
    }

    //stack-helpers.js

    /**
     * TODO: revamp
     * Non Bar charts: adds dummy data and order series
     * @param  {Array} data      [description]
     * @param  {Object} dataset   [description]
     * @param  {Object} processor [description]
     */
    function prepareStackData(data, dataset, processor) {
      var helpers = DataProcessor.helpers,
        isCatNullX = helpers.isCatNull(dataset, 'x'),
        xCategories,
        xCategoriesLength;

      data.forEach(function (series, seriesIndex) {
        var chartType = helpers.getChartType(null, NUMERIC_DATATYPE, seriesIndex, processor.data),
          isStkd = processor.isstacked(chartType) || processor.isPercentChart;

        if (isStkd && !isBarChartType(chartType)) {
          var xMappingFunction = function xMappingFunction(d) {return dataset.getX(d);};

          var columnList, splitLeavesColumn;
          if (processor.categoryHierarchy) {
            columnList = processor.hierarchical.pivotLayout.getRootNodeList('column');
            splitLeavesColumn = columnList.splitColumnLeaves;
            var uniformLeafScale = processor.chartObj.systemConf.chart.axes.xaxis.uniformLeafScale;
            xCategories = uniformLeafScale ?
            columnList.getUniqueDomainForCluster(0) :
            columnList.getDomainForClusterSet(0, series.column);
            if (columnList.count && !splitLeavesColumn) {
              xMappingFunction = function xMappingFunction(d) {return dataset.getActualX(d);};
            }
          }

          if (!xCategories) {
            xCategories = processor.getDomain(processor.getCategories('x'), 'x', true); // Fixed #ZC1179
            if (processor.pivot) {
              xCategories = columnList.getUniqueDomainForCluster(0);
            }
            xCategoriesLength = xCategories.length;
          }

          series.data.forEach(function (d) {
            var currentkeys = d.map(xMappingFunction);
            for (var idx = 0, len = xCategoriesLength; idx < len; idx++) {
              var key = xCategories[idx];
              var haveKey = currentkeys.indexOf(key);
              //aaranging order of data as per x order;
              if (haveKey >= 0 && haveKey != idx) {
                d.splice(idx, 0, d[haveKey]); //copying , Moving unordererd data to correct position i
                d.splice(haveKey + 1, 1); // removing the copied data from old position havekey
                currentkeys = d.map(xMappingFunction); // Rearranging the currentkeys
              }
              if (_typeof(currentkeys[idx]) != UNDEFINED && isCatNullX(currentkeys[idx])) {
                d.splice(idx, 1);
              }
              if (haveKey < 0) {
                var duplicate = [];
                var order = helpers.getParsedYAxisOrder(series.yaxiscolumnorder);
                duplicate.splice(dataset.xidx, 0, key);
                duplicate.splice(dataset.yidx(order), 0, 0); //dummy data add as 0
                duplicate.isDummy = true;
                // to remove stacked area with dummy data added
                duplicate.isPrevDummy = idx == 0 ? true : d[idx - 1].isDummy;
                if (idx == len - 1) {
                  duplicate.isNextDummy = true;
                } else if (idx != 0) {
                  d[idx - 1].isNextDummy = true;
                }

                d.splice(idx, 0, duplicate);
                currentkeys = d.map(xMappingFunction); // Rearranging the currentkeys
              } else {
                d.isDummy = false;
              }
            }

            // If the series has duplicate x values, just remove that. Test_586.json, Test_587.json
            if (xCategoriesLength != d.length) {
              d.splice(xCategoriesLength, d.length - xCategoriesLength);
            }
          });
        }
      });
    }

    function AddDataToStackLayout(data, dataset, processor) {
      var helpers = DataProcessor.helpers,
        hasSplitLeaves = processor.pivot ? processor.hierarchical.pivotLayout.columns.splitColumnLeaves : false;
      data.forEach(function (seriesData, index) {
        var seriesIndex = processor.pivot ? seriesData.row + seriesData.column + index : index,
          seriesAssist = processor.seriesAssist[seriesIndex];

        if (!seriesData.disabled && arrayIncludes(seriesAssist.layout || [], 'stack')) {
          var stackIndex = processor.pivot ? "".concat(seriesData.row, "_").concat(seriesData.column) : seriesAssist.stackIndex,
            stackTransform = processor.getEncode('stack', stackIndex),
            layout = stackTransform.layout,
            curdata = seriesData.data,
            yaxiscolumnorder = helpers.getParsedYAxisOrder(seriesData.yaxiscolumnorder),
            data = d3_merge(curdata), //TODO: merge is not needed if subseries support is removed
            valueAccessor = function valueAccessor(d) {return dataset.getY(d, yaxiscolumnorder);},
            keyAccessor = function keyAccessor(d) {return dataset.getX(d);};

          //ZC1931, ZC1932
          var chartType = helpers.getChartType(null, NUMERIC_DATATYPE, seriesIndex, processor.data);
          if (isBarChartType(chartType)) {
            // stack bar chart
            // #ZC2315 @param getCategories(0, false)

            var xCategories = processor.getCategories('x', 0, false),
              xDomainValues = hasSplitLeaves ? xCategories : processor.getDomain(xCategories, 'x', true); // Fixed #ZC1179
            data = processor.updateSeriesdatabyCategories(data, xDomainValues); //TODO: IMPORTANT updateSeriesdatabyCategories should be done on the data processor init only once. now every renderer has this function
          }

          layout.add(data, keyAccessor, valueAccessor);
        }
      });
      var stackSortAccessor = processor.isStackedSort();
      if (stackSortAccessor) {
        var stackEncodes = processor.getEncode('stack'),
          keys = objectValues(stackEncodes);

        var valueAccessor = function valueAccessor(d) {return dataset.getY(d, 0);},
          keyAccessor = function keyAccessor(d) {return dataset.getX(d);};
        keys.map(function (d) {
          var stackLayout = d.layout;
          stackLayout.sort(keyAccessor, valueAccessor, stackSortAccessor);
        });
      }
    }

    function saveStackInfo(processor, curdata, i, stackIndex, chartType_num) {
      var groupedByStack = processor.groupedByStack,
        obj = {
          si: i,
          d: curdata
        };

      if (isBarChartType(chartType_num)) {
        if (!groupedByStack.has(stackIndex)) {
          groupedByStack.set(stackIndex, [obj]);
        } else {
          var lastData = groupedByStack.get(stackIndex);
          groupedByStack.set(stackIndex, lastData.concat([obj]));
        }
        groupedByStack.get(stackIndex).stackLabelIndex = obj.si;
      }
    }

    function convertToStackPercent(stackedData, dataset) {
      each(stackedData, function (datum, stackIndex) {
        var seriesData = datum.seriesData,
          stackLayout = datum.layout;

        seriesData.map(function (series) {
          var data = d3_merge(series.data), //TODO: merge is not needed if subseries support is removed
            keyAccessor = function keyAccessor(d) {return dataset.getX(d);};

          stackLayout.toPercent(data, keyAccessor);
        });
      });
    }

    function removeDummyData(series) {
      var removalElePos = new Array(0);
      series.data[0].map(function (d, i) {
        if (d.isDummy) {
          removalElePos.push(i);
        }
        d.isDummy = false;
        d.isPrevDummy = false;
        d.isNextDummy = false;
      });

      for (var k = removalElePos.length - 1; k >= 0; k--) {
        series.data[0].splice(removalElePos[k], 1);
      }
      return series;
    }

    //$Id$

    var ReverseLegendHighlight = function ReverseLegendHighlight(chartObj, options) {
      var element = chartObj.legendarea.element,
        legendSeries = element && element.selectAll('.legseries').node();

      this.chartObj = chartObj;
      this.legendSeries = legendSeries;
      this.legendElements = legendSeries ? legendSeries.children : [];
      this.itemHighlighted = false;
      this.hoveredSeriesIndex = NULL$1;
      this.hoveredlegendOrder = NULL$1;
      this.previousHoveredSeriesIndex = NULL$1;
      this.legend_series_height = NULL$1;
      this.legendScrollable = NULL$1;
      this.legendComponents = initComponents(chartObj.legends);

      if (legendSeries) {
        this.legend_series_height = legendSeries.clientHeight;
        this.legendScrollable = legendSeries.scrollHeight > this.legend_series_height;
      }
    };

    ReverseLegendHighlight.prototype.highlight = function (options) {
      var chartObj = this.chartObj;

      // Size legend highlight ---
      each(this.legendComponents, function (comp, id) {
        var reverseEventManager = chartObj.legendEvents.reverseEventManager,
          reverseManager = reverseEventManager[getManagerID(chartObj, id)],
          legend = chartObj.legends.get(id);

        if (!reverseManager || isEmptyObject(reverseManager)) {
          // TODO: remove reverseManager != null
          return;
        }

        var encode = legend.meta.encode,
          hoverOptions = getHoverOptions(reverseManager.options.config, encode, false);
        if (!hoverOptions.showOnDataHover || !options) {
          // options = null for sharedSeriesInfo
          return;
        }

        var dt =
          chartObj.isGeoMap && options.type ?
          options.point :
          encode === 'clr' ?
          options.data && options.data.data || options.data || options // TODO: check
          : options,
          previousHighlightedData = comp.data,
          highlightedData = reverseManager.getData('mousemove', dt);
        reverseManager.targetEvent = d3_event();

        if (previousHighlightedData && jsonStringify(highlightedData.point) !== jsonStringify(previousHighlightedData.point)) {
          reverseManager.associateBehaviours('mouseout', previousHighlightedData);
        }

        if (!hasEncode(encode, chartObj, options)) {
          return;
        }

        reverseManager.associateBehaviours('mousemove', highlightedData);

        comp.data = _objectSpread({}, highlightedData);
        comp.highlighted = true;
      });

      // --- Size legend highlight

      if (legend_helpers.isContinousLegend(chartObj)) {
        return;
      }

      var previousHoveredSeriesIndex = this.previousHoveredSeriesIndex,
        legendOptions = chartObj.systemConf.legend,
        hoverOptions = getHoverOptions(legendOptions, 'clr', false),
        legendComponent = chartObj.legend.component,
        commonRendererProp = options ? chartObj.renderer[options.rendererIndex || 0].commonRendererProp() : NULL$1;

      // get proper legend component based on legend order
      if (chartObj.dataObject.pivot && options) {
        var legendOrder = commonRendererProp.legendOrder();
        this.hoveredlegendOrder = legendOrder;
        legendComponent = chartObj.legends[legendOrder].component.encode;
      }

      if (!legendComponent) {
        return;
      }

      if (
      hoverOptions &&
      hoverOptions.showOnDataHover &&
      !(legend_helpers.isContinousLegend(chartObj) && (!hoverOptions.type || hoverOptions.type === NONE)))
      {
        var oldInfo = chartObj.eventHandler.eventManager.selectionManager,
          highlightItem = legendComponent.highlightItem;
        if (
        !(
        chartObj.isAxisCategory ||
        chartObj.dataObject.isPolarAxisCategory ||
        chartObj.isGeoMap ||
        chartObj.dataObject.isFlowChartCategory) ||

        oldInfo && oldInfo.nearest)
        {
          var hoveredData, seriesIndex, itemIndex;
          if (
          chartObj.isAxisCategory ||
          chartObj.dataObject.isPolarAxisCategory ||
          chartObj.isGeoMap ||
          chartObj.dataObject.isFlowChartCategory)
          {
            hoveredData = chartObj.isGeoMap && options.type ? options.point : options;
            seriesIndex = options.seriesIndex;
            itemIndex = options.itemIndex;
            if (chartObj.dataObject.pivot && options && hoveredData.type != 'threshold-marker') {
              seriesIndex = commonRendererProp.legendIndex(); //proper series index for pivot chart with multi cluster rows
            }
          } else {
            hoveredData = options.data ? options.data.data || options.data : options;
            seriesIndex = options.seriesIndex;
            itemIndex = options.itemIndex;
            if (chartObj.dataObject.pivot && options) {
              if (chartObj.dataObject.isHierarchy) {
                var gridOptions = chartObj.dataObject.hierarchical.gridOptions;
                seriesIndex = gridOptions[options.paneid || '0_0'].legendIndices[options.seriesIndex || 0];
              } else {
                seriesIndex = commonRendererProp.legendIndex();
              }
            }
          }
          //#ZC1565
          var hoveredSeriesIndex = this.hoveredSeriesIndex = this.getLegendIndex(
          hoveredData,
          chartObj.isAxisCategory ||
          chartObj.dataObject.isPolarAxisCategory ||
          chartObj.isNonAxisMultiSeriesCategory ||
          chartObj.isGeoMap ?
          seriesIndex :
          itemIndex);


          if (legend_helpers.isContinousLegend(chartObj)) {
            var clrValue = chartObj.dataset.getClr(hoveredData),
              userRanges = legendOptions.colorBand.ranges,
              brushScale = chartObj.axes.clr.brushScale,
              pos;

            if (userRanges && userRanges.length) {
              pos = brushScale(userRanges[hoveredSeriesIndex]) + brushScale.bandwidth() / 2;
            } else {
              pos = brushScale(clrValue);
            }

            highlightItem(pos, true, NULL$1, userRanges && userRanges.length ? hoveredSeriesIndex : [clrValue]);
            this.itemHighlighted = true;
          } else {
            var legendElements = this.legendElements;
            if (legendElements[hoveredSeriesIndex]) {
              var legendData = legend_helpers.getLegendData(chartObj);

              if (hoveredSeriesIndex !== previousHoveredSeriesIndex && previousHoveredSeriesIndex != null) {
                highlightItem(
                legendElements[previousHoveredSeriesIndex],
                legendData[previousHoveredSeriesIndex],
                previousHoveredSeriesIndex,
                legendOptions);

              }

              highlightItem(
              legendElements[hoveredSeriesIndex],
              legendData[hoveredSeriesIndex],
              hoveredSeriesIndex,
              legendOptions,
              true);

              this.itemHighlighted = true;

              // scroll into view;
              if (this.legendScrollable && !(chartObj.systemConf.legend.expandable && chartObj.systemConf.legend.expandable.show)) {
                this.legendSeries.scrollTop = legendElements[hoveredSeriesIndex].offsetTop - this.legend_series_height / 2;
              }
            }
          }
          this.previousHoveredSeriesIndex = hoveredSeriesIndex;
        }
      }
    };

    ReverseLegendHighlight.prototype.reset = function () {
      var chartObj = this.chartObj;

      // Size legend reset ---
      each(this.legendComponents, function (comp, id) {
        if (comp.highlighted) {
          var reverseEventManager = chartObj.legendEvents.reverseEventManager,
            previousHighlightedData = comp.data,
            reverseManager = reverseEventManager[getManagerID(chartObj, id)];

          if (!reverseManager || isEmptyObject(reverseManager)) {
            return;
          }

          reverseManager.targetEvent = d3_event();
          reverseManager.associateBehaviours('mouseout', previousHighlightedData);
          comp.data = null;
          comp.highlighted = false;
        }
      });

      // --- Size legend reset

      if (legend_helpers.isContinousLegend(chartObj)) {
        return;
      }

      if (this.itemHighlighted) {
        var legendElements = this.legendElements,
          hoveredSeriesIndex = this.hoveredSeriesIndex,
          legendComponent = chartObj.legend.component;

        if (chartObj.dataObject.pivot) {
          legendComponent = chartObj.legends[this.hoveredlegendOrder || 0].component.encode;
        }

        if (!legendComponent) {
          return;
        }

        var highlightItem = legendComponent.highlightItem;

        if (legend_helpers.isContinousLegend(chartObj)) {
          highlightItem(NULL$1, false);
        } else if (defined(legendElements[hoveredSeriesIndex])) {
          var legendData = legend_helpers.getLegendData(chartObj),
            legendOptions = chartObj.systemConf.legend;
          highlightItem(legendElements[hoveredSeriesIndex], legendData[hoveredSeriesIndex], hoveredSeriesIndex, legendOptions);
        }
        this.hoveredSeriesIndex = null;
      }
      this.itemHighlighted = false;
    };

    ReverseLegendHighlight.prototype.getLegendIndex = function (d, index) {
      var chartObj = this.chartObj,
        clrOptions = chartObj.axes.clr,
        isSankey = chartObj.chartTypes[0].name === SANKEY_CHARTNAME;

      if (clrOptions.scaleType) {
        return colorscale_helpers.getItemIndex(chartObj, clrOptions.indexScale, d);
      } else if (isSankey) {
        var renderer = chartObj.renderer[0],
          node = d._type === 'link' ? renderer.getLinkByPoint(d).source : renderer.getSankeyNodeByPoint(d);
        return node.point.itemIndex;
      } else if (index != null) {
        return index;
      }
    };

    function getManagerID(chart, id) {
      var legend = chart.legends.get(id);

      var encode = legend.meta.encode,
        view = getLegendView(chart.legends, id);

      return "".concat(fullEncode(encode).toUpperCase(), "_").concat(view.toUpperCase(), "(").concat(id, ")");
    }

    function initComponents() {var legends = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var components = {},
        _init = function _init(legend) {return components[legend.id] = { data: null, highlighted: false };};

      legends.forEach(_init);
      return components;
    }

    function fullEncode(encode) {
      var list = ['shape'];
      return arrayIncludes(list, encode) ? encode : encode === 'z' ? 'size' : encode === 'clr' ? 'color' : null;
    }

    function hasEncode(encode, chartObj, options) {
      var seriesIndex = options.seriesIndex;

      switch (encode) {
        case 'z':
          return defined(seriesIndex) && isBubbleChartType(chartObj.chartTypes[seriesIndex].value);
        case 'clr':
          return legend_helpers.isContinousLegend(chartObj);}

    }

    var reConstructChartData = function reConstructChartData(seriesInfo, seriesIndices, chart) {
      var chartData = chart.userdata.seriesdata.chartdata,
        oldSeriesDataLength = chartData.length,
        seriesAddedAtEnd = true,
        seriesDataIndexMap = d3_map(),
        length;
      if (seriesIndices.length === 1 && isUndefined(seriesIndices[0])) {
        seriesIndices.splice(0, 1);
      }
      length = oldSeriesDataLength + seriesIndices.length;

      //mapping of input seriesinfo wih input seriesindex
      seriesInfo.map(function (d, i) {
        if (isUndefined(seriesIndices[i])) {
          seriesIndices[i] = length;
          length++;
        }
        seriesDataIndexMap.set(seriesIndices[i], d);
      });
      //sorting of seriesIndices
      seriesIndices.sort(function (a, b) {
        return a - b;
      });
      if (chart.nochartdata) {
        chart.rendererConf = [];
      }
      seriesIndices.map(function (i) {
        var index = i,
          d = seriesDataIndexMap.get(i);
        chart.seriesAddRemoveDetails.maxDOMseriesIndex++;
        chart.seriesAddRemoveDetails.seriesPositionMap.set(index, chart.seriesAddRemoveDetails.maxDOMseriesIndex);
        chartData.splice(index, 0, d);
        chart.renderer.splice(index, 0, null);
        chart.rendererConf.splice(index, 0, null);
        if (i < oldSeriesDataLength) {
          seriesAddedAtEnd = false;
        }
      });

      chart.staticPaneSVG.
      selectAll('.qualitativeGroup').
      selectAll('g').
      remove();
      //notes removal
      chartObj.notes.selectAll('*').remove();
      chartObj.container.selectAll('g.zc-annotation').remove();

      chart.seriesAddRemoveDetails.seriesUpdatedAtEnd = seriesAddedAtEnd;
      return seriesDataIndexMap;
    };

    function getClassInfoForAddSeries(newSeries, oldSeries, chart) {
      //old series is the series before which the new series will get added
      var newSeriesType = getChartName(newSeries.type),
        newSeriesClass = [".".concat(
        newSeriesType).concat(GROUP_SELECTOR.get(newSeriesType)).concat(chart.seriesAddRemoveDetails.seriesPositionMap.get(newSeries.index))],

        oldSeriesClass;

      if (!isUndefined(oldSeries.data)) {
        var oldSeriesType = getChartName(oldSeries.type),
          dynamicPosition;
        if (chart.renderer[oldSeries.index] === null) {
          dynamicPosition = chart.seriesAddRemoveDetails.seriesPositionMap.get(oldSeries.index);
        } else {
          if (
          chartObj.renderer[oldSeries.index] &&
          chartObj.renderer[oldSeries.index].commonRendererProp() &&
          chartObj.renderer[oldSeries.index].commonRendererProp().params &&
          !isUndefined(chartObj.renderer[oldSeries.index].commonRendererProp().params.dynamicSeriesPosition))
          {
            dynamicPosition = chart.renderer[oldSeries.index].commonRendererProp().params.dynamicSeriesPosition;
          } else {
            dynamicPosition = chart.renderer[oldSeries.index].commonRendererProp().params.datasetIndex;
          }
        }
        oldSeriesClass = [".".concat(oldSeriesType).concat(GROUP_SELECTOR.get(oldSeriesType)).concat(dynamicPosition)];
      }

      if (newSeriesType === 'line') {
        newSeriesClass.push(".scatterseries_".concat(chart.seriesAddRemoveDetails.seriesPositionMap.get(newSeries.index)));
        if (oldSeriesClass) {
          oldSeriesClass.push(".scatterseries_".concat(dynamicPosition));
        }
      }
      if (newSeriesType === 'area') {
        newSeriesClass.push(".lineseries_".concat(chart.seriesAddRemoveDetails.seriesPositionMap.get(newSeries.index)));
        newSeriesClass.push(".scatterseries_".concat(chart.seriesAddRemoveDetails.seriesPositionMap.get(newSeries.index)));
        if (oldSeriesClass) {
          oldSeriesClass.push(".lineseries_".concat(dynamicPosition));
          oldSeriesClass.push(".scatterseries_".concat(dynamicPosition));
        }
      }
      return {
        newSeriesClass: newSeriesClass,
        oldSeriesClass: oldSeriesClass
      };
    }
    function insertSeriesToDOM(chart, seriesIndices) {
      var isComboChart = chart.dataObject.isCombinationalChart = chart.dataObject.pivot ?
        getUniqueChartTypes(chart).values().length > 1 :
        getDistinct(DataProcessor.helpers.getAllChartTypes(chart.systemConf, 'object'), function (d) {return charttypenames.get(d);}).length > 1,
        seriesholder = chart.svg.selectAll('.seriesholder');

      if (isComboChart) {
        var orderedSeriesdata = isComboChart ? renderer_helpers.arrangeSeriesRenderingOrder(chart) : chart.seriesdata;
        for (var i = orderedSeriesdata.length - 1, ele; i >= 0; i--) {
          var currData = orderedSeriesdata[i],
            currSeriesIdx = currData.seriesidx;
          if (chart.renderer[currSeriesIdx] === null) {
            if (orderedSeriesdata[i + 1]) {
              ele = getClassInfoForAddSeries(
              {
                data: currData,
                index: currSeriesIdx,
                type: DataProcessor.helpers.getChartType(currData.type, 'string', currSeriesIdx, chart.userdata)
              },
              {
                data: orderedSeriesdata[i + 1],
                index: orderedSeriesdata[i + 1].seriesidx,
                type: DataProcessor.helpers.getChartType(
                orderedSeriesdata[i + 1].type,
                'string',
                orderedSeriesdata[i + 1].seriesidx,
                chart.userdata)

              },
              chart);

            } else {
              ele = getClassInfoForAddSeries(
              {
                data: currData,
                index: currSeriesIdx,
                type: DataProcessor.helpers.getChartType(currData.type, 'string', currSeriesIdx, chart.userdata)
              },
              {},
              chart);

            }
            if (!ele.oldSeriesClass) {
              ele.oldSeriesClass = [];
            }
            ele.newSeriesClass.map(function (d, i) {
              createElement('g', d, [{ data: currData, index: i }], seriesholder, ele.oldSeriesClass[i], function (d) {return d;});
            });
          }
        }
      } else {
        for (var i = seriesIndices.length - 1, ele; i >= 0; i--) {
          var currData = chart.seriesdata[i],
            currSeriesIdx = i;
          if (chart.seriesdata[i + 1]) {
            ele = getClassInfoForAddSeries(
            {
              data: chart.seriesdata[i],
              index: seriesIndices[i],
              type: DataProcessor.helpers.getChartType(chart.seriesdata[i].type, 'string', seriesIndices[i], chart.userdata)
            },
            {
              data: chart.seriesdata[seriesIndices[i] + 1],
              index: seriesIndices[i] + 1,
              type: DataProcessor.helpers.getChartType(
              chart.seriesdata[seriesIndices[i] + 1].type,
              'string',
              seriesIndices[i] + 1,
              chart.userdata)

            },
            chart);

          } else {
            ele = getClassInfoForAddSeries(
            {
              data: chart.seriesdata[i],
              index: i,
              type: DataProcessor.helpers.getChartType(chart.seriesdata[i].type, 'string', i, chart.userdata)
            },
            chart);

          }
          if (!ele.oldSeriesClass) {
            ele.oldSeriesClass = [];
          }
          ele.newSeriesClass.map(function (d, i) {
            createElement('g', d, [{ data: currData, index: i }], seriesholder, ele.oldSeriesClass[i], function (d) {return d;});
          });
        }
      }
    }

    var addSeries = /*#__PURE__*/function () {var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(seriesInfo, seriesIndices) {var chart, nonAxisCharts, renderingMode, oldSeriesDataLength, seriesDataIndexMap, flattenPoints;return _regeneratorRuntime().wrap(function _callee$(_context) {while (1) switch (_context.prev = _context.next) {case 0:
              chart = this,
              nonAxisCharts = chartcategory.nonaxis;

              seriesInfo = splat(seriesInfo);
              seriesIndices = splat(seriesIndices);
              try {
                seriesInfo.some(function (d, i) {
                  if (nonAxisCharts.indexOf(charttype[d.type]) != -1) {
                    throw "Action not possible! Add series is not supported for \"".concat(d.type, "\"");
                  }
                });
                chart.seriesAddRemoveDetails = updateAddRemoveSeriesProperty(
                chart.seriesAddRemoveDetails,
                'add',
                chart.seriesdata && chart.seriesdata.length);


                renderingMode = chart && chart.plot && chart.plot.renderer && chart.plot.renderer.mode || 'svg',
                oldSeriesDataLength = chart.userdata.seriesdata.chartdata.length,
                seriesDataIndexMap = reConstructChartData(seriesInfo, seriesIndices, chart),
                flattenPoints = chart.dataObject.flattenPoints;

                //we need not insert element to DOM in canvas case and if we add series to a null data,chart.seriesdata not updated in this case
                if (renderingMode === 'svg' && oldSeriesDataLength) {
                  insertSeriesToDOM(chart, seriesIndices);
                }
                chart.redraw(true);
                if (chart.seriesAddRemoveDetails.seriesUpdatedAtEnd && !chart.dataObject.flattenPoints) {
                  chart.dataObject.flattenPoints = flattenPoints;
                  updateFlattenPoints(seriesDataIndexMap, seriesIndices, chart);
                }

                if (chart.dataObject.pushFlattenAnnotation && chart.eventHandler.isSingleSource()) {
                  chart.dataObject.pushFlattenAnnotation();
                }

                chart.eventHandler.reverseLegendHighlight = new ReverseLegendHighlight(chart);
                chart.seriesAddRemoveDetails.seriesAddRemovePhase = false;
              } catch (err) {
                VizLayout.helpers.handleErrors(chart, err);
              }case 4:case "end":return _context.stop();}}, _callee, this);}));return function addSeries(_x3, _x4) {return _ref10.apply(this, arguments);};}();

    function updateFlattenPoints(seriesDataIndexMap, seriesIndices, chart) {
      seriesIndices.map(function (i) {
        var currSeriesData = seriesDataIndexMap.get(i).data[0],
          currSeriesIdx = i,
          renderer = chart.renderer[currSeriesIdx],
          flattenData = {
            seriesindex: currSeriesIdx,
            subseriesindex: 0,
            row: null,
            column: null,
            index: 0,
            rendererIndex: renderer.commonRendererProp().rendererIndex()
          };
        currSeriesData.map(function (data) {
          flattenData.data = [[data]];
          chart.dataObject.flattenData([flattenData]);
        });
      });
    }

    function getChartNameString(chart, type) {
      if (type === undefined) {
        type = chart.userdata.seriesdata.type;
      }
      if (Number(type)) {
        type = charttypenames.get(type);
      }
      return type.toLowerCase();
    }

    var reConstructChartData$1 = function reConstructChartData$1(seriesIndices, chart) {
      seriesIndices.sort(function (a, b) {
        return b - a;
      });
      var chartData = chart.userdata.seriesdata.chartdata,
        dataLength = chartData.length - 1,
        seriesRemovedFromEnd = true,
        seriesTypesRemoved = [],
        seriesholder = chart.svg.selectAll('.seriesholder'),
        renderingMode = chart && chart.plot && chart.plot.renderer && chart.plot.renderer.mode || 'svg';

      seriesIndices.map(function (data, i) {
        if (data === undefined) {
          data = chartData.length - 1;
          seriesIndices[i] = data;
        }
        if (dataLength != data) {
          seriesRemovedFromEnd = false;
        }
        dataLength--;
        //collection removed series type inorder to flattendata,if series removed from end
        var uniqueChartType = getChartNameString(chart, chartData[data].type);
        seriesTypesRemoved.push(uniqueChartType);

        var charttype = getChartName(uniqueChartType); //for gantt,bullet and many others charttype will be bar,which is collected here

        //removal of element from DOM
        if (renderingMode === 'svg') {
          var dynamciPosition;
          if (chart.renderer[data].commonRendererProp().params.dynamicSeriesPosition != undefined) {
            dynamciPosition = chart.renderer[data].commonRendererProp().params.dynamicSeriesPosition;
          } else {
            dynamciPosition = chart.renderer[data].commonRendererProp().params.datasetIndex;
          }
          if (charttype === 'area') {
            seriesholder.
            selectAll("g.areaseries_".concat(dynamciPosition, ",g.lineseries_").concat(dynamciPosition, ",g.scatterseries_").concat(dynamciPosition)).
            remove();
          } else if (charttype === 'line') {
            seriesholder.selectAll("g.lineseries_".concat(dynamciPosition, ",g.scatterseries_").concat(dynamciPosition)).remove();
          } else {
            seriesholder.selectAll(".".concat(charttype).concat(GROUP_SELECTOR.get(charttype)).concat(dynamciPosition)).remove();
          }
        }
        //removal of data
        chartData.splice(data, 1);
        chart.renderer.splice(data, 1);
        chart.rendererConf.splice(data, 1);
      });

      //whiskers removal
      chart.staticPaneSVG.
      selectAll('.qualitativeGroup').
      selectAll('g').
      remove();

      //notes removal
      chartObj.notes.selectAll('*').remove();
      chartObj.container.selectAll('g.zc-annotation').remove();

      //datalabels removal
      chart.staticPaneSVG.
      selectAll('.labelholder').
      selectAll('g').
      remove();

      //sizelegend removal
      chart.staticPaneSVG.
      selectAll('.legendarea').
      selectAll('g').
      remove();

      chart.seriesAddRemoveDetails.seriesUpdatedAtEnd = seriesRemovedFromEnd;
      return { seriesTypesRemoved: seriesTypesRemoved };
    };

    function getActiveNumberOfSeries(chartData) {
      var activeSeriesCount = 0,
        isAnySeriesDisabled;
      chartData.map(function (d, i) {
        if (d.disabled && !isAnySeriesDisabled) {
          isAnySeriesDisabled = true;
        }
        if (!d.disabled) {
          activeSeriesCount++;
        }
      });
      return { activeSeriesCount: activeSeriesCount, isAnySeriesDisabled: isAnySeriesDisabled };
    }
    function isAllActiveSeriesRemoved(seriesIndices, chartData) {
      var activeSeriesInfo = getActiveNumberOfSeries(chartData),
        isAnySeriesDisabled = activeSeriesInfo.isAnySeriesDisabled,
        activeSeriesCountToBeRemoved = 0;
      if (isAnySeriesDisabled) {
        seriesIndices.map(function (seriesIndexToBeRemoved, index) {
          if (isUndefined(seriesIndexToBeRemoved)) {
            seriesIndexToBeRemoved = chartData.length - 1;
            seriesIndices[index] = seriesIndexToBeRemoved;
          }
          if (!chartData[seriesIndexToBeRemoved].disabled) {
            activeSeriesCountToBeRemoved++;
          }
        });
      }
      if (chartData.length === seriesIndices.length) {
        return true;
      }
      return (
        isAnySeriesDisabled &&
        activeSeriesInfo.activeSeriesCount === activeSeriesCountToBeRemoved &&
        seriesIndices.length != chartData.length);

    }

    var removeSeries = function removeSeries(seriesIndices) {
      var chart = this;

      seriesIndices = splat(seriesIndices);
      try {
        if (isAllActiveSeriesRemoved(seriesIndices, chart.userdata.seriesdata.chartdata)) {
          throw "You are trying to remove/disable all the active series' from the chart data,which is not possible";
        }
        chart.seriesAddRemoveDetails = updateAddRemoveSeriesProperty(
        chart.seriesAddRemoveDetails,
        'remove',
        chart.seriesdata && chart.seriesdata.length);

        var removedSeriesInfo = reConstructChartData$1(seriesIndices, chart),
          flattenPoints = chart.dataObject.flattenPoints;

        if (!chart.seriesdata[0]) {
          chart.systemConf.seriesdata.chartdata = [];
          chart.dataObject.processedseriesData = [];
          chart.staticPaneSVG.selectAll('g').remove();
          delete chart.eventHandler;
          chart.redraw(true);
        } else {
          chart.redraw(true);
          if (chart.seriesAddRemoveDetails.seriesUpdatedAtEnd) {
            chart.dataObject.flattenPoints = flattenPoints;
            updateFlattenPoints$1(chart, removedSeriesInfo, seriesIndices);
          }
          chart.eventHandler.reverseLegendHighlight = new ReverseLegendHighlight(chart);
        }

        if (chart.dataObject.pushFlattenAnnotation && chart.eventHandler.isSingleSource()) {
          chart.dataObject.pushFlattenAnnotation();
        }

        chart.seriesAddRemoveDetails.seriesAddRemovePhase = false;
      } catch (err) {
        VizLayout.helpers.handleErrors(chart, err);
      }
    };
    function updateFlattenPoints$1(chart, removedSeriesInfo, seriesIndices) {
      var seriesTypesRemoved = removedSeriesInfo.seriesTypesRemoved,
        pane = chart.dataObject.flattenPoints.get('pane0_0'),
        subSeriesIndex = 0;
      seriesIndices.map(function (d, i) {
        delete pane.get(seriesTypesRemoved[i])["".concat(d, "_").concat(subSeriesIndex)];
        if (Object.keys(pane.get(seriesTypesRemoved[i])).length === 0) {
          delete pane["$".concat(seriesTypesRemoved[i])];
        }
      });
    }

    //data-processor-helpers.js

    DataProcessor.helpers = {
      /**
       *
       * @param dataset
       * @param type
       * @param index
       * @return {Function}
       */

      isCatNull: function isCatNull(dataset, type, index) {
        var noNullFormat = dataset.hasNullFormatter && !dataset.hasNullFormatter[type + (defined(index) ? index : '')];
        return function (cat) {
          return !defined(cat) && noNullFormat;
        };
      },

      /**
       *
       * @param data
       * @return {boolean}
       */

      is3D: function is3D(data) {
        return isArray$1(data) && isArray$1(data[0]) && isArray$1(data[0][0]);
      },

      getParsedYAxisOrder: function getParsedYAxisOrder(yaxiscolumnorder) {
        return isArray$1(yaxiscolumnorder) ? yaxiscolumnorder[0] : yaxiscolumnorder || 0;
      },

      /**
       *
       * @param type
       * @param chartTypeBy
       * @param index
       * @param data
       * @return {{name: *, value: *}}
       */
      getChartType: function getChartType(type, chartTypeBy, index, data) {
        if (type == null && index == null) {
          return;
        }

        var seriesdata = data && data.seriesdata.chartdata,
          chartName,
          chartValue;
        if (defined(index)) {
          type = pick((seriesdata[index] || seriesdata[0]).type, data.seriesdata.type);
        }
        if (isNaN(+type)) {
          chartName = type.toLowerCase();
          chartValue = charttype[chartName];
        } else {
          chartValue = +type;
          chartName = charttypenames.get(chartValue);
        }
        return chartTypeBy === 'string' ?
        chartName :
        chartTypeBy === NUMERIC_DATATYPE ?
        chartValue :
        {
          name: chartName,
          value: chartValue
        };
      },

      /**
       *
       * @param data
       * @param chartTypeBy
       */

      getAllChartTypes: function getAllChartTypes(data, chartTypeBy) {
        var helpers = this;
        var globalChartType = data.seriesdata && data.seriesdata.type;

        return pick(getPropVal(data, 'seriesdata.chartdata'), []).map(function (a) {
          var temp = helpers.getChartType(pick(a.type, globalChartType), pick(chartTypeBy, NUMERIC_DATATYPE));
          if (!chartTypeBy && chartTypeBy === 'object') {
            return {};
          }
          return temp;
        });
      },

      /**
       *
       * @param data
       * @param chartTypeBy
       */

      getAllChartTypesFromSeriesdata: function getAllChartTypesFromSeriesdata(userdata, processedSeriesdata, chartTypeBy) {
        var helpers = this;
        var globalChartType = userdata.seriesdata && userdata.seriesdata.type;

        return pick(processedSeriesdata, []).map(function (a) {
          var temp = helpers.getChartType(pick(a.type, globalChartType), pick(chartTypeBy, NUMERIC_DATATYPE));
          if (!chartTypeBy && chartTypeBy === 'object') {
            return {};
          }
          return temp;
        });
      },

      /**
       *
       * @param array
       * @param rangeX
       * @param accessorX
       * @param rangeY
       * @param accessorY
       * @return {*}
       */
      filterDataToViewPort: function filterDataToViewPort(array, rangeX, accessorX, rangeY, accessorY) {
        var both = isArray$1(rangeX) && isArray$1(rangeY),
          counter = 0;

        return array.filter(function (d) {
          var valX = accessorX && accessorX(d);
          var valY = accessorY && accessorY(d);
          var show;

          if (both) {
            show = valX !== null && valY !== null && valX >= rangeX[0] && valX <= rangeX[1] && valY >= rangeY[0] && valY <= rangeY[1];
          } else {
            show = valX !== null && valX >= rangeX[0] && valX <= rangeX[1];
          }

          if (show) {
            d._filter = false;
            d.counter = counter++;
          } else {
            d._filter = true;
          }
          return show;
        });
      },

      /**
       *
       * @param point
       * @param property
       * @param seriesIndex
       * @param subSeriesIndex
       * @param chart
       * @param chartType
       * @param xScale
       * @param yScale
       * @return {*}
       */
      getDataPosition: function getDataPosition(point, property) {var seriesIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var subSeriesIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var chart = arguments.length > 4 ? arguments[4] : undefined;var chartType = arguments.length > 5 ? arguments[5] : undefined;var xScale = arguments.length > 6 ? arguments[6] : undefined;var yScale = arguments.length > 7 ? arguments[7] : undefined;
        var renderer = chart.renderer[seriesIndex],
          rendererConf = chart.rendererConf[seriesIndex], // TODO: PIVOT
          yAxisOrder = rendererConf.yaxiscolumnorder(),
          rotated = chart.axes.rotated,
          stacked = rendererConf.stacked(),
          position = null;

        chartType = pick(chartType, chart.chartTypes[seriesIndex].name);
        xScale = pick(xScale, rendererConf.xscale());
        yScale = pick(yScale, rendererConf.yscale());

        if (chartType === 'bar') {
          position = chart.dataObject.getTransRectValue(property, point, subSeriesIndex, 0, renderer.commonOption);
        } else if (chartType === 'bubblepie') {
          // #ZC2073
          var referencePoint = point[seriesIndex];
          position = chart.dataObject.getXYvalue(rotated, stacked, xScale, yScale, yAxisOrder, referencePoint, property);
        } else {
          position = chart.dataObject.getXYvalue(rotated, stacked, xScale, yScale, yAxisOrder, point, property);
        }

        if (isNaN(position)) {
          position = null;
        }
        return position;
      },

      filterPointsInViewport: function filterPointsInViewport(chart, points, chartType, axisType) {var seriesIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;var subSeriesIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        // #ZC2193
        if (chart.isGeoMap) {
          // TODO GEO CHARTS
          return points;
        }

        // #ZC2219
        var needPositionCorrection = arrayIncludes(['line', 'area', 'bar', 'arearange', 'canvasscatter'], chartType),
          plotArea = chart.plotarea,
          rangeX = [0, plotArea.width],
          rangeY = [0, plotArea.height],
          rotated = chart.axes.rotated,
          reversed = chart.axes.x.reversed,
          getPosition = DataProcessor.helpers.getDataPosition;

        if ((axisType === 'x' || axisType === 'xy') && isArray$1(chart.scrollView)) {
          rangeX = chart.scrollView.map(chart.axes.x.baseScale).sort(d3_ascending);
        }

        if (needPositionCorrection && (points.length > 1 || chartType === 'bar')) {
          if (chartType === 'bar') {
            if (rotated) {
              rangeX = rangeY;
            }
            rangeX = [rangeX[0] - chart.barscale2.bandwidth(), rangeX[1]];
          } else {
            var correctionX,
              correctionY,
              p0_x = getPosition(points[0], 'x', seriesIndex, subSeriesIndex, chart, chartType),
              p1_x = getPosition(points[1], 'x', seriesIndex, subSeriesIndex, chart, chartType),
              p0_y = getPosition(points[0], 'y', seriesIndex, subSeriesIndex, chart, chartType),
              p1_y = getPosition(points[1], 'y', seriesIndex, subSeriesIndex, chart, chartType);
            if (reversed) {
              correctionX = p0_x - p1_x;
              correctionY = p0_y - p1_y;
            } else {
              correctionX = p1_x - p0_x;
              correctionY = p1_y - p0_y;
            }

            if (rotated) {var _map3 =
              [correctionY, correctionX].map(mathAbs);var _map4 = _slicedToArray(_map3, 2);correctionX = _map4[0];correctionY = _map4[1];var _ref11 =
              [rangeY, rangeX];rangeX = _ref11[0];rangeY = _ref11[1];
            }

            rangeX = [rangeX[0] - correctionX, rangeX[1] + correctionX];
            rangeY = [rangeY[0] - correctionY, rangeY[1] + correctionY];
          }
        } else {
          if (rotated) {var _ref12 =
            [rangeY, rangeX];rangeX = _ref12[0];rangeY = _ref12[1];
          }
        }

        var accessorX = function accessorX(d) {return getPosition(d, rotated ? 'y' : 'x', seriesIndex, subSeriesIndex, chart, chartType);},
          accessorY = function accessorY(d) {return getPosition(d, rotated ? 'x' : 'y', seriesIndex, subSeriesIndex, chart, chartType);};

        if (axisType === 'xy') {
          return DataProcessor.helpers.filterDataToViewPort(points, rangeX, accessorX, rangeY, accessorY);
        } else if (axisType === 'x') {
          return DataProcessor.helpers.filterDataToViewPort(points, rangeX, accessorX);
        } else if (axisType === 'y') {
          return DataProcessor.helpers.filterDataToViewPort(points, rangeY, accessorY);
        }
      },

      groupByDataIndices: function groupByDataIndices(metadata, chart) {
        /*
         * returns an array of groupby dataindices
         */
        var dataSplicer = chart.dataSplicer,
          metadata_axes = dataSplicer.getEncode(),
          metadata_columns = dataSplicer.getColumns();

        var groupbyCol = metadata_axes.groupby || [];
        return groupbyCol.map(function (d) {
          return metadata_columns[d].dataindex;
        });
      },

      /**
       * @param  {Object} processor [description]
       * @param  {Number} index     [description]
       * @return {Boolean}           [description]
       */
      hasLevelMarkerData: function hasLevelMarkerData(processor, index) {
        var LEVELMARKER_LIST = [BAR_CHARTNAME, BULLET_CHARTNAME, DIAL_CHARTNAME, BOXPLOT_CHARTNAME, BARRANGE_CHARTNAME],
          seriesIndices = processor.getEncode('y', index).seriesIndices,
          allChartTypes = processor.allChartTypes,
          check = function check(seriesIndex) {return arrayIncludes(LEVELMARKER_LIST, charttypenames.get(allChartTypes[seriesIndex]));};

        return seriesIndices.some(check);
      },

      /*
       * @return {boolean}
       */
      hasMarkerCorrection: function hasMarkerCorrection(processor) {
        return false;
        // var markerSize = getMarkerSize(processor.chartObj);
        // return markerSize.left > 0 || markerSize.right > 0 || markerSize.top > 0 || markerSize.bottom > 0;
      },

      /**
       *
       * @param chartId
       * @param seriesIndex
       * @param subSeriesIndex
       * @param itemIndex
       * @return {string}
       */
      generatePointKey: function generatePointKey(chartId, gridId, seriesIndex, subSeriesIndex, itemIndex) {
        return "".concat(chartId, "_").concat(gridId, "_").concat(seriesIndex, "_").concat(subSeriesIndex, "_").concat(itemIndex);
      },

      getSeriesdata: function getSeriesdata(chart, paneid, seriesIndex) {
        if (defined(seriesIndex)) {
          if (chart.dataObject.pivot) {
            var layers = chart.dataObject.hierarchical.pivotLayout.getRootNodeList('layer'),
              panes = layers.panes;
            return panes[paneid].data[seriesIndex].node;
          } else {
            return chart.seriesdata[seriesIndex];
          }
        }
      },

      getDynamicData: function getDynamicData(data, chart) {
        var data_dynamic = d3_values(data);
        var co = data_dynamic.count;
        for (var i = 0; i <= co; i++) {
          data_dynamic.splice(i, 0, [null, null]);
        }
        return data_dynamic;
      }
    };

    //pre-processor-helpers.js

    /**************** Pre Processor Dependency Functions  **************/
    PreProcessor.helpers = {
      time: {},
      ordinal: {},
      numeric: {},
      linear: {}
    };

    /**
     *
     * @param series
     * @return {*|boolean}
     */

    PreProcessor.helpers.hasInnerSeries = function (series) {
      // return isArray(series.data) && typeof series.data[0] === 'object' && defined(series.data[0].seriesname);
      return isArray$1(series.data) && series.data[0] && series.data[0].constructor === Object;
    };

    /************ Time Helpers Start **************/

    PreProcessor.helpers.time = {
      /**
       *
       * @param data
       * @param isDiscrete
       * @return {{indices: Array, formatConf: Array}}
       */

      getDataInfo: function getDataInfo(data, isDiscrete, chart) {
        var dataSplicer = chart.dataSplicer,
          metaAxes = dataSplicer.getEncode(),
          metadata_columns = dataSplicer.getColumns(),
          xColumnIndex = metaAxes.x,
          zColumnIndex = metaAxes.z || [],
          clrColumnIndex = metaAxes.clr || [],
          columnIndexes = d3_merge([xColumnIndex, d3_merge(metaAxes.y), zColumnIndex, clrColumnIndex]),
          regexTimeStamp = /timestamp/i,
          timeFormatConfig,
          inputFormat,
          column,
          timeDataIndices = [],
          formatConf = [];

        columnIndexes.map(function (d) {
          column = pick(metadata_columns[d], {});
          timeFormatConfig = pick(column.time, {});

          if (column.datatype === 'time' && d !== xColumnIndex && !isDiscrete) {
            inputFormat = timeFormatConfig.inputformat;

            if (!regexTimeStamp.test(inputFormat) || inputFormat === 'function' || typeof window[inputFormat] === 'function') {
              formatConf.push(timeFormatConfig);
            } else {
              formatConf.push(null);
            }
            timeDataIndices.push(metadata_columns[d].dataindex);
          }
        });

        return {
          indices: timeDataIndices,
          formatConf: formatConf
        };
      },

      /**
       *
       * @param d
       * @param info
       * @return {*}
       */

      applyFormats: function applyFormats(d, info) {
        var indices = info.indices,
          format = info.formatConf;

        indices.map(function (index, j) {
          if (defined(d[index])) {
            if (isArray$1(d[index])) {
              d[index] = d[index].map(function (d) {
                return generateDateVal(d, null, format[j], true).getTime();
              });
            } else {
              d[index] = generateDateVal(d[index], null, format[j], true).getTime();
            }
          }
        });
        return d;
      }
    };

    /************ Time Helpers End **************/

    /************ Linear Helpers Start **************/

    PreProcessor.helpers.linear = {
      /**
       *
       * @param array
       * @param dataIndex
       */

      sort: function sort(array, dataIndex) {
        return array.sort(function (a, b) {
          a = a[dataIndex];
          b = b[dataIndex];
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        });
      }
    };

    /************ Linear Helpers End **************/

    /**
     *
     * @param d
     * @param groupbyDataIndices
     * @param chartType
     * @return {*|Array}
     */

    DataProcessor.prototype.convertTo3DArray = function (d, groupbyDataIndices, cType) {
      var curdata = d.data;

      if (groupbyDataIndices.length > 0 && (cType === charttype.bar || cType === charttype.stkdbar)) {
        //Finding unique categories across series

        var groupbyCategories = getDistinctGroupbyCategories(d, groupbyDataIndices),
          distintGroupbyCat = groupbyCategories.distintGroupbyCat,
          allGroupbyCat = groupbyCategories.allGroupbyCat;

        //Grouping data by unique categories across series
        var newSeriesdata = [];
        d.data.forEach(function (d, j) {
          var index = distintGroupbyCat.indexOf(allGroupbyCat[j]);
          newSeriesdata[index] = newSeriesdata[index] || [];
          newSeriesdata[index].push(d);
        });
        curdata = d.data = newSeriesdata;
      }
      // If data is [[]], don't convert to 3D as stacked bar chart throws error on d3.layout.stack().
      // Convert is possible, if data is [] or 2D with data points
      else if (defined(curdata) && (!curdata.length || defined(curdata[0]) && isArray$1(curdata[0]))) {
        d.data = [];
        d.data.push(curdata);
        curdata = d.data;
      }

      return curdata;
    };

    /**
     *
     * @param curSeriesdata
     * @param groupbyDataIndices
     * @return {{distintGroupbyCat: Array, allGroupbyCat: Array}}
     */

    function getDistinctGroupbyCategories(curSeriesdata, groupbyDataIndices) {
      var allGroupbyCat = curSeriesdata.data.map(function (d) {return groupbyDataIndices.reduce(function (prev, cur) {return prev + d[cur];}, '');}),
        distintGroupbyCat = getDistinct(allGroupbyCat);

      return {
        distintGroupbyCat: distintGroupbyCat,
        allGroupbyCat: allGroupbyCat
      };
    }

    //dataCount.js

    DataProcessor.prototype.totalDataCount = function (curdata) {
      var processor = this,
        chart = processor.chartObj,
        temp = 0;
      curdata.map(function (subgroup) {
        if (!curdata.disabled && isArray$1(subgroup)) {
          var len =
          chart._isAxisCategory() || processor.isPolarAxisCategory || processor.isNonAxisMultiSeriesCategory ?
          subgroup.length :
          subgroup.reduce(function (prev, cur) {
            return prev + (cur.disabled ? 0 : 1);
          }, 0);
          temp += len === 1 && (subgroup[0] === null || !subgroup[0].length) ? 0 : len;
        }
      });
      this.totalnoofdatas += temp;
      return temp;
    };

    //$Id$

    // export * from './../scroll/defaultScroll';
    // TODO renaming exports or $ZC
    charts.get = function (chartHolder, data) {
      return new Chart(chartHolder, data);
    };

    function Chart(container, data) {
      this.container = container;
      this.userdata = data;
      this.dataObject = null;
      this.dataset = null;
      this.svg = null;
      this.seriesColor = [];
      this.axes = {
        x: {
          levels: [],
          branches: [],
          clusters: [],
          leaves: []
        },
        y: {
          groups: [],
          branches: [],
          clusters: [],
          leaves: []
        }
      };
      // this.renderer = [];
      this.ismultiy = null;
      this.plotarea_approx = null;
      this.nochartdata = false;
      this.chartRendered = false;
      this.plot = {};
      this.events = {};

      this.viewPortExtent = null;
      // this.legend = {
      //     component: null
      // };

      // extend VizLayout

      VizLayout.call(this, container, data);
      this.initialize();
    }

    inherit(Chart, VizLayout);
    Chart.helpers = VizLayout.helpers;

    Chart.prototype.initialize = function () {
      var chartObj = this;

      // CURRENT_CHART_COUNT++;
      // chart.id = "ZC_" + CURRENT_CHART_COUNT;
      // chart.idNumeric = CURRENT_CHART_COUNT;

      try {
        // var data = this.userdata,
        // dataProcessorHelpers = chart.dataProcessorHelpers = DataProcessor.helpers;

        // chart.createHelperElements();
        // chart.handleHiddenContainer();
        // chart.chartFontProp = {};
        // chart.chartWidth = chart.getChartDimension("width");
        // chart.chartHeight = chart.getChartDimension("height");
        // Chart.helpers.initializeChartHolders(chart);
        // chart.setCanvasDimension();

        // get all chart types
        // chart.chartTypes = dataProcessorHelpers.getAllChartTypes(data, "object");
        // chart.globalProp = setGlobalPropByUserdata(data, {
        //     "width": chart.canvasarea.width,
        //     "height": chart.canvasarea.height
        // }, chart.chartFontProp);

        // chart.themeoptions = chart.getThemeOptions(chart.globalProp);

        // (!data.metadata) ? setDefaultOptions("metadata", data) : null; // If metadata is unavailable, get default metadata
        chartObj.timerObj = new Array(0);
        chartObj.processUserData(chartObj.themeoptions);
        chartObj.setChartDimension();

        var _legendHighlight = Registry.getComponent('LegendHighlight');
        chartObj.legendHighlight = new _legendHighlight(chartObj, chartObj.svg);

        VizLayout.helpers.constructChartGroups(chartObj);
      } catch (err) {
        VizLayout.helpers.handleErrors(chartObj, err);
      }
    };

    /**
     * @returns {void}
     */

    Chart.prototype.draw = function () {
      var chart = this,
        plotBgData = this.systemConf.chart.plot.background;
      if (plotBgData.image.lockAspectRatio && plotBgData.imageUrl) {
        var img = new Image();
        this.plot.hasBgAspectRatio = true;
        var plotBgObj = this.plot.backgroundImg = {};
        img.onload = function () {
          plotBgObj.width = this.width;
          plotBgObj.height = this.height;
          chart.render(false);
        };
        img.src = plotBgData.imageUrl;
      } else {
        this.render(false);
      }
    };

    /**
     *
     * @param {boolean} update
     */

    Chart.prototype.render = function (update) {
      var chart = this;

      try {
        chart.updateCanvasArea();

        var systemConfig = chart.systemConf;
        chart.applyChartProperties();
        if (chart.nochartdata) {
          chart.hideLoading(chart.container);
          chart.handleNoData(systemConfig.noDataHandler);
          chart.chartRendered = true;
          stateChangeListener(chart, systemConfig.canvas.events, 'chart', update ? 'onreload' : 'onload');
        } else {
          chart.clearNoData(systemConfig.noDataHandler);
          chart.getChartSeriesColor();
          chart.isAxisCategory = chart.dataObject.isAxisCategory;
          chart.isNonAxisMultiSeriesCategory = chart.dataObject.isNonAxisMultiSeriesCategory;
          chart.isPolarAxisCategory = chart.dataObject.isPolarAxisCategory;

          chart.parseScale();
          chart.zscale = chart.scales[0] && chart.scales[0].getScale();

          Registry.getComponent('legend.render')(chart, update);
          tooltip_block_helpers.updatePlotarea4BlockTooltip(chart);
          prePlotRenderings(chart, systemConfig, update);

          if (chart.plot.renderer) {
            chart.plot.renderer.draw(update);
          } else {
            var renderer = chart.plot.renderer = plot.render(chart, update);
            renderer.draw(false);
          }

          // fix the legend position based on plot area
          // chart.fixLegendPosition();

          if (chart.isAxisCategory) {
            chart.drawThreshold(update);
          }
          chart.handleEvent(update);
          chart.drawPlotareaClippath();

          chart.positionEventTrackerElement(chart.wrap.selectAll('rect.dummy-rect-filter'));

          // stateChangeListener(chart, systemConfig.canvas.events, "chart", (update)?"onreload":"onload");
        }
      } catch (err) {
        VizLayout.helpers.handleErrors(chart, err);
      }
    };

    function prePlotRenderings(chart, systemConfig, update) {
      if (isObjectPropDefined(chart.systemConf, 'notes') && chart.systemConf.notes.enabled) {
        //Adding block level annotations
        var _annotation2 = Registry.getComponent('annotation');
        if (!_annotation2._empty) {
          _annotation2.addBlockAnnotations(chart);
        }
      }

      if (chart._isAxisCategory() || chart.dataObject.isPolarAxisCategory || chart.dataObject.hasLevelMarker) {
        chart.axes.rotated = _getAxisRotated(systemConfig);
        if (chart.axes.rotated) {
          chart.axes.x.orient = 'left';
          chart.axes.y.orient = 'bottom';
        } else {
          chart.axes.x.orient = 'bottom';
          chart.axes.y.orient = 'left';
        }
        chart.ismultiy = chart.getAxesCount('y') > 1;
        chart.ismultix = chart.getAxesCount('x') > 1;
      }

      //brushing
      if (isObjectPropDefined(chart.systemConf.chart, 'scroll') && chart.systemConf.chart.scroll.enabled) {
        if (chart.scroll) {
          chart.scroll.update();
        } else {
          var _ChartBrushScroll = Registry.getComponent('ChartBrushScroll');
          setDefaultOptions('scroll', chart.systemConf.chart, chart.globalProp);
          var scrollOrient = chart.systemConf.chart.scroll.orient,
            scrollType = scrollOrient && (scrollOrient === 'right' || scrollOrient === 'left') && !chart.axes.rotated ? 'y' : 'x';
          chart.scroll = new _ChartBrushScroll(chart, scrollType);
        }
      } else if (chart.scroll) {
        chart.scroll.destroy();
        chart.scroll = null;
        chart.behaviouralEvents.eventManager.behaviours.CHART_SCROLL = null;
        // #ZC2320
        delete chart.behaviouralEvents.eventManager.behaviours.CHART_SCROLL;
        delete chart.scroll;
      }
      //aspect ratio
      if (chart.plot.backgroundImg) {
        var imgWidth = chart.plot.backgroundImg.width,
          imgHeight = chart.plot.backgroundImg.height,
          aspectRatio = imgWidth / imgHeight,
          widthT = mathMax(chart.chartWidth, chart.chartHeight) * aspectRatio,
          heightT = widthT / aspectRatio;

        chart.systemConf.chart.width = widthT;
        chart.systemConf.chart.height = heightT;
      }
      if (isSmoothScrollEnabled(chart)) {
        var smothScroll = Registry.getComponent('smoothScroll');
        var div_scroll = new smothScroll();
        chart.divScroll = div_scroll;
        div_scroll.initialize(chart);
      }

      // Axis renderer
      stateChangeListener(chart, systemConfig.chart.axes.events, null, 'init');

      //plot border ZC1384
      chart.drawPlotBorder();



      if (chart._isAxisCategory()) {
        axis.render(chart, chart.chartWidth, chart.chartHeight, update);
      }

      // Polar axis rendering
      var hasPolarAxis = chart.dataObject.isPolarAxisCategory || seriesIs(chart.chartTypes[0].value, DIAL_CHARTNAME);
      if (hasPolarAxis) {
        axis.polar.render(chart);
      }

      if (chart.legend.isSingleLayout) {
        chart.zscale = chart.dataObject.hasZaxis && !chart.dataObject.isHierarchy ? chart.scales[0].create() : null;
      }
      stateChangeListener(chart, systemConfig.chart.axes.events, null, update ? 'onreload' : 'onload');

      chart.updatePlotareaProp();
      return new Promise(function (resolve, reject) {
        // setTimeout(() => {
        //     resolve();
        // }, 0);
        resolve();
      });
    }

    /**
     *
     * @param baseSystemConf
     * @param update
     */

    Chart.prototype.processUserData = function (baseSystemConf, update) {
      var chart = this,
        systemConfig,
        series,
        chartdata;

      chart.systemConf = systemConfig = mergeJSON$1(baseSystemConf, chart.userdata, true, true);
      series = getPropVal(systemConfig, 'seriesdata') || {};
      // chart.seriesdata = chartdata = simpleClone(series.chartdata);
      chart.seriesdata = chartdata = series.chartdata;

      // if (!update) {
      stateChangeListener(chart, systemConfig.canvas.events, 'chart', 'init');
      // }
      var _chartSpecGetter = Registry.getComponent('dataSplicer');
      if (chart.userdata.viewParser || chart.userdata._viewParser) {
        var _viewParser = Registry.getComponent('viewParser');
        chart.viewFlow = new _viewParser(chart.userdata.viewParser || chart.userdata, chart.userdata);
        _chartSpecGetter = Registry.getComponent('dataSplicer4ViewParser');
        chart.parserConfig = chart.viewFlow.init();
      }

      chart.dataSplicer = new _chartSpecGetter(chart.userdata, chart.systemConf, chart);

      chart.nochartdata = !defined(chartdata) || defined(chartdata) && chartdata.length < 1;

      if (chart.nochartdata) {
        chart.seriesdata = null;
      } else {
        addColorColumnToMeta(chart); //ZC2635

        chart.dataset = new dataparser.get(systemConfig, chart);
        chart.preProcessor = new PreProcessor(chart);
        if (!chart.seriesdata.length) {
          chart.nochartdata = true;
          return;
        }
        chart.dataObject = chart.getDataObject();

        chart.nochartdata = chart.dataObject.totalnoofdatas < 1;
      }
    };

    /**
     *
     *
     * @returns {*}
     */

    Chart.prototype.getDataObject = function () {
      var chart = this,
        chartType = chart.chartTypes[0].value,
        processorName,
        processor;

      var dataObject = this.dataObject,preProcessor = this.preProcessor,
        hierarchical = dataObject.hierarchical;

      var isPivotType =
      hierarchical && hierarchical.facetRendering ||
      preProcessor && preProcessor.hierarchical && preProcessor.hierarchical.facetRendering;
      processorName =
      !isPivotType && arrayIncludes(chartcategory.hierarchy, chartType) && !chart.isAxisedHierarchyChart ?
      'hierarchyDataProcessor' :
      arrayIncludes(chartcategory.axis, chartType) ||
      arrayIncludes(chartcategory.polarAxis, chartType) ||
      seriesIs(chartType, DIAL_CHARTNAME) ||
      arrayIncludes(chartcategory.flow, chartType) ||
      isPivotType ||
      chart.isAxisedHierarchyChart ?
      'cartesianDataProcessor' :
      'defaultDataProcessor',
      processor = Registry.getComponent(processorName);

      /*if (chart._isAxisCategory()) {
          processorName = 'cartesianDataProcessor';
      } else if (arrayIncludes(chartcategory.hierarchy, chartType)) {
          processorName = 'hierarchyDataProcessor';
      } else if (
          arrayIncludes(chartcategory.axis, chartType) ||
          arrayIncludes(chartcategory.polarAxis, chartType) ||
          seriesIs(chartType, DIAL_CHARTNAME) ||
          arrayIncludes(chartcategory.flow, chartType)
      ) {
          processorName = 'cartesianDataProcessor';
      } else {
          processorName = 'defaultDataProcessor';
      }
       processor = Registry.getComponent(processorName);*/


      addProcessorPolyfills(processor); //TODO: remove

      return new processor(chart.systemConf, chart.dataset, chart);
    };

    /**
     *
     * @param type
     * @returns {number}
     */
    Chart.prototype.getAxesCount = function (type) {
      var chart = this,
        count = 1,
        dataSplicer = chart.dataSplicer,
        metadata_axes = dataSplicer.getEncode(),
        metadata_columns = dataSplicer.getColumns(),
        hierarchical = chart.dataObject.hierarchical;

      if (type === 'x') {
        var columnIndex = chart.dataset.getColumnIdx(type),
          originalDataType = metadata_columns[columnIndex].datatype,
          formatConfig = pick(metadata_columns[columnIndex][originalDataType], {}),
          formatFunction = formatConfig.subfunction,
          axisEnabled = chart.systemConf.chart.axes.xaxis.show;

        if (hierarchical) {
          var columnList = hierarchical.pivotLayout.getRootNodeList('column');
          count = columnList.getCount() + columnList.getLeavesCount();
        } else if (axisEnabled && isArray$1(formatConfig.groupby) && formatConfig.groupby.length) {
          count = formatConfig.groupby.length + 1;
        } else if (axisEnabled && formatConfig.groupby === 'AUTO') {
          count = DataProcessor.HierarchicalTimeDataAdapter.getAutoGroupOrder(formatFunction).length + 1;
        }
        chart.axes[type].count = count;
      } else {
        var metadataY = metadata_axes.y;

        if (hierarchical && hierarchical.pivot) {
          var rowList = hierarchical.pivotLayout.getRootNodeList('row'),
            totalNoOfRows = rowList.getCount() || 0,
            leavesCount = rowList.getLeavesCount();
          count = totalNoOfRows + leavesCount;
        } else {
          count = metadataY.length;
        }
        chart.axes[type].count = count;
      }
      return count;
    };

    /**
     *
     * @param update
     */

    Chart.prototype.drawThreshold = function (update) {
      if (axis.threshold) {
        var chart = this;
        chart.cache.thresholdCustomPoints = []; // clear it
        axis.threshold(chart, update);
        applyEffect(chart.container.selectAll('g.threshold'), { chartObj: chart });
      }
    };

    /**
     *
     * @param update
     */
    Chart.prototype.handleEvent = function (update) {
      var chart = this,
        systemConfig = chart.systemConf,
        chartEvents = Registry.getComponent('ZC_ChartEvents');
      if (!update || !chart.eventHandler) {
        chart.createEventGroups(update);
        var trackerGroup = createElement('g', '.trackerGroup', [1], chart.eventWrap).attr('pointer-events', 'all'),
          trackerElement = createElement('rect', '.eventhandler', [1], trackerGroup);

        // TODO Hack
        trackerElement.node().__chart = chart;

        chart.eventHandler = new chartEvents(chart, trackerGroup);
        chart.eventHandler.trackerGroup = trackerGroup;
        chart.eventHandler.trackerElement = trackerElement;
        addClipToTracker(chart);
        chart.eventHandler.init();
        initTooltip(chart); //TODO code clean
      } else {
        chart.eventHandler.update();
        //update tooltip
        updateTooltip(chart);
      }
      if (chart.eventHandler.isSingleSource()) {
        if (chart.renderer.length) {
          if (
          !(
          chart.seriesAddRemoveDetails &&
          chart.seriesAddRemoveDetails.seriesAddRemovePhase &&
          chart.seriesAddRemoveDetails.seriesUpdatedAtEnd))

          {
            chart.dataObject.flattenData();
          }
        }
        chart.positionEventTrackerElement();
      }

      addClipToTracker(chart);

      if (isSmoothScrollEnabled(chart)) {
        chart.divScroll.defaultScroll(chart);
      }

      if (chart.behaviouralEvents) {
        chart.behaviouralEvents.update();
      } else if (systemConfig.__$overview !== true) {
        chart.behaviouralEvents = new BehaviouralEvents(chart);

        // TODO Hack
        var brushOverlay = chart.eventHandler.trackerGroup.selectAll('rect.overlay');
        if (!brushOverlay.empty()) {
          brushOverlay.node().__chart = chart;
        }
      }
      // render it before event
      chart.scroll && chart.scroll.render();

      chart.handleLegendEvents(); // Legend events
    };

    /**
     *
     * @param series
     * @param i
     * @param axisorder
     * @param updateAllAxes
     */

    Chart.prototype.addRemoveSeries = function (series, i, axisorder, updateAllAxes) {
      var chart = this,
        systemConfig = chart.systemConf;

      chart.phase = 'legendFilter';
      chart.cache.correction = {};

      if (isFacet(chart)) {
        chart.cache.search = {};
        chart.plot.renderer.draw(true);
        return;
      }

      if (colorscale_helpers.isQuantileColorScale(chart)) {
        chart.phase = 'legendFilter-colorScale';
        chart.cache.search = {}; // ZC2390
        chart.plot.renderer.draw(true);
        return;
      }

      chart.dataObject.formattedData = {
        x: [],
        y: []
      };
      chart.dataObject.initialize('addorremoveseries');

      stateChangeListener(chart, systemConfig.chart.axes.events, null, 'init');
      if (chart.isAxisCategory) {
        chart.updateZscale();
        var hierarchical = chart.dataObject.hierarchical;
        if (updateAllAxes) {
          chart.axes.y.groups.forEach(function (d, i) {
            chart.updateScale([i, 0], 'y');
          });
          if (chart.dataObject.hierarchical) {
            var rowList = hierarchical.pivotLayout.getRootNodeList('row'),
              rowCount = rowList.getCount();
            if (rowCount) {
              scale.setRowScale(chart, 'row');
            }
          }
        } else {
          chart.updateScale(axisorder, 'y');
        }

        // #ZC2174 $[chart.viewPortExtent]
        chart.updateScale(0, 'x', chart.viewPortExtent);
        if (hierarchical) {
          chart.axes.x.rangeScale = chart.axes.x.scale.copy();
          chart.axes.x.rangeScale.outerPaddingPx = chart.axes.x.scale.outerPaddingPx;
          if (chart.dataObject.hierarchical.groupByDiscreteTime) {
            chart.axes.x.rangeScale.domain(d3_range(chart.axes.x.scale.domain().length));
          }
          var rangeScaleUtils = hierarchical.setScaleForRange(chart.axes.x.rangeScale);
          hierarchical.pivotLayout.setRanges('column', rangeScaleUtils);
          chart.axes.x.levels.forEach(function (d, i) {
            chart.updateScale(axisorder, 'x', null, i + 1);
          });
          if (hierarchical.categoryTree) {
            axis.TickLabelFilter.updateTickEventHandler(chart, series.disabled, 'x');
          }
        }
        chart.drawThreshold(true);
        chart.updatePlotareaProp();
      } else if (chart.dataObject.isPolarAxisCategory) {
        axis.polar.render(chart, 'x');
      }

      stateChangeListener(chart, systemConfig.chart.axes.events, null, 'onreload');
      // update the events
      chart.events = {};
      chart.plot.renderer.draw(true);
      chart.drawPlotareaClippath();
      if (chart.isAxisCategory || chart.dataObject.isPolarAxisCategory) {
        chart.positionEventTrackerElement();
        if (chart.systemConf.chart.width || chart.systemConf.chart.height) {
          chart.divScroll.defaultScroll(chart, 'addorremoveseries');
        }
      }

      if (chart.dataObject.pushFlattenAnnotation && chart.eventHandler.isSingleSource()) {
        chart.dataObject.pushFlattenAnnotation();
      }

      // #ZC2374
      if (chart.behaviouralEvents) {
        chart.behaviouralEvents.update();
      }

      if (chart.scroll && !(chart.racing && chart.racing.isInitiated)) {
        chart.scroll.update();
      }
    };
    Chart.prototype.removeSeries = removeSeries;
    Chart.prototype.addSeries = addSeries;
    /**
     * Add data point to single series or multiple series
     * @param seriesidx
     * @param point
     * @param shift
     */
    Chart.prototype.pushDataPoint = function (seriesidx, point, shift, paneIds) {
      var chart = this,
        isComboChart = chart.dataObject.isCombinationalChart,
        orderedSeriesdata = isComboChart ? renderer_helpers.arrangeSeriesRenderingOrder(chart) : chart.seriesdata,
        isPivot = chart.dataObject.pivot,
        hierarchical = chart.dataObject.hierarchical,
        facetRendering = hierarchical && hierarchical.facetRendering,
        gridlist,
        panes,
        containsStacked;

      if (facetRendering) {
        var pivotLayout = facetRendering && hierarchical.pivotLayout,
          layers = pivotLayout.getRootNodeList('layer');
        panes = layers.panes;
        gridlist = objectValues(panes);
      }

      // If series indices were not of ARRAY type, then convert it to array and process
      if (!Array.isArray(seriesidx)) {
        var seriesidx_arr = [],
          point_arr = [];
        seriesidx_arr.push(seriesidx);
        point_arr.push(point);
        seriesidx = seriesidx_arr;
        point = point_arr;
        if (isPivot) {
          paneIds = [paneIds];
        }
      }
      //Reset cache for data
      chart.cache.data = {};
      chart.cache.search = {};
      // chart.cache.correction = {};
      seriesidx.forEach(function (d, i) {
        var paneid = isPivot ? "".concat(paneIds[i][0], "_").concat(paneIds[i][1]) : '0_0',
          currOrdereddata = isPivot ? panes[paneid].data[d] : orderedSeriesdata[d],
          curSeriesidx = isComboChart && !isPivot ? currOrdereddata.seriesidx : d,
          series = DataProcessor.helpers.getSeriesdata(chart, paneid, curSeriesidx),
          renderer = isPivot ? hierarchical.gridOptions[paneid].renderer[curSeriesidx] : chart.renderer[curSeriesidx],
          stacked = renderer.commonRendererProp().stacked(),
          shiftPoint,
          shiftInfo,
          shiftCurSeries;

        shiftCurSeries = isArray$1(shift) ? shift[i] : shift;

        if (stacked) {
          containsStacked = true;
          series = removeDummyData(series);
          series.data[0].push(point[i]);
        }

        series.data[0].push(point[i]);
        chart.dataObject.flattenData([
        {
          seriesindex: curSeriesidx,
          subseriesindex: 0,
          index: isPivot ? panes[paneid].index : 0,
          data: [[point[i]]],
          row: isPivot ? paneIds[i][0] : null,
          column: isPivot ? paneIds[i][1] : null,
          rendererIndex: renderer.commonRendererProp().rendererIndex()
        }]);

        if (shiftCurSeries) {
          shiftPoint = series.data[0][0];
          var shiftedData = series.data[0].shift();
          shiftedData._filter = true;
          if (defined(renderer.shiftInfo())) {
            shiftInfo = renderer.shiftInfo();
            shiftInfo.count++;
          } else {
            shiftInfo = {};
            shiftInfo.count = 0;
          }
          shiftInfo.point = shiftPoint;
          shiftInfo.shiftedData = shiftedData;
          renderer.shiftInfo(shiftInfo);
        } else {
          renderer.shiftInfo(null);
        }

        // if (chart.ismultiy) {
        //     chart.updateScale(series, 'y');
        // }
      });
      if (isPivot) {
        //update pivot layout
        chart.dataObject.hierarchical.update(false);
        chart.dataObject.processedseriesData = chart.seriesdata = chart.dataObject.hierarchical.getSeries();
      }

      chart.dataObject.initialize();

      /*
      For stacked data, we need to remove the duplicate dummy data entries and need to add again the all data properly.
      Hence we are flatten all the series data again.
       */
      if (containsStacked) {
        chart.dataObject.flattenPoints = null;
        if (chart.renderer.length) {
          chart.dataObject.flattenData();
        }
      }
      //update x scale

      if (isPivot) {
        //update rows, columns scale
        updateScaleForPivot(chart);
        var axesCount = chart.axes.x.count;
        for (var i = 0; i < axesCount; i++) {
          chart.updateScale(null, 'x', null, i);
        }
        //update row scale
        //ZC2993 recalculate rowscale to find exact axis area on rotation of ticklabels
        updateScaleForPivot(chart, null, false);
      } else {
        chart.updateScale(null, 'x');
      }

      //update y scale
      if (isPivot) {
        var axesCount = chart.axes.y.count;
        for (var i = 0; i < axesCount; i++) {
          chart.updateScale(null, 'y', null, i);
        }
      } else {
        if (chart.ismultiy) {
          seriesidx.forEach(function (d, i) {
            var currOrdereddata = orderedSeriesdata[d],
              curSeriesidx = isComboChart ? currOrdereddata.seriesidx : d,
              series = chart.seriesdata[curSeriesidx];
            chart.updateScale(series, 'y');
          });
        } else {
          chart.updateScale(chart.seriesdata[0], 'y');
        }
      }

      //update plot and renderer
      chart.plot.renderer.draw(true);
      chart.drawThreshold(true);
      // chart.eventHandler.updateParams(chart);
    };

    /**
     *
     * @param seriesidx
     */

    Chart.prototype.popDataPoint = function (seriesidx) {
      var chart = this,
        series = chart.seriesdata[seriesidx];

      series.data.forEach(function (d) {
        d.pop();
      });
      chart.dataObject.initialize();
      chart.updateScale(series, 'x');
      chart.updateScale(series, 'y');
      chart.plot.renderer.draw(true);
      chart.drawThreshold(true);
      // chart.eventHandler.updateParams(chart);
    };

    /**************** Zooom ********************/

    /**
     *
     * @param seriesIndex
     * @param range
     */
    Chart.prototype.zoomX = function (seriesIndex, range) {
      var chart = this;
      chart.__enableZoom('x');
      _ZoomToDomain(chart.behaviouralEvents.eventManager, range, 'x', seriesIndex);
    };

    /**
     *
     * @param seriesIndex
     * @param range
     */
    Chart.prototype.zoomY = function (seriesIndex, range) {
      var chart = this;
      chart.__enableZoom('y');
      _ZoomToDomain(chart.behaviouralEvents.eventManager, range, 'y', seriesIndex);
    };

    /**
     *
     * @param seriesIndex
     * @param xrange
     * @param yrange
     */
    Chart.prototype.zoomXY = function (seriesIndex, xrange, yrange) {
      var chart = this;

      chart.__enableZoom('xy');
      _ZoomToDomain(chart.behaviouralEvents.eventManager, [xrange, yrange], 'xy', seriesIndex);
    };

    Chart.prototype.zoomReset = function () {
      var chart = this;
      chart.behaviouralEvents.eventManager.behaviours.PLOT_ZOOM.instance.reset();
    };

    /**
     *
     * @param type
     */
    Chart.prototype.brushON = function (type) {
      var chart = this;
      chart.__enableBrush(type);
    };

    /**
     *
     */
    Chart.prototype.brushOFF = function () {
      var chart = this;
      chart.__enableBrush(null);
    };

    Chart.prototype.brushX = function (seriesIndex, domain) {
      var chart = this;
      chart.__enableBrush('x');
      _BrushToDomain(chart.behaviouralEvents.eventManager, domain, 'x', seriesIndex);
    };

    Chart.prototype.brushY = function (seriesIndex, domain) {
      var chart = this;
      chart.__enableBrush('y');
      _BrushToDomain(chart.behaviouralEvents.eventManager, domain, 'y', seriesIndex);
    };

    Chart.prototype.brushXY = function (seriesIndex, domainX, domainY) {
      var chart = this;
      chart.__enableBrush('xy');
      _BrushToDomain(chart.behaviouralEvents.eventManager, [domainX, domainY], 'xy', seriesIndex);
    };

    /**
     *
     * @param type
     */
    Chart.prototype.changeZoomType = function (type) {
      var chart = this,
        systemConfig = chart.systemConf;

      if (!this.zoom) {
        //ZC1647 - M2.2 - To initialize systemconf.zoom only one time, else need to remove zoom obj from defaulttheme
        setDefaultOptions('zoom', systemConfig.chart, chart.globalProp);
      }
      systemConfig.chart.zoom.type = type;
    };

    function addColorColumnToMeta(chart) {
      var dataSplicer = chart.dataSplicer,
        systemConf = chart.systemConf,
        metadata_axes = dataSplicer.getEncode(),
        metadata_columns = dataSplicer.getColumns(),
        facetHierarchy = systemConf.facets,
        singleChartTypes = [PIE_CHARTNAME, FUNNEL_CHARTNAME, PYRAMID_CHARTNAME],
        hasSingleChartType = getUniqueChartTypes(chart).
        values().
        some(function (_) {return arrayIncludes(singleChartTypes, _);});
      var xColumn = metadata_columns[metadata_axes.x[0]],
        xDataType = xColumn.datatype;

      if (
      facetHierarchy &&
      !(metadata_axes.clr && metadata_axes.clr.length) &&
      !(systemConf.facets.color && systemConf.facets.color.length) &&
      hasSingleChartType)
      {
        systemConf.metadata.axes.clr = [metadata_axes.x[0]];
        setPropVal(chart.userdata, 'legend._dummy', true);
        setPropVal(chart.systemConf, 'legend._dummy', true);

        if (xDataType === ORDINAL_DATATYPE) {
          if (!isObjectPropDefined(xColumn.ordinal, 'nullformatting')) {
            setPropVal(xColumn, 'ordinal.nullformatting', 'null');
            setPropVal(xColumn, 'ordinal._dummyNullformatting', true);
          }
          var nullFormatter = isObjectPropDefined(xColumn.ordinal, 'nullformatting', true) || 'null';
          setPropVal(chart.userdata, 'legend.colorBand.nullAs', nullFormatter);
          setPropVal(chart.systemConf, 'legend.colorBand.nullAs', nullFormatter);
        }
      } else if (!hasSingleChartType && getPropVal(chart.userdata, 'legend._dummy')) {
        delete systemConf.metadata.axes.clr;
        setPropVal(chart.userdata, 'legend._dummy', undefined);
        setPropVal(chart.systemConf, 'legend._dummy', undefined);

        if (xDataType === ORDINAL_DATATYPE) {
          if (isObjectPropDefined(xColumn.ordinal, '_dummyNullformatting')) {
            setPropVal(xColumn, 'ordinal.nullformatting', undefined);
            setPropVal(xColumn, 'ordinal._dummyNullformatting', undefined);
          }

          setPropVal(chart.userdata, 'legend.colorBand.nullAs', undefined);
          setPropVal(chart.systemConf, 'legend.colorBand.nullAs', undefined);
        }
      }
    }

    /**
     *
     * @type {Chart}
     */

    // })($ZC);

    defaultTheme.notes = function (userProp) {
      return {
        enabled: false,
        chartValues: [
          //example
          //                      {
          //                        "text": "notesText",
          //                        "x": 0,
          //                        "y": "50%"
          //                      }
        ],
        plotValues: [
          //single series bar example data
          //                              {
          //                                 "data": [2010,57],
          //                                 "text": "High value"
          //                             }
          //multiseries area,stacked area,line,scatter example data
          //                             {
          //                                 "data": [1356978600000,6,"West"],
          //                                 "text": "High value"
          //                             }
        ],
        blockValues: [
          //  {
          //    "htmlEl": "Annotate here",
          //    "hAlign": "center",
          //    "vAlign": "bottom",
          //    "type" : "customNote"
          // }
        ],
        type: 'stickyNote', //stickyNote || customNote
        options: {
          stickyNote: {
            headWidth: 15,
            headHeight: 15,
            bodyWidth: 100,
            bodyHeight: 100,
            fontSize: userProp.fontL1Size.l5,
            color: [
            '#F0F8FF',
            '#FFE4C4',
            '#DCDCDC',
            '#ADFF2F',
            '#90EE90',
            '#87CEFA',
            '#FFC0CB',
            '#B0E0E6',
            '#D2B48C',
            '#D8BFD8',
            '#EE82EE',
            '#F5DEB3'],

            mode: 'close', //open || close
            border: '1px solid grey'
          },
          customNote: {
            fontSize: userProp.fontL1Size.l5
          }
        }
      };
    };

    //annotation.js

    var annotation = function annotation() {};
    Registry.setComponent('annotation', annotation);

    function getBarCommonOption(conf, index, legendOrder, paneid) {
      legendOrder = pick(legendOrder, index);
      var rp = conf.params,
        stacked = rp.stacked,
        chartObj = rp.chartObj,
        yscale = rp.yscale,
        processor = chartObj.dataObject,
        barDataSetIndex = chartObj.renderer[index].barDatasetIndex ? chartObj.renderer[index].barDatasetIndex() : 0,
        commonPlotOptions = rp.commonPlotOptions,
        cType_Obj = getChartTypeByIndex(chartObj, paneid, legendOrder),
        cType = cType_Obj.name,
        isBullet = cType == 'bullet',
        plotoptions = (chartObj.seriesdata[legendOrder] || chartObj.seriesdata[0]).plotoptions,
        levelMarker =
        plotoptions && plotoptions.levelMarker ?
        mergeJSON$1(commonPlotOptions.levelMarker, plotoptions.levelMarker, true) :
        commonPlotOptions.levelMarker,
        levelMarkerOptions = commonPlotOptions.levelMarker || {};

      var wid = chartObj.barscale2.bandwidth() || 0,
        levelMarkerWidth = wid,
        barWidth = +(commonPlotOptions.bandWidth || null) || (isBullet ? wid / 3 : wid);

      var levelMarkerBandWidth = +(levelMarkerOptions.bandWidth || wid),
        levelMarkerMaxBandWidth = +(levelMarkerOptions.maxBandWidth || wid),
        maxBandWidth = invokeFunction(commonPlotOptions.maxBandWidth, chartObj.barscale1, chartObj);
      maxBandWidth = maxBandWidth < 0 ? null : maxBandWidth;
      maxBandWidth = +(maxBandWidth || wid); //setting bandwidth if the actual bandwidth is greater than the maximum bar bandwidth

      levelMarkerWidth = mathMin(levelMarkerBandWidth, levelMarkerMaxBandWidth, wid);
      barWidth = mathMin(barWidth, maxBandWidth, wid);

      var barPadding = mathMax(0, (wid - barWidth) / 2),
        levelMarkerPadding = mathMax(0, (wid - levelMarkerWidth) / 2);

      var addRangeBand = function addRangeBand() {
        return yscale.bandwidth ? yscale.bandwidth() / 2 : 0;
      };

      var stackGroupIndex;
      if (stacked) {
        var allChartTypes = processor.allChartTypes,
          stackGroup = processor.getStackGroup(),
          callback = function callback(d) {return d.some(function (seriesIndex) {return !chartObj.seriesdata[seriesIndex].disabled && isBarChartType(allChartTypes[seriesIndex]);});},
          stackBarEncodes = stackGroup.filter(callback);

        stackGroupIndex = processor.categoryHierarchy ? 0 : getStackGroupIndex(stackBarEncodes, index);
      } else {
        stackGroupIndex = 0;
      }

      var commonOption = {
        stacked: stacked,
        categories: rp.xscale.domain(),
        axisrotated: rp.axisrotated,
        bandwidth1: rp.xscale,
        bandwidth2: chartObj.barscale2,
        barDatasetIndex: barDataSetIndex,
        padding: barPadding,
        yscale: yscale,
        hasNegValue: rp.hasNegValue,
        yaxiscolumnorder: rp.yaxiscolumnorder,
        addRangeBand: addRangeBand,
        barWidth: barWidth,
        charttype: cType,
        levelMarker: levelMarker,
        levelMarkerWidth: levelMarkerWidth,
        levelMarkerPadding: levelMarkerPadding,
        stackGroupIndex: stackGroupIndex
      };

      chartObj.renderer[index].commonOption = commonOption;
      return commonOption;
    }

    //$Id$

    function generateDataForAnnotation(d, seriesname) {
      var clonedata = (d.data || d).slice();
      var data = clonedata.splice(0, clonedata.length);
      if (seriesname != null) {
        data.push(seriesname);
      }
      return data;
    }

    function saveAnnotation$1(noteConf, id, text, coordinate, annotationType) {
      if (annotationType == 'plot') {
        noteConf.plotValues.push({
          data: id,
          text: text
        });
      } else {
        noteConf["".concat(annotationType, "Values")].push({
          id: id,
          text: text,
          x: coordinate[0],
          y: coordinate[1]
        });
      }
    }

    function getCoordinateWithinBound(left, top, width, height, chartWidth, chartHeight) {
      // TODO I have to check with remila akka.
      if (left + width > chartWidth) {
        left = left - (left + width - chartWidth);
      }
      if (top + height > chartHeight) {
        top = top - (top + height - chartHeight);
      }
      return [left, top];
    }

    function getAnnotationIndex(noteConf, id, basedOn) {
      var conf = noteConf["".concat(basedOn, "Values")];
      return conf.indexOf(
      conf.filter(function (d) {
        return basedOn === 'plot' ? jsonStringify(d.data) == jsonStringify(id) : d.id == id;
      })[0]);

    }

    //$Id$

    annotation.draw = function (chart, notesArray) {

      var notes = chart.systemConf.notes,
        notesEnabled = defined(notes) && notes.enabled === true;
      chart.notesParent = new Array(0);

      if (notesEnabled) {
        var isPolar = chart.dataObject.isPolarAxisCategory,
          isFlow = chart.dataObject.isFlowChartCategory,
          chartAnnotations = pick(notes.chartValues, []),
          annotationByData = [];

        chartAnnotations.forEach(function (d) {
          annotation.addNotes(chart, {
            coordinate: [d.x, d.y],
            conf: d
          });
        });

        chart.dataObject.annotation.forEach(function (_) {
          var seriesIndex = _.seriesIndex;
          annotationByData[seriesIndex] = annotationByData[seriesIndex] || [];
          annotationByData[seriesIndex].push(_);
        });

        if (chart.isAxisCategory || isPolar || chart.isGeoMap || isFlow) {var _loop4 = function _loop4()
          {
            renderer = chart.renderer[i];
            if (chart.plot.renderer.mode === 'image') {
              renderer_helpers.setRendererProp(chart, renderer, chart.seriesdata, i, i, {
                image: true
              });
            }
            rp = chart.rendererConf[i].params;

            xscale = rp.xscale,
            yscale = rp.yscale,
            stacked = rp.stacked,
            index = rp.datasetIndex,
            legendOrderIndex = rp.legendOrderIndex,
            rendererIndex = rp.rendererIndex,
            axisrotated = rp.axisrotated,
            yaxiscolumnorder = rp.yaxiscolumnorder,

            cType = chart.chartTypes[index].value;

            if (!chart.isGeoMap && !isFlow) {
              categories = chart.dataset.getDataType('x') == ORDINAL_DATATYPE ? xscale.domain() : chart.dataObject.getCategories('x');
            }

            if (isBarChartType(cType)) {
              commonOption = getBarCommonOption(chart.rendererConf[index], index, legendOrderIndex); // TODO: PIVOT
              xy = function xy(dt, i, j) {
                return [
                chart.dataObject.getTransRectValue('x', dt, i, j, commonOption),
                chart.dataObject.getTransRectValue('y', dt, i, j, commonOption)];

              };
            } else {
              var yrangePos = rp.isRangeChart ? 1 : null,
                dxy = isPolar ? [chart.plotarea_approx.x, chart.plotarea_approx.y] : [0, 0];
              xy = function xy(dt) {
                return [
                chart.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, dt, 'x', null, yrangePos) +
                dxy[0],
                chart.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, dt, 'y', null, yrangePos) +
                dxy[1]];

              };
            }
            notesArray = annotation.preprocessAnnotations(
            chart.seriesdata,
            index,
            xy,
            notesArray,
            chart,
            rp,
            categories,
            annotationByData[i]);

          };for (var i = 0, len = chart.seriesdata.length; i < len; i++) {var renderer, rp, xy, xscale, yscale, stacked, index, legendOrderIndex, rendererIndex, axisrotated, yaxiscolumnorder, categories, cType, commonOption;_loop4();}
        }
        notesArray.forEach(function (d) {
          annotation.addNotes(chart, d);
        });
      }
      notesArray = [];
      return notesArray;
    };
    annotation.addNotes = function (chart, args) {
      var noteConf = chart.systemConf.notes,
        plotarea = chart.plotarea,
        canvasarea = chart.canvasarea,
        chartWidth = pick(chart.systemConf.chart.width, canvasarea.width),
        chartHeight = pick(chart.systemConf.chart.height, canvasarea.height),
        coordinate = args.coordinate,
        basedOn = args.basedOn || 'chart',
        annotationData = args.data,
        val = args.conf || {},
        disabled = chart.defaultScroll ? false : args.disabled,
        displayMode = pick(val.type, noteConf.type, 'stickyNote'),
        baseBoundary = basedOn === 'block' || basedOn === 'plot' ? plotarea : canvasarea,
        overflow = val.overflow || noteConf.overflow || 'scroll',
        maxWidth,
        maxHeight,
        overflowX,
        overflowY;

      if (basedOn === 'block') {
        overflowX = overflow === 'scroll' ? 'auto' : 'hidden';
        maxWidth = perToPx(noteConf.maxWidth || '100%', baseBoundary.width);
      }
      if (basedOn === 'block') {
        overflowY = overflow === 'scroll' ? 'auto' : 'hidden';
        maxHeight = perToPx(noteConf.maxHeight || '10%', baseBoundary.height);
      }

      var id =
      basedOn == 'plot' ?
      jsonStringify(annotationData) + pick(args.index, '') :
      basedOn == 'block' ?
      generateIdByPropValue(val, '') :
      jsonStringify(args.conf);
      id = basedOn != 'plot' && val.id != null ? val.id : basedOn + replaceSpecialCharWithName(id);

      // check again
      val.id = id;
      //
      var annotationRenderer = annotation[displayMode === 'stickyNote' ? 'stickyNote' : 'customNote'](),
        conf = getMergedConfig(noteConf, args, displayMode);

      var container,
        annotationNode,
        parent = conf.parent,
        _svg = false;

      if (parent) {
        parent = invokeFunction(parent, chart);
        parent = parent.isD3Selection ? parent : d3_select(parent);
        _svg = isSvgElement(parent);
        annotationNode = appendEle(parent, _svg ? 'g' : 'div', [args], '#', 'id', id);
        annotationNode.style('display', disabled ? NONE : null);
      } else {
        container = appendEle(chart.notes, 'div', [1], '#', 'id', basedOn);
        container.styles({ width: '0', height: '0' });
        annotationNode = appendEle(container, 'div', [args], '#', 'id', id);
      }
      if (basedOn == 'plot') {
        chart.notesParent.push(annotationNode);
      }

      var _s = annotationNode.node().getAttribute('style');
      if (!_svg && !(_s && chart.racing && chart.racing.syncTransition)) {
        annotationNode.styles({
          display: disabled ? NONE : null,
          position: 'absolute',
          left: '0', // Position at left:0 & top:0. Else on redraw the annotation may be wrapped as it's previous position is out of div's current position. (e.g: threshold-02.json)
          top: '0',
          'overflow-x': overflowX,
          'overflow-y': overflowY,
          'max-width': defined(maxWidth) ? maxWidth + PX : NULL$1,
          'max-height': defined(maxHeight) ? maxHeight + PX : NULL$1
        });
      }

      chart._annotation = null; // TODO: check

      annotationNode.attr('class', 'zc-annotation');
      annotationRenderer.chartObj(chart).conf(conf);

      applyFont(annotationNode, [conf, chart.systemConf.canvas, $ZCG], _svg ? false : true);
      annotationNode.call(annotationRenderer);

      if (disabled) {
        return;
      }

      var ele = annotationNode.node();
      var BW =
        displayMode === 'stickyNote' ?
        mathMax(
        parseFloat(annotationNode.selectAll('.head').style('width')),
        parseFloat(annotationNode.selectAll('.body').style('width'))) :

        0,
        BH =
        displayMode === 'stickyNote' ?
        parseFloat(annotationNode.selectAll('.head').style('height')) +
        parseFloat(annotationNode.selectAll('.body').style('height')) :
        0;

      coordinate = coordinate.map(function (d, i) {
        var position =
        basedOn === 'plot' ?
        d + chart.plotarea[i == 0 ? LEFT_ALIGN : TOP_ALIGN] //plot annotation
        : invokeFunction(d, chart, val, ele);
        return isNaN(+position) //Contains '%'
        ? perToPx(d, i == 0 ? chartWidth : chartHeight, 0) :
        position;
      });

      var transform = basedOn === 'plot' || basedOn === 'block' ? conf.transform : null;
      coordinate = invokeFunction(transform, chart, val, ele, coordinate) || coordinate;

      annotationRenderer.coordinate(coordinate);
      coordinate = getCoordinateWithinBound(coordinate[0], coordinate[1], BW, BH, chartWidth, chartHeight);


      if (_svg) {
        annotationNode.attr('transform', translateString(coordinate));
      } else {
        if (_s && chart.racing && chart.racing.syncTransition) {
          annotationNode.interrupt();
          annotationNode.transition(chart.racing.syncTransition).styles({
            left: coordinate[0] + PX,
            top: coordinate[1] + PX
          });
        } else {
          annotationNode.styles({
            left: coordinate[0] + PX,
            top: coordinate[1] + PX
          });
        }
      }

      if (basedOn === 'plot') {
        addEvent(chart._annotation, coordinate, annotationData, chart, conf); // TODO: check
      }

      // check again
      var dt = basedOn == 'plot' ? annotationData : id;
      var index = getAnnotationIndex(noteConf, dt, basedOn, args.index);
      if (!defined(args.index) && index == -1) {
        saveAnnotation$1(noteConf, dt, '', args.coordinate, basedOn);
      }
      //
      return annotationNode;
    };
    //Preprocessor for plot annotations to get the coordinate
    annotation.preprocessAnnotations = function (seriesdata, idx, coordinate, notesArray, chartObj, rp, categories) {var _annotationByData = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];
      if (chartObj.destroying) {
        return;
      }

      var notes = chartObj.systemConf.notes;

      if (!defined(notes) || !defined(notes.enabled) || notes.enabled === false) {
        //as in default systemconf there will be no notes object
        return notesArray;
      }

      var notesConf = notes.plotValues,
        isAxisCat = chartObj.isAxisCategory,
        isNonAxisMultiSeriesCat = chartObj.isNonAxisMultiSeriesCategory,
        dataset = chartObj.dataset,
        stacked = rp.stacked,
        plotarea = chartObj.plotarea,
        yaxiscolumnorder = rp.yaxiscolumnorder,
        curSeries = seriesdata[idx],
        isWithin = geometryUtils.pointInRectangle;

      var curData = chartObj.dataObject.isHierarchy ? curSeries : curSeries.data,
        serName = (isAxisCat || isNonAxisMultiSeriesCat) && seriesdata.length > 1 ? curSeries.seriesname : null,
        cType = chartObj.chartTypes[idx].name,
        seriesnames =
        chartObj.dataObject.seriesNames || (
        chartObj.dataObject.seriesNames = chartObj.seriesdata.map(function (d) {
          return d.seriesname;
        })); //Collect the series names

      var filteredNotes =
      isAxisCat && seriesdata.length > 1 ?
      notesConf.filter(function (d) {
        var s = d.data[d.data.length - 1];
        return serName == s || seriesnames.indexOf(s) == -1;
      }) :
      notesConf;
      filteredNotes.forEach(function (curNote, i) {
        var found = false,
          nData = curNote.data;
        for (var subseries = 0, slen = isAxisCat ? curData.length : 1; subseries < slen && !found; subseries++) {
          for (var j = 0, len = curData[subseries].length; j < len && !found; j++) {
            var dt = curData[subseries][j];
            var data = generateDataForAnnotation(dt, serName);
            if (jsonStringify(data) == jsonStringify(nData)) {
              found = true;
              var pos = coordinate(dt, subseries, j);
              var disabled =
              isAxisCat && !isWithin(pos, plotarea) // Exclude if the data is out of domain
              ? true :
              isAxisCat || isNonAxisMultiSeriesCat ?
              curSeries.disabled :
              dt.disabled;
              disabled = disabled || !isDataActive(dt, chartObj);
              pushNotes(pos, data, curNote, disabled);
            }
          }
        }
        if (isAxisCat && !found && (cType === 'bar' ? categories.indexOf(dataset.getX(nData)) != -1 : true)) {
          //Non data points
          found = true;
          var dt = generateDataForAnnotation(nData);
          if (stacked) {
            dt.y = dataset.getY(nData, yaxiscolumnorder);
            dt.y0 = 0;
          }
          var pos = coordinate(dt, 0, j);
          var disabled =
          isAxisCat && !isWithin(pos, plotarea) // Exclude if the data is out of domain
          ? true :
          isAxisCat && seriesdata.length > 1 && seriesnames.indexOf(nData[nData.length - 1]) == -1 //Non data points in multi series chart
          ? false :
          curSeries.disabled;
          pushNotes(pos, dt, curNote, disabled);
        }
        if (!found && cType === 'sunburst') {
          // Sunburst parent arc
          var parentData = [serName, curSeries.value];
          if (jsonStringify(parentData) === jsonStringify(nData)) {
            pushNotes(coordinate(curSeries), parentData, curNote, curSeries.disabled);
          }
        }

        // sankey node annotation
        // related to #ZC2643 & #2654
        if (!found && cType === SANKEY_CHARTNAME) {
          var node = chartObj.renderer[0].getSankeyNodeByPoint(nData);

          if (node) {
            var dataObj = chartObj.dataset,
              nodeData = [];
            nodeData[dataObj.xidx] = nodeData[dataObj.yidx(0)] = node.name;
            nodeData[dataObj.zidx] = node.value;

            if (jsonStringify(nodeData) === jsonStringify(nData)) {
              pushNotes(coordinate(nData), nodeData, curNote);
            }
          } else {
            pushNotes([null, null], nData, curNote, true);
          }
        }
      });

      _annotationByData.forEach(function (_) {
        var subSeriesIndex = _.subSeriesIndex,itemIndex = _.itemIndex,dt = _.data,
          data = dt.data || dt,
          noteVal = dt[notes.dataIndex],
          pos = coordinate(dt, subSeriesIndex, itemIndex),
          disabled =
          isAxisCat && !isWithin(pos, plotarea) // Exclude if the data is out of domain
          ? true :
          isAxisCat || isNonAxisMultiSeriesCat ?
          curSeries.disabled :
          dt.disabled;
        disabled = disabled || !isDataActive(dt, chartObj);
        splat(noteVal).forEach(function (_, i) {
          var conf = invokeFunction(_, data, chartObj) || {};
          pushNotes(pos, data, _objectSpread(_objectSpread({}, conf), {}, { data: data }), disabled, i);
        });
      });
      var seriesData = chartObj.userdata.seriesdata.chartdata;
      if (seriesData && filteredNotes.length && chartObj.seriesAddRemoveDetails) {
        //this execution occurs all the time after adding or removing a series
        notesArray.map(function (d) {
          var exist = false;
          seriesData.map(function (series) {
            if (series.seriesname === d.data[2]) {
              exist = true;
            }
          });
          if (!exist) {
            d.disabled = true;
          }
        });
      }
      return notesArray;

      function pushNotes(coordinate, data, conf, disabled, index) {
        notesArray.push({
          coordinate: coordinate,
          data: data,
          conf: conf,
          disabled: disabled,
          basedOn: 'plot',
          index: index
        });
      }
    };

    annotation.addBlockAnnotations = function (chart) {
      var notes = chart.systemConf.notes;

      if (!defined(notes) || notes.enabled === false) {
        return;
      }

      var defaultAnnotationOptions = setDefaultOptions('notes', chart.systemConf, chart.globalProp);
      notes = chart.systemConf.notes;
      var blockAnnotations = notes.blockValues,
        plotarea = chart.plotarea,
        maxWidth = perToPx(notes.maxWidth || '100%', plotarea.width),
        maxHeight = perToPx(notes.maxHeight || '10%', plotarea.height),
        drawnAtBottom,
        drawnAtTop,
        PW = plotarea.width,
        PH = plotarea.height,
        PL = plotarea.left,
        PT = plotarea.top,
        PB = plotarea.bottom;

      blockAnnotations.forEach(function (d) {
        var hAlign = d.hAlign,
          vAlign = d.vAlign,
          overflow = d.overflow || notes.overflow || 'scroll',
          isRight = hAlign === RIGHT_ALIGN,
          isLeft = hAlign === LEFT_ALIGN,
          isTop = vAlign === TOP_ALIGN,
          isBottom = vAlign === BOTTOM_ALIGN;

        if (!(drawnAtTop && isTop || drawnAtBottom && isBottom)) {
          var xFunc = function xFunc(chart, val, ele) {
              var bound = ele.getBoundingClientRect();
              var x = isRight ? PL + PW : isLeft ? PL : PL + PW / 2,
                dx = isRight ? bound.width : isLeft ? 0 : bound.width / 2;
              return mathMax(x - dx, 0);
            },
            yFunc = function yFunc(chart, val, ele) {
              var bound = ele.getBoundingClientRect();
              var y = isTop ? PT : PT + PH,
                dy = isTop ? 0 : bound.height;
              return y - dy;
            };

          var note = annotation.addNotes(chart, {
            coordinate: [xFunc, yFunc],
            conf: d,
            basedOn: 'block'
          });

          var noteEle = note.node(),
            bound = noteEle.getBoundingClientRect(),
            bHei = bound.height,
            bWid = bound.width;

          //overflow:fire
          if (overflow === 'fire' && (noteEle.scrollHeight > maxHeight || noteEle.scrollWidth > maxWidth)) {
            note.remove();
          } else {
            plotarea.height = PH - bHei;
            if (isTop) {
              plotarea.top = PT + bHei;
            } else if (isBottom) {
              plotarea.bottom = PB + bHei;
            }
          }

          drawnAtTop = drawnAtTop || isTop;
          drawnAtBottom = drawnAtBottom || isBottom;
        }
      });
    };

    function replaceSpecialCharWithName(str) {
      // ZC2984
      // replace(/[`~!@#$%^&*( )_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '')
      return str.
      replace(/\`/gi, '_tilde_').
      replace(/\~/gi, '_acute_').
      replace(/\!/gi, '_exclamation_mark_').
      replace(/\@/gi, '_at_').
      replace(/\#/gi, '_hash_').
      replace(/\$/gi, '_dollar_').
      replace(/\%/gi, '_percent_').
      replace(/\^/gi, '_caret_').
      replace(/\&/gi, '_ampersand_').
      replace(/\*/gi, '_asterisk_').
      replace(/\(/gi, '_left_parenthesis_').
      replace(/ /gi, '_space_').
      replace(/\)/gi, '_right_parenthesis_').
      replace(/\_/gi, '_underscore_').
      replace(/\|/gi, '_pipe_').
      replace(/\+/gi, '_plus_').
      replace(/\-/gi, '_minus_').
      replace(/\=/gi, '_equal_').
      replace(/\?/gi, '_question_mark_').
      replace(/\;/gi, '_semi_colon_').
      replace(/\:/gi, '_colon_').
      replace(/\'/gi, '_single_quote_').
      replace(/\"/gi, '_double_quote_').
      replace(/\,/gi, '_comma_').
      replace(/\./gi, '_dot_').
      replace(/\</gi, '_less_than_').
      replace(/\>/gi, '_greater_than_').
      replace(/\{/gi, '_left_brace_').
      replace(/\}/gi, '_right_brace').
      replace(/\[/gi, '_open_bracket_').
      replace(/\]/gi, '_close_bracket_').
      replace(/\\/gi, '_backslash_').
      replace(/\//gi, '_forwardslash_');
    }

    function getMergedConfig(noteConf, args, displayMode) {
      var batch = args.conf && args.conf.batch,
        batchOptions = noteConf.batch,
        _options = noteConf.options,
        baseConfig = batch && batchOptions[batch] ? mergeJSON$1(_options[displayMode], batchOptions[batch], true) : _options[displayMode];
      return mergeJSON$1(baseConfig, args.conf || {}, true);
    }

    function addEvent(root, xy, _data, chart, conf) {
      if (!root) {
        return;
      }

      var children = root.children,_root$config2 = root.config,config = _root$config2 === void 0 ? {} : _root$config2,_root$data2 = root.data,data = _root$data2 === void 0 ? [1] : _root$data2,_config$x =
        config.x,x = _config$x === void 0 ? 0 : _config$x,_config$y = config.y,y = _config$y === void 0 ? 0 : _config$y,
        newXY = [xy[0] + getVal(x, [_data]), xy[1] + getVal(y, [_data])];

      if (root.event) {
        chart.annotation.events.push({ parser: root, xy: newXY, data: _data, conf: conf });
      }

      if (children && children.length) {
        children.forEach(function (_) {return addEvent(_, newXY, _data, chart, conf);});
      }
    }

    //$Id$

    annotation.customNote = function () {
      var conf, coordinate, chartObj;

      function annotationComp(selection) {
        selection.each(function (args) {var _this17 = this;
          d3_select(this).each(function () {
            var thisElement = d3_select(_this17);

            if (conf.parser && !(!args.conf.parser && args.conf.htmlEl)) {
              var parser = invokeFunction(conf.parser, chartObj, args.conf || conf);
              renderDom(parser, thisElement);
              chartObj._annotation = parser; // TODO: check
              return;
            }

            var customContent = invokeFunction(conf.htmlEl, chartObj, args.conf || conf);

            if (customContent && (customContent.isD3Selection || customContent.nodeType === 1)) {
              thisElement.html(''); // remove everything
              var el = customContent.isD3Selection ? customContent.node() : customContent;
              if (el.nodeType === 1) {
                _this17.appendChild($Browser.IE ? el.cloneNode(true) : el); // ZC2382
              }
            } else {
              thisElement.html(customContent);
            }
          });
        });
      }
      annotationComp.coordinate = function (_) {
        if (!arguments.length) {
          return coordinate;
        }
        coordinate = _;
        return annotationComp;
      };
      annotationComp.conf = function (_) {
        if (!arguments.length) {
          return conf;
        }
        conf = _;
        return annotationComp;
      };
      annotationComp.chartObj = function (_) {
        if (!arguments.length) {
          return chartObj;
        }
        chartObj = _;
        return annotationComp;
      };
      return annotationComp;
    };

    //$Id$
    /*
     * z-index check
     * textarea resize
     * While opening a note, check within the plot
     * dragging
     */
    annotation.stickyNote = function () {
      var chartObj, conf, coordinate;

      function annotationComp(selection) {
        selection.each(function (args) {
          var container = d3_select(this);
          var noteConf = chartObj.systemConf.notes,
            chartWidth = chartObj.canvasarea.width,
            chartHeight = chartObj.canvasarea.height,
            notesWrap = chartObj.notes;

          var basedOn = args.basedOn || 'chart',
            annotationData = args.data,
            // disabled = args.disabled,
            xy = args.coordinate;

          var xInPercent = typeof xy[0] === 'string' && xy[0].indexOf('%') > -1,
            yInPercent = typeof xy[1] === 'string' && xy[1].indexOf('%') > -1;

          var text = conf.text,
            colorIndex = notesWrap.selectAll('.head').size(),
            bgColor = conf.color,
            open = conf.mode === 'open',
            bodyWidth = validateNullVal(conf.bodyWidth, 100),
            bodyHeight = validateNullVal(conf.bodyHeight, 100),
            headWidth = validateNullVal(conf.headWidth, 15),
            headHeight = validateNullVal(conf.headHeight, 15),
            toggle = open ? 0 : 1,
            cache = basedOn === 'plot' ? args.conf.data : args.conf;
          bgColor = isArray$1(bgColor) ? bgColor[colorIndex % bgColor.length] : bgColor;

          if (!cache._color) {
            cache._color = bgColor;
          }

          //Drag behaviour
          var drag = d3_drag().on('drag', function (d, i) {
            if (d3_event().defaultPrevented) {
              return;
            }
            // d3_event().sourceEvent.stopPropagation();
            var parentEle = d3_select(this.parentNode);
            var x = parseFloat(parentEle.style('left')) + d3_event().x,
              y = parseFloat(parentEle.style('top')) + d3_event().y,
              w = mathMax(toggle % 2 != 0 ? 0 : bodyWidth, headWidth),
              h = (toggle % 2 != 0 ? 0 : bodyHeight) + headHeight;
            x = x > chartWidth - w ? chartWidth - w : x < 0 ? 0 : x;
            y = y > chartHeight - h ? chartHeight - h : y < 0 ? 0 : y;
            coordinate[0] = x, coordinate[1] = y;
            var leftVal = x + PX,
              topVal = y + PX;

            parentEle.styles({
              left: leftVal,
              top: topVal
            });
            if (basedOn != 'plot') {
              var iden = parentEle.attr('id');
              var index = getAnnotationIndex(noteConf, iden, basedOn);
              if (index != -1) {
                noteConf.chartValues[index].x = xInPercent ? "".concat(x / chartWidth * 100, "%") : x;
                noteConf.chartValues[index].y = yInPercent ? "".concat(y / chartHeight * 100, "%") : y;
              }
            }
          });

          container.attr('class', 'group').styles({
            width: 0,
            height: 0,
            'z-index': 2
          });

          // Draw text area
          var textarea = appendEle(notesWrap, 'textarea', [1]);
          textarea.
          styles({
            width: bodyWidth + PX,
            height: bodyHeight + PX,
            position: 'absolute',
            'border-color': TRANSPARENT,
            'border-radius': (conf.bodyBorderRadius || 0) + PX,
            'background-color': TRANSPARENT,
            overflow: 'hidden',
            display: NONE,
            resize: NONE, //Need to implement textarea resize
            'z-index': 2,
            outline: NONE
          }).
          on('blur', function (d, i) {
            var baseEle = textarea.attr('eleID');
            textarea.style('display', NONE);
            if (baseEle != null) {
              var parentEle = d3_select("#".concat(baseEle));
              var bodyEle = parentEle.selectAll('.body');

              bodyEle.style('color', null);

              parentEle.style('z-index', 2);
            }
          }).
          on('input', function () {
            var curEle = d3_select(this);
            if (curEle.style('display') === NONE) {
              return;
            }
            var parentEle = d3_select("#".concat(curEle.attr('eleID')));
            var noteEle = parentEle.selectAll('.body');
            var iden = parentEle.attr('id'),
              txt = textarea.node().value,
              datum = parentEle.datum();
            var basedOn = datum.basedOn || 'chart',
              annotationData = datum.data;
            noteEle.text(txt);
            var dt = basedOn == 'plot' ? annotationData : iden;
            var index = getAnnotationIndex(noteConf, dt, basedOn);
            if (index == -1) {
              saveAnnotation$1(noteConf, dt, txt, xy, basedOn);
            } else {
              noteConf["".concat(basedOn, "Values")][index].text = txt;
            }
          }).
          text(text);

          // Draw head
          var head = appendEle(container, 'div', [1], '.', 'class', 'head');
          head.styles({
            width: headWidth + PX,
            height: headHeight + PX,
            border: conf.border,
            'border-radius': (conf.headBorderRadius || 0) + PX,
            'z-index': 'auto',
            'background-color': cache._color
          });
          // .call(drag);

          var click = function click(d, i) {
            if (d3_event().defaultPrevented) {
              return;
            }
            var close = toggle % 2 == 0;
            var bodyEle = d3_select(this.nextSibling),
              parentEle = d3_select(this.parentNode);
            textarea.on('blur')();

            if (!close) {
              var xy = getCoordinateWithinBound(
              parseFloat(parentEle.style('left')),
              parseFloat(parentEle.style('top')),
              bodyWidth,
              headHeight + bodyHeight,
              chartWidth,
              chartHeight);

              parentEle.styles({
                left: xy[0] + PX,
                top: xy[1] + PX
              });
            } else {
              parentEle.
              transition().
              delay(250).
              duration(0).
              styles({
                left: coordinate[0] + PX,
                top: coordinate[1] + PX
              });
            }

            bodyEle.
            style('color', null).
            transition().
            ease(d3_ease_linear).
            styles({
              width: close ? 0 + PX : bodyWidth + PX,
              height: close ? 0 + PX : bodyHeight + PX,
              display: close ? null : 'block'
            });

            bodyEle.
            transition().
            delay(250).
            style('display', close ? NONE : null);

            notesWrap.selectAll('.group').style('z-index', 1);
            parentEle.style('z-index', 2);

            toggle++;
          };
          var mouseHandlers = {
              click: click
            },
            touchHandlers = {
              tap: click
            };
          attachevents(head, mouseHandlers, touchHandlers);

          //Draw body
          var body = appendEle(container, 'div', [1], '.', 'class', 'body');
          body.styles({
            width: !open ? '0' : bodyWidth + PX,
            height: !open ? '0' : bodyHeight + PX,
            display: !open ? NONE : null,
            border: conf.border,
            overflow: 'hidden',
            'box-shadow': conf.shadow,
            'border-radius': (conf.bodyBorderRadius || 0) + PX,
            'z-index': 'auto',
            'background-color': cache._color
          }).text(text);

          var click = function click(d, i) {
            var curEle = d3_select(this),
              parentEle = d3_select(this.parentNode);
            textarea.on('blur')();
            textarea.
            styles({
              display: null,
              left: parentEle.style('left'),
              top: parseFloat(parentEle.style('top')) + headHeight + PX,
              color: parentEle.style('color'),
              'font-size': parentEle.style('font-size'),
              'font-family': parentEle.style('font-family'),
              'font-weight': parentEle.style('font-weight'),
              'font-style': parentEle.style('font-style')
            }).
            attr('eleID', parentEle.attr('id'));
            textarea.node().value = curEle.text();
            textarea.node().focus();

            curEle.style('color', TRANSPARENT);

            notesWrap.selectAll('.group').style('z-index', 1);
            parentEle.style('z-index', 2);
            textarea.style('z-index', 3);
          };
          var mouseHandlers = {
              click: click
            },
            touchHandlers = {
              tap: click
            };
          attachevents(body, mouseHandlers, touchHandlers);

          var customHTML = appendEle(container, 'div', conf.htmlEl ? [1] : [], '.', 'class', 'zcannotation-custom');
          customHTML.
          styles({
            position: 'absolute',
            left: 0,
            top: 0
          }).
          each(function () {
            var comp = annotation.
            customNote().
            conf(conf).
            chartObj(chartObj);
            d3_select(this).call(comp);
          });
        });
      }

      annotationComp.chartObj = function (_) {
        if (!arguments.length) {
          return chartObj;
        }
        chartObj = _;
        return annotationComp;
      };
      annotationComp.conf = function (_) {
        if (!arguments.length) {
          return conf;
        }
        conf = _;
        return annotationComp;
      };
      annotationComp.coordinate = function (_) {
        if (!arguments.length) {
          return coordinate;
        }
        coordinate = _;
        return annotationComp;
      };
      return annotationComp;
    };

    /**
     *
     * @constructor
     */
    function SHOW_SELECTION_BOX(instanceMap) {
      var eventManager = this,
        brushInstance = instanceMap.instance,
        brushOptions = eventManager.chart.systemConf.chart.brush;

      setStyles(brushInstance._selection, brushOptions.selectionArea);
    }

    /**
     *
     * @param instanceMap
     * @constructor
     */
    function HIDE_SELECTION_BOX(instanceMap) {
      instanceMap.instance.reset();
    }

    /**
     *
     * @param instanceMap
     * @param event
     * @constructor
     */
    function ChartBrushListener(instanceMap, event) {
      var eventManager = this;
      var data = eventManager.getData(instanceMap, event.type, event.selection),
        point = data.point;

      // fire the start event
      // if data fire
      if (event.type === 'start' || point.x || point.y) {
        eventManager.associateBehaviours(instanceMap, event.type, data, event.selection, event);
      }
    }

    /**
     *
     * @param instanceMap
     * @param selection
     * @param type
     */
    function ChartBrushDataFinder(instanceMap, type, selection, forced) {
      var eventManager = this,
        chart = eventManager.chart,
        brushInstance = instanceMap.instance,
        brushTypeOriginal = brushInstance.options.type,
        brushType = fixBrushDirection(brushTypeOriginal, chart.axes.rotated),
        brushedAxes = plotBrushed(selection, brushType, UNDEFINED, forced);

      // updated every time
      brushInstance.brushedAxes = brushedAxes;

      return CHART_DOMAIN_HELPERS.GET_DOMAIN_INFO(selection, brushedAxes, brushTypeOriginal, chart);
    }

    /**
     *
     * @param selection
     * @param type
     * @param mindist
     * @return {string[]}
     */
    function plotBrushed(selection, type) {var mindist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var forced = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var brushedAxes = {};
      if (!selection) {
        if (forced) {
          if (type === 'xy') {
            brushedAxes.x = brushedAxes.y = true;
          } else {
            brushedAxes[type] = true;
          }
        }
      } else {
        selection = splat(selection);
        if (type === 'xy') {
          var _selection4 = selection,_selection5 = _slicedToArray(_selection4, 2),x = _selection5[0],x1 = _selection5[1];
          brushedAxes = {
            x: x1[0] - x[0] > mindist,
            y: x1[1] - x[1] > mindist
          };
        } else {
          if (selection[1] - selection[0] > mindist) {
            brushedAxes[type] = true;
          }
        }
      }
      return Object.keys(brushedAxes).filter(function (axes) {return brushedAxes[axes];});
    }

    /**
     *
     * @param instanceMap
     * @param selectionManager
     * @constructor
     */

    function ClearOldInfo_C(instanceMap, selectionManager) {
      var eventManager = this,
        chart = eventManager.chart,
        chartEventManager = chart.eventHandler.eventManager;

      // clear the highlighted points
      clearHighlightContext(eventManager.chart);

      chart.eventHandler.tooltipElement.hide();
      chart.eventHandler.handlers.mouseout.call(chart.eventHandler);
    }

    var buttonCount = 0;var

    CustomButton = /*#__PURE__*/function () {
      function CustomButton(className, text, button, parent) {_classCallCheck(this, CustomButton);
        this.label = text;
        this.button = button;
        this.parent = parent;
        this.className = className;
        this.init();
      }_createClass(CustomButton, [{ key: "init", value:

        function init() {
          var button = this,
            padding = getMargin(button.button, 5),
            className = button.className ? '.' + button.className : ".custom-button-".concat(buttonCount++),
            group = button.group = createElement('g', className, [1], button.parent),
            rect = button._rect = createElement('rect', ".custom-button-rect", [1], group),
            text = button._text = createElement('text', ".custom-button-text", [1], group),
            fixRadius = function fixRadius(obj) {return obj.radius && (obj.rx = obj.ry = obj.radius);};

          text.text(button.label.text).attrs({ dy: '.9em' });
          setStyles(button._text, button.label.style);

          var boundingBox = getBoundingRect(text);
          var width = pick(button.button.width, boundingBox.width),
            height = pick(button.button.height, boundingBox.height),
            dimension = {
              width: width + padding.left + padding.right,
              height: height + padding.top + padding.bottom
            },
            textOffset = {
              x: dimension.width / 2 - boundingBox.width / 2,
              y: dimension.height / 2 - boundingBox.height / 2
            };

          // fix the radius
          fixRadius(button.button, dimension);

          //#ZC2153
          setStyles(rect, _objectSpread(_objectSpread({}, dimension), button.button), UNDEFINED, { width: 'width', height: 'height' });

          text.attrs(textOffset);
          button.group.styles({ cursor: POINTER });

          //save the bounds
          button.bounds = {
            text: _objectSpread(_objectSpread({},
            textOffset), {}, {
              width: boundingBox.width,
              height: boundingBox.height }),

            rect: dimension
          };
        } }, { key: "translate", value:

        function translate(_translate2) {
          this.group.attr('transform', "translate(".concat(_translate2.join(' '), ")"));
        } }, { key: "show", value:

        function show() {
          this.group.style('display', null);
        } }, { key: "hide", value:

        function hide() {
          this.group.style('display', 'none');
        } }]);return CustomButton;}();


    function PlotResetButtonAction() {
      var eventManager = this,
        chart = eventManager.chart,
        options = chart.systemConf.chart.brush,
        behaviours = eventManager.behaviours,
        plotBrushInstanceMap = behaviours.PLOT_BRUSH,
        plotZoomInstanceMap = behaviours.PLOT_ZOOM,
        domain;

      // reset saved [minRange, maxRange] for both axis
      options.x = options.y = null;

      // #ZC2379 call mouseout before the brush reset
      ClearOldInfo_C.call(eventManager);

      if (plotZoomInstanceMap) {
        plotZoomInstanceMap.instance.reset();
      } else if (chart.scroll && chart.scroll.visible) {
        chart.scroll.visiblePointCount = null;
        chart.scroll.brushInstance.setSelection(chart.scroll.brushInstance.getRange());
      } else {
        domain = ChartBrushDataFinder.apply(eventManager, [plotBrushInstanceMap, null, null, true]);

        // filter the to null domain
        CHART_DOMAIN_HELPERS.FILTER_CHART(domain, chart);
      }
      // hide it
      eventManager.resetButton.hide();
      //
      // update the brush extent
      plotBrushInstanceMap && plotBrushInstanceMap.instance.updateExtent([[0, 0], [chart.plotarea.width, chart.plotarea.height]]);
      // #ZC2123
      chart.positionEventTrackerElement();
    }

    /**
     *
     * @param behaviourEventInstance
     * @constructor
     */
    function ShowBrushResetButton(behaviourEventInstance) {
      // show the reset button

      var eventManager = this,
        button = getResetButton(eventManager.chart, eventManager);

      if (button) {
        button.show();
      }
    }
    /**
     *
     * @param {Chart} chart
     * @param {BehaviouralEventManager} eventManager
     * @return {*}
     */

    function getResetButton(chart, eventManager) {
      var scroll = chart.scroll,
        _chart = chart.systemConf.chart,
        brush = _chart.brush,
        behaviour = _chart.behaviour,
        isOverview = scroll && scroll.overviewEnabled,
        _scale = scroll && scroll.brushScale,
        _r = chart.overview && chart.overview.axes.x.scale.actualRange ? chart.overview.axes.x.scale.actualRange : _scale && _scale.range(),
        _s = scroll && scroll.brushInstance.getSelection();

      // if (!_r && scroll && !scroll.brushScale.bandwidth) {
      //     _r = _scale && _scale.brushScale;
      //     var padding = (_scale.range()[1] - _scale.range()[0]) * _scale.outerPadding;
      //     _r[0] = _r[0] + padding;
      //     _r[1] = _r[1] - padding;
      // }
      if (_r && _s) {
        var minRange = Number(Math.min(_r[0], _r[1]).toFixed(5)),
          maxRange = Number(Math.max(_r[0], _r[1]).toFixed(5)),

          minSelection = Number(Math.min(_s[0], _s[1]).toFixed(5)),
          maxSelection = Number(Math.max(_s[0], _s[1]).toFixed(5));
      }


      var commonReset = behaviour && behaviour.resetButton,
        brushReset = brush.resetButton,
        zoomDomain = chart.axes.x && chart.axes.x.zoomScale && chart.axes.x.zoomScale.domain(),
        noOverviewAction = isOverview && !(minSelection > minRange || maxSelection < maxRange),
        noZoomAction = zoomDomain && zoomDomain[0] === 0 && zoomDomain[1] === 100;

      if (noOverviewAction || noZoomAction) {
        eventManager.resetButton && eventManager.resetButton.hide();
        return;
      }
      // if (eventManager.resetButton) {
      //     return eventManager.resetButton;
      // }

      if (!(brush.enabled && brushReset && brushReset.enabled || commonReset && commonReset.enabled)) {
        return;
      }

      var resetButtonSettings = mergeJSON$1(commonReset, brushReset, true);

      var buttonOptions = getButtonOptions(resetButtonSettings, chart, defined(eventManager.behaviours.PLOT_ZOOM)),
        resetButton = eventManager.resetButton = new CustomButton(
        'custom-button-0',
        buttonOptions.label,
        buttonOptions.button,
        chart.staticPaneSVG.select('.eventgroup'));


      applyEffect(resetButton.group, { config: resetButtonSettings, chartObj: chart });

      // existing class name retain
      resetButton.group.classed('zmbtn', true);

      positionResetButton(chart);
      setResetButtonEvents(eventManager.resetButton, chart, resetButtonSettings);
      return resetButton;
    }
    function setResetButtonEvents(behaviourEvent, chart, resetData) {
      var eventsData = resetData.events,
        manager = chart.behaviouralEvents.eventManager;

      behaviourEvent.instance = behaviourEvent.group;
      behaviourEvent.defaultBehaviour = {
        click: function click(behaviourEvent, event, chartObj) {
          var eventManager = chartObj.behaviouralEvents.eventManager,
            resetButton = eventManager.resetButton;
          PlotResetButtonAction.call(eventManager, resetButton);
        },
        tap: function tap(behaviourEvent, event, chartObj) {
          var eventManager = chartObj.behaviouralEvents.eventManager,
            resetButton = eventManager.resetButton;
          PlotResetButtonAction.call(eventManager, resetButton);
        }
      };
      behaviourEvent.customBehaviour = {
        click: eventsData && eventsData.click,
        tap: eventsData && eventsData.tap
      };

      var event = d3_event({}),
        listeners = {
          click: function click() {
            event.type = 'click';
            _l(chart, event);
          },
          tap: function tap() {
            event.type = 'tap';
            _l(chart, event);
          }
        };
      manager.resetButton.listenerTypes = d3_set(['click', 'tap']);
      manager.attachListeners(manager.resetButton, listeners);

      var _l = function _l(chart, event) {
        var manager = chart.behaviouralEvents.eventManager,
          behaviours = manager.getBehaviours(behaviourEvent, event.type),
          allowDefault = true;
        if (isArray(behaviours) && behaviours.length) {
          behaviours.forEach(function (b) {
            if (b.type === 'custom') {
              invokeFunction(true, b.behaviour, manager, behaviourEvent, event, chart);
              allowDefault = event.allowDefault;
            } else if (allowDefault) {
              b.behaviour.apply(manager, [behaviourEvent, event, chart]);
            }
          });
        }
      };
    }

    /**
     *
     * @param chart
     */
    function positionResetButton(chart) {
      var _chart = chart.systemConf.chart,
        brush = _chart.brush,
        behaviour = _chart.behaviour,
        commonReset = behaviour && behaviour.resetButton,
        brushReset = brush.resetButton,
        resetButtonSettings = mergeJSON$1(commonReset, brushReset, true),
        eventManager = chart.behaviouralEvents.eventManager,
        resetButton = eventManager.resetButton;

      if (eventManager.resetButton) {
        var x = pick(
          invokeFunction(resetButtonSettings.x, chart, resetButton.bounds.rect),
          chart.plotarea.left + chart.plotarea.width - resetButton.bounds.rect.width),

          y = pick(invokeFunction(resetButtonSettings.y, chart, resetButton.bounds.rect), 10);

        // hide and translate the button by default
        resetButton.translate([x, y]);
      }
    }

    /**
     *
     * @param buttonSettings
     * @param chart
     * @param zoomEnabled
     * @return {{button: {'stroke-dasharray': [], 'stroke-width': (*|number), radius: number, fill: *, 'fill-opacity': *, stroke: *, 'stroke-linecap': *}, label: {style: {'font-size': *, 'font-family', fill: (*|string)}, text: *}}}
     */
    var getButtonOptions = function getButtonOptions(buttonSettings, chart, zoomEnabled) {
      var btnBorderConf = buttonSettings.border,
        btnLabelConf = buttonSettings.label,
        showBtnBorder = btnBorderConf.show,
        btnRadius = showBtnBorder ? btnBorderConf.radius : 0,
        dashStyle = getDashArray(btnBorderConf.style, btnBorderConf.size),
        priorityArray = [btnLabelConf, chart.systemConf.chart, chart.systemConf.canvas, { fontColor: 'white', fontSize: 11 }, $ZCG],
        text = pick(btnLabelConf.text, zoomEnabled ? 'Reset Zoom' : 'Reset Brush');

      return {
        label: {
          text: text,
          style: _objectSpread(_objectSpread({},
          btnLabelConf), {}, {
            fill: btnLabelConf.fontColor || 'white',
            'font-size': btnLabelConf.fontSize,
            'font-family': getValByPriority(priorityArray, 'fontFamily'),
            'text-shadow': getValByPriority(priorityArray, 'textShadow') })

        },
        button: {
          radius: btnRadius,
          fill: buttonSettings.fillColor,
          'fill-opacity': buttonSettings.fillOpacity,
          stroke: btnBorderConf.color,
          'stroke-width': showBtnBorder ? btnBorderConf.size : 0,
          'stroke-dasharray': dashStyle,
          'stroke-linecap': getLineCap(btnBorderConf.lineCap, dashStyle),
          marginTop: btnLabelConf.marginTop,
          marginRight: btnLabelConf.marginRight,
          marginBottom: btnLabelConf.marginBottom,
          marginLeft: btnLabelConf.marginLeft,
          filter: svgBoxShadow(buttonSettings.shadow, chart)
        }
      };
    };

    function UpdateViewportArea_C(behaviourEventInstance, selectionManager, transform) {
      var eventManager = this,
        zoomInstance = behaviourEventInstance.instance,
        plotBrush = eventManager.behaviours.PLOT_BRUSH,
        chart = eventManager.chart,
        domainInfo = selectionManager.point;

      chart.disableAnimation = false;

      // if (domainInfo.x && domainInfo.x[0].domain) {
      //     chart.viewPortExtent = domainInfo.x[0].domain;
      // }

      each(domainInfo, function (axis, type) {
        each(axis, function (info, index) {
          var axisInfo = getAxisObject(chart, type, index);
          if (axisInfo.scale.ordinalRange) {
            axisInfo.scale.ordinalRange = null;
          }
        });
      });

      var extent = [[0, 0], [chart.plotarea.width, chart.plotarea.height]];
      if (plotBrush) {
        plotBrush.instance.updateExtent(extent);
      }
      // #ZC2123
      chart.positionEventTrackerElement();

      zoomInstance.updateExtent(extent);
      chart.zooming = false;
      chart.brushing = false;
    }

    /**
     *
     * @param behaviourEventInstance
     * @param selectionManager
     * @param transform
     * @constructor
     */
    function UPDATE_SCROLL_BY_DOMAIN(behaviourEventInstance, selectionManager, transform) {
      var eventManager = this,
        chart = eventManager.chart,
        domainInfo = selectionManager.point,
        plotZoom = getPropVal(eventManager, 'behaviours.PLOT_ZOOM.instance');

      if (chart.scroll && chart.scroll.visible && !chart.scrolling && domainInfo.x) {
        var domain = domainInfo.x[0].domain,
          brushSelection;
        if (domain && !domain.length) {
          var scale = chart.scroll.brushScale,
            _bandWidth = scale.bandwidth(),
            ordinalRange = scale.ordinalRange,
            rangeBand = scale.bandwidth(),
            maxBandwidth = scale.maxBandWidth,
            actualWidth = maxBandwidth ? mathMin(rangeBand, maxBandwidth) : rangeBand,
            diffRange = ordinalRange.length > 1 ? mathAbs(ordinalRange[1] - ordinalRange[0]) : 0,
            actualPadding = mathAbs(diffRange - actualWidth),
            _domain = chartObj.emptySelectionDomain,
            _startPos,
            _endPos,
            axisrotated = chart.axes.rotated,
            axisReversed = chart.axes.x.reversed;

          var _diff = actualPadding * 0.1;
          _startPos = scale(_domain.start) - _diff;
          _endPos = scale(_domain.end) + _bandWidth + _diff;
          if (!axisrotated && axisReversed || axisrotated && !axisReversed) {
            if (!_domain.start) {
              _startPos = _endPos = scale(_domain.end) + _bandWidth + _diff;
            } else if (!_domain.end) {
              _startPos = _endPos = scale(_domain.start) - _diff;
            }
          } else {
            if (!_domain.start) {
              _startPos = _endPos = scale(_domain.end) - _diff;
            } else if (!_domain.end) {
              _startPos = _endPos = scale(_domain.start) + _bandWidth + _diff;
            }
          }
          brushSelection = [_startPos, _endPos];
        } else {
          brushSelection = _getScrollSelection(chart, domain, transform);
        }
        if (plotZoom && chart.zooming || !plotZoom) {
          chart.scroll.scrollDomain = domain;
          chart.scroll.brushInstance.setSelection(brushSelection);
        }
      }
    }

    /**
     *
     * @param chart
     * @param domain
     * @param transform
     * @return {number[]}
     */
    function _getScrollSelection(chart, domain, transform) {
      var scrollScale = chart.scroll.brushScale,
        brushSelection,
        limit = (scrollScale.origRange || scrollScale.range()).slice(0).sort(d3_ascending);

      if (isArray$1(domain) && scrollScale.bandwidth) {
        domain = [domain[0], domain[domain.length - 1]];
      }

      if (scrollScale.bandwidth && transform && transform.invert) {
        var side = 'width',
          invertType = 'X',
          x,
          width;

        if (chart.axes.rotated) {
          side = 'height';
          invertType = 'Y';
        }

        x = transform["invert".concat(invertType)](0);
        width = chart.plotarea[side] / transform.k;
        brushSelection = [x, width + x];
      } else if (domain) {
        // brushSelection = domain.map(scrollScale);
        // for ordinal scale add the band-with in the end
        // if (scrollScale.bandwidth) {
        //     brushSelection[1] = brushSelection[1] + (scrollScale.bandwidth ? scrollScale.bandwidth() : 1);
        // }
        brushSelection = domainToActualRange(chart, domain, 0, 'x', false, false, scrollScale);
      }

      if (brushSelection) {
        brushSelection.sort(d3_ascending);
        brushSelection[0] = mathMax(brushSelection[0], limit[0]);
        brushSelection[1] = mathMin(brushSelection[1], limit[1]);
      }
      // make it withing limit

      return brushSelection;
    }

    /**
     *
     */
    function setBrushStatus() {
      /**
       * @this BehaviouralEventManager
       * @type {boolean}
       */
      this.chart.brushing = true;
    }

    var _start = [],
      _brush = [];

    if ($Browser.isTouchDevice) {
      _brush = [ClearOldInfo_C];
    } else {
      _start = [ClearOldInfo_C];
    }

    var _chartBrushHandlers = {
      LISTENER: {
        start: ChartBrushListener,
        brush: ChartBrushListener,
        end: ChartBrushListener
      },
      DATA_FINDER: {
        start: ChartBrushDataFinder,
        brush: ChartBrushDataFinder,
        end: ChartBrushDataFinder
      },
      BEHAVIOUR: {
        start: [].concat(_toConsumableArray(_start), [SHOW_SELECTION_BOX]),
        brush: [setBrushStatus].concat(_toConsumableArray(_brush)),
        end: [HIDE_SELECTION_BOX, ApplyBrushSelectionOnPlot, UPDATE_SCROLL_BY_DOMAIN, ShowBrushResetButton, UpdateViewportArea_C]
      },
      LISTENER_TYPES: d3_set(['start', 'brush', 'end']),
      SUPPORTED: function SUPPORTED(chart) {return chart.isAxisCategory && !chart.isPolarAxisCategory;},
      UPDATE: function UPDATE() {
        //ZC2307
        positionResetButton(this.eventManager.chart);
      }
    };

    Registry.setComponent('_chartBrushHandlers', _chartBrushHandlers);

    defaultTheme.brush = function (userProp) {
      return {
        enabled: false,
        type: 'x', // x, y, xy
        pan: true, // works only if zoom is enabled [* with shift key]
        snap: false, // snap for bar chart
        selectionArea: {
          fillColor: '#3a8aea',
          fillOpacity: 0.2,
          strokeColor: '#3a8aea',
          dashStyle: '',
          strokeWidth: 0.8
        },
        resetButton: {
          enabled: true,
          fillColor: '#3c3c3c',
          label: {
            marginTop: 6,
            marginRight: 10,
            marginBottom: 6,
            marginLeft: 10,
            fontSize: 14,
            fontColor: 'white',
            fontWeight: 500
          },
          border: {
            show: true,
            size: 1,
            radius: 2,
            color: 'transparent'
          }
        }
      };
    };

    /**
     *
     * @param target
     * @param type
     * @param selection
     * @constructor
     */
    function BrushEvent(target, type, selection) {
      this.target = target;
      this.type = type;
      this.selection = selection;
    }

    function nopropagation() {
      d3_event().stopImmediatePropagation();
    }

    function preventDefault() {
      var event = d3_event();
      if (event.cancelable) {
        event.preventDefault();
      }
    }

    /**
     *
     * @param event
     * @return {Touch[] | TouchList}
     */
    function isTouchEvent(event) {
      return event.touches;
    }

    //***********************************/

    function d3_eventSource() {
      var e = d3_event(),
        s;
      while (s = e.sourceEvent) {
        e = s;
      }
      return e;
    }

    function defaultFilter() {
      var event = d3_event();
      return !event.ctrlKey && !event.button;
    }

    /**
     *
     * @param container
     * @param i
     * @return {[number, number]|number[]}
     */
    function d3_mousePoint(container, i) {
      var e = d3_eventSource();
      if (e.changedTouches) {
        e = e.touches[i];
      }
      var svg = container.ownerSVGElement || container;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = e.clientX;
        point.y = e.clientY;
        point = point.matrixTransform(container.getScreenCTM().inverse());

        var mouse = [point.x, point.y];

        if (isTouchEvent(d3_event()) && !$Browser.ANDROID && $Browser.uiwebview) {
          //d3.mouse(node) considers pageXOffset and pageYOffset in android devices
          mouse[0] += window.pageXOffset;
          mouse[1] += window.pageYOffset;
        }
        return mouse;
      }
      var rect = container.getBoundingClientRect();
      return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
    }

    /**
     *
     * @param brushType
     * @return {brush}
     */
    function brushWrapper(brushType) {
      var extent,
        listeners = d3_dispatch('start', 'brush', 'end'),
        filter = defaultFilter;

      /**
       *
       * @param selection
       * @param type
       * @param group
       */
      function emit(selection, type, group) {
        var brushEvent = new BrushEvent(brush, type, selection);
        d3_customEvent(brushEvent, listeners.apply, listeners, [type, group, [brushEvent, group]]);
      }

      function brush(group) {
        var rect = createElement('rect', '.selection', [1], group).attrs({
          fill: '#777',
          'fill-opacity': 0.3,
          stroke: '#fff',
          'shape-rendering': 'crispEdges'
        });

        /**
         *
         * @param p1
         * @param p2
         * @return {[[number, number], [number, number]]}
         */
        var getSelection = function getSelection(p1, p2) {
          var x1 = mathMin(p1[0], p2[0]),
            y1 = mathMin(p1[1], p2[1]),
            x2 = mathMax(p1[0], p2[0]),
            y2 = mathMax(p1[1], p2[1]);

          x1 = mathMax(x1, extent[0][0]);
          y1 = mathMax(y1, extent[0][1]);
          x2 = mathMin(x2, extent[1][0]);
          y2 = mathMin(y2, extent[1][1]);

          return [
          [x1, y1],
          [x2, y2]];

        };

        /**
         *
         * @param selection
         * @return {*[]|*}
         */
        var getUserSelection = function getUserSelection(selection) {
          switch (brushType) {
            case 'X':{
                return [selection[0][0], selection[1][0]];
              }
            case 'Y':{
                return [selection[0][1], selection[1][1]];
              }
            default:{
                return selection;
              }}

        };

        /**
         *
         * @param selection
         */
        var drawPreview = function drawPreview(selection) {
          var x = null,
            y = null,
            width = null,
            height = null;

          if (selection !== null) {
            switch (brushType) {
              case 'X':{
                  x = selection[0][0];
                  width = selection[1][0] - selection[0][0];
                  y = extent[0][1];
                  height = extent[1][1] - extent[0][1];
                  break;
                }
              case 'Y':{
                  x = extent[0][0];
                  width = extent[1][0] - extent[0][0];
                  y = selection[0][1];
                  height = selection[1][1] - selection[0][1];
                  break;
                }
              default:{
                  x = selection[0][0];
                  y = selection[0][1];
                  width = selection[1][0] - selection[0][0];
                  height = selection[1][1] - selection[0][1];
                }}

          }

          rect.attrs({ width: width, height: height, x: x, y: y });
        };

        var updateSelectionInternal = function updateSelectionInternal(selection) {
          if (selection !== null) {
            switch (brushType) {
              case 'X':{
                  selectionInternal[0][0] = selection[0];
                  selectionInternal[1][0] = selection[1];
                  break;
                }
              case 'Y':{
                  selectionInternal[0][1] = selection[0];
                  selectionInternal[1][1] = selection[1];
                  break;
                }
              default:{
                  selectionInternal = _toConsumableArray(selection);
                }}

          }
        };

        var startPoint,
          windowSelect = d3_select(window),
          selectionInternal,
          eventNode = group.node();

        /**
         *
         */
        var move = function move() {
          preventDefault();
          nopropagation();

          var currentPoint;
          if (isTouchEvent(d3_event())) {
            startPoint = d3_mousePoint(eventNode, 0);
            currentPoint = d3_mousePoint(eventNode, 1);
          } else {
            currentPoint = d3_mouse(eventNode);
          }
          selectionInternal = getSelection(startPoint, currentPoint);
          drawPreview(selectionInternal);

          // fire the event
          emit(getUserSelection(selectionInternal), 'brush', group);
        };

        /**
         *
         */
        var ended = function ended() {
          preventDefault();
          // we should remove the event with exact name which was used to bind it.
          windowSelect.on('mousemove.brush', null);
          windowSelect.on('touchmove.brush', null);
          windowSelect.on('mouseup.brush touchend.brush', null);
          if (selectionInternal) {
            emit(getUserSelection(selectionInternal), 'end', group);
          }
        };

        group.on('mousedown.brush, touchstart.brush', function () {
          if (!filter.apply(this, arguments)) {
            return;
          }

          preventDefault();
          // touch zoom
          // nopropagation();

          startPoint = d3_mouse(eventNode);
          selectionInternal = [startPoint, startPoint];
          drawPreview(selectionInternal);
          emit(getUserSelection(selectionInternal), 'start', group);
          //
          var event = d3_event(),
            touches = event.touches;
          // need to capture the event while
          if (isTouchEvent(event) && touches.length > 1) {
            windowSelect.on('touchmove.brush', move, true);
          } else {
            windowSelect.on('mousemove.brush', move, true);
          }
          // bind the event
          windowSelect.on('mouseup.brush touchend.brush', ended, true);
        });

        brush.move = function (group, selection) {
          if (selection) {
            emit(getUserSelection(selectionInternal), 'start', group);

            // update with the current brush
            updateSelectionInternal(selection);
            emit(getUserSelection(selectionInternal), 'brush', group);
            emit(getUserSelection(selectionInternal), 'end', group);
          } else {
            selectionInternal = null;
          }
          drawPreview(selectionInternal);
        };
      }

      brush.extent = function (_) {
        return arguments.length ? extent = _ : extent, brush;
      };

      brush.on = function () {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      // error handle
      brush.handleSize = function () {};

      // #ZC2380, #ZC2380
      brush.filter = function (_) {
        return arguments.length ? (filter = typeof _ === 'function' ? _ : filter, brush) : filter;
      };

      return brush;
    }

    function brushX() {
      return brushWrapper('X');
    }

    function brushY() {
      return brushWrapper('Y');
    }

    function brush() {
      return brushWrapper('XY');
    }

    var customBrushMap = /*#__PURE__*/Object.freeze({
      brushX: brushX,
      brushY: brushY,
      brush: brush
    });

    var d3BrushMap = {
      brush: d3_brush,
      brushX: d3_brushX,
      brushY: d3_brushY
    };

    var defaultOptions = {
      // * For wheel zoom
      extent: [[0, 0], [0, 0]],
      handleSize: 6,
      type: 'xy',
      snap: null,
      element: null,
      metaKey: null,
      styles: {
        track: {},
        selection: {},
        handles: {}
      }
    };

    /**
     * This is used as a interface for zoom position
     */var
    BrushD3Options = /*#__PURE__*/_createClass(
    function BrushD3Options(options) {_classCallCheck(this, BrushD3Options);
      this.settings = _objectSpread(_objectSpread({}, defaultOptions), options);
    });


    /**
     *
     */var
    BrushD3 = /*#__PURE__*/function () {
      /**
       *
       * @param {BrushD3Options} brushD3Options
       */
      function BrushD3(brushD3Options) {_classCallCheck(this, BrushD3);
        var options = this.options = brushD3Options.settings;
        this.type = this.options.type;
        this.initialize();
        this.hookCount = 0;
        this._snap = {};

        if (defined(options.behaviour)) {
          if (BrushD3.behaviours.has(options.behaviour)) {
            this.behaviour = BrushD3.behaviours.get(options.behaviour);
          } else {
            throw new TypeError("".concat(options.behaviour, " behaviour not found"));
          }
        }

        if (options.element && options.element.isD3Selection) {
          this.bindTo(options.element);
        }
      }_createClass(BrushD3, [{ key: "initialize", value:

        function initialize() {
          var brush = this,
            options = brush.options,
            useCustomBrush = $Browser.isTouchDevice && options.multitouch === true,
            extent = options.extent,
            type_map = {
              x: 'brushX',
              y: 'brushY',
              xy: 'brush'
            },
            brush_type = brush.type = pick(type_map[brush.type], 'brush'),
            /**
             * @type BrushBehavior
             */
            d3_brush = brush.d3_brush = brush.d3_brush || (useCustomBrush ? customBrushMap : d3BrushMap)[brush_type](),
            signal,
            behaviour_signal;

          // set the extent if defined;
          if (isArray$1(extent) && isArray$1(extent[0]) && isArray$1(extent[1])) {
            d3_brush.extent(extent);
          }

          if (options.metaKey) {
            d3_brush.filter(function () {
              return !d3_event()[options.metaKey];
            });
          }

          // must call before the rendering
          d3_brush.handleSize(pick(options.handleSize, 6));

          // handle the events
          signal = brush._signal = d3_dispatch('start', 'brush', 'end');
          behaviour_signal = brush.behaviour_signal = d3_dispatch('init', 'start', 'brush', 'end');

          var lastSelection = [0, 0],
            brushed = false,
            mode;

          d3_brush.on('start', function () {
            // ignore when reset
            var event = d3_event(),
              sourceEvent,
              ee = event;
            if (!event.selection) {
              return false;
            }

            brushed = false;

            while (sourceEvent = ee.sourceEvent) {
              ee = sourceEvent;
            }

            var sourceElement = ee && ee.target && ee.target.getAttribute ? ee.target : null;
            mode = sourceElement && /handle/.test(sourceElement.getAttribute('class')) ? 'resize' : 'move';

            event.mode = mode;
            behaviour_signal.call('start', brush, event);
            signal.call('start', brush, event);
          });

          d3_brush.on('brush', function () {
            // ignore when reset
            if (BrushD3.isInvalidBrush()) {
              return false;
            }

            // call the start on first brush mouse
            // if (!started) {
            //     // let e = d3_event();
            //     // e.type = 'start';
            //     // started = true;
            //     // signal.call('start', brush, e);
            // }
            var event = d3_event();
            event.mode = mode;

            var snapping = brush._snap.when === 'brush' && isFunction(brush._snap.calculate) && brush._snap.calculate(event);

            if (snapping) {
              if (BrushD3.isInvalidBrush()) {
                return;
              }

              var snapSelection = pick(snapping, lastSelection);
              brush.setSelection(snapSelection);

              if (lastSelection[0] !== snapSelection[0] || lastSelection[1] !== snapSelection[1]) {
                lastSelection = event.selection = snapSelection;
                brush.positionCustomHandles(lastSelection);
                behaviour_signal.call('brush', brush, event);
                signal.call('brush', brush, event);
              }
            } else {
              brush.positionCustomHandles();
              behaviour_signal.call('brush', brush, event);
              signal.call('brush', brush, event);
            }

            // detect manual brush
            if (event && event.sourceEvent && event.sourceEvent.type !== 'end') {
              brushed = true;
            }
          });

          d3_brush.on('end', function () {
            if (BrushD3.isInvalidBrush()) {
              return;
            }

            var event = d3_event(),
              selection = brush.getSelection(),
              snapping = brush._snap.when === 'end' && isFunction(brush._snap.calculate) && brush._snap.calculate(brush, event);
            // set the mode
            event.mode = mode;

            if (snapping && selection) {
              var snapSelection = pick(snapping, lastSelection);
              brush.setSelection(snapSelection, brush._snap.duration);

              if (lastSelection[0] !== snapSelection[0] || lastSelection[1] !== snapSelection[1]) {
                lastSelection = event.selection = snapSelection;
                behaviour_signal.call('end', brush, event, brushed);
                signal.call('end', brush, event, brushed);
              }
            } else {
              brush.positionCustomHandles();
              behaviour_signal.call('end', brush, event, brushed);
              signal.call('end', brush, event, brushed);
            }
          });
        } }, { key: "snap", value:

        function snap(when, calculator, duration) {
          this._snap = {
            when: when,
            calculate: calculator,
            duration: duration
          };
        }

        /**
         *
         * @return {{}}
         */ }, { key: "getSignals", value:
        function getSignals() {
          return this._signal;
        }

        /**
         *
         * @param type
         * @param hook
         * @return {string}
         */ }, { key: "addHook", value:
        function addHook(type, hook) {
          this.hookCount++;
          var currentHookID = "".concat(type, ".").concat(this.hookCount);
          this._signal.on(currentHookID, hook);
          return currentHookID;
        }

        /**
         *
         * @param currentHookID
         */ }, { key: "removeHook", value:
        function removeHook(currentHookID) {
          this._signal.on(currentHookID, null);
        }

        /**
         *
         * @param type
         * @param hook
         * @return {string}
         */ }, { key: "addBehaviourHook", value:
        function addBehaviourHook(type, hook) {
          this.hookCount++;
          var currentHookID = "".concat(type, ".").concat(this.hookCount);
          this.behaviour_signal.on(currentHookID, hook);
          return currentHookID;
        }

        /**
         *
         * @param currentHookID
         */ }, { key: "removeBehaviourHook", value:
        function removeBehaviourHook(currentHookID) {
          this.behaviour_signal.on(currentHookID, null);
        } }, { key: "bindTo", value:

        function bindTo(parent) {
          var brush = this,
            d3_brush = brush.d3_brush,
            styles = brush.options.styles || {};

          // let group = createElement('g', '.brush-group-wrapper', [1], parent);
          var group = parent;
          // save the brush
          brush.parent_group = group;
          // call the brush
          group.call(d3_brush);

          // save the elements
          brush._track = group.selectAll('rect.overlay');
          brush._selection = group.selectAll('rect.selection');
          brush._handles = group.selectAll('rect.handle');

          // apply the styles
          setStyles(brush._track, styles.track);
          setStyles(brush._selection, styles.selection);
          setStyles(brush._handles, styles.handle);

          // if resizer is false, remove the nodes because, there is no API to remove them.
          if (brush.options.resizer === false) {
            group.selectAll('rect.handle').remove();
          }

          if (defined(brush.behaviour)) {
            brush.behaviour.call(brush);
          }

          // call the behaviour signal
          brush.behaviour_signal.call('init', brush);
        } }, { key: "addCustomHandle", value:

        function addCustomHandle(handles) {
          var brush = this;

          // register external custom handle
          if (handles.isD3Selection) {
            return brush.customHandles = handles;
          } else if (handles[0].shape === 'default') {
            return setStyles(brush._handles, handles[0].style);
          }

          brush.customHandles = BrushD3.ADD_HANDLE(handles, brush.parent_group).attrs({
            cursor: function cursor(d) {return BrushD3.getCursor(d.type);},
            'pointer-events': 'all'
          });

          brush.positionCustomHandles();

          return brush.customHandles;
        }

        /**
         *
         */ }, { key: "positionCustomHandles", value:
        function positionCustomHandles() {
          var syncTrans = this.options.styles.slider && this.options.styles.slider.animation && this.options.styles.slider.animation.transition;
          var brush = this,
            selection = brush.getSelection();

          if (brush.customHandles) {
            if (selection) {
              if (syncTrans && syncTrans()) {
                brush.customHandles.
                transition(syncTrans()).
                attr('transform', function (d) {
                  var position = brush.getCustomHandlePosition(d);
                  return "translate(".concat(position.join(' '), ")");
                }).
                style('display', null);
              } else {
                brush.customHandles.
                attr('transform', function (d) {
                  var position = brush.getCustomHandlePosition(d);
                  return "translate(".concat(position.join(' '), ")");
                }).
                style('display', null);
              }
            } else {
              brush.customHandles.style('display', 'none');
            }
          }
        }

        /**
         *
         * @param handle
         * @return {*}
         */ }, { key: "getCustomHandlePosition", value:
        function getCustomHandlePosition(handle) {
          var brush = this,
            selection = brush.getSelection(),
            brushArea = boundToRect(pick(brush.options.extent, brush.d3_brush.extent()())),
            alignCenter = handle.alignCenter !== false,
            centerX = 0,
            centerY = 0;
          // center the handle
          if (alignCenter) {
            centerX = brushArea.width / 2;
            centerY = brushArea.height / 2;
          }

          if (selection) {
            return {
              e: [selection[1], centerY],
              w: [selection[0], centerY],
              n: [centerX, selection[0]],
              s: [centerX, selection[1]]
            }[handle.type];
          }
        }

        /**
         *
         * @param selection
         * @param transitionDuration
         */ }, { key: "setSelection", value:
        function setSelection(selection, transitionDuration) {
          var brush = this,
            type = brush.options.type,
            range = brush.getRange(type);

          // #ZC2166 constrain
          if (type === 'xy') {
            selection = [
            [mathMax(range[0][0], selection[0][0]), mathMin(range[0][1], selection[0][1])],
            [mathMin(range[1][0], selection[1][0]), mathMin(range[1][1], selection[1][1])]];

          } else {
            selection = [mathMax(range[0], selection[0]), mathMin(range[1], selection[1])];
          }

          if (d3_event()) {
            d3_event().selection = selection;
          }

          if (isNumber(transitionDuration) && transitionDuration > 0) {
            brush.parent_group.
            transition().
            duration(transitionDuration).
            call(brush.d3_brush.move, selection);
          } else {
            brush.__checkSameType = true;
            brush.parent_group.call(brush.d3_brush.move, selection);
          }
        } }, { key: "getSelection", value:

        function getSelection() {
          return d3_event() && d3_event().selection || d3_brushSelection(this.parent_group.node());
        }

        /**
         *
         * @return {[]}
         */ }, { key: "getRange", value:
        function getRange() {
          var brush = this,
            extent = brush.d3_brush.extent()();

          switch (brush.options.type) {
            case 'x':
              return [extent[0][0], extent[1][0]];
            case 'y':
              return [extent[0][1], extent[1][1]];
            default:
              return extent;}

        } }, { key: "hide", value:

        function hide() {
          this.parent_group.attr('display', 'none');
        } }, { key: "show", value:

        function show() {
          this.parent_group.attr('display', null);
        } }, { key: "reset", value:

        function reset() {
          this.parent_group.call(this.d3_brush.move, null);
        } }, { key: "destroy", value:

        function destroy() {
          var brush = this;
          // #ZC2766
          brush.parent_group && brush.parent_group.on('.brush', null);
          brush.parent_group && brush.parent_group.selectAll('rect.overlay, rect.handle, rect.selection').remove();

          each(brush, function (value, key) {
            brush[key] = null;
            delete brush[key];
          });
        } }, { key: "update", value:

        function update(options) {
          this.options = options;
          this.type = pick(options.type, 'xy');
          this.initialize();
        } }, { key: "updateExtent", value:

        function updateExtent(extent) {
          if (isArray$1(extent) && isArray$1(extent[0]) && isArray$1(extent[1])) {
            this.d3_brush.extent(extent);
            if (this.parent_group) {
              this.parent_group.call(this.d3_brush);
            }
          }
        } }], [{ key: "isInvalidBrush", value:

        function isInvalidBrush(type) {
          var event = d3_event(),
            sourceEvent = event && event.sourceEvent;

          return sourceEvent && sourceEvent.type === (type || d3_event().type);
        } }, { key: "getCursor", value:

        function getCursor(direction) {
          return {
            e: 'ew-resize',
            w: 'ew-resize',
            n: 'ns-resize',
            s: 'ns-resize'
          }[direction];
        }

        /**
         *
         * @param handles
         * @param parent
         */ }, { key: "ADD_HANDLE", value:
        function ADD_HANDLE(handles, parent) {
          handles = splat(handles);

          var handle_selection = createElement('g', '.handle--custom', handles, parent);

          // create the shapes
          createElement(
          'path',
          '.custom-handle-path',
          function (d, i) {
            var shapes = splat(d.shape);

            if (isArray$1(d.shape[i])) {
              shapes = d.shape[i];
            }

            return splat(shapes).map(function (shape) {
              return { type: d.type, shape: shape, i: i };
            });
          },
          handle_selection).

          attr('d', function (d) {return d.shape;}).
          each(function (d, index) {
            var selection = d3_select(this),
              handle = handles[d.i],
              style = splat(handle.style),
              attributes = splat(handle.attributes);
            // add the attributes if any
            selection.attrs(pick(attributes[index], handle.attributes));
            // set the styles
            setStyles(selection, pick(style[index], handle.style));
          });

          return handle_selection;
        } }]);return BrushD3;}();


    BrushD3.prototype.on = BrushD3.prototype.addHook;

    /**
     *
     */
    BrushD3.behaviours = d3_map();
    /**
     *
     * @param name
     * @param behaviour
     * @return {*}
     */
    BrushD3.addBehaviour = function (name, behaviour) {
      if (!defined(behaviour)) {
        return BrushD3.behaviours.remove(name);
      }
      BrushD3.behaviours.set(name, behaviour);
    };

    Registry.setComponent('BrushD3', BrushD3);
    Registry.setComponent('BrushD3Options', BrushD3Options);

    /**
     *
     * @param brush
     * @param selectionForce
     */
    function positionSliderToMouseCenter(brush, selectionForce) {
      var type = brush.options.type;

      var selection = selectionForce || brush.getSelection();
      var center = d3_mouse(this)[type === 'x' ? 0 : 1];
      var size = selection[1] - selection[0];

      var x0 = center - size / 2,x1 = center + size / 2;
      var _brush$getRange = brush.getRange(),_brush$getRange2 = _slicedToArray(_brush$getRange, 2),minX = _brush$getRange2[0],maxX = _brush$getRange2[1];

      var newSelection = x1 > maxX ? [maxX - size, maxX] : x0 < minX ? [minX, minX + size] : [x0, x1];

      // call the move
      brush.setSelection(newSelection);
    }

    /**
     *
     * @param selection
     */
    function fixEdgeCancellation(selection, brush) {
      // actually d3 cancels brush when start and end point are same.
      // when we move both the handle to the start or end position the start and end position become same and it get cancelled.
      // so we are adjust the position a little bit.

      if (selection[0] === selection[1]) {
        selection[1] += 0.000000001;
        selection[0] -= 0.000000001;
        brush.setSelection(selection, 0);
      }
    }

    function closestValue(array, value) {
      var result, lastDelta;

      array.some(function (item) {
        var delta = Math.abs(value - item);
        if (delta > lastDelta) {
          return true;
        }
        result = item;
        lastDelta = delta;
      });
      return result;
    }

    var brushBehaviours = {
      /**
       * Scroll behaviour
       */

      scroll: function scroll() {
        var brush = this,
          last = 0,
          brushSelectionFn = null;
        this._track.datum({ type: 'selection' }).on('mousedown touchstart', function () {
          var selectionArgs = {
            scrollType: brush.options.type,
            brushInstance: brush,
            scrollScale: brush.options.brushScale,
            ismousedownTouchstart: true
          };
          brushSelectionFn = brush.options.brushSelection;
          if (brushSelectionFn != null && typeof brushSelectionFn === "string") {
            invokeFunction(brushSelectionFn, selectionArgs);
          } else {
            positionSliderToMouseCenter.call(this, brush);
          }
        });

        brush.addBehaviourHook('brush.scroll', function () {
          last = brush.getSelection();
        });

        brush.addBehaviourHook('end.scroll', function (event) {
          if (!event.sourceEvent || last[0] !== last[1]) {
            return;
          }
          fixEdgeCancellation(last, brush);
        });
      },

      /**
       * move the current selected area to the mouse clicked
       * also support re-selection
       */

      reposition: function reposition() {
        var brush = this,
          last;

        brush.addBehaviourHook('brush.reposition', function () {return last = brush.getSelection();});
        brush.addBehaviourHook('end.reposition', function (event, brushed) {
          if (!event.sourceEvent) {
            return;
          }
          if (!brushed) {
            positionSliderToMouseCenter.call(brush.parent_group.node(), brush, last);
          }
        });
      },

      /**
       *
       * resize the brush selection to the mouse position
       */
      resizeToMouse: function resizeToMouse() {
        var brush = this,
          last = brush.getSelection(),
          type = brush.options.type;

        brush.addBehaviourHook('brush.resizeToMouse', function () {
          last = brush.getSelection();
        });

        brush.addBehaviourHook('end.resizeToMouse', function (event, brushed) {
          if (!event.sourceEvent) {
            return;
          }

          if (!brushed && isArray$1(last)) {
            var position = d3_mouse(brush.parent_group.node())[type === 'x' ? 0 : 1],
              index = last.indexOf(closestValue(last, position));

            last[index] = position;
            brush.setSelection(last);
          } else {
            fixEdgeCancellation(last, brush);
          }
        });
      },

      slider: function slider() {
        var brush = this,
          last = brush.getSelection(),
          type = brush.options.type,
          resizeOnClick = function resizeOnClick() {
            var _d3$mouse = d3.mouse(brush.parent_group.node()),_d3$mouse2 = _slicedToArray(_d3$mouse, 1),x = _d3$mouse2[0];
            brush.setSelection([0, x]);
          };
        // stop resize
        this._selection.datum({ type: 'none' });
        this._track.datum({ type: 'none' });
        this._track.on('click touchstart', resizeOnClick);
        this._selection.on('click touchstart', resizeOnClick);

        brush.addBehaviourHook('start.slider', function (e) {
          {
            brush.customHandles && d3_select(brush.customHandles.node()).remove();
          }
        });

        brush.addBehaviourHook('brush.slider', function (event) {
          var _event$selection = _slicedToArray(event.selection, 2),x1 = _event$selection[0],x2 = _event$selection[1];
          last = [0, x2];
          if (x1 > 0) {
            brush.setSelection(last);
          }
        });
        brush.addBehaviourHook('end.slider', function (event) {return event.sourceEvent && fixEdgeCancellation(last, brush);});
      }
    };

    // add the behaviours
    each(brushBehaviours, function (behaviour, name) {return BrushD3.addBehaviour(name, behaviour);});

    /**
     *
     * @param chart
     * @return {ZoomD3Options}
     */
    function _getPlotBrushArguments(chart) {
      var options = chart.systemConf.chart.brush,
        zoomOptions = chart.systemConf.chart.zoom,
        extent = [[0, 0], [chart.plotarea.width, chart.plotarea.height]],
        BrushD3Options = Registry.getComponent('BrushD3Options'),
        type = chart.isGeoMap ? 'xy' : fixBrushDirection(options.type, chart.axes.rotated),
        metaKey;

      // when brush and zoom enabled together and user wants to pan
      // we enable it on shift key and drag
      if (options.pan === true && zoomOptions.enabled) {
        metaKey = 'shiftKey';
      }

      return new BrushD3Options({
        type: type,
        extent: extent,
        element: chart.eventHandler.trackerGroup,
        metaKey: metaKey,
        multitouch: options.multitouch,
        styles: {
          selection: {
            fillColor: 'transparent',
            strokeColor: 'transparent'
          }
        }
      });
    }

    Registry.setComponent('_getPlotBrushArguments', _getPlotBrushArguments);

    //$Id$
    //slider-marker-options.js

    function getDefaultSliderOptions(dimension, isHorizontal, segmentCount) {
      return {
        line: {
          strokeColor: 'grey',
          strokeWidth: 2,
          height: dimension[isHorizontal ? 1 : 0] + 20
        },
        triangleUp: {
          size: 15,
          fillColor: '#4C4C4C'
        },
        triangleDown: {
          size: 15,
          fillColor: '#4C4C4C'
        },
        triangleUpDown: {
          size: 15,
          fillColor: '#4C4C4C',
          padding: dimension[isHorizontal ? 1 : 0] + 15
        },
        box: {
          strokeWidth: 1,
          strokeColor: 'black',
          fillColor: 'transparent',
          height: dimension[isHorizontal ? 1 : 0],
          width: segmentCount ? dimension[isHorizontal ? 0 : 1] / segmentCount : 10
        },
        enlarge: {
          range: 1.2,
          height: dimension[isHorizontal ? 1 : 0],
          width: segmentCount ? dimension[isHorizontal ? 0 : 1] / segmentCount : 10
        },
        lever: {
          height: 26,
          width: 9,
          radius: 2,
          stripeHeight: 8,
          stripePadding: 2,
          fillColor: 'white',
          strokeColor: '#DADADA',
          stripeColor: '#DADADA',
          shadow: '0 0 2px rgba(0,0,0,0.2)'
        },
        hollowCircle: {
          size: 25,
          outerFillColor: 'white',
          outerStrokeColor: '#DADADA',
          innerStrokeColor: '#DADADA',
          shadow: '0 0 2px rgba(0,0,0,0.2)'
        },
        circle: {
          size: 25,
          outerStrokeColor: 'white',
          outerStrokeWidth: 2,
          innerFillColor: 'white',
          shadow: '0 0 2px rgba(0,0,0,0.2)'
        },
        vernier: {
          height: 26,
          width: 9,
          fillColor: 'white',
          strokeColor: '#DADADA',
          shadow: '0 0 2px rgba(0,0,0,0.2)'
        },
        pentagon: {
          size: 8,
          bandWidth: 3,
          fillColor: 'white',
          strokeColor: '#DADADA',
          shadow: '0 0 2px rgba(0,0,0,0.2)',
          height: dimension[isHorizontal ? 1 : 0]
        },
        lineCircle: {
          size: 15,
          strokeWidth: 2,
          strokeColor: 'blue',
          position: isHorizontal ? 'end' : 'start'
        },
        rectangle: {
          fillColor: '#333',
          strokeWidth: 1
        }
      };
    }

    var __CUSTOM_SLIDER_SHAPES = d3_map();

    /**
     *
     * @param name
     * @param handle
     */
    function setCustomBrushHandle(name, handle) {
      __CUSTOM_SLIDER_SHAPES.set(name, handle);
    }

    var getSliderShape = function getSliderShape(type, config, brushType, dimension) {var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];
      // user defined handles
      if (__CUSTOM_SLIDER_SHAPES.has(type)) {
        return __CUSTOM_SLIDER_SHAPES.get(type);
      }

      var handle = null,
        transform,
        index = { x: 1, y: 0 }[brushType],
        isHorizontal = brushType === 'x',
        translate = getSliderPosition(brushType, type, dimension, config.size);

      // add the offset
      // #ZC2227
      translate = translate.map(function (t0, i) {return t0 + offset[i];});

      switch (type) {
        case 'line':
          handle = {
            shape: getSVGsymbol('vertical-line')(config.height),
            style: {
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth
            }
          };
          break;
        case 'triangleUp':
          handle = {
            shape: getSVGsymbol('triangle-down')(config.size),
            style: {
              fill: config.fillColor,
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth
            }
          };
          break;

        case 'triangleDown':
          handle = {
            shape: getSVGsymbol('triangle-up')(config.size),
            style: {
              fill: config.fillColor,
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth
            }
          };
          break;
        case 'triangleUpDown':
          var padding = config.padding / 2,
            transformDown = isHorizontal ? [0, padding] : [padding, 0],
            transformUp = transformDown.map(function (t0) {return t0 * -1;});

          transformUp = [transformUp[0] + translate[0], transformUp[1] + translate[1]];
          transformDown = [transformDown[0] + translate[0], transformDown[1] + translate[1]];

          handle = {
            shape: [getSVGsymbol('triangle-down')(config.size), getSVGsymbol('triangle-up')(config.size)],
            style: [
            {
              fill: config.fillColor,
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth,
              transform: "translate(".concat(transformUp, ")")
            },
            {
              fill: config.fillColor,
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth,
              transform: "translate(".concat(transformDown, ")")
            }]

          };
          break;
        case 'box':
          var strokeWidth = config.strokeWidth,
            w = config.width,
            h = config.height;

          handle = {
            shape: roundedRect(-(w - strokeWidth) / 2, -(h - strokeWidth) / 2, w - strokeWidth, h - strokeWidth, getBorderRadius()),
            style: {
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth,
              fill: config.fillColor
            }
          };
          break;
        case 'enlarge':
          var strokeWidth = config.strokeWidth,
            range = config.range || 1,
            w = config.width * range,
            h = config.height * range;

          handle = {
            shape: roundedRect(-w / 2, -h / 2, w, h, getBorderRadius()),
            style: {
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth,
              fillColor: config.fillColor
            }
          };
          break;
        case 'lever':
          var r = getBorderRadius(config.radius);
          handle = {
            shape: [
            roundedRect(-config.width / 2, -config.height / 2, config.width, config.height, r), "M".concat(
            -config.stripePadding / 2, " ").concat(-config.stripeHeight / 2, " L").concat(-config.stripePadding / 2, " ").concat(config.stripeHeight /
            2, " M").concat(config.stripePadding / 2, " ").concat(-config.stripeHeight / 2, " L").concat(config.stripePadding / 2, " ").concat(config.stripeHeight / 2)],

            style: [
            {
              fill: config.fillColor,
              stroke: config.strokeColor
            },
            {
              stroke: config.stripeColor
            }]

          };
          break;
        case 'hollowCircle':
          handle = {
            shape: [getSVGsymbol()(config.size), getSVGsymbol()(config.size * 0.4)],
            style: [
            {
              fill: config.outerFillColor,
              stroke: config.outerStrokeColor
            },
            {
              fill: config.innerFillColor,
              stroke: config.innerStrokeColor
            }]

          };
          break;
        case 'circle':
          handle = {
            shape: [getSVGsymbol()(config.size), getSVGsymbol()(config.size * 0.3)],
            style: [
            {
              fill: config.outerFillColor,
              stroke: config.outerStrokeColor,
              'stroke-width': config.outerStrokeWidth
            },
            {
              fill: config.innerFillColor,
              stroke: config.innerStrokeColor
            }]

          };
          break;
        case 'vernier':
          var w = config.width,
            h = config.height,
            path1 = "M".concat(-w * 0.5, " ").concat(-h * 0.5, " L").concat(w * 0.5, " ").concat(-h * 0.5, " L").concat(w * 0.5, " ").concat(h * 0.5, " L").concat(-w * 0.5, " ").concat(h * 0.2, " Z"),
            path2 = "M".concat(-w * 0.5, " ").concat(-h * 0.5, " L").concat(w * 0.5, " ").concat(-h * 0.5, " L").concat(w * 0.5, " ").concat(h * 0.2, " L").concat(-w * 0.5, " ").concat(h * 0.5, " Z");

          handle = {
            shape: [[path1], [path2]],
            style: {
              fill: config.fillColor,
              stroke: config.strokeColor
            }
          };
          break;
        case 'pentagon':
          var size = config.size,
            bandWidth = config.bandWidth,
            h = config.height,
            path =
            "M".concat(-size * 0.5 - bandWidth, " ").concat(-h * 0.5 - bandWidth, " L").concat(size * 0.5 + bandWidth, " ").concat(-h * 0.5 - bandWidth, " L").concat(size * 0.5 +
            bandWidth, " ").concat(h * 0.5, "L0 ").concat(h * 0.5 + bandWidth * 1.5 + 2, " L").concat(-size * 0.5 - bandWidth, " ").concat(h * 0.5, "Z") + "M".concat(
            -size * 0.5, " ").concat(-h * 0.5, " L").concat(size * 0.5, " ").concat(-h * 0.5, " L").concat(size * 0.5, " ").concat(h * 0.5 - bandWidth * 0.5, "L0 ").concat(h * 0.5 +
            bandWidth * 0.5, " L").concat(-size * 0.5, " ").concat(h * 0.5 - bandWidth * 0.5, "Z"),
            innerBand = "M".concat(-size * 0.5, " ").concat(-h * 0.5, " L").concat(size * 0.5, " ").concat(-h * 0.5, " L").concat(size * 0.5, " ").concat(h * 0.5, " L").concat(-size * 0.5, " ").concat(h * 0.5, "Z");

          handle = {
            _effectElementIndex: 1,
            shape: [innerBand, path],
            style: [
            {},
            {
              'fill-rule': 'evenodd',
              fill: config.fillColor,
              stroke: config.strokeColor
            }]

          };
          break;
        case 'lineCircle':
          var size = config.size,
            lineSize = dimension[index],
            factor = config.position === 'end' ? 1 : -1,
            circleTranslate = size / 2 * factor,
            lineType = 'vertical-line';

          // add the size if the marker needs in the end
          if (config.position === 'end') {
            circleTranslate += dimension[index];
          }

          transform = [0, circleTranslate];

          if (!isHorizontal) {
            transform.reverse();
          }
          // #ZC2227
          transform = transform.map(function (t0, i) {return t0 + offset[i];});

          handle = {
            shape: [getSVGsymbol('circle')(size), getSVGsymbol(lineType)(lineSize)],
            style: [
            {
              fill: config.fillColor,
              stroke: config.strokeColor,
              transform: "translate(".concat(transform.join(' '), ")")
            },
            {
              fill: config.fillColor,
              stroke: config.strokeColor,
              'stroke-width': config.strokeWidth
            }]

          };
          break;

        case 'rectangle':{
            //  use default
            // if rectangle, use the default styles
            return {
              shape: 'default',
              style: _objectSpread({}, config)
            };
          }}


      transform = translate && "translate(".concat(translate.join(' '), ") ") || '';
      splat(handle.style).forEach(function (style) {
        var currentTransform = style.transform || transform;
        if (brushType === 'y') {
          currentTransform += ' rotate(-90)';
        }
        style.transform = currentTransform;
      });

      return handle;
    };

    var getSliderPosition = function getSliderPosition(brushType, sliderType, dimension, size) {
      var index = { x: 1, y: 0 }[brushType],
        transform = [0, 0];

      switch (sliderType) {
        case 'triangleUp':
          transform[index] = -size / 2;
          break;
        case 'triangleDown':
          transform[index] = dimension[index] + size / 2;
          break;
        default:
          transform[index] = dimension[index] / 2;}

      return transform;
    };

    /**
     *
     * @param brushType
     * @return {*}
     */
    function getD3BrushHandle(brushType) {
      return { x: [{ type: 'w' }, { type: 'e' }], y: [{ type: 'n' }, { type: 's' }] }[brushType];
    }

    /**
     *
     * @param brushType
     * @param sliderType
     * @param extent
     * @param segmentCount
     * @param userStyles
     */
    function getMergedHandleStyles(brushType, sliderType, extent, segmentCount, userStyles) {
      var dimension = [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]],
        defaultStyles = getDefaultSliderOptions(dimension, brushType === 'x', segmentCount)[sliderType];

      return _objectSpread(_objectSpread({}, defaultStyles), userStyles);
    }

    /**
     *
     * @param brushType
     * @param sliderType
     * @param extent
     * @param segmentCount
     * @param userStyles
     * @return {{shape: string, style: {'stroke-width': *, stroke: *}}|{shape: string, style: {transform: string, 'stroke-width': *, fill: *, stroke: *}}|{shape: [string, string], style: [{transform: string, 'stroke-width': *, fill: *, stroke: *}, {transform: string, 'stroke-width': *, fill: *, stroke: *}]}|{shape: string, style: {'stroke-width', fill, stroke: *}}|{shape, style: {fillColor, 'stroke-width', stroke}}|*}
     */
    function getBrushHandleStyles(brushType, sliderType, extent, segmentCount, userStyles, offset) {
      var dimension = [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]],
        defaultStyles = getDefaultSliderOptions(dimension, brushType === 'x', segmentCount)[sliderType],
        handleStyles = _objectSpread(_objectSpread({}, defaultStyles), userStyles),
        handles = getSliderShape(sliderType, handleStyles, brushType, dimension, offset);

      splat(handles).forEach(function (handle) {
        // splat(handle.style).forEach(style => {
        //     // style.transform = style.transform || null;
        // });
        handle.alignCenter = false;
      });

      return handles;
    }

    /**
     *
     * @param brushType
     * @param sliderType
     * @param extent
     * @param segmentCount
     * @param styles
     * @return {*}
     */
    function getBrushHandle(brushType) {var sliderType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'lever';var extent = arguments.length > 2 ? arguments[2] : undefined;var segmentCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;var styles = arguments.length > 4 ? arguments[4] : undefined;var offset = arguments.length > 5 ? arguments[5] : undefined;
      var handleShapes = getBrushHandleStyles(brushType, sliderType, extent, segmentCount, styles, offset);
      return getD3BrushHandle(brushType).map(function (handle) {
        return _objectSpread(_objectSpread({}, handle), handleShapes);
      });
    }

    /**
     *
     * @param instanceMap
     * @param event
     * @constructor
     */
    function MapBrushListener(instanceMap, event) {
      var eventManager = this;

      if (event.selection) {
        eventManager.associateBehaviours(instanceMap, event.type, {}, event.selection, event);
      }
    }

    /**
     *
     * @param instanceMap
     * @param selectionManager
     * @param selection
     * @constructor
     */
    function ApplyBrushOnMap(instanceMap, selectionManager, selection) {
      var eventManager = this,
        behaviours = eventManager.behaviours;

      if (selection && behaviours.PLOT_ZOOM) {
        var zoomInstance = behaviours.PLOT_ZOOM.instance,
          transform = zoomInstance.getTransform();

        instanceMap.instance.reset();
        zoomInstance.zoomToBounds(selection.map(function (b0) {return transform.invert(b0);}));
      }
    }

    var _mapBrushHandlers = {
      LISTENER: {
        start: MapBrushListener,
        end: MapBrushListener
      },
      DATA_FINDER: {},
      BEHAVIOUR: {
        start: SHOW_SELECTION_BOX,
        end: ApplyBrushOnMap
      },
      LISTENER_TYPES: d3_set(['start', 'brush', 'end']),
      SUPPORTED: function SUPPORTED(chart) {return chart.isGeoMap;}
    };

    Registry.setComponent('_mapBrushHandlers', _mapBrushHandlers);

    //$Id$

    function fetchForColorDomainParser(datatype) {
      return d3_set(['extremes', 'sortedRanges', 'filteredStops', 'min', 'max']);
    }

    function fetchForColorRangeParser(datatype) {
      return d3_set(['colorRanges', 'mapDistinctRanges', 'mapArrayRanges']);
    }

    function fetchForSizdDomainParser(datatype) {
      return datatype === ORDINAL_DATATYPE ? d3_set(['categories']) : d3_set(['extremes']);
    }

    function fetchForShapeDomainParser(datatype) {
      return datatype === ORDINAL_DATATYPE ? d3_set(['categories']) : d3_set(['extremes']);
    }

    /*
    @array - array of input data
    @min - minimum value to filter
    @max - maximum value to filter
    Filters the array data and return the array of data present within the minimum and maximum value
     Covered unit testcases in filteredStops.spec.js
     */


    function filterArrayWithInRange(array, min, max) {
      var _min = defined(min),
        _max = defined(max);
      var output = array.filter(function (d) {
        if (_min && _max) {
          return d >= min && d <= max;
        } else if (_min) {
          return d >= min;
        } else if (_max) {
          return d <= max;
        } else {
          return true;
        }
      });

      return output;
    }

    function spliceMinMaxToArray(array, min, max) {
      if (min < array[0] || !array.length) {
        array.splice(0, 0, min);
      }
      if (max > array[array.length - 1]) {
        array.splice(array.length, 0, max);
      }
      return array;
    }

    function colorDomainParser(encodeType, index, config, chart) {
      var band = config.colorBand,
        stops = band.stops,
        ranges = band.ranges,
        id = encodeType + pick(index, ''),
        processor = chart.dataObject,
        datatype = chart.dataset.getDataType(encodeType);

      var domainOperators = {},
        defaultOperators = fetchForColorDomainParser(datatype);
      /*
          EXTREMES
       */
      if (defaultOperators.has('extremes')) {
        domainOperators.extremes = [
        {
          _type: 'extremesByData',
          data: processor.processedseriesData,
          indices: [chart.dataset.clridx]
        }];

      }

      /*
          Custom min max range
       */
      domainOperators.min = band.minRange;
      domainOperators.max = band.maxRange;

      if (ranges && ranges.length) {
        /* Ranges*/
        domainOperators.ranges = true;
        domainOperators.sortedRanges = {
          datatype: datatype,
          config: band
        };

        //pair and splicemax
      } else if (stops && stops.length) {
        /*Stops*/
        domainOperators.stops = true;
        domainOperators.filteredStops = {
          array: d3_values(stops).sort(d3_ascending),
          min: band.minRange,
          max: band.maxRange
        };
        //spliceminmax
      }
      return domainOperators;
    }

    function sortRanges(operatorC) {
      return getLegendRanges(operatorC.config, operatorC.datatype, true, operatorC.clone);
    }

    function filterStops(operatorC) {
      return filterArrayWithInRange(operatorC.array, operatorC.min, operatorC.max);
    }
    ScaleRegistry.add('color.domainParser', colorDomainParser);

    ScaleRegistry.add('color.sortRanges', sortRanges);
    ScaleRegistry.add('color.filterStops', filterStops);

    ALLOWED_OPERATORS.set('filteredStops', ScaleRegistry.get('color.filterStops'));
    ALLOWED_OPERATORS.set('sortedRanges', ScaleRegistry.get('color.sortRanges'));

    function colorRangeParser(encodeType, index, config, chart) {
      var band = config.colorBand,
        stops = band.stops,
        ranges = band.ranges,
        id = encodeType + pick(index, ''),
        processor = chart.dataObject,
        datatype = chart.dataset.getDataType(encodeType),
        isOrdinal = datatype == ORDINAL_DATATYPE,
        orient = getAxisOrient(encodeType, chart.axes.rotated),
        legendType = getLegendType(config, chart),
        isContinousLegend = legendType !== 'discrete';

      var rangeOperators = {},
        defaultOperators = fetchForColorRangeParser(datatype);

      if (defaultOperators.has('colorRanges')) {
        rangeOperators.colorRanges = {
          colors: chart.imagePallete || chart.seriesColor
        };
      }

      if (ranges && ranges.length) {
        rangeOperators.sortedRanges = {
          datatype: datatype,
          config: band
        };
        rangeOperators.mapArrayRanges = {
          ranges: ranges,
          isOrdinal: isOrdinal,
          isContinousLegend: isContinousLegend
        };
      } else if (!isOrdinal && stops && stops.length) {
        rangeOperators.mapDistinctRanges = {
          stops: stops
        };
      }
      return rangeOperators;
    }

    ScaleRegistry.add('color.rangeParser', colorRangeParser);

    function _pairs(values, first) {
      var pairs = [],
        previous = first;
      values.map(function (d) {
        pairs.push([previous, d[0]]);
        previous = d[0];
      });
      return pairs;
    }

    ScaleRegistry.add('color.utils._pairs', _pairs);

    function spliceMaxIntegers(array) {
      array.splice(0, 0, [-Infinity, -MAX_SAFE_INTEGER]);
      array.splice(array.length, 0, [MAX_SAFE_INTEGER, Infinity]);
      return array;
    }

    function expressionEvalForColorDomain(operators) {
      var extremes = operators.extremes,
        min = this.config.domain.operators.min,
        max = this.config.domain.operators.max,
        ranges,
        stops,
        _domain;

      min = pick(min, extremes[0]) || 0; //min may be undefined|null //Test_695.json
      max = pick(max, extremes[1]) || 0; //max may be undefined|null //Test_695.json

      _domain = [min, max];

      if (operators.sortedRanges) {
        ranges = operators.sortedRanges;
        if (this.config.dataType == ORDINAL_DATATYPE) {
          _domain = ranges;
        } else {
          _domain = ranges;
          if (ranges[0].length === 1) {
            _domain = _pairs(ranges, min);
          }
          _domain = spliceMaxIntegers(_domain);
        }
        _domain = d3_merge(_domain);
      }

      if (operators.filteredStops) {
        stops = operators.filteredStops;
        _domain = spliceMinMaxToArray(stops, min, max);
      }

      return _domain;
    }

    ScaleRegistry.add('color.evalDomain', expressionEvalForColorDomain);

    function expressionEvalForColorRange(operators) {
      var range = operators.mapArrayRanges || operators.mapDistinctRanges || operators.colorRanges;
      this.d3_scale.origRange = range.slice();
      return range;
    }

    ScaleRegistry.add('color.evalRange', expressionEvalForColorRange);

    function colorBoundForScaleRange(operatorC) {
      var _scale = this,
        _parser = _scale.config,
        _chart = _scale.chartObj;

      return operatorC.colors;
    }

    ScaleRegistry.add('color.rangeBound', colorBoundForScaleRange);
    ALLOWED_OPERATORS.set('colorRanges', ScaleRegistry.get('color.rangeBound'));

    function mapDistinctDomainToRanges(operatorC, appliedOperators) {
      var domain = this.d3_scale.domain,
        stops = operatorC.stops,
        range = appliedOperators.colorRanges,
        prevStopIndex = 0,
        range_mapped = [];
      domain.forEach(function (d, i) {
        var stopIndex = stops.indexOf(d);
        if (stopIndex === -1) {
          stopIndex = prevStopIndex;
        }
        range_mapped.push(range[stopIndex % range.length]);
        prevStopIndex = stopIndex;
      });
      return range_mapped;
    }

    function mapRangeDomainsToRanges(operatorC, appliedOperators) {
      var domain = this.d3_scale.domain,
        isOrdinal = operatorC.isOrdinal,
        range = appliedOperators.colorRanges,
        sortedRange = appliedOperators.sortedRanges,
        isContinousLegend = operatorC.isContinousLegend,
        range_mapped = [];
      var i = 0,
        check = function check(r, j) {
          if (
          r.length === 1 ?
          isOrdinal ?
          r[0] === domain[i] :
          r[0] === domain[i + 1] :
          r[0] === domain[i] && r[1] === domain[i + 1])
          {
            rangeIndex = j;
            return true;
          }
        };

      for (var len = domain.length; i < len; isOrdinal ? i++ : i += 2) {
        var rangeIndex = -1;
        sortedRange.some(check);
        if (rangeIndex === -1 || !isContinousLegend && sortedRange[rangeIndex].disabled) {
          range_mapped.push(null);
        } else {
          range_mapped.push(range[rangeIndex % range.length]);
        }
      }

      // range_mapped.push(null);
      // sortedRange.map((d,i) => {
      //     range_mapped.push(range[i%range.length]);
      // })
      // range_mapped.push(null);

      return range_mapped;
    }

    ScaleRegistry.add('color.rangesForDistinctDomain', mapDistinctDomainToRanges);
    ScaleRegistry.add('color.rangesForArrayDomain', mapRangeDomainsToRanges);

    ALLOWED_OPERATORS.set('mapDistinctRanges', ScaleRegistry.get('color.rangesForDistinctDomain'));
    ALLOWED_OPERATORS.set('mapArrayRanges', ScaleRegistry.get('color.rangesForArrayDomain'));

    //$Id$

    function shapeDomainParser(encodeType, index, config, chart) {
      var processor = chart.dataObject,
        dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType, index),
        columnInfo = dataSet.getColumn(encodeType, index),
        nullAsOptions = { config: config, columnKey: dataSet.getColumnIdx(encodeType, index) },
        _data = processor.processedseriesData,

        isCatNull = DataProcessor.helpers.isCatNull,
        isCatNullX = isCatNull(dataSet, 'x'),
        isCatNullY = isCatNull(dataSet, 'y', 0),
        condition =
        hasGeo$1(chart) || chart.systemConf.legend.singleLayout && dataType === NUMERIC_DATATYPE ?
        false :
        function (d) {return !(isCatNullX(dataSet.getActualX(d, index)) || isCatNullY(dataSet.getY(d, index)));},
        schema = dataType === TIME_DATATYPE ? toTimestamp(config, columnInfo) : null,_ref13 =
        schema || config,minRange = _ref13.minRange,maxRange = _ref13.maxRange,stops = _ref13.stops,ranges = _ref13.ranges,
        nullAsConvertion = function nullAsConvertion(d) {return convertNull(d[columnInfo.dataindex], nullAsOptions);};

      var domainOperators = {},
        defaultOperators = fetchForShapeDomainParser(dataType);

      /*
          EXTREMES
       */
      if (defaultOperators.has('extremes')) {
        if (chart.systemConf.legend.singleLayout && encodeType === 'z') {
          domainOperators.extremes = [function () {return processor.getMinMaxZ();}];
        } else {
          domainOperators.extremes = [
          {
            _type: 'extremesByAccessor',
            data: _data,
            condition: condition,
            accessor: function accessor() {
              return nullAsConvertion;
            }
          }];

        }
      }

      if (defaultOperators.has('categories')) {
        var _d = d3_merge(_data.map(function (_) {return d3_merge(_.data);}));
        domainOperators.categories = categories(_d, nullAsConvertion);
      }

      if (dataType === NUMERIC_DATATYPE && !chart.isGeoMap) {
        var base = config.base;
        domainOperators.base = base !== UNDEFINED ? base : 0;
      }

      /*
          Custom min max range
       */
      domainOperators.min = minRange;
      domainOperators.max = maxRange;

      if (ranges && ranges.length) {
        /* Ranges*/
        domainOperators.sortedRanges = {
          datatype: dataType,
          clone: false,
          config: _objectSpread(_objectSpread({}, config), {}, { ranges: ranges })
        };
      } else if (stops && stops.length) {
        /*Stops*/
        domainOperators.filteredStops = {
          array: d3_values(stops).sort(d3_ascending),
          min: minRange,
          max: maxRange
        };
      }
      return domainOperators;
    }

    ScaleRegistry.add('shape.domainParser', shapeDomainParser);

    function hasGeo$1(chartObj) {
      // TODO  change chartObj.dataObject.isFlowChartCategory
      return chartObj.isGeoMap || chartObj.mapObj || chartObj.dataObject.isFlowChartCategory;
    }

    //$Id$

    function shapeRangeParser(encodeType, index, config, chart, customMax) {
      // TODO
      var dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType),
        ranges = config.ranges,userShapes = config.shapes,
        rangeOperators = {};

      if (userShapes) {
        rangeOperators.userShapes = {
          shapes: userShapes
        };
        return rangeOperators;
      }

      rangeOperators.baseShapes = {
        shapes: ['star', 'heart', 'diamond']
      };

      if (ranges || dataType === ORDINAL_DATATYPE) {
        rangeOperators.mapDiscreteDomainToDiscreteRange = { ranges: ranges };
      } else {
        rangeOperators.mapContinuousDomainToDiscreteRange = {};
      }

      return rangeOperators;
    }

    ScaleRegistry.add('shape.rangeParser', shapeRangeParser);

    //$Id$

    function shapeLegendParser(encodeType) {var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var chart = arguments.length > 2 ? arguments[2] : undefined;var config = arguments.length > 3 ? arguments[3] : undefined;
      var dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType, index),
        columnInfo = dataSet.getColumn(encodeType, index);

      var parser = {
        type: dataType,
        dataType: dataType,
        scaleType: columnInfo.scaleType,
        field: columnInfo,
        reverse: config.reversed,
        clamp: true,
        data: [],
        domain: {
          operators: ScaleRegistry.get('shape.domainParser')(encodeType, index, config, chart),
          evaluator: ScaleRegistry.get('shape.evalDomain')
        },
        range: {
          operators: ScaleRegistry.get('shape.rangeParser')(encodeType, index, config, chart),
          evaluator: ScaleRegistry.get('shape.evalRange')
        }
      };

      return parser;
    }

    Registry.setComponent('shape.parser', shapeLegendParser);

    //$Id$

    function expressionEvalForShapeDomain(operators) {
      var extremes = operators.extremes,
        schema = this.config.domain.operators,
        min = schema.min,max = schema.max,base = schema.base,
        sortedRanges = operators.sortedRanges,filteredStops = operators.filteredStops,
        domain = extremes;

      if (sortedRanges) {
        return d3_merge(sortedRanges);
      }

      if (schema.categories) {
        return schema.categories;
      }

      if (defined(base)) {
        domain = d3_extent([].concat(_toConsumableArray(domain), [base]));
      }

      if (defined(min)) {
        domain[0] = min;
      }

      if (defined(max)) {
        domain[domain.length - 1] = max;
      }

      if (filteredStops) {
        domain = spliceMinMaxToArray(filteredStops, pick(min, domain[0]) || 0, pick(max, domain[domain.length - 1]) || 0);
      }

      return domain;
    }

    ScaleRegistry.add('shape.evalDomain', expressionEvalForShapeDomain);

    //$Id$

    function expressionEvalForShapeRange(operators) {
      return operators.userShapes || operators.mapDiscreteDomainToDiscreteRange || operators.mapContinuousDomainToDiscreteRange;
    }

    ScaleRegistry.add('shape.evalRange', expressionEvalForShapeRange);

    //$Id$

    function userShapes(operatorC, appliedOperators) {
      // TODO
      return operatorC.shapes;
    }

    function baseShapes(operatorC, appliedOperators) {
      return operatorC.shapes;
    }

    ALLOWED_OPERATORS.set('userShapes', userShapes);
    ALLOWED_OPERATORS.set('baseShapes', baseShapes);

    ScaleRegistry.add('size.userShapes', userShapes);
    ScaleRegistry.add('size.baseShapes', baseShapes);

    //$Id$
    // import { ScaleRegistry } from '../../scale-registry';

    function mapDiscreteDomainToDiscreteRange(operatorC, appliedOperators) {
      var _scale = this,
        domain = _scale.d3_scale.domain,
        ranges = operatorC.ranges,
        baseShapes = appliedOperators.baseShapes,
        tempDomain = ranges || domain,
        tempScalePoint = d3_scaleOrdinalOrg();

      tempScalePoint.
      domain(tempDomain) // multiple values
      .range(baseShapes);

      return tempDomain.map(tempScalePoint);
    }

    function mapContinuousDomainToDiscreteRange(operatorC, appliedOperators) {
      var _scale = this,
        domain = _scale.d3_scale.domain,
        baseShapes = appliedOperators.baseShapes,
        tempDomain = [domain[0], domain[domain.length - 1]],
        tempScaleLinear = d3_scaleLinear();

      tempScaleLinear.
      domain(tempDomain) // multiple stops may have
      .range(baseShapes); // TODO check single data (tempDomain[0] == tempDomain[1] ? [mid, mid] : range)

      return domain.map(tempScaleLinear);
    }

    ALLOWED_OPERATORS.set('mapDiscreteDomainToDiscreteRange', mapDiscreteDomainToDiscreteRange);
    ALLOWED_OPERATORS.set('mapContinuousDomainToDiscreteRange', mapContinuousDomainToDiscreteRange);

    // ScaleRegistry.add('size.mapDiscreteDomainToRange', mapDiscreteDomainToRange);
    // ScaleRegistry.add('size.mapContinuousDomainToRange', mapContinuousDomainToRange);

    //$Id$

    //$Id$

    function sizeDomainParser(encodeType, index, config, chart) {
      var processor = chart.dataObject,
        dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType, index),
        columnInfo = dataSet.getColumn(encodeType, index),
        nullAsOptions = { config: config, columnKey: dataSet.getColumnIdx(encodeType, index) },
        zEncode = processor.encodes && processor.getEncode(encodeType, index),
        _data = config._data || (zEncode ? zEncode.seriesData : []),

        isCatNull = DataProcessor.helpers.isCatNull,
        isCatNullX = isCatNull(dataSet, 'x'),
        isCatNullY = isCatNull(dataSet, 'y', 0),
        condition =
        hasGeo$2(chart) || chart.systemConf.legend.singleLayout && dataType === NUMERIC_DATATYPE ?
        false :
        function (d) {return !(isCatNullX(dataSet.getActualX(d, index)) || isCatNullY(dataSet.getY(d, index)));},
        schema = dataType === TIME_DATATYPE ? toTimestamp(config, columnInfo) : null,_ref14 =
        schema || config,minRange = _ref14.minRange,maxRange = _ref14.maxRange,stops = _ref14.stops,ranges = _ref14.ranges,
        nullAsConvertion = function nullAsConvertion(d) {return convertNull(d[columnInfo.dataindex], nullAsOptions);};

      // _data = _data.map(series => {
      //     series.data[0].filter(condition)
      // })

      // if (ranges && ranges._dummy) {
      //     config.ranges = null;
      //     ranges = null;
      // }

      // TODO
      // let view = _legendType(encodeType, { config, dataType }),
      //     newRanges = generateRanges(config, schema, scale, view);
      //
      // if (newRanges) {
      //     config.ranges = newRanges;
      // }

      // if (encodeType === 'z') {
      //     // getLegendConfig(encodeType, index, chart).ranges = ranges;
      // }

      var domainOperators = {},
        defaultOperators = fetchForSizdDomainParser(dataType);

      /*
          EXTREMES
       */
      if (defaultOperators.has('extremes')) {
        if (chart.systemConf.legend.singleLayout && encodeType === 'z') {
          domainOperators.extremes = [function () {return processor.getMinMaxZ();}];
        } else {
          domainOperators.extremes = [
          {
            _type: 'extremesByAccessor',
            data: _data,
            condition: condition,
            accessor: function accessor() {
              return nullAsConvertion;
            }
          }];

        }
      }

      if (defaultOperators.has('categories')) {
        var _d = d3_merge(_data.map(function (_) {return d3_merge(_.data);}));
        domainOperators.categories = categories(_d, nullAsConvertion);
      }

      if (dataType === NUMERIC_DATATYPE && !chart.isGeoMap) {
        var base = config.base;
        domainOperators.base = base !== UNDEFINED ? base : 0;
      }

      /*
          Custom min max range
       */
      domainOperators.min = minRange;
      domainOperators.max = maxRange;

      if (ranges && ranges.length) {
        /* Ranges*/
        domainOperators.sortedRanges = {
          datatype: dataType,
          clone: false,
          config: _objectSpread(_objectSpread({}, config), {}, { ranges: ranges })
        };
      } else if (stops && stops.length) {
        /*Stops*/
        domainOperators.filteredStops = {
          array: d3_values(stops).sort(d3_ascending),
          min: minRange,
          max: maxRange
        };
      }
      return domainOperators;
    }

    // function generateRanges(config, schema, scale, view) {
    //     let { dataType, meta } = schema.data,
    //         { ranges, stops } = schema.domain,
    //         configRanges = config.ranges,
    //         subFunction = getSubFunction(meta),
    //         scale_domain = scale.domain();
    //
    //     if (view !== LIST_LEGEND_TYPE || ranges || dataType === ORDINAL_DATATYPE) {
    //         return;
    //     }
    //
    //     // If no change in scale domain and subfunction, just return the ranges(reason: after legend filter if chart dimension differs on redraw, new set of ranges are created in where disabled property is removed)
    //     let _cache = configRanges && configRanges._cache;
    //     if (_cache && _cache.subFunction === subFunction && jsonStringify(_cache.domain) === jsonStringify(scale_domain)) {
    //         return configRanges;
    //     }
    //
    //     let count = getTickCount(config, scale, view),
    //         ticks = stops ? scale_domain : getEntries(scale, dataType, count + 1, subFunction),
    //         generated = ticks.length === 1 ? [[ticks[0], ticks[0]]] : d3_pairs(ticks); // ZC2548
    //
    //     generated._dummy = true;
    //     generated._cache = { subFunction, domain: scale_domain };
    //
    //     // Adding the disabled property on redraw
    //     if (configRanges && jsonStringify(configRanges) === jsonStringify(generated)) {
    //         configRanges.forEach((_, i) => (generated[i].disabled = _.disabled));
    //     }
    //
    //     return generated;
    // }
    //
    // function getSubFunction(meta) {
    //     let { datatype: dataType } = meta,
    //         formatConfig = meta[dataType] || {};
    //
    //     return formatConfig.subfunction;
    // }

    ScaleRegistry.add('size.domainParser', sizeDomainParser);

    function hasGeo$2(chartObj) {
      // TODO  change chartObj.dataObject.isFlowChartCategory
      return chartObj.isGeoMap || chartObj.mapObj || chartObj.dataObject.isFlowChartCategory;
    }

    var getUserFontValue = function getUserFontValue(fontStyle, userStyle) {
      var FONT_NORMAL = 'normal',
        style = userStyle && userStyle['font-style'] || fontStyle['font-style'] || FONT_NORMAL,
        weight = userStyle && userStyle['font-weight'] || fontStyle['font-weight'] || FONT_NORMAL,
        size = userStyle && userStyle['font-size'] || fontStyle['font-size'],
        family = userStyle && userStyle['font-family'] || fontStyle['font-family'];

      return "".concat(style, " ").concat(FONT_NORMAL, " ").concat(weight, " ").concat(size, " ").concat(family);
    };

    function getTextHeight(font) {
      var globalSvg = d3_selectAll('div.__baseZC_Container__ > svg.svgPattern');
      if (!globalSvg.node()) {
        globalSvg = createElement('svg', '.__zc_fakeBody', [1], d3_selectAll('body'));
      }
      var textElement = createElement('text', '#zc-text-dummy', [1], globalSvg);

      textElement.html('qtyplkjhgfd');
      applyFont(textElement, font);

      var height = bbox(textElement).height;
      textElement.remove();

      return height;
    }

    //

    function sizeCorrection(size, bound, options, chartObj) {
      if (chartObj.systemConf.legend.singleLayout) {
        return size;
      }

      var encode = 'z',
        config = options.config,
        minSize = config.minSize,maxSize = config.maxSize,titleConfig = config.title,
        legendType = _legendType(encode, options),
        renderer = LegendRegistry.get(encode, legendType),
        maxWidth = bound.maxWidth,maxHeight = bound.maxHeight,
        viewOptions = config[legendType] || {},
        padding = pick(viewOptions.padding, 3),
        globalFont = chartObj.systemConf.canvas,

        legendAlign = getLegendAlignment(config),
        isHorizontal = legendAlign.layout === HORIZONTAL_ALIGN;

      if (!isLegendEnabled(config, chartObj, encode) || renderer === noOperation) {
        return size;
      }

      if (renderer.adjustFactor) {
        if (titleConfig.show) {
          var titleMargin = parseShortHandValue(pick(titleConfig.margin, 3)),
            keepAligned = titleConfig.keepAligned;

          if (!(keepAligned && isHorizontal)) {
            maxHeight -= getTextHeight([titleConfig, globalFont, $ZCG]) + titleMargin.top + titleMargin.bottom;
          }
        }

        var adjust = renderer.adjustFactor(config, maxWidth, maxHeight, globalFont, size);
        maxWidth -= adjust[0];
        maxHeight -= adjust[1];
      }

      var dim = mathMin(maxWidth, maxHeight) - 2 * padding,
        maxDim = mathMax(dim, 20), // ZC2254
        minDim = mathMax(dim * 0.1, 5);

      if (size[1] > dim) {
        if (isUndefined(maxSize)) {
          size[1] = maxDim;
        }

        if (isUndefined(minSize)) {
          size[0] = minDim;
        }
      }

      // If min size is greater than max size // DOC_BUBBLEPIE_6
      if (size[0] > size[1]) {
        if (isUndefined(maxSize)) {
          size[1] = size[0];
        }

        if (isUndefined(minSize)) {
          size[0] = size[1];
        }
      }

      return size;
    }

    //$Id$

    function sizeRangeParser(encodeType, index, config, chart, customMax) {
      var dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType),
        ranges = config.ranges,userSizes = config.sizes,
        bound = getLegendBound(config, chart.chartarea, customMax),
        rangeOperators = {};

      if (userSizes) {
        rangeOperators.userRanges = {
          size: userSizes,
          plotBound: _isMatrix(chart) ? null : chart.plotarea,
          callbackArgs: [chart, bound]
        };
        return rangeOperators;
      }

      rangeOperators.baseSize = {
        config: config,
        size: _defaultPercent(chart),
        plotBound: _isMatrix(chart) ? null : chart.plotarea,
        correction: function correction(_) {return sizeCorrection(_, bound, { config: config, dataType: dataType }, chart);},
        callbackArgs: [chart, bound]
      };

      if (ranges || dataType === ORDINAL_DATATYPE) {
        rangeOperators.mapDiscreteDomainToRange = { ranges: ranges };
      } else {
        rangeOperators.mapContinuousDomainToRange = {};
      }

      return rangeOperators;
    }

    function _defaultPercent(chart) {
      return _isMatrix(chart) ? ['25%', '100%'] : chart.systemConf.legend.singleLayout ? ['2.5%', '25%'] : ['2%', '20%'];
    }

    function _isMatrix(chart) {
      var chartType = chart.chartTypes[0].value;
      return isHeatMapChartType(chartType);
    }

    ScaleRegistry.add('size.rangeParser', sizeRangeParser);

    //$Id$

    function sizeLegendParser(encodeType) {var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var chart = arguments.length > 2 ? arguments[2] : undefined;var config = arguments.length > 3 ? arguments[3] : undefined;
      var dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType, index),
        columnInfo = dataSet.getColumn(encodeType, index);

      var parser = {
        type: dataType,
        dataType: dataType,
        scaleType: columnInfo.scaleType,
        field: columnInfo,
        reverse: config.reversed,
        clamp: true,
        data: [],
        domain: {
          operators: ScaleRegistry.get('size.domainParser')(encodeType, index, config, chart),
          evaluator: ScaleRegistry.get('size.evalDomain')
        },
        range: {
          operators: ScaleRegistry.get('size.rangeParser')(encodeType, index, config, chart),
          evaluator: ScaleRegistry.get('size.evalRange')
        }
      };

      return parser;
    }

    Registry.setComponent('size.parser', sizeLegendParser);

    //$Id$

    function expressionEvalForSizeDomain(operators) {
      var extremes = operators.extremes,
        schema = this.config.domain.operators,
        min = schema.min,max = schema.max,base = schema.base,
        sortedRanges = operators.sortedRanges,filteredStops = operators.filteredStops,
        domain = extremes;

      if (sortedRanges) {
        return d3_merge(sortedRanges);
      }

      if (schema.categories) {
        return schema.categories;
      }

      if (defined(base)) {
        domain = d3_extent([].concat(_toConsumableArray(domain), [base]));
      }

      if (defined(min)) {
        domain[0] = min;
      }

      if (defined(max)) {
        domain[domain.length - 1] = max;
      }

      if (filteredStops) {
        domain = spliceMinMaxToArray(filteredStops, pick(min, domain[0]) || 0, pick(max, domain[domain.length - 1]) || 0);
      }

      return domain;
    }

    ScaleRegistry.add('size.evalDomain', expressionEvalForSizeDomain);

    //$Id$

    function expressionEvalForSizeRange(operators) {
      return operators.userRanges || operators.mapDiscreteDomainToRange || operators.mapContinuousDomainToRange;
    }

    ScaleRegistry.add('size.evalRange', expressionEvalForSizeRange);

    //$Id$

    function baseSize(operatorC, appliedOperators) {
      var _operatorC$config = operatorC.config,config = _operatorC$config === void 0 ? {} : _operatorC$config,_defaultSize = operatorC.size,_operatorC$callbackAr = operatorC.callbackArgs,callbackArgs = _operatorC$callbackAr === void 0 ? [] : _operatorC$callbackAr,correction = operatorC.correction,
        minSize = invokeFunction.apply(void 0, [config.minSize].concat(_toConsumableArray(callbackArgs))),
        maxSize = invokeFunction.apply(void 0, [config.maxSize].concat(_toConsumableArray(callbackArgs)));

      var defaultSize = [pick(minSize, _defaultSize[0]), pick(maxSize, _defaultSize[1])].map(convertTo(operatorC));
      return correction ? correction(defaultSize) : defaultSize;
    }

    function userRanges(operatorC, appliedOperators) {
      var size = operatorC.size,_operatorC$callbackAr2 = operatorC.callbackArgs,callbackArgs = _operatorC$callbackAr2 === void 0 ? [] : _operatorC$callbackAr2,
        userSizes = invokeFunction.apply(void 0, [size].concat(_toConsumableArray(callbackArgs)));

      return userSizes.map(convertTo(operatorC));
    }

    function convertTo(operatorC) {
      var plotBound = operatorC.plotBound,
        dimension = plotBound ? mathMin(plotBound.width, plotBound.height) : 1;
      return function (_) {return perToPx(_, dimension);};
    }

    ALLOWED_OPERATORS.set('baseSize', baseSize);
    ALLOWED_OPERATORS.set('userRanges', userRanges);

    ScaleRegistry.add('size.baseSize', baseSize);
    ScaleRegistry.add('size.userRanges', userRanges);

    //$Id$

    function mapDiscreteDomainToRange(operatorC, appliedOperators) {
      var _scale = this,
        domain = _scale.d3_scale.domain,
        ranges = operatorC.ranges,
        baseSize = appliedOperators.baseSize,
        tempDomain = ranges || domain,
        tempScalePoint = d3_scalePoint();

      tempScalePoint.
      domain(tempDomain) // multiple values
      .range(baseSize);

      return tempDomain.map(tempScalePoint);
    }

    function mapContinuousDomainToRange(operatorC, appliedOperators) {
      var _scale = this,
        domain = _scale.d3_scale.domain,
        baseSize = appliedOperators.baseSize,
        tempDomain = [domain[0], domain[domain.length - 1]],
        mid = baseSize[0] + (baseSize[1] - baseSize[0]) / 2,
        tempScaleLinear = d3_scaleLinear();

      tempScaleLinear.
      domain(tempDomain) // multiple stops may have
      .range(tempDomain[0] == tempDomain[1] ? [mid, mid] : baseSize);

      return domain.map(tempScaleLinear);
    }

    ALLOWED_OPERATORS.set('mapDiscreteDomainToRange', mapDiscreteDomainToRange);
    ALLOWED_OPERATORS.set('mapContinuousDomainToRange', mapContinuousDomainToRange);

    ScaleRegistry.add('size.mapDiscreteDomainToRange', mapDiscreteDomainToRange);
    ScaleRegistry.add('size.mapContinuousDomainToRange', mapContinuousDomainToRange);

    //$Id$

    defaultTheme.axes = function (userProp) {
      var axisOptions = {
        xaxisLevels: {},
        yaxisLevels: {},
        xaxis: {
          splitLeaves: false,
          uniformLeafScale: true,
          show: true,
          label: {
            show: true,
            text: 'Xaxis',
            fontSize: userProp.fontL2Size.l4,
            marginTop: 5,
            marginRight: 5,
            marginBottom: 5,
            marginLeft: 5
          },
          grid: {
            show: true,
            color: 'transparent',
            strokeWidth: null
          },
          minorGrid: {
            show: false,
            color: '#ececec'
          },
          subtickmark: {
            show: false,
            color: '#ececec',
            size: 3,
            count: 0
          },
          ticklabel: {
            textOverflow: 'ellipsis', // none,ellipsis,hidden
            fontSize: userProp.fontL2Size.l5
          },
          tickmark: {
            strokeWidth: null,
            color: '#ececec',
            size: 3
          },
          axisline: {
            show: true,
            color: '#ececec',
            strokeWidth: null,
            style: 'solid'
          },
          baseline: {
            show: false,
            value: 10,
            color: 'black'
          },
          threshold: {
            line: {
              show: false,
              values: [],
              label: {
                text: ['Description comes here'],
                fontSize: userProp.fontL2Size.l5
              },
              marker: {
                enabled: true,
                hoveroptions: {
                  innerStrokeOpacity: 1,
                  outerFillColor: 'transparent',
                  outerStrokeWidth: 2
                }
              }
            },
            coloroverlay: {
              show: false,
              values: [],
              overlayRange: 'below'
            },
            range: {
              show: false,
              values: [],
              label: {
                text: ['Description comes here'],
                fontSize: userProp.fontL2Size.l5
              }
            }
          }
        },
        yaxis: [
        {
          show: true,
          label: {
            show: true,
            text: 'Yaxis',
            fontSize: userProp.fontL2Size.l4,
            marginTop: 5,
            marginRight: 5,
            marginBottom: 5,
            marginLeft: 5
          },
          grid: {
            show: true,
            color: '#ececec'
          },
          minorGrid: {
            show: false,
            color: '#ececec'
          },
          ticklabel: {
            textOverflow: 'ellipsis', // none,ellipsis,hidden
            fontSize: userProp.fontL2Size.l5
          },
          tickmark: {
            color: '#ececec',
            size: 3
          },
          subtickmark: {
            color: '#ececec',
            size: 5,
            count: 0
          },
          axisline: {
            show: true,
            color: '#ececec',
            strokeWidth: null,
            style: 'solid'
          },
          baseline: {
            show: false,
            value: 0,
            color: 'grey',
            strokeWidth: null
          },
          threshold: {
            line: {
              show: false,
              values: [],
              label: {
                text: ['Description comes here'],
                fontSize: userProp.fontL2Size.l5
              },
              marker: {
                enabled: true,
                hoveroptions: {
                  innerStrokeOpacity: 1,
                  outerFillColor: 'transparent',
                  outerStrokeWidth: 2
                }
              }
            },
            coloroverlay: {
              show: false,
              values: [],
              overlayRange: 'below'
            },
            range: {
              show: false,
              values: [],
              label: {
                text: ['Description comes here'],
                fontSize: userProp.fontL2Size.l5
              }
            }
          }
        }]

      };
      return axisOptions;
    };

    function addMinmaxToTicks(ticks) {
      var scale = this.scale(),
        type = this.type,order = this.order,config = this.config,plotRect = this.plotRect,datatype = this.datatype,column = this.column;

      var minmaxlabelsdata = config.ticklabel.minmaxlabels || {};
      if (minmaxlabelsdata.show === true) {
        var newScale = this.tickH.scale(); //Scale with actual outerPadding
        var domain = newScale.domain();
        if (validateNullVal(minmaxlabelsdata.excludeIntervals, true)) {
          ticks = domain;
        } else {
          if (domain[0] !== ticks[0]) {
            ticks.splice(0, 0, domain[0]);
          }
          if (domain[1] !== ticks[ticks.length - 1]) {
            ticks.push(domain[1]);
          }
        }
      }
      return ticks;
    }

    function _getLogTicks(logTickH) {var _this18 = this;
      {
        var _scale5 = this.scale,size = this.size,side = this.side,_styles2 = this.styles,format = this.format,rotation = this.rotation,formatter = this.formatter,formatAccessor = this.formatAccessor,margin = this.margin,
          domain = logTickH.domain,_this$config$ticklabe2 =
          this.config.ticklabel,tickCount = _this$config$ticklabe2.tickCount,tickInterval = _this$config$ticklabe2.tickInterval,
          column = this.column,orient = this.orient,
          tickValues,
          minorTickValues,
          logDomain,
          formattingSubFunction = format.subfunction;

        if (_scale5.constant) {
          var min = d3_min(domain);
          if (min > 0 && min < pick(logTickH.axisObj.logBase, 10) && logTickH.axisObj.allowNonPositiveTicks === false) {
            _scale5.constant(0.0001);
          } else {
            _scale5.constant(1);
          }
        }
        var addMinMaxLog = function addMinMaxLog(tickValues) {
          logTickH.axisInfo.logDomain = d3_extent(tickValues);

          return addMinmaxToTicks.call(_this18, tickValues);
        };
        var formatFunc = function formatFunc(tickValues) {
          return tickValues.map(formatAccessor);
        };
        // fix all negative
        var _getLogTicks3 = getLogTicks(
        logTickH.domainCopy,
        size,
        logTickH.dataMinMax,
        logTickH.usePadding,
        logTickH.axisObj,
        _scale5.copy(),
        margin,
        {
          fontSize: _styles2.fontSize,
          fontFamily: _styles2.fontFamily
        },
        formatFunc,
        orient,
        rotation,
        logTickH.adjustToBase,
        addMinMaxLog,
        logTickH.hasFixedPosition,
        domain);tickValues = _getLogTicks3.tickValues;minorTickValues = _getLogTicks3.minorTickValues;logDomain = _getLogTicks3.logDomain;

        logTickH.axisInfo.logDomain = logDomain;
        return { ticks: tickValues, minorTickValues: minorTickValues };

      }
    }

    function getNumericTicks() {
      var domain = this.domain,simpleScale = this.simpleScale,size = this.size,side = this.side,format = this.format,_this$config =
        this.config,tickCount = _this$config.tickCount,interval = _this$config.interval,maxRange = _this$config.maxRange,tickMultiples = _this$config.tickMultiples,minTick = _this$config.minTick,
        ticks,
        formattingSubFunction = format.subfunction,
        calculatedInterval = (domain[1] - domain[0]) / interval;

      if (simpleScale.isD3) {
        simpleScale = simpleScale().
        domain(domain).
        range(size);
      }
      if (defined(interval) && calculatedInterval < size) {
        interval = defined(tickCount) ? (domain[1] - domain[0]) / tickCount : interval;
        ticks = getLinearTicksByInterval$1(domain, interval, minTick, maxRange);
      } else if (+tickCount > 0) {
        interval = (domain[1] - domain[0]) / tickCount;
        ticks = getLinearTicksByCount$1(domain, tickCount, minTick, maxRange, formattingSubFunction, tickMultiples);
      } else if (formattingSubFunction === 'integer') {
        ticks = getLinearTicksBySubFunction$1(domain, null, maxRange);
      } else {
        if (side === 'height') {
          tickCount = tickCount || mathRound(size / 40);
        } else {
          tickCount = tickCount || mathRound(size / 100);
        }
        if (defined(minTick)) {
          var step = d3_tickStep(minTick, domain[1], tickCount);
          ticks = d3_range(minTick, domain[1], step);
        } else {
          ticks = simpleScale.ticks(tickCount);
        }
      }
      ticks = addMinmaxToTicks.call(this, ticks);


      return ticks;
    }

    function getLinearTicksByCount$1(domain, count, customStart, customStop, intervalType, tickMultiples) {
      if (count === 1) {
        step = getLinearStep$1(domain, 1);
        min = Math.ceil(domain[0] / step) * step;
        return [min];
      } else {
        var tickInterval = (domain[1] - domain[0]) / (count - 1),
          min,
          max,
          remaining,
          m = count - 1,
          span = domain[1] - domain[0],
          step = span / m,
          power = mathFloor(mathLog(step) / mathLN10),
          magnitude = mathPow(10, power),
          ticks;

        magnitude = magnitude * Math.floor(step / magnitude);
        magnitude = +magnitude.toFixed(12); //To avoid floating point error (e.g):1.7000000000000002

        var nicedInterval = nearestTickInterval(tickInterval, magnitude, tickMultiples, intervalType);

        if (intervalType == 'integer' && nicedInterval < 1) {
          return getLinearTicksBySubFunction$1(domain, count, customStop);
        }
        min = domain[0];
        max = domain[1];
        remaining = span - nicedInterval * m;

        // if (remaining < nicedInterval && Math.floor((span / m) / magnitude) > 1) {
        //     nicedInterval -= magnitude;
        //     remaining = span - (nicedInterval * m);
        // }

        var mag_remaining = mathPow(10, mathFloor(mathLog(remaining) / mathLN10) + 1);
        min = nearestNiceMin(min, remaining, mag_remaining, nicedInterval);
        min = +min.toFixed(12); //To avoid floating point error (e.g):1.7000000000000002
        min = pick(customStart, min);
        max = min + nicedInterval * count;
        max = +max.toFixed(12); //Test_559,560

        max = max > domain[1] ? +domain[1] : max;
        ticks = d3_range(min, max, nicedInterval);
        if (defined(customStop)) {
          ticks = addMaxStopToTicks$1(ticks, nicedInterval, customStop);
        } else if (ticks.length < count) {
          ticks = addMaxStopToTicks$1(ticks, nicedInterval, max);
        }
        return ticks;
      }
    }

    function getLinearStep$1(domain, count) {
      var m = defined(count) ? count : 10,
        span = domain[1] - domain[0],
        step = mathPow(10, mathFloor(mathLog(span / m) / mathLN10)),
        err = m / span * step;
      if (err <= 0.15) {
        step *= 10;
      } else if (err <= 0.35) {
        step *= 5;
      } else if (err <= 0.75) {
        step *= 2;
      }
      return step;
    }

    function getLinearTicksByInterval$1(domain, tickInterval, customStart, customStop) {
      var count = mathFloor((domain[1] - domain[0]) / tickInterval),
        min,
        ticks;

      if (count) {
        var step = getLinearStep$1(domain, count);
        min = mathCeil(domain[0] / step) * step;

        if (min - domain[0] > tickInterval) {
          var s = mathPow(10, mathFloor(mathLog(tickInterval) / mathLN10)),
            q = mathFloor((min - domain[0]) / s);
          min -= q * s;
        }
      } else {
        var span = domain[1] - domain[0],
          s = mathPow(10, mathFloor(mathLog(span) / mathLN10));
        min = domain[0] - domain[0] % s + s;
      }
      min = pick(customStart, min);
      ticks = d3_range(min, domain[1], tickInterval);
      if (defined(customStop)) {
        ticks = addMaxStopToTicks$1(ticks, tickInterval, customStop);
      }
      return ticks;
    }

    function getLinearTicksBySubFunction$1(domain, count, customStop) {
      var ticks,
        interval = getNiceStep$1(domain, count);
      ticks = d3_range(getNiceMin$1(domain, 1), domain[1], interval);
      if (defined(customStop)) {
        ticks = addMaxStopToTicks$1(ticks, interval, customStop);
      }
      return ticks;
    }

    function getNiceMin$1(domain, minStep) {
      var step = getLinearStep$1(domain);
      if (defined(minStep)) {
        // Test_525.json
        step = mathMax(minStep, step);
      }
      return mathCeil(domain[0] / step) * step;
    }

    function getNiceStep$1(domain, count) {
      return mathCeil(getLinearStep$1(domain, count));
    }

    function addMaxStopToTicks$1(ticks, interval, stopValue) {
      if (ticks[ticks.length - 1] + interval <= stopValue) {
        ticks.push(ticks[ticks.length - 1] + interval);
      }
      return ticks;
    }

    function _brushDomain(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,datatype = helpers.datatype,plotRect = helpers.plotRect,
        dataObject = chart.dataObject,
        behaviours = getPropVal(chart, 'behaviouralEvents.eventManager.behaviours') || {},
        domain,
        ticks,
        side = isRotatedChart(type, chart.axes.rotated) ? 'height' : 'width',
        axisInfo = getAxisObject(chart, type, order),
        existingScale,
        firstChartName = chart.chartTypes[0].name,
        commonPlotOptions = chart.systemConf.chart.plot.plotoptions[firstChartName],
        outerPadding = dataObject.isAxisCategory ? commonPlotOptions.outerPadding || 0 : 0,
        plotSize = getPlotSize(helpers.chart, side, plotRect),
        zoomedPlotSize,
        hasSmoothEffect = behaviours.PLOT_ZOOM || behaviours.CHART_SCROLL && chart.scroll && chart.scroll.settings.smooth && type === 'x';
      if (behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL) {
        // let axisInfo = getAxisObject(chart, type, axisOrder);
        existingScale = axisInfo.scale;

        // #ZC2133
        // for scroll apply only x axis
        if (type === 'x' && behaviours.CHART_SCROLL) {
          // #ZC2287 $chart.viewPortExtent first
          domain = chart.viewPortExtent || axisInfo.domain || domain;
        } else {
          domain = axisInfo.domain || domain;
        }

        ticks = hasSmoothEffect ? null : domain;

        if (datatype == ORDINAL_DATATYPE) {
          return ticks;
        }
        var newRange = existingScale.range();
        zoomedPlotSize = plotSize = mathAbs(newRange[1] - newRange[0]);

        if (datatype === 'time' && isArray$1(domain) && existingScale) {
          if (domain[0] instanceof Date) {
            domain = domain.map(function (d) {return d.getTime();});
          }

          var diff = mathAbs(domain[1] - domain[0]),
            correction = diff * existingScale.outerPadding;

          domain[0] = domain[0] + correction;
          domain[1] = domain[1] - correction;
        }
        return domain;
      }
    }

    function _ordinalDomain(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,
        dataObject = chart.dataObject,
        behaviours = getPropVal(chart, 'behaviouralEvents.eventManager.behaviours') || {},
        hasBrushEnabled = behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL,
        domain = type === 'x' && order === 0 ? chart.viewPortExtent : null;
      if (hasBrushEnabled) {
        domain = _brushDomain(helpers);
      }
      if (dataObject.hierarchical) {
        domain = _pivotOrdinalDomain(helpers);
      } else {
        domain = domain || dataObject.getCategories(type, order).slice(0);
      }
      return domain;
    }

    function _ordinalCategories(helpers, filterTicksIndexes) {
      var type = this.type,order = this.order,chart = this.chart,
        dataObject = chart.dataObject,
        domain = dataObject.getCategories(type, order, true, filterTicksIndexes).slice(0);
      return domain;
    }

    function _pivotOrdinalDomain(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,
        dataObject = chart.dataObject;

      var processor = chart.dataObject,
        hierarchical = processor.hierarchical,
        pLayout = hierarchical.pivotLayout,
        columnList = pLayout.getRootNodeList('column'),
        splitLeavesColumn = columnList.splitColumnLeaves,
        filterByIndex = hierarchical.categoryTree && type == 'x' && !splitLeavesColumn && order == 0,
        domain = filterByIndex ? columnList.getClusterNodes(0) : dataObject.getCategories(type, order).slice(0);
      return domain;
    }

    function getOrdinalTicks() {
      var
        domain =












        this.domain,scale = this.scale,size = this.size,side = this.side,format = this.format,styles = this.styles,useTickAsIndices = this.useTickAsIndices,filter = this.filter,rotation = this.rotation,rotationConfig = this.rotationConfig,chartPadding = this.chartPadding,filteredTickIndices = this.filteredTickIndices,subFormatType = this.subFormatType,
        orient = this.orient,_this$config2 =
        this.config,tickCount = _this$config2.tickCount,interval = _this$config2.interval,
        ticks = domain,
        tickValueIndices,
        tickLeafNodes,
        margin = getMargin(this.config.ticklabel),
        formattingSubFunction = format.subfunction,
        needFilter = !this.autoScrollX && !this.branchType,
        ordinalCategories = _ordinalCategories.call(this);
      if (this.column.datatype === TIME_DATATYPE && !defined(formattingSubFunction)) {
        // set sub function
        formattingSubFunction = subFormatType(format, domain[domain.length - 1] - domain[0]);
      }
      var dimension = {};
      dimension.width = dimension.height = styles.fontSize;
      var space = getTickWidth(side, dimension, margin, rotation, styles.fontSize, orient);
      var visibleTickCount = mathRound(size / space);

      if (visibleTickCount < ticks.length && side === 'width') {
        if (rotation || this.config.rotation > 0) {
          space =
          distBetweenRotatedRect(rotationConfig.tickAutoRotation, styles.fontSize, styles.fontSize, orient).tickSpacing +
          margin.left +
          margin.right;
        }
      }
      if (needFilter) {
        if (tickCount < ticks.length) {
          ticks = filterCategories(ticks, tickCount, null, useTickAsIndices);
        } else if (defined(interval)) {
          ticks = filterCategories(ticks, tickCount, interval, useTickAsIndices);
        } else if (visibleTickCount < ticks.length) {
          ticks = filterCategories(ticks, visibleTickCount, null, useTickAsIndices);
        }
      }

      if (useTickAsIndices) {
        tickLeafNodes = ticks.nodes || ticks;
        tickValueIndices = ticks.indices;
        ticks = ticks.ticks || ordinalCategories;
      }
      return { ticks: ticks, tickValueIndices: tickValueIndices, tickLeafNodes: tickLeafNodes };
    }

    function filterTicksAfterBestFit(tickCountH, bestFitTickModel) {
      var domain = this.domain,size = this.size,side = this.side,format = this.format,styles = this.styles,useTickAsIndices = this.useTickAsIndices,filter = this.filter,orient = this.orient,chartPadding = this.chartPadding,maxSize = this.maxSize,
        scale = this.tickH.scale(),
        ticks = tickCountH.ticks,ticks_formatted = tickCountH.ticks_formatted,customTickInfo = tickCountH.customTickInfo,
        maxTickCount = bestFitTickModel.maxTickCount,
        tickValueIndices;
      // filter ticks if needed
      if (useTickAsIndices) {
        var _tickLeafNodes = tickCountH.tickLeafNodes && tickCountH.tickLeafNodes.length ? tickCountH.tickLeafNodes : ticks;
        ticks = filterCategories(_tickLeafNodes || ticks, maxTickCount, null, useTickAsIndices);
        tickValueIndices = ticks.indices;
        ticks = ticks.ticks;
      } else {
        ticks = filterCategories(ticks, maxTickCount);
        if (this.config.ticklabel.showAs) {
          // TODO have convert multiple object to single object to reduce loop.
          customTickInfo.styles = filterCategories(customTickInfo.styles, maxTickCount);
          customTickInfo.userRawTicks = filterCategories(customTickInfo.userRawTicks, maxTickCount);
        }
      }

      ticks_formatted = filterCategories(ticks_formatted, maxTickCount);
      return { ticks: ticks, ticks_formatted: ticks_formatted, tickValueIndices: tickValueIndices };
      // longestTick = getLongestTick(formattedTickValues, tickValues, tickFontSize, tickFontFamily, customTickInfo.styles);
    }

    function _linearDomain(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,_order = helpers._order,
        dataObject = chart.dataObject,
        behaviours = getPropVal(chart, 'behaviouralEvents.eventManager.behaviours') || {},
        hasBrushEnabled = behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL,
        domain = type === 'x' && order === 0 ? chart.viewPortExtent : NULL$1;
      if (hasBrushEnabled) {
        domain = _brushDomain(helpers);
      }
      domain = defined(domain) ?
      domain :
      type === 'x' ?
      dataObject.getMinMaxX() :
      dataObject.getMinMaxY(_order, UNDEFINED, chart.datalabels.hasFixedPosition);
      return domain;
    }

    function _customExtent(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,_order = helpers._order,
        behaviours = getPropVal(chart, 'behaviouralEvents.eventManager.behaviours') || {},
        hasBrushEnabled = behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL,
        domain = type === 'x' && order === 0 ? chart.viewPortExtent : NULL$1;
      if (hasBrushEnabled) {
        domain = _brushDomain(helpers);
      }
      return domain;
    }

    function getTimeTicks() {
      var _ = this,_$config =
        _.config,tickCount = _$config.tickCount,interval = _$config.interval,
        ticks,
        specifierIndex = _.groupby ? _.order : null,
        column = _.column,
        datatype = column.datatype;
      // #ZC1187
      if (!defined(column[datatype])) {
        column[datatype] = _.format;
      }
      var formattingSubFunction = _.subFormatType(_.format, _.domain[1] - _.domain[0]);
      var start = new Date(_.domain[0]),
        end = new Date(_.domain[1]);

      // get the date utils 1326
      var dateInterval = new date_utils(_.format);
      dateInterval.useUTC = _.format.useUTC === true;

      var longestFormattedTick = dateInterval.getMaxDate(_.format, specifierIndex); // save it
      longestFormattedTick = formatTickWrapByMode(
      longestFormattedTick,
      _.rotationConfig.tickAlignmentMode,
      _.maxSize.horizontal,
      _.maxSize.vertical,
      _.styles.fontSize);

      var dimension = getTextBound(longestFormattedTick, _.styles.fontSize, _.styles.fontFamily);
      var space = getTickWidth(_.side, dimension, _.margin, _.rotation, _.styles.fontSize, _.orient);

      // tickCount = _.size / space;
      tickCount = pick(tickCount, _.size / space);
      // get the date range
      if (_.isAutoFormat) {
        ticks = _.tickH.scale(_customExtent(this)).ticks();
        longestFormattedTick = null;
      } else {
        var dateRange = dateInterval.range(start, end, mathCeil(tickCount), formattingSubFunction, interval);

        ticks = dateRange.TICKS;
      }
      ticks = addMinmaxToTicks.call(this, ticks);

      return { ticks: ticks, longestFormattedTick: longestFormattedTick };
    }

    function recalculteTicksAfterBestFit(tickCountH, bestFitTickModel) {
      var maxTickCount = bestFitTickModel.maxTickCount,
        ticks = tickCountH.ticks,ticks_formatted = tickCountH.ticks_formatted,customTickInfo = tickCountH.customTickInfo,tickRotateMode = tickCountH.tickRotateMode,tickAutoRotation = tickCountH.tickAutoRotation,rotation = tickCountH.rotation,tickCount = tickCountH.tickCount;
      if (this.isAutoFormat) {
        // let timeScale = existingScale || scale;
        var timeScale = this.scale;
        // #ZC2211 only if
        var reduceAutoTick = tickCount > maxTickCount && tickRotateMode && rotation === 0;

        ticks = timeScale.ticks(reduceAutoTick ? maxTickCount * 0.5 : maxTickCount);

        if (this.tickCount > maxTickCount && !reduceAutoTick) {
          // change the rotation manually as there are no control
          // over calculating ticks in auto format to avoid overlapping
          rotation = tickAutoRotation;
        }
        ticks_formatted = ticks.map(function (d) {return timeScale.tickFormat()(d);});
        this.longestTick = getLongestTick$1(
        ticks_formatted,
        ticks,
        this.styles && this.styles.fontSize,
        this.styles && this.styles.fontFamily,
        customTickInfo && customTickInfo.styles);
        //TODO check
      } else {
        var start = new Date(this.domain[0]),
          end = new Date(this.domain[1]);
        var dateInterval = new date_utils(this.format);
        dateInterval.useUTC = this.format.useUTC === true;
        var dateRange = dateInterval.range(start, end, maxTickCount, this.format.subfunction, this.config.interval);
        ticks = dateRange.TICKS;
        ticks = addMinmaxToTicks.call(this, ticks);
        // formatAccessor = formatAccessor(axisH, { formatter, format, styles, maxSize, groupby, rotation });
        ticks_formatted = ticks.map(this.formatAccessor);
      }
      return { ticks: ticks, ticks_formatted: ticks_formatted, rotation: rotation };
    }

    function generateTimeGroupByAdapter(ticks) {
      var dataObject = this.chart.dataObject;
      if (this.groupby && !defined(dataObject.hierarchical)) {
        dataObject.hierarchical = new DataProcessor.HierarchicalTimeDataAdapter(
        this.chart,
        ticks,
        this.format.groupby,
        this.datatype !== TIME_DATATYPE,
        this.column);

      } else if (this.groupby) {
        dataObject.hierarchical.update(ticks);

        /*
        Find ranges for column branches
        */
        var rangeScaleUtils = dataObject.hierarchical.setScaleForRange(this.chart.axes.x.rangeScale);
        dataObject.hierarchical.pivotLayout.setRanges('column', rangeScaleUtils);
      }
    }

    /**
     *
     * @param ticks
     * @return {*}
     */
    function filterTickFromViewport(scale, ticks) {
      // $span instead of plotarea because sometime during resize, the plotarea changes before range
      // and the tick values gets filtered out
      var span = mathAbs(scale.origRange[1] - scale.origRange[0]),
        correction = scale.bandwidth ? scale.bandwidth() / 2 : 0,
        r = [-correction, span - correction];

      return ticks.filter(function (t) {
        var pos = scale(t);
        return pos !== null && pos >= r[0] && pos <= r[1];
      });
    }

    function customTicks(ticks) {
      var type = this.type,order = this.order,chart = this.chart,config = this.config,plotRect = this.plotRect,datatype = this.datatype,column = this.column;

      var tickConfig = config.ticklabel;
      var parentArray = [],
        parentStyles = [],
        userTickValues = [],
        hasCustomG;

      var userColumnInfo = {
        data: [column]
      };
      column.columnindex = pick(column.columnindex, 0); //TODO pass proper columindex instead of 0

      ticks.forEach(function (d, i) {
        var userInput = invokeFunction(tickConfig.showAs, d, tickConfig, userColumnInfo, chart, i, order),
          childArray = [],
          styles = [];

        if (isArray$1(userInput)) {
          parentArray.push(childArray);
          parentStyles.push(styles);
        } else {
          childArray = parentArray;
          styles = parentStyles;
        }
        userTickValues.push(userInput);

        if (defined(userInput)) {
          // if (isArray(userInput)) {
          //     userInput = userInput.join('\n');
          // }
          // var sandBox = document.createElement('div');
          // sandBox.innerHTML = userInput;

          // let userInputWrapped = `<zc-temp>${userInput}</zc-temp>`,
          // sandBox = new DOMParser().parseFromString(userInputWrapped, 'text/xml');
          var sandBox = SVGDOMParser(userInput);

          var children = sandBox.querySelectorAll('zc-temp')[0].childNodes,
            tspan = parseSVGElementsToArray(sandBox, 'tspan'),
            images = parseSVGElementsToArray(sandBox, 'image,img'),
            group = parseSVGElementsToArray(sandBox, 'g');

          if (children && children.length) {
            for (var _i25 = 0; _i25 < children.length; _i25++) {
              if (_i25 > 0 && !tspan.length && !images.length) {
                return;
              }
              var t = children[_i25];
              if (t.tagName == 'tspan') {
                childArray.push(t.textContent.trim());
                var _style = t.style || {},
                  attributes = t.attributes || {};
                styles.push({
                  fontSize: _style.fontSize && parseFloat(_style.fontSize),
                  fontFamily: _style.fontFamily,
                  fontStyle: _style.fontStyle,
                  fontWeight: _style.fontWeight,
                  x: attributes.x,
                  y: attributes.y,
                  dy: attributes.dy
                });
              } else if (t.tagName == 'image' || t.tagName == 'img') {
                toArray(sandBox.querySelectorAll('image,img')).forEach(function (t) {
                  var style = t.style || {},
                    attributes = t.attributes || {};
                  childArray.push({
                    width: +t.getAttribute('width'),
                    height: +t.getAttribute('height')
                  });
                  styles.push({
                    y: t.getAttribute('y'),
                    dy: t.getAttribute('dy')
                  });
                });
              } else if (t.tagName == 'g') {
                hasCustomG = true;
                var customG = createElement('g', '.customTick', [1], chart.wrap, null).html(userInput),
                  _bbox3 = customG.node().getBBox();

                childArray.push({
                  width: +_bbox3.width,
                  height: +_bbox3.height,
                  type: 'group'
                });
                customG.remove();
              } else if (!tspan.length && !images.length && !group.length) {
                childArray.push(userInput);
              }
            }
          } else {
            childArray.push(userInput);
          }

          // if (tspan.length) {
          //     tspan.forEach(function(t) {
          //         childArray.push(t.textContent.trim());
          //         let style = t.style || {},
          //             attributes = t.attributes || {};
          //         styles.push({
          //             fontSize: style.fontSize && parseFloat(style.fontSize),
          //             fontFamily: style.fontFamily,
          //             fontStyle: style.fontStyle,
          //             fontWeight: style.fontWeight,
          //             x: attributes.x,
          //             y: attributes.y,
          //             dy: attributes.dy
          //         });
          //     });
          // } else if (!images.length) {
          //     childArray.push(userInput);
          // }
          //
          // if (images.length) {
          //     toArray(sandBox.querySelectorAll('image,img')).forEach(function(t) {
          //         let style = t.style || {},
          //             attributes = t.attributes || {};
          //         childArray.push({
          //             width: +t.getAttribute('width'),
          //             height: +t.getAttribute('height')
          //         });
          //         styles.push({
          //             y: t.getAttribute('y'),
          //             dy: t.getAttribute('dy')
          //         });
          //     });
          // }
          sandBox = null;
        }
      });

      return {
        customGroup: hasCustomG,
        tickValues: parentArray,
        styles: parentStyles,
        userRawTicks: userTickValues
      };
    }

    function recalculatePlotSize(scrollThickness, tickSize, side, tickCount, margin, padding, outerPadding, type, chartObj) {
      var categoryThickness = scrollThickness || tickSize[side],
        v,
        p,
        oldPlotSize;
      if (side === 'height') {
        categoryThickness += margin.top + margin.bottom;
        v = categoryThickness * tickCount;
        oldPlotSize = [v, 0];
      } else {
        categoryThickness += margin.left + margin.right;
        v = categoryThickness * tickCount;
        oldPlotSize = [0, v];
      }
      p = type == 'x' ? getOuterPaddingInPixel(oldPlotSize, tickCount, padding, outerPadding, categoryThickness) : 0;
      v += p;
      chartObj.systemConf.chart[side] = v;
      return v;

    }

    function tickAlignment(tickSizeH) {
      var _ = this,
        datatype = this.datatype,rotation = this.rotation,type = this.type,
        ticks = tickSizeH.ticks,longestTick = tickSizeH.longestTick,tickBound = tickSizeH.tickBound,longestFormattedTick = tickSizeH.longestFormattedTick,ticks_formatted = tickSizeH.ticks_formatted,_this$rotationConfig =
        this.rotationConfig,tickAlignmentMode = _this$rotationConfig.tickAlignmentMode,tickRotateMode = _this$rotationConfig.tickRotateMode,tickAutoRotation = _this$rotationConfig.tickAutoRotation,
        tickCount = ticks.length;

      if (tickAlignmentMode === 'auto') {
        //First check for normal ticks with rotation as 0
        var maxCount_Rotate_0 = getMaxTickCountByRotation(0);
        //second check for zigzag only for ordinal datatype, for numeric and time datatype go for rotation with 45
        if (maxCount_Rotate_0.maxTickCount < tickCount) {
          var maxCount_zigzag =
          datatype == ORDINAL_DATATYPE ? getMaxTickCountByZigzag() : getMaxTickCountByRotation(tickAutoRotation, true);
          //third for tick rotation with 45
          if (maxCount_zigzag.maxTickCount < tickCount) {
            var maxCount_Rotate_45 = getMaxTickCountByRotation(tickAutoRotation, true);
            //fourth for ticks with white space
            if (maxCount_Rotate_45.maxTickCount < tickCount && longestTick.hasWhiteSpace) {
              return getMaxTickCountByWrapOnSpace();
            } else {
              return maxCount_Rotate_45;
            }
          } else {
            return maxCount_zigzag;
          }
        } else {
          return maxCount_Rotate_0;
        }
      } else if (tickRotateMode) {
        return getMaxTickCountByRotation(null, false);
      } else if (tickAlignmentMode == 'zigzag') {
        return getMaxTickCountByZigzag();
      } else if (tickAlignmentMode == 'wrapOnSpace') {
        return getMaxTickCountByWrapOnSpace();
      } else if (tickAlignmentMode == 'wrapAll') {
        return getMaxTickCountByWrapAll();
      }

      function getMaxTickCountByBounds(rotation, customBounds, includePadding) {
        var tickArea,
          temp,
          padding = 0,
          countForAngle,
          bounds;

        var length = _.plotSize_no_zoom; //getPlotSize(helpers.chart, side, tick.plotRect, gridSize);
        if (includePadding) {
          padding = length * _.chartOuterPadding * 2;
        }

        tickArea = _.plotSize_no_zoom - padding;
        countForAngle = !!rotation;
        bounds = customBounds || tickBound;
        if (countForAngle) {
          if (_.side === 'height' && (rotation === 90 || rotation === 270)) {
            return tickArea / (bounds.width + mathAbs(_.margin.top) + mathAbs(_.margin.bottom));
          }

          var r = rotation % 90;
          var angleCheck = _.side === 'height' ? r > 0 : r > 0 || rotation === 90 || rotation === 270;

          if (angleCheck) {
            var distBwTicks = distBetweenRotatedRect(rotation, bounds.width, bounds.height, _.orient);
            return tickArea / (distBwTicks.tickSpacing + mathAbs(_.margin.left) + mathAbs(_.margin.right));
          }
        }

        if (_.side === 'height') {
          temp = bounds.height + mathAbs(_.margin.top) + mathAbs(_.margin.bottom);
        } else {
          temp = bounds.width + mathAbs(_.margin.left) + mathAbs(_.margin.right);
        }
        return tickArea / temp;
      }

      function getMaxTickCountByRotation(customRotation, recalculate) {
        var rotation_new = defined(customRotation) ? customRotation : rotation;

        var count;
        if (rotation_new === 'auto') {
          rotation = 0;
          count = getMaxTickCountByBounds(0, null, type == 'x');
          var actualRange = _.scale.actualRange;
          var isSingleTick = actualRange && actualRange[0] === actualRange[1];
          if (!isSingleTick && count < tickCount) {
            if (_.side === 'width') {
              if (_.leafType) {
                rotation = 90; //For hierarchy auto rotate 90
              } else {
                rotation = tickAutoRotation;
              }

              count = getMaxTickCountByBounds(tickAutoRotation, null, false); //For auto rotation calculation customType should be null, excludePaddig is true
              recalculate = true;
            } else {
              recalculate = true;
            }
          } else {
            recalculate = false;
          }
        } else {
          count = getMaxTickCountByBounds(rotation_new, tickBound, type == 'x');
          rotation = rotation_new;
        }
        return {
          mode: 'rotate',
          rotation: rotation,
          maxTickCount: count,
          recalculate: recalculate
        };
      }
      function getMaxTickCountByZigzag() {
        var count = getMaxTickCountByBounds(); //For zigzag rotation is 0

        return {
          mode: 'zigzag',
          rotation: 0,
          maxTickCount: count * 2
        };
      }

      function getMaxTickCountByWrapOnSpace() {
        if (tickAlignmentMode == 'auto') {
          ticks_formatted = ticks_formatted.map(function (d, i) {
            return d.split(' ');
          });
          var longestTick = getLongestTick(
          _.ticks_formatted,
          ticks,
          _.styles.fontSize,
          _.styles.fontFamily,
          _.customTickInfo.styles);

          if (!defined(longestFormattedTick)) {
            longestFormattedTick = longestTick.formattedVal;
          }

          // calculate number of tick can be fit.
          var tickBound = getTextBound(
          longestFormattedTick,
          _.styles.fontSize,
          _.styles.fontFamily,
          longestTick.style,
          true);

        }

        var count = getMaxTickCountByBounds();

        return {
          mode: 'wrapOnSpace',
          maxTickCount: count,
          rotation: rotation,
          longestFormattedTick: longestFormattedTick
        };
      }

      function getMaxTickCountByWrapAll() {
        var count = getMaxTickCountByBounds();

        return {
          mode: 'wrapAll',
          maxTickCount: count,
          rotation: _.rotation
        };
      }
    }

    function getTicksForAxis() {
      var _ = this,
        _h = _.tickH;
      var ticks,
        minorTickValues,
        tickValueIndices,
        tickLeafNodes,
        longestTick,
        longestFormattedTick,
        ticks_formatted,
        rotation,
        scale,
        customTickInfo = {},
        tickConfig = _.config.ticklabel,
        tickCount = _.config.tickCount,
        margin = getMargin(tickConfig);
      rotation = _.rotation;
      // _.scaleComp = _.scale;
      if (_.datatype == NUMERIC_DATATYPE) {
        if (_.column.scaleType == LOG) {var _getLogTicks$call =
          _getLogTicks.call(this, _.tickH.logTickH());ticks = _getLogTicks$call.ticks;minorTickValues = _getLogTicks$call.minorTickValues;
        } else {
          ticks = getNumericTicks.call(this);
        }
      } else if (_.datatype == ORDINAL_DATATYPE || _.datatype == ORDINAL_NON_LINEAR_DATATYPE) {var _getOrdinalTicks$call =
        getOrdinalTicks.call(this);ticks = _getOrdinalTicks$call.ticks;tickValueIndices = _getOrdinalTicks$call.tickValueIndices;tickLeafNodes = _getOrdinalTicks$call.tickLeafNodes;
      } else if (_.datatype == TIME_DATATYPE) {var _getTimeTicks$call =
        getTimeTicks.call(this);ticks = _getTimeTicks$call.ticks;longestFormattedTick = _getTimeTicks$call.longestFormattedTick;
      }
      // chartType viewport filtering
      // #ZC2068 $hasSmoothEffect
      if (_.filter && !_.useTickAsIndices) {
        ticks = filterTickFromViewport(_.scale, ticks);
      }
      tickCount = ticks.length;
      scale = _.column.scaleType == LOG ? _h.scale() : _.scale;
      var actualRange = scale.actualRange;
      var isSingleTick = actualRange && actualRange[0] === actualRange[1];
      if (isSingleTick) {
        ticks = [_.scale.invert(actualRange[0])];

        // ZC2839
        if (_.column.scaleType == LOG) {
          ticks = ticks.map(function (d) {return fixFloatingPoint(d);});
        }
      }

      // format the values and get the longest tick value.
      // formatAccessor = formatAccessor(helpers, { formatter, format, styles, maxSize, groupby, rotation });

      ticks_formatted = _.isAutoFormat ? ticks.map(function (d) {return _.scale.tickFormat()(d);}) : ticks.map(_.formatAccessor);

      // get custom tick labels
      if (defined(tickConfig.showAs)) {
        customTickInfo = customTicks.call(this, ticks);
        ticks_formatted = customTickInfo.tickValues;
        customTickInfo.length = ticks_formatted.length;
      }

      longestTick = getLongestTick$1(ticks_formatted, ticks, _.styles.fontSize, _.styles.fontFamily, customTickInfo.styles);

      // uncomment the bellow condition to use the default longest date.
      if (!defined(longestFormattedTick)) {
        longestFormattedTick = longestTick.formattedVal;
      }

      // calculate number of tick can be fit.
      var tickBound = getTextBound(longestFormattedTick, _.styles.fontSize, _.styles.fontFamily, longestTick.style, true);
      var labelSize = getMaxTickSize(tickConfig, _.chartRect);
      tickBound.width = mathMin(tickBound.width, labelSize.horizontal);
      tickBound.height = mathMin(tickBound.height, labelSize.vertical);
      // #ZC1765
      if (_.autoScrollX) {
        recalculatePlotSize(_h.scrollThickness(), tickBound, _.side, tickCount, margin, _.chartPadding, _.chartOuterPadding, 'x', _.chart);
      }

      if (_.autoScrollY) {
        recalculatePlotSize(
        _h.scrollThickness(),
        _h.pivotLeafSize(),
        _.side,
        _h.pivotLeafCount(),
        margin,
        _.chartPadding,
        _.chartOuterPadding,
        'y',
        _.chart);

      }
      if (_.datatype != ORDINAL_NON_LINEAR_DATATYPE) {
        var bestFitTickModel = tickAlignment.call(this, { ticks: ticks, longestTick: longestTick, tickBound: tickBound, longestFormattedTick: longestFormattedTick, ticks_formatted: ticks_formatted });
        var mode = bestFitTickModel.mode,
          maxTickCount = bestFitTickModel.maxTickCount;
        rotation = bestFitTickModel.rotation;

        if (!isSingleTick && (tickCount > maxTickCount || bestFitTickModel.recalculate)) {
          // time data need a re-calculation of tick values after rotation
          var _$rotationConfig2 = _.rotationConfig,tickAlignmentMode = _$rotationConfig2.tickAlignmentMode,tickRotateMode = _$rotationConfig2.tickRotateMode,tickAutoRotation = _$rotationConfig2.tickAutoRotation,hasDefinedAutoRotation = _$rotationConfig2.hasDefinedAutoRotation,
            tickCountH = {
              tickCount: tickCount,
              ticks: ticks,
              ticks_formatted: ticks_formatted,
              tickAutoRotation: tickAutoRotation,
              tickLeafNodes: tickLeafNodes,
              customTickInfo: customTickInfo,
              tickRotateMode: tickRotateMode,
              rotation: rotation
            };

          if (_.datatype === TIME_DATATYPE) {var _recalculteTicksAfter =
            recalculteTicksAfterBestFit.call(this, tickCountH, bestFitTickModel);ticks = _recalculteTicksAfter.ticks;ticks_formatted = _recalculteTicksAfter.ticks_formatted;rotation = _recalculteTicksAfter.rotation;
            if (_.isAutoFormat) {
              longestTick = getLongestTick$1(ticks_formatted, ticks, _.styles.fontSize, _.styles.fontFamily, customTickInfo.styles);
            }
            //For this we can add it at the end commonly. we didn't recalculate longest tick for time time without autoformat alone
          } else if (maxTickCount < tickCount) {
            // filter ticks if needed
            var _filterTicksAfterBest = filterTicksAfterBestFit.call(this, tickCountH, bestFitTickModel);ticks = _filterTicksAfterBest.ticks;ticks_formatted = _filterTicksAfterBest.ticks_formatted;tickValueIndices = _filterTicksAfterBest.tickValueIndices;
            longestTick = getLongestTick$1(ticks_formatted, ticks, _.styles.fontSize, _.styles.fontFamily, customTickInfo.styles);
          }
        }

        // time data group by
        if (_.column.datatype === TIME_DATATYPE && _.groupby) {
          generateTimeGroupByAdapter.call(this, ticks);
        }
      }

      if (_.config.ticks) {
        ticks = invokeFunction(this.config.ticks, ticks, scale.domain());
        ticks_formatted = _.isAutoFormat ? ticks.map(function (d) {return _.scale.tickFormat()(d);}) : ticks.map(_.formatAccessor);
        longestTick = getLongestTick$1(ticks_formatted, ticks, _.styles.fontSize, _.styles.fontFamily, customTickInfo.styles);
      }

      if (defined(customTickInfo.styles) || _.format && _.format.format && _.format.format.breakSpace) {
        longestTick = getLongestTick$1(ticks_formatted, ticks, _.styles.fontSize, _.styles.fontFamily, customTickInfo.styles);
      }

      var tickInfo = {};

      tickInfo.scale = scale;
      tickInfo.ticks = ticks;
      tickInfo.ticks_formatted = ticks_formatted;
      tickInfo.tickValueIndices = tickValueIndices;
      tickInfo.tickLeafNodes = tickLeafNodes;
      tickInfo.longestTick = longestTick;
      tickInfo.longestFormattedTick = longestFormattedTick;
      tickInfo.longTickSize = getTextBound(longestFormattedTick, _.styles.fontSize, _.styles.fontFamily, longestTick.style, true);
      tickInfo.maxSize = _.maxSize;
      tickInfo.rotation = rotation;
      tickInfo.mode = mode || _.rotationConfig.tickAlignmentMode;
      tickInfo.minorTickValues = minorTickValues;
      tickInfo.maxTickSize = _.maxSize;
      tickInfo.customTicks = customTickInfo.userRawTicks;
      tickInfo.customTickInfo = customTickInfo;
      tickInfo.isInline = isTickInnerOrient(_.config, _.type, _.chart);
      tickInfo.inlineToPlot = tickInfo.isInline ? checkTickInlineAlignWithInPlot(_.type, _.orient, _.chart.systemConf) : false;
      tickInfo.showGrid = _.config.grid.show && _.config.grid.color != TRANSPARENT;

      return tickInfo;
    }var

    AxisTicks = /*#__PURE__*/function () {
      function AxisTicks(args, tickParser) {_classCallCheck(this, AxisTicks);
        this.chart = args.chart;
        this.type = args.type;
        this.order = args.order;
        this.config = args.config;
        this.plotRect = args.plotRect;
        this.plotRect1 = args.plotRect1;
        this._order = args._order;
        this.orient = args.orient;
        this.datatype = args.datatype;
        this.column = args.column;

        this.initialize(args, tickParser);
      }_createClass(AxisTicks, [{ key: "initialize", value:
        function initialize(_axisH, tickParser) {
          _axisH.axisInfo.logDomain = null;
          var tickH = this.tickH = tickParser(_axisH);
          this.domain = tickH.domain();
          this.scale = tickH.scale(); //no need to execute here
          this.simpleScale = tickH.simpleScale();
          this.filter = tickH.filter();
          this.useTickAsIndices = tickH.useTickAsIndices;
          this.styles = tickH.styles();
          this.rotationConfig = tickH.rotation();
          this.rotation = this.rotationConfig.rotation;
          this.format = tickH.format();
          this.formatter = tickH.formatter();
          this.groupby = tickH.groupby();
          this.side = tickH.side();
          this.size = tickH.size();
          this.maxSize = tickH.maxSize(); //TODO check with maxttick
          this.margin = tickH.margin();
          this.padding = tickH.padding(this.margin);
          this.autoScrollX = tickH.autoScrollX();
          this.autoScrollY = tickH.autoScrollY();
          this.chartPadding = tickH.chartPadding();
          this.chartOuterPadding = tickH.chartOuterPadding();
          this.plotSize = tickH.plotSize();
          this.plotSize_no_zoom = tickH.plotSize_no_zoom();
          this.subFormatType = tickH.subFormatType;
          this.chartRect = tickH.chartRect();
          this.branchType = tickH.isBranchType && tickH.isBranchType();
          this.leafType = tickH.isLeafType && tickH.isLeafType();
          this.bzsEnabled = tickH.bzsEnabled();
          this.customTickInfo = {};
          this.isAutoFormat = this.datatype == TIME_DATATYPE ? hasAutoFormat(this.format) : null;
          this.formatAccessor = tickH.formatAccessor(_axisH, this);
        } }, { key: "collect", value:
        function collect() {
          this.tickInfo = getTicksForAxis.call(this);

          if (defined(this.customTickInfo.styles) || this.format && this.format.format && this.format.format.breakSpace) {
            this.tickInfo.longestTick = getLongestTick$1(
            this.ticks_formatted,
            this.ticks,
            this.styles.fontSize,
            this.styles.fontFamily,
            this.customTickInfo.styles);

          }
        } }]);return AxisTicks;}();


    function precalculateAxisGroup() {
      /**
       * Adding the axis label here for the only first time. Next time just calls the transform method.
       */

      var type = this.type,order = this.order,chart = this.chart,config = this.config,plotRect = this.plotRect,viewParser = this.viewParser,orient = this.orient,rotated = this.rotated,
        tickMargin = this.axisTicks.margin,_this$axisTitle =
        this.axisTitle,hideTitle = _this$axisTitle.hideTitle,titleConfig = _this$axisTitle.titleConfig,titleMargin = _this$axisTitle.titleMargin,branchTitleConfig = _this$axisTitle.branchTitleConfig,
        axisgroup = this.axisTicks.precalculate.axisgroup,
        tick_data = this.axisTicks.tickInfo,
        tickPrecalculation = _objectSpread(_objectSpread({}, this.axisTicks.precalculate), this.axisTicks.tickInfo),
        preCalcAxisLen;

      var axisSize = 0;
      var axes = this.axisInfo,
        selector = type == 'x' ? "".concat(type, "-axis-").concat(order) : "".concat(type, "-axis-").concat(order),
        axisG = chart.svg.selectAll("g.".concat(type, "-axis")),
        axisWrap = appendEle(axisG, 'g', [config], '.', 'class', selector);

      var markExtender = this.axisView && this.axisView.conf.preMarkExtender,
        axisTitleMark = this.marks.axisTitle.onReady();
      if (markExtender) {
        axisTitleMark = invokeFunction(markExtender, axisTitleMark, this);
      }
      renderDom(axisTitleMark, axisWrap);
      var _labelNode = axisWrap.selectAll('text.axislabel'),
        _label = _labelNode.node();

      axes.axisLabel = _label;
      // if (axes.axisLabel && axes.axisLabel.order == order) {
      //     let axisAreaDim = getAxisAreaDim(type, order, orient, chart, plotRect);
      //     axes.axisLabel.show = !hideTitle;
      //     axes.axisLabel.transformLabel(axisgroup, axisAreaDim, orient);
      // } else {
      //     axes.axisLabel = new axis.AxisLabel(axisdata_merged, axisLabelProperties, orient, axisWrap);
      // }

      // renderDom(marks, tempDom);

      if (!hideTitle) {
        if (!_labelNode.empty() && axisWrap.style('display') !== NONE) {
          axisSize = _label.getBBox().height; // calculate and cache.
        } else {
          axisSize = 0;
        }
        switch (orient) {
          case 'left':{
              var width_new = tickPrecalculation.inlineToPlot ?
              0 :
              tickPrecalculation.isInline ?
              axisgroup.width :
              axisgroup.width + tickMargin.left;
              preCalcAxisLen = width_new + titleMargin.right + axisSize + titleMargin.left;
              break;
            }
          case 'right':{
              var width_new = tickPrecalculation.inlineToPlot ?
              0 :
              tickPrecalculation.isInline ?
              axisgroup.width :
              axisgroup.width + tickMargin.right;
              preCalcAxisLen = width_new + titleMargin.left + axisSize + titleMargin.right;
              break;
            }
          case 'bottom':{
              var height_new = tickPrecalculation.inlineToPlot ?
              0 :
              tickPrecalculation.isInline ?
              axisgroup.height :
              axisgroup.height + tickMargin.bottom;
              preCalcAxisLen = height_new + titleMargin.bottom + axisSize + titleMargin.top;
              break;
            }
          case 'top':{
              var height_new = tickPrecalculation.inlineToPlot ?
              0 :
              tickPrecalculation.isInline ?
              axisgroup.height :
              axisgroup.height + tickMargin.top;
              preCalcAxisLen = height_new + titleMargin.top + axisSize + titleMargin.bottom;
              break;
            }}

      } else {
        preCalcAxisLen = orient === 'bottom' || orient == 'top' ? axisgroup.height + tickMargin.bottom : axisgroup.width + tickMargin.left;
      }

      // let width = axisgroup.width,
      //     height = axisgroup.height;
      // if ((orient === 'left' || orient === 'right') && defined(tick_data.width)) {
      //     width = perToPx(getPriorityValue1(tick_data.width, tick_data.maxWidth) || axis.ticks.maxTickSizeRatio_Hori, plotRect.width);
      // } else if (defined(this.axisTicks.tickInfo.height)) {
      //     height = perToPx(getPriorityValue1(tick_data.height, tick_data.maxHeight) || axis.ticks.maxTickSizeRatio_Vert, plotRect.height);
      // }
      // _label.remove();

      // let preCalcTickLen = {
      //     x: axisgroup.left,
      //     y: axisgroup.top,
      //     width: width,
      //     height: height
      // };
      return {
        // preCalcTickLen,
        preCalcAxisLen: preCalcAxisLen
      };
      // return preCalcAxisLen;
    }

    function tick_overflow_helpers(_h) {
      var scale = this.scale,config = this.config,chartRect = this.chartRect,orient = this.orient,type = this.type,chart = this.chart,styles = this.styles,plotSize = this.plotSize,_this$tickInfo =
        this.tickInfo,rotation = _this$tickInfo.rotation,ticks = _this$tickInfo.ticks,ticks_formatted = _this$tickInfo.ticks_formatted,customTickInfo = _this$tickInfo.customTickInfo,longestTick = _this$tickInfo.longestTick,
        helpers = _objectSpread(_objectSpread({}, _h), {}, { scale: scale, ticks: ticks, rotation: rotation, config: config, chartRect: chartRect, orient: orient, type: type, chart: chart, styles: styles, plotSize: plotSize });
      var overflow_helpers = {
        needTrimByMaxSize: true,
        hasDynamicTickSpacing: helpers.isHierarchialLevelType(),
        fitTextInBetween: fitTextInBetween(helpers),
        maxTickSize: getMaxTickSize(config.ticklabel, chartRect),
        boundaryEdges: getBoundaryEdgesForTick(helpers),
        tickSpacing: distanceBetweenTicks(helpers),
        minMargin: needMinMarginToExcludeFromTrim(helpers) ? helpers.styles.fontSize : 0,
        margin: getExtraMarginForBoundary(helpers),
        needDynamicEdge: chart && chart.dataObject && chart.dataObject.hierarchical && chart.dataObject.hierarchical.dynamicLeafScale,
        dynamicBoundaryEdges: function dynamicBoundaryEdges() {return getDynamicBoundaryEdgesForTick;},
        dynamicMaxTickSize: function dynamicMaxTickSize() {return getMaxTickSizeByData;},
        referenceBounds: function referenceBounds() {return getBoundingRect(helpers.tempDom.selectAll('.axisline'));},
        overflowPattern: config.ticklabel.textOverflow == null || config.ticklabel.textOverflow == 'ellipsis' ? '..' : '',
        prerender: true
      };

      return overflow_helpers;
    }function needMinMarginToExcludeFromTrim(helpers) {
      if (fitTextInBetween(helpers) || helpers.chart.dataObject.isPolarAxisCategory) {
        return false;
      } else {
        return true;
      }
    }
    function fitTextInBetween(helpers) {
      //dontUseMargin
      return !helpers.isHierarchialLevelType() && helpers.isHierarchy() && helpers.type == 'x' || helpers.config.tickmark == 'between';
    }
    function distanceBetweenTicks(helpers) {
      if (fitTextInBetween(helpers)) {
        return scale.getRangeBand(helpers.scale, helpers.ticks, 0);
      }
    }
    function getMaxTickSizeByData(node, index, helpers, overflowH) {
      var maxTickSize_Hori, maxTickSize_Vert;
      var count = helpers.tempDom.selectAll('text.ticklabel').nodes().length;
      var outerPadding = mathAbs(overflowH.tickSpacing.outerPaddingInPixel),
        hasUserLabelSize = defined(helpers.config.ticklabel.width) || defined(helpers.config.ticklabel.maxWidth);
      if (helpers.orient == 'bottom' || helpers.orient == 'top') {
        if (hasUserLabelSize) {
          maxTickSize_Hori = overflowH.maxTickSize.horizontal;
        } else if (helpers.rotation != 90 && helpers.rotation != 270) {
          maxTickSize_Hori = index == 0 || index == count - 1 ? outerPadding * 2 : mathAbs(overflowH.tickSpacing.rangeBand) * 2;
        }
      } else if ((helpers.orient == 'left' || helpers.orient == 'right') && (helpers.rotation == 90 || helpers.rotation == 270)) {
        maxTickSize_Vert = index == 0 || index == count - 1 ? outerPadding * 2 : mathAbs(overflowH.tickSpacing.rangeBand) * 2;
      }

      return {
        horizontal: maxTickSize_Hori,
        vertical: maxTickSize_Vert
      };
    }

    function getBoundaryEdgesForTick(helpers, _bandwidth) {
      var scale = helpers.scale,ticks = helpers.ticks,rotation = helpers.rotation,config = helpers.config,chartRect = helpers.chartRect,orient = helpers.orient,type = helpers.type,
        bandWidth = scale.bandwidth ? scale.bandwidth() / 2 : 0;

      var minTick = ticks[0],
        maxTick = ticks[ticks.length - 1];
      if (config.reversed) {
        minTick = ticks[ticks.length - 1], maxTick = ticks[0];
      }
      var _bandwidthCopy = pick(_bandwidth, bandWidth);
      var edge = {};
      // var scale1 = axisType == 'x' && hasSplitLeavesColumn && chartObj.axes.x.leaves[0] ? chartObj.axes.x.leaves[0].scale : scaleObj;
      if (fitTextInBetween(helpers)) {
        var distBwTicks = distanceBetweenTicks(helpers),
          outerPadding = mathAbs(distBwTicks.outerPaddingInPixel);

        if (orient == 'bottom' || orient == 'top') {
          edge.left = scale(minTick) - mathAbs(_bandwidthCopy - outerPadding),
          edge.right = scale(maxTick) + (outerPadding + _bandwidthCopy);
        } else if ((orient == 'left' || orient == 'right') && (rotation == 90 || rotation == 270)) {
          edge.top = scale(maxTick) - outerPadding, edge.bottom = scale1(minTick) + outerPadding;
        }
      } else {
        edge.top = edge.left = 0;
        edge.right = orient == 'bottom' || orient == 'top' ? helpers.plotSize : 0;
        edge.bottom = orient == 'bottom' || orient == 'top' ? 0 : helpers.plotSize;
      }

      return edge;
    }

    function getDynamicBoundaryEdgesForTick(node, index, helpers, overflowH, textBounds) {
      var chart = helpers.chart,
        hasDynamicLeafScale =
        chart && chart.dataObject && chart.dataObject.hierarchical && chart.dataObject.hierarchical.dynamicLeafScale,
        edge = {};
      if (overflowH.edgeOptions) {
        edge = overflowH.edgeOptions(node, textBounds);
      } else if (hasDynamicLeafScale && helpers.scale.bandwidth) {
        edge = getBoundaryEdgesForTick(helpers, helpers.scale.bandwidth);
      }
      return edge;
    }

    function getExtraMarginForBoundary(helpers) {
      var marginPercent = 0.5,
        margin = {};
      //TODO dynamic label type or add margin
      if (needMinMarginToExcludeFromTrim(helpers)) {
        margin.left =
        marginPercent * helpers.chart.plotarea.left, //ZC743 If its axislabel margin right and left should be same, because always axislabel placed at center of plotarea with textanchor middle
        margin.right =
        marginPercent * (helpers.chart.canvasarea.width - (helpers.chart.plotarea.left + helpers.chart.plotarea.width)),
        margin.top = marginPercent * helpers.chart.plotarea.top,
        margin.bottom = marginPercent * helpers.chart.plotarea.bottom;
      } else {
        //TODO isPolar
        margin.left = margin.right = 0;
        margin.top = margin.bottom = 0;
      }

      return margin;
    }

    function handleSVGTextOverflow(helpers, overflowH, nodeH) {
      var plotRect = helpers.plotRect,side = helpers.side,overflow = helpers.overflow,orient = helpers.orient,rotation = helpers.rotation,scale = helpers.scale,
        maxTickSize_Hori = overflowH.maxTickSize.horizontal,
        maxTickSize_Vert = overflowH.maxTickSize.vertical,
        maxTickSize,
        margin = overflowH.margin,boundaryEdges = overflowH.boundaryEdges,prerender = overflowH.prerender,needTrimByMaxSize = overflowH.needTrimByMaxSize,tickSpacing = overflowH.tickSpacing,hasDynamicTickSpacing = overflowH.hasDynamicTickSpacing,minMargin = overflowH.minMargin,overflowPattern = overflowH.overflowPattern,
        node = nodeH.node,index = nodeH.index;
      if (overflow == 'none') {
        return;
      }
      /*
       * Cropping the text to maximum ticklabel size (according to bounded box of the text)
       */
      var activeNode = node;
      var childNodes = [activeNode.childNodes[0]]; //If the SVG text has title element, the title element will be removed while changing this.textContent as because it modifies all the childNodes of it. So take the text element alone to trim

      // only for multiple line ticklabel, checking tspan
      var tspan = d3_select(activeNode).
      selectAll('tspan').
      nodes();
      if (tspan && tspan.length) {
        tspan.sort(function (a, b) {
          return b.textContent.length - a.textContent.length;
        });
        childNodes = tspan;
      }

      if (!childNodes) {
        return;
      }

      //Change maxTickSize if margin was not needed
      if (overflowH.fitTextInBetween) {
        //dontUseMargin
        maxTickSize = overflowH.dynamicMaxTickSize()(node, index, helpers, overflowH);
        // let count = node.selectAll('text.ticklabel').nodes().length;
        // var outerPadding = mathAbs(distBwTicks.outerPaddingInPixel);
        // if (orient == 'bottom' || orient == 'top') {
        //     if (hasUserLabelSize) {
        //         maxTickSize_Hori = labelSize.horizontal;
        //     } else if (rotation != 90 && rotation != 270) {
        //         maxTickSize_Hori = index == 0 || index == count - 1 ? outerPadding * 2 : mathAbs(distBwTicks.rangeBand) * 2;
        //     }
        // } else if ((orient == 'left' || orient == 'right') && (rotation == 90 || rotation == 270)) {
        //     maxTickSize_Vert = index == 0 || index == count - 1 ? outerPadding * 2 : mathAbs(distBwTicks.rangeBand) * 2;
        // }
      }

      //Iterate childnodes and apply ellipsis for each node
      for (var i = 0; i < childNodes.length; i++) {
        var txtNode = tspan && tspan.length ? childNodes[i] : activeNode,
          initial_textContent = txtNode.textContent,
          clientRect = txtNode.nodeName == 'tspan' ? getTspanBoundingClientRect : getDefaultBoundingClientRect,
          textBounds = clientRect(txtNode),
          initial_textBound = textBounds,
          trimmed,
          max = {
            // This should be changed for axis labels
            width: maxTickSize_Hori,
            height: maxTickSize_Vert
          };

        //For hierarchy level type, check only for maxWidth
        if (hasDynamicTickSpacing && needTrimByMaxSize && !prerender) {
          var rb =
          orient == 'left' || orient == 'right' ? maxTickSize_Hori : Math.abs(scale.discreteWidth(node.__data__)) || maxTickSize_Hori;
          var maxWid = mathMin(maxTickSize_Hori, rb);
          naiveEllipsis(txtNode, txtNode, txtNode.textContent, maxWid, maxTickSize_Vert, textBounds, overflowPattern);
          return;
        }

        //Check for maxwidth and add ellipsis
        if (needTrimByMaxSize) {
          //labelType == 'ticklabel'
          var trimmedNode = trimTextBasedOnMaxSize(
          txtNode,
          textBounds,
          { horizontal: maxTickSize_Hori, vertical: maxTickSize_Vert },
          overflowPattern);

          textBounds = clientRect(trimmedNode);
          // if (maxTickSize_Hori < textBounds.width) {
          //     overflowLength = (textBounds.width - maxTickSize_Hori) / textBounds.width;
          //     var croppedTextLength = mathCeil((1 - overflowLength) * txtNode.textContent.length);
          //     txtNode.textContent = txtNode.textContent.substring(0, croppedTextLength - 2) + overflowPattern; //TODO: for textOverflow = 'hidden', subtracting 2 letters is necessary?
          //     textBounds = clientRect(txtNode); //update new textbounds
          // }
          // if (maxTickSize_Vert < textBounds.height) {
          //     overflowLength = (textBounds.height - maxTickSize_Vert) / textBounds.height;
          //     var croppedTextLength = mathCeil((1 - overflowLength) * txtNode.textContent.length);
          //     txtNode.textContent = txtNode.textContent.substring(0, croppedTextLength - 2) + overflowPattern;
          //     textBounds = clientRect(txtNode); //update new textbounds
          // }
        }

        //calculte new boundary edges and textbounds

        // edge = overflowH.boundaryEdges();
        var referenceBounds = overflowH.referenceBounds();
        var newTextBounds = {
          left: textBounds.left - referenceBounds.left,
          right: textBounds.left + textBounds.width - referenceBounds.left,
          top: textBounds.top - referenceBounds.top,
          bottom: textBounds.top + textBounds.height - referenceBounds.top,
          width: textBounds.width,
          height: textBounds.height
        };

        // if (options.edge) {
        //     boundaryEdges = options.edge(txtNode, textBounds);
        // } else
        if (overflowH.needDynamicEdge && scale.bandwidth) {
          boundaryEdges = overflowH.dynamicBoundaryEdges()(node, index, helpers, overflowH, textBounds);
        }

        //Trim text based on boundary edges
        if ((orient == 'left' || orient == 'right') && rotation != 0 && rotation != 180 && rotation != 360) {
          if (
          newTextBounds.top + mathMax(minMargin, margin.top) < boundaryEdges.top ||
          newTextBounds.bottom - mathMax(minMargin, margin.bottom) > boundaryEdges.bottom)
          {
            trimmed = true;
            trimText(txtNode, txtNode.textContent, newTextBounds, boundaryEdges, orient, overflowPattern, margin, max, txtNode);
          }
        } else if ((orient == 'bottom' || orient == 'top') && rotation != 90 && rotation != 270) {
          if (
          newTextBounds.left + mathMax(minMargin, margin.left) < boundaryEdges.left ||
          newTextBounds.right - mathMax(minMargin, margin.right) > boundaryEdges.right)
          {
            trimmed = true;
            trimText(txtNode, txtNode.textContent, newTextBounds, boundaryEdges, orient, overflowPattern, margin, max, txtNode);
          }
        }

        if (needTrimByMaxSize && !trimmed) {
          var textBounds = clientRect(txtNode);
          if (textBounds.width != initial_textBound.width || textBounds.height != initial_textBound.height) {
            naiveEllipsis(txtNode, activeNode, initial_textContent, max.width, max.height, textBounds, overflowPattern);
          }
        }

        if (txtNode.textContent == overflowPattern) {
          txtNode.textContent = prerender ? '.' : ''; //hack  while casper automation DOC_CHART_61
        }
      }
    }

    function trimTextBasedOnMaxSize(node, bounds, maxSize, overflowPattern) {
      var clientRect = node.nodeName == 'tspan' ? getTspanBoundingClientRect : getDefaultBoundingClientRect;
      if (maxSize.horizontal < bounds.width) {
        var overflowLength = (bounds.width - maxSize.horizontal) / bounds.width;
        var croppedTextLength = mathCeil((1 - overflowLength) * node.textContent.length);
        node.textContent = node.textContent.substring(0, croppedTextLength - 2) + overflowPattern; //TODO: for textOverflow = 'hidden', subtracting 2 letters is necessary?
        bounds = clientRect(node);
      }
      if (maxSize.vertical < bounds.height) {
        var _overflowLength = (bounds.height - maxSize.vertical) / bounds.height;
        var croppedTextLength = mathCeil((1 - _overflowLength) * node.textContent.length);
        node.textContent = node.textContent.substring(0, croppedTextLength - 2) + overflowPattern;
      }
      return node;
    }

    var MarksRegistry = {
      add: function add(name, component) {
        Registry.setComponent(name, component);
      },
      get: function get(name) {return Registry.getComponent(name);}
    };

    function precalculateTickGroup(marks, tempDom) {
      var plotRect = this.plotRect,config = this.config,orient = this.orient,datatype = this.datatype,chart = this.chart,_this$axisTicks =
        this.axisTicks,scale = _this$axisTicks.scale,styles = _this$axisTicks.styles,chartArea = _this$axisTicks.chartArea,plotSize = _this$axisTicks.plotSize,_this$axisTicks$tickH =
        this.axisTicks.tickH,isHierarchialLevelType = _this$axisTicks$tickH.isHierarchialLevelType,isHierarchy = _this$axisTicks$tickH.isHierarchy,_this$axisTicks$tickI =
        this.axisTicks.tickInfo,rotation = _this$axisTicks$tickI.rotation,ticks = _this$axisTicks$tickI.ticks,ticks_formatted = _this$axisTicks$tickI.ticks_formatted,customTickInfo = _this$axisTicks$tickI.customTickInfo,longestTick = _this$axisTicks$tickI.longestTick,
        useHTML = customTickInfo && customTickInfo.styles,

        left = orient == 'right' ? plotRect.left + plotRect.width : plotRect.left,
        top = orient == 'bottom' ? plotRect.top + plotRect.height : plotRect.top;

      var ticks_sorted_index = sortByIndices(ticks_formatted),
        counter = -1,
        isFinalLongTick,
        curIdx = ticks_sorted_index[0],
        maxIdx = ticks_sorted_index[0],
        sortIdx,
        curTick,
        curTick_formatted,
        curTick_content,
        maxTick,
        maxTick_formatted,
        maxTick_content,
        maxTick_htmlContent,
        textWidth = textWidthAccessor({ orient: orient, customTickInfo: customTickInfo, styles: styles });

      var markSelection = MarksRegistry.get('markSelection');
      var markSelector = new markSelection(marks);

      if (useHTML) {
        //Need to sort the ticklabels by finding text width
        var formattedCustomTickValuesSize = ticks_formatted.map(function (d, i) {
          return textWidth(d, i);
        });
        ticks_sorted_index = sortByIndices(formattedCustomTickValuesSize, 'integer');
      }
      var _helperObj = { config: config, orient: orient, isHierarchialLevelType: isHierarchialLevelType, isHierarchy: isHierarchy, tempDom: tempDom, rotation: rotation, ticks: ticks, styles: styles, chart: chart, scale: scale, plotSize: plotSize },
        overflowH = tick_overflow_helpers.call(this.axisTicks, { isHierarchialLevelType: isHierarchialLevelType, isHierarchy: isHierarchy, tempDom: tempDom });

      /*
      Initiate max tick content
        */

      maxIdx = longestTick.index;
      maxTick = ticks[maxIdx];
      maxTick_formatted = useHTML ? customTickInfo.userRawTicks[longestTick.index] : longestTick.formattedVal;

      markSelector.select('selector', '.zc-tick').data([maxTick]);
      markSelector.select('name', 'ticklabel').data([maxTick_formatted]);
      marks = markSelector.parser;
      // marks.children[0].data = [maxTick];
      // marks.children[0].children[0].data = [maxTick_formatted];
      renderDom(marks, tempDom);
      wrapTextContent(tempDom.selectAll('text'), maxTick_formatted, null, useHTML); //TODO change for custom tick and merge into renderDOM
      handleSVGTextOverflow(_helperObj, overflowH, { node: tempDom.selectAll('text').node(), index: maxIdx });
      maxTick_content = getTextContent(tempDom.selectAll('text'));
      maxTick_htmlContent = useHTML ? getCustomTickContent(tempDom) : maxTick_content;

      while (!isFinalLongTick && counter < ticks.length - 2) {
        //TODO in previous we didnt consider for lwast sorted tick
        counter = counter + 1;

        sortIdx = ticks_sorted_index[counter];
        curTick = ticks[sortIdx];
        curTick_formatted = useHTML ? customTickInfo.userRawTicks[sortIdx] : ticks_formatted[sortIdx];

        // maxTick = ticks[maxIdx];
        // maxTick_formatted = useHTML ? customTickInfo.userRawTicks[maxIdx] : ticks_formatted[maxIdx];
        // let tickContent = useHTML ? : curTick;
        //apply marks
        markSelector.select('selector', '.zc-tick').data([curTick]);
        markSelector.select('name', 'ticklabel').data([curTick_formatted]);
        marks = markSelector.parser;

        // marks.children[0].data = [curTick];
        // marks.children[0].children[0].data = [curTick_formatted];
        renderDom(marks, tempDom);
        wrapTextContent(tempDom.selectAll('text'), curTick_formatted, null, useHTML); //TODO change for custom tick and merge into renderDOM
        handleSVGTextOverflow(_helperObj, overflowH, { node: tempDom.selectAll('text').node(), index: counter });
        curTick_content = getTextContent(tempDom.selectAll('text'));
        // if (counter == 0) {
        //     maxTick_content = curTick_content;
        // }else{
        if (textWidth(maxTick_content, maxIdx) > textWidth(curTick_formatted, sortIdx)) {
          isFinalLongTick = true;
        }
        // }
        // handleOverflowTicks();
        // if(textWidth(maxTick_content, maxIdx) < textWidth(curTick_formatted, sortIdx)){
        //     isFinalLongTick = true;
        // }
        if (textWidth(curTick_content, curIdx) > textWidth(maxTick_content, maxIdx)) {
          maxTick = ticks[sortIdx];
          maxTick_formatted = useHTML ? customTickInfo.userRawTicks[sortIdx] : ticks_formatted[sortIdx];
          maxIdx = sortIdx;
          maxTick_content = curTick_content;
          maxTick_htmlContent = useHTML ? getCustomTickContent(tempDom) : maxTick_content;
        }
        //check overflow and next tick
        var isLastTick = !ticks.length || counter === ticks.length - 1 || ticks.length === 1;
        tempDom.selectAll('g.customTick').remove();
      }

      markSelector.select('selector', '.zc-tick').data([maxTick]);
      markSelector.select('name', 'ticklabel').data([maxTick_formatted]);
      marks = markSelector.parser;

      // marks.children[0].data = [maxTick];
      // marks.children[0].children[0].data = [maxTick_formatted];
      renderDom(marks, tempDom);

      //2.24 viewparser

      // maxTick_htmlContent = useHTML ? getCustomTickContent(tempDom) : tempDom.selectAll('text.ticklabel').text();

      wrapTextContent(tempDom.selectAll('text'), maxTick_htmlContent, null, useHTML); //TODO change for custom tick and merge into renderDOM
      //calculate g.customTick for custom group tick element
      var finalWrap =
      useHTML && customTickInfo.tickValues[maxIdx] && customTickInfo.tickValues[maxIdx].type == 'group' ?
      tempDom.selectAll('g.customTick') :
      tempDom.selectAll('text');

      var axisgroup = tempDom.node().getBoundingClientRect();
      var width = axisgroup.width,
        height = axisgroup.height,
        tick_data = this.axisTicks.tickInfo;
      if ((orient === 'left' || orient === 'right') && defined(tick_data.width)) {
        width = perToPx(getPriorityValue1(tick_data.width, tick_data.maxWidth) || axis.ticks.maxTickSizeRatio_Hori, plotRect.width);
      } else if (defined(this.axisTicks.tickInfo.height)) {
        height = perToPx(getPriorityValue1(tick_data.height, tick_data.maxHeight) || axis.ticks.maxTickSizeRatio_Vert, plotRect.height);
      }

      var preCalcTickLen = {
        x: axisgroup.left,
        y: axisgroup.top,
        width: width,
        height: height
      };

      return {
        axisgroup: axisgroup,
        preCalcTickLen: preCalcTickLen,
        longTickSize: finalWrap.node().getBoundingClientRect(),
        ticks: ticks
      };
    }

    var getPriorityValue1 = function getPriorityValue1(constant, max) {
      if (defined(constant) && defined(constant)) {
        return constant > max ? max : constant;
      } else {
        return constant || max;
      }
    };

    function textWidthAccessor(tickInfo) {
      var customTickInfo = tickInfo.customTickInfo,styles = tickInfo.styles,orient = tickInfo.orient,
        useHTML = customTickInfo && customTickInfo.styles;
      var style, dimension;
      return function (text, index) {
        if (useHTML) {
          style = customTickInfo.styles[index];
        }

        dimension = getTextBound(text, styles.fontSize, styles.fontFamily, style);

        if (useHTML) {
          return dimension.width * dimension.height;
        }

        return orient == 'left' || orient == 'right' ? dimension.width : dimension.width * dimension.height;
      };
    }
    function getCustomTickContent(actualTickGroup) {
      var tspan = actualTickGroup.
        selectAll('text.ticklabel').
        selectAll('tspan').
        nodes(),
        image = actualTickGroup.
        selectAll('g.image').
        selectAll('image', 'img').
        nodes(),
        group = actualTickGroup.selectAll('g.customTick').nodes(),
        childArray = [];

      if (group && group.length) {
        group.forEach(function (d) {
          childArray.push(d.outerHTML);
        });
      } else {
        if (tspan && tspan.length) {
          tspan.forEach(function (d) {
            childArray.push(d.outerHTML);
          });
        }
        if (image && image.length) {
          image.forEach(function (d) {
            childArray.push(d.outerHTML);
          });
        }
      }

      return childArray;
    }

    function getTickRotateInfo(orient, rotation, ticklabels, axisObj, tickmarkSize, tickPadding, tickObj) {
      var rotateInfo = {};
      var topbaseline = '0.71em',
        middlebaseline = '0.35em',
        bottombaseline = '0em',
        w = orient === 'left' || orient === 'right' ? 'width' : 'height',
        tickPadding = tickPadding == null ? axisObj.tickPadding() : tickPadding,
        isInline = tickObj && tickObj.isInline,
        isInwardPlot = tickObj && tickObj.inlineToPlot,
        tickSpacing = isInline && !isInwardPlot ? tickObj.longTickSize[w] + Math.max(tickmarkSize, 0) + tickPadding : Math.max(tickmarkSize, 0) + tickPadding,
        k = orient === 'top' || orient === 'left' ? -1 : 1,
        l = isInwardPlot ? -k : k,
        changeDY = isInline && tickObj.showGrid;

      switch (orient) {
        case 'top':
          // var k = isInline ? 1 : -1;
          rotateInfo.rotate = [rotation, 0, l * tickSpacing];

          if (rotation >= 0 && rotation < 45 || rotation > 315 && rotation <= 360) {
            rotateInfo.dy = isInline ? topbaseline : bottombaseline;
            rotateInfo.dy1 = '-1em';
          } else if (rotation >= 45 && rotation <= 90 || rotation >= 90 && rotation <= 135 || rotation >= 225 && rotation <= 315) {
            rotateInfo.dy = middlebaseline;
          } else if (rotation > 135 && rotation < 225) {
            rotateInfo.dy = topbaseline;
          }
          rotateInfo.textAnchor =
          rotation == '0' || pInt(rotation) == 180 || pInt(rotation) == 360 ? 'middle' : pInt(rotation) < 180 ? 'end' : 'start';
          break;

        case 'bottom':
          // var k = isInline ? -1 : 1;
          rotateInfo.rotate = [rotation, 0, l * tickSpacing];

          if (rotation >= 0 && rotation < 45 || rotation > 315 && rotation <= 360) {
            rotateInfo.dy = isInline ? bottombaseline : topbaseline;
            rotateInfo.dy1 = '1.71em';
          } else if (rotation >= 45 && rotation <= 90 || rotation >= 90 && rotation <= 135 || rotation >= 225 && rotation <= 315) {
            rotateInfo.dy = middlebaseline;
          } else if (rotation > 135 && rotation < 225) {
            rotateInfo.dy = bottombaseline;
          }
          var textAnchor =
          rotation == '0' || pInt(rotation) == 180 || pInt(rotation) == 360 ? 'middle' : pInt(rotation) < 180 ? 'start' : 'end';
          rotateInfo.textAnchor = isInline ? textAnchor == 'start' ? 'end' : textAnchor == 'end' ? 'start' : textAnchor : textAnchor;
          break;

        case 'left':
          // var k = isInline ? 1 : -1;
          rotateInfo.rotate = [rotation, l * tickSpacing, 0];

          if (rotation >= 0 && rotation < 45) {
            rotateInfo.dy = changeDY ? "-".concat(middlebaseline) : middlebaseline;
          } else if (rotation >= 45 && rotation <= 90 || rotation >= 90 && rotation <= 135) {
            rotateInfo.dy = topbaseline;
          } else if (rotation > 135 && rotation < 225 || rotation >= 225 && rotation <= 315 || rotation > 315 && rotation <= 360) {
            rotateInfo.dy = isInline ? '1em' : bottombaseline;
          }
          var textAnchor = rotation == '90' || pInt(rotation) == 270 ? 'middle' : rotation > 90 && rotation < 270 ? 'start' : 'end';
          rotateInfo.textAnchor = isInline ? textAnchor == 'start' ? 'end' : textAnchor == 'end' ? 'start' : textAnchor : textAnchor;
          break;

        case 'right':
          // var k = isInline ? -1 : 1;
          rotateInfo.rotate = [rotation, l * tickSpacing, 0];

          if (rotation >= 0 && rotation < 45 || rotation > 135 && rotation < 225) {
            rotateInfo.dy = changeDY ? "-".concat(middlebaseline) : middlebaseline;
          } else if (rotation >= 225 && rotation <= 315 || rotation > 315 && rotation <= 360) {
            rotateInfo.dy = topbaseline;
          } else if (rotation >= 90 && rotation <= 135 || rotation >= 45 && rotation <= 90) {
            rotateInfo.dy = bottombaseline;
          }
          rotateInfo.textAnchor = isInline ?
          'end' :
          rotation == '90' || pInt(rotation) == 270 ?
          'middle' :
          rotation > 90 && rotation < 270 ?
          'end' :
          'start';
          break;}


      return rotateInfo;
    }

    var AxisRegistry = {
      add: function add(name, component) {
        Registry.setComponent(name, component);
      },
      get: function get(name) {return Registry.getComponent(name);}
    };

    /*
    render -> true -> render
    render -> false -> prerender
     */
    function getPositionForTicks(render, scale) {
      var _ = this,
        existingTickInfo = _.existingTickInfo,
        oldTickObj = existingTickInfo && existingTickInfo.precalculate,
        tickInfo = _.axisTicks.tickInfo,
        attrs_key = {
          x: _.orient === 'left' || _.orient === 'right' ? 'x' : 'y',
          w: _.orient === 'left' || _.orient === 'right' ? 'width' : 'height',
          y: _.orient === 'left' || _.orient === 'right' ? 'y' : 'x'
        },
        attrs_value = {
          k: _.orient === 'top' || _.orient === 'left' ? -1 : 1
        };

      /*
      Margin, padding  details
       */
      var ticklabelMargin = getMargin(_.config.ticklabel),
        axislabelMargin = getMargin(_.config.label),
        tickPadding = getTickPadding(_.orient, ticklabelMargin, isTickInnerOrient(_.config, _.type, _.chart)),
        tickSizeInner = validateNullVal(_.config.tickmark.size, 6),
        supportSubTicks = _.column.scaleType === LOG,
        /*
        Sub minor ticks details, currently added for log scale
         */
        minorGrid = tickInfo.minorTickValues,
        hasMinorGridPositions = supportSubTicks || isArray$1(minorGrid) && minorGrid.length > 0,
        subTickMarkData = _.config.subtickmark || {},
        isSubTickMarkShow = (subTickMarkData.count > 0 || defined(subTickMarkData.interval)) && hasMinorGridPositions,
        subTickSize = isSubTickMarkShow ? validateNullVal(_.config.subtickmark.size, 6) : 0,
        tickmarkSize = Math.max(tickSizeInner, subTickSize, 0),
        /*
        ticklabel default spacing with tickmark size and padding
         */
        spacing_default = tickmarkSize + tickPadding,
        /*
         ticklabel as inline mode
         */
        isInline = isTickInnerOrient(_.config, _.type, _.chart),
        inlineToPlot = isInline ? checkTickInlineAlignWithInPlot(_.type, _.orient, _.chart.systemConf) : false,
        inlineWspace = isInline && !inlineToPlot,
        inline_reRender = oldTickObj && inlineWspace,
        /*
        controllers
         */
        l = inlineToPlot ? -attrs_value.k : attrs_value.k,
        m = isInline ? -attrs_value.k : attrs_value.k,
        /*
        tick label positioning:
        For normal ticks, it will take from tickmark size and padding
        For inlineWspace charts, on init, consider only tickpadding, because tickmark size should not be included in precalculation
        For final rendering cnsider tickmarksize, padding
         */
        spacing = inline_reRender ? oldTickObj.longTickSize[attrs_key.w] : inlineWspace ? tickPadding : spacing_default,
        /*
        tickmark positioning
         */
        tickmarkStart = inline_reRender ? oldTickObj.axisgroup[attrs_key.w] : 0,
        /*
        rotation details
         */
        tickRotation = pick(tickInfo.rotation, 0),
        rotation = tickRotation < 0 ? 360 - mathAbs(tickRotation) : tickRotation;
      rotation = tickRotation > 360 ? mathAbs(rotation) - 360 : rotation;

      var tickObj = oldTickObj ? _objectSpread(_objectSpread({}, existingTickInfo.tickInfo), existingTickInfo.precalculate) : null;
      var rotationInfo = getTickRotateInfo(_.orient, rotation || 0, null, null, tickmarkSize, tickPadding, tickObj); //handling subticksize also;

      var positionH = {
        attrs_key: attrs_key,
        attrs_value: attrs_value,
        m: m,
        l: l,
        spacing: spacing,
        tickmarkStart: tickmarkStart,
        rotation: rotation,
        rotationInfo: rotationInfo,
        tickSizeInner: tickSizeInner,
        subTickSize: subTickSize
      };

      return {
        axisG: AxisRegistry.get('cartesian.axisGPosition').call(this),
        tickG: AxisRegistry.get('cartesian.tickGPosition').call(this, scale),
        ticklabel: AxisRegistry.get('cartesian.ticklabelPosition').call(this, positionH),
        tickmark: AxisRegistry.get('cartesian.tickmarkPosition').call(this, positionH, positionH.tickSizeInner, render),
        subtickmark: AxisRegistry.get('cartesian.tickmarkPosition').call(this, positionH, positionH.subTickSize, render),
        gridline: _.axisInfo && _.axisInfo.ticks ? _.axisInfo.ticks.majorTicks : null,
        axisline: AxisRegistry.get('cartesian.axisLinePosition').call(this),
        axislinePath: AxisRegistry.get('cartesian.axisLinePath').call(this, positionH)
      };
    }

    AxisRegistry.add('cartesian.positionFinder', getPositionForTicks);

    function initializeAxisTitle(axisTitleParser) {
      var titleH = this.titleH = axisTitleParser.call(this, this.axisTicks.tickH);
      return {
        hideTitle: titleH.hideAxislabel(),
        titleConfig: titleH.axislabelData(),
        titleMargin: titleH.margin(),
        branchTitleConfig: titleH.branchLabelData()
      };
    }var

    CartesianAxisPrerender = /*#__PURE__*/function () {
      function CartesianAxisPrerender(args, helpers) {_classCallCheck(this, CartesianAxisPrerender);
        var type = args.type,order = args.order,config = args.config,plotRect = args.plotRect,viewParser = args.viewParser,maxSize = args.maxSize,chart = args.chart;
        this.type = type;
        this.order = order;
        this.config = config;
        this.plotRect = plotRect;
        this.plotRect1 = plotRect;
        this.maxSize = maxSize;
        this.chart = chart;

        this.initialize(args, helpers);
      }_createClass(CartesianAxisPrerender, [{ key: "initialize", value:
        function initialize(args, helpers) {
          var _h = helpers.axisH;
          this._order = _h.order(this.type, this.order);
          this.orient = _h.orient(this.type, this.order);
          this.datatype = _h.datatype(this.type, this.order);
          this.column = _h.column(this.type, this.order);
          this.axisInfo = _h.axisInfo(this.type, this.order);
          this.tickParser = helpers.tickH;
          this.titleParser = helpers.titleH;

          this.axisView = this.axisInfo.axisView;
        } }, { key: "getDefaultMarkParser", value:

        function getDefaultMarkParser() {
          var markParser = 'cartesian.axisPreRenderMarks';
          if (this.axisView && this.axisView.conf && this.axisView.conf.preMarkParser) {
            markParser = this.axisView.spec.preMarkParser;
          }
          return {
            placeHolder: this.chart.svg.append('g').attr('class', 'dummy'),
            markParser: AxisRegistry.get(markParser).call(this)
          };
        } }, { key: "title", value:
        function title() {
          var hideTitle = this.titleH.hideTitle(),
            titleConfig = this.titleH.titleConfig();
          renderAxisTitle.call(this);
        } }, { key: "getTicks", value:
        function getTicks(newPlotRect) {
          var args = {
            chart: this.chart,
            type: this.type,
            _order: this._order,
            config: this.config,
            plotRect: this.plotRect,
            plotRect1: this.plotRect1,
            order: this.order,
            orient: this.orient,
            datatype: this.datatype,
            column: this.column,
            maxSize: this.maxSize,
            axisInfo: this.axisInfo
          };
          this.axisTicks = new AxisTicks(args, this.tickParser);
          this.axisTicks.collect();
        } }, { key: "preRender", value:
        function preRender(newPlotRect) {
          this.plotRect = newPlotRect || this.plotRect;
          this.preRenderTickG();
          this.preRenderAxisG();
        } }, { key: "preRenderTickG", value:
        function preRenderTickG(newPlotRect) {
          this.plotRect = newPlotRect || this.plotRect;
          this.existingTickInfo = this.axisTicks && this.axisTicks.tickInfo ? this.axisTicks : null;
          this.getTicks();
          var positionH = getPositionForTicks.call(this);
          var markExtender = this.axisView && this.axisView.conf.preMarkExtender;
          var markInfo = this.getDefaultMarkParser(),
            marks = markInfo.markParser(positionH),
            mark = marks.mark;
          this.marks = marks;
          if (markExtender) {
            mark = invokeFunction(markExtender, mark, this);
          }
          var tempDom = this.placeHolder = markInfo.placeHolder;
          this.axisTicks.precalculate = precalculateTickGroup.call(this, mark, tempDom);
          this.placeHolder.remove();
          this.placeHolder = null;
        } }, { key: "preRenderAxisG", value:
        function preRenderAxisG() {
          this.axisTitle = initializeAxisTitle.call(this, this.titleParser);
          // this.title();
          this.axisTitle.precalculate = precalculateAxisGroup.call(this);
        } }]);return CartesianAxisPrerender;}();


    AxisRegistry.add('cartesian.prerender', CartesianAxisPrerender);

    function getAxisGroupPosition() {
      var _ = this,
        left = _.orient == 'right' ? _.plotRect.left + _.plotRect.width : _.plotRect.left,
        top = _.orient == 'bottom' ? _.plotRect.top + _.plotRect.height : _.plotRect.top,
        attrs = {
          transform: "translate(".concat(left, ",").concat(top, ")")
        };
      return attrs;
    }

    AxisRegistry.add('cartesian.axisGPosition', getAxisGroupPosition);

    function getAxisLinePosition() {
      var _ = this,
        attrs = {
          x1: 0,
          y1: 0,
          x2: _.orient == 'bottom' || _.orient == 'top' ? _.plotRect.width : 0.0001, // phantomjs 1.9.8 issue
          y2: _.orient == 'bottom' || _.orient == 'top' ? 0.0001 : _.plotRect.height // // phantomjs 1.9.8 issue
        };
      return attrs;
    }

    function getAxisLinePathVal(positionH) {
      var _ = this,
        axisInfo = _.axisInfo,
        scale = axisInfo.scale || _.axisTicks.tickInfo.scale,
        range = scale.origRange ? scale.origRange : scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        tickSizeOuter = 0,
        d =
        _.orient === 'left' || _.orient == 'right' ? "M".concat(
        positionH.attrs_value.k * (tickSizeOuter + positionH.tickmarkStart), ",").concat(range0, 'h', "0.5V").concat(range1, "H").concat(positionH.
        attrs_value.k * (
        tickSizeOuter + positionH.tickmarkStart)) : "M".concat(
        range0, ",").concat(positionH.attrs_value.k * tickSizeOuter, "V0.5H").concat(range1, "V").concat(positionH.attrs_value.k * tickSizeOuter);
      return d;
    }

    AxisRegistry.add('cartesian.axisLinePosition', getAxisLinePosition);
    AxisRegistry.add('cartesian.axisLinePath', getAxisLinePathVal);

    function getTickGroupPosition(scale1) {
      var _ = this,
        tickInfo = _.axisTicks.tickInfo,
        isLevelType = this.axisTicks.tickH.isHierarchialLevelType(),
        attrs = {};
      attrs.position = function (d) {
        var scale = scale1 || _.axisInfo.scale || tickInfo.scale,
          offset = 0;
        if (scale.bandwidth) {
          if (scale.discreteWidth) {
            if (isLevelType) {
              offset = 0;
            } else {
              offset = Math.max(0, scale.bandwidth(d) - 1) / 2; // Adjust for 0.5px offset.
              // if (scale1.round()) {
              offset = Math.round(offset);
            }
          } else {
            offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
            if (scale.round()) {
              offset = Math.round(offset);
            }
          }
        }

        var pos = pick(scale(d), 0) + (offset || 0);
        return pos;
      };
      attrs.transform = function (d, position) {
        var _position = position || attrs.position(d),
          position2d = _.orient == 'bottom' || _.orient == 'top' ? "".concat(_position + 0.5, ",0") : "0,".concat(_position + 0.5);
        return "translate(".concat(position2d, ")");
      };
      return attrs;
    }

    AxisRegistry.add('cartesian.tickGPosition', getTickGroupPosition);

    function getTicklabelPosition(positionH) {var _attrs2;
      var _ = this,
        tickInfo = _.axisTicks.tickInfo,
        isLevelType = this.axisTicks.tickH.isHierarchialLevelType(),
        attrs = (_attrs2 = {}, _defineProperty(_attrs2,
        positionH.attrs_key.x, positionH.l * positionH.spacing), _defineProperty(_attrs2,
        positionH.attrs_key.y, 0), _defineProperty(_attrs2, "dy",

        tickInfo && tickInfo.mode == 'zigzag' && positionH.rotationInfo.dy1 ?
        positionH.rotationInfo.dy1 :
        positionH.rotationInfo.dy), _defineProperty(_attrs2, "_dy",
        positionH.rotationInfo.dy), _defineProperty(_attrs2, "transform", "rotate(".concat(
        positionH.rotationInfo.rotate[0], " ").concat(positionH.rotationInfo.rotate[1], " ").concat(
        positionH.rotationInfo.rotate[2], ")")), _defineProperty(_attrs2, "transform1",



        function transform1(d, i) {
          var scale = _.axisInfo.scale || tickInfo.scale,
            t = [0, 0];
          if (_.config.tickTransform) {
            t = invokeFunction(_.config.tickTransform, d, scale, _.chart);
          }
          if (isLevelType) {
            /*
            centering ticklabels
             */

            if (scale.bandwidth && scale.discreteWidth) {
              var _position = scale.discreteWidth(i) / 2 || 0,
                position2d =
                _.orient == 'bottom' || _.orient == 'top' ? "".concat(_position + t[0], ",").concat(t[1]) : "".concat(t[0], ",").concat(_position + t[1]);
              return "translate(".concat(position2d, ")");
            }
          }
          return "rotate(".concat(positionH.rotationInfo.rotate[0], " ").concat(positionH.rotationInfo.rotate[1] + t[0], " ").concat(positionH.rotationInfo.
          rotate[2] + t[1], ")");
        }), _defineProperty(_attrs2, "textAnchor",
        positionH.rotationInfo.textAnchor), _defineProperty(_attrs2, "customTransform",

        function customTransform(d, attr, val) {
          var scale = _.axisInfo.scale || tickInfo.scale,
            callback = _.config.tickTransform;
          if (callback) {
            var customTickTransform = invokeFunction(callback, d, scale, _.chart);
            val += attr == 'x' ? customTickTransform[0] : customTickTransform[1];
          }
          return val;
        }), _attrs2),

        keys = {
          attrs_key: positionH.attrs_key
        };

      return _objectSpread(_objectSpread({}, attrs), keys);
    }

    AxisRegistry.add('cartesian.ticklabelPosition', getTicklabelPosition);

    /*
    Gives position details for both axis tickmark and subtickmark.
    - controls using variable 'tickmarkSize'
    - Option 'render' is used to detect whether we are using the function for render or for prerender
    In 'pre-render', we won't apply tickmarksize
     */
    function getTickMarkPosition(positionH, tickmarkSize, render) {var _attrs3;
      var _ = this,
        tickInfo = _.axisTicks.tickInfo,
        x2 = positionH.attrs_value.k * positionH.tickmarkStart + positionH.m * tickmarkSize,
        attrs = (_attrs3 = {}, _defineProperty(_attrs3, "".concat(
        positionH.attrs_key.x, "1"),
        tickInfo.isInline && !tickInfo.inlineToPlot ?
        positionH.attrs_value.k * positionH.tickmarkStart :
        positionH.attrs_value.k * positionH.tickmarkStart), _defineProperty(_attrs3, "".concat(
        positionH.attrs_key.x, "2"), tickInfo.isInline && !tickInfo.inlineToPlot ? x2 : render ? x2 : 0), _defineProperty(_attrs3, "x",
        positionH.attrs_key.x), _attrs3),

        keys = {
          attrs_key: positionH.attrs_key
        };
      return _objectSpread(_objectSpread({}, attrs), keys);
    }

    AxisRegistry.add('cartesian.tickmarkPosition', getTickMarkPosition);

    function getAxisTitlePosition() {
      var _ = this,
        axisTicks = _.axisTicks,
        tickInfo = axisTicks.tickInfo,
        axisgroup = axisTicks.precalculate.axisgroup,
        axisTitle = _.axisTitle;
      var rotations = {
          top: 0,
          right: 90,
          bottom: 0,
          left: 270
        },
        textAnchor = 'middle', // it is middle for all angle
        rotate = rotations[_.orient],
        x,
        y,
        dy = '-0.25em',
        axisRect = axisgroup,
        plotBound = axisTitle.precalculate ? getAxisAreaDim(_.type, _.order, _.orient, _.chart, _.chart.plotarea) : null,
        plotRect = pick(plotBound, this.plotRect),
        tickLabelConfig = _.config.ticklabel,
        axisLabelConfig = axisTitle.branchTitleConfig,
        tickMargin = axisTicks.margin,
        labelMargin = axisTitle.titleMargin;
      var formattedValue = getFormattedValue({}, axisLabelConfig.label.text, 'ordinal', this.chart, 'axis'),
        // fontSize = parseFloat(utils.getVal(getValByPriority([label.config, systemConfig.chart, systemConfig.canvas, $ZCG], 'fontSize'))),
        styleObj = applyFont(null, [axisLabelConfig.label, this.chart.systemConf.chart, this.chart.systemConf.canvas, $ZCG]);
      //
      // // reset BBox
      // if (label.fontSize !== fontSize) {
      //     label.rect = null;
      // } else {
      //     label.fontSize = fontSize;
      // }

      // if axis rotated is called;
      // label.element.attr('dy', '-0.25em');
      var isInline = tickInfo.isInline,
        isInwardToPlot = tickInfo.inlineToPlot,
        isOutwardToPlot = isInline && !isInwardToPlot,
        offset = isOutwardToPlot ? 0 : tickMargin[_.orient],
        _attrs;

      var axisInfo = _.axisInfo,
        scale = axisInfo.scale || _.axisTicks.tickInfo.scale,
        range = scale.origRange ? scale.origRange : scale.range(),
        rangeDiff = mathAbs(range[1] - range[0]);

      switch (_.orient) {
        case 'top':{
            var tickLength = isInwardToPlot ? 0 : axisRect.height + offset;
            x = plotRect.width / 2;
            y = tickLength + labelMargin.bottom;
            _attrs = getParsedAttrs(rotate, x, -y);
            break;
          }

        case 'right':{
            // label.element.attr("dy", "-0.25em");
            var tickLength = isInwardToPlot ? 0 : axisRect.width + offset;
            x = plotRect.height / 2;
            y = tickLength + labelMargin.left;
            _attrs = getParsedAttrs(rotate, x, -y);
            break;
          }
        case 'bottom':{
            var tickLength = isInwardToPlot ? 0 : axisRect.height + offset;
            x = _.chart.defaultScroll ? plotRect.width / 2 : d3_min([range[0], range[1]]) + rangeDiff / 2;
            y = tickLength + labelMargin.top;

            // apply baseline
            dy = '0.91em';
            // label.element.attr('dy', '0.91em');
            _attrs = getParsedAttrs(rotate, x, y);
            break;
          }
        case 'left':{
            // label.element.attr("dy", "-0.25em");
            var tickLength = isInwardToPlot ? 0 : axisRect.width + offset;
            x = tickLength + labelMargin.right;
            y = plotRect.height / 2;
            _attrs = getParsedAttrs(rotate, -x, y, -x, y);
            break;
          }}


      var titleProp = {
        x: _attrs.x,
        y: _attrs.y,
        transform: _attrs.transform,
        dy: dy,
        textAnchor: textAnchor,
        text: formattedValue,
        styleObj: styleObj
      };

      return titleProp;
    }

    AxisRegistry.add('cartesian.axisTitle', getAxisTitlePosition);

    function getParsedAttrs(rotate, x, y, x1, y1) {
      return {
        x: x,
        y: y,
        transform: "rotate(".concat(rotate, " ").concat(x1 || 0, " ").concat(y1 || 0, ")")
      };
    }

    function _defaultAxisPreRenderMark() {
      var _ = this,
        styleObj = applyFont(null, [_.config.ticklabel, _.chart.systemConf.chart, _.chart.systemConf.canvas, $ZCG]),
        axisTitleH;
      return function (positionH) {var _attrs4, _attrs5;
        var _x_tl = positionH.ticklabel.attrs_key.x, //tl -ticklabel, tm- tickmark
          _y_tl = positionH.ticklabel.attrs_key.y,
          _x_tm = positionH.tickmark.attrs_key.x;
        var _axisMark = {
          renderOnDemand: true,
          datatype: _.datatype,
          column: _.column,
          scale: {
            accessor: function accessor() {

              // return viewParser.encodes[columnIdx].scale;
            } },
          order: _._order,
          config: _.config,
          orient: _.orient,
          mark: {
            mark: 'g',
            selector: '.axisgroups',
            data: [1],
            properties: {
              attrs: {
                transform: positionH.axisG.transform
              }
            },
            children: [
            {
              mark: 'g',
              selector: '.zc-tick',
              data: [_.axisTicks.tickInfo.ticks_formatted[0]],
              properties: {
                attrs: {
                  transform: function transform(d) {
                    var useIndices = _.axisTicks.tickInfo.scale.discreteWidth || _.axisTicks.useTickAsIndices,
                      d1 = useIndices ? _.axisTicks.tickInfo.scale.domain()[0] : d;
                    return positionH.tickG.transform(d1);
                  }
                }
              },
              children: [
              {
                name: 'ticklabel',
                selector: '.ticklabel',
                mark: 'text',
                datum: function datum() {},
                data: [_.axisTicks.tickInfo.ticks_formatted[0]],
                properties: {
                  text: function text(d, i) {
                    return d;
                  },
                  attrs: (_attrs4 = {}, _defineProperty(_attrs4,
                  _x_tl, positionH.ticklabel[_x_tl]), _defineProperty(_attrs4,
                  _y_tl, positionH.ticklabel[_y_tl]), _defineProperty(_attrs4, "dy",
                  positionH.ticklabel.dy), _defineProperty(_attrs4, "transform",
                  positionH.ticklabel.transform), _attrs4),

                  styles: _objectSpread({
                    'text-anchor': positionH.ticklabel.textAnchor },
                  styleObj)

                }
              },
              {
                name: 'tickmark',
                selector: '.tickmark',
                mark: 'line',
                data: [_.axisTicks.tickInfo.ticks_formatted[0]],
                properties: {
                  attrs: (_attrs5 = {}, _defineProperty(_attrs5, "".concat(
                  _x_tm, "1"), positionH.tickmark["".concat(_x_tm, "1")]), _defineProperty(_attrs5, "".concat(
                  _x_tm, "2"), positionH.tickmark["".concat(_x_tm, "2")]), _attrs5)

                }
              }]

            },
            {
              name: 'axisline',
              selector: '.axisline',
              mark: 'line',
              data: [1],
              properties: {
                attrs: {
                  x1: positionH.axisline.x1,
                  y1: positionH.axisline.y1,
                  x2: positionH.axisline.x2, // phantomjs 1.9.8 issue
                  y2: positionH.axisline.y2 // // phantomjs 1.9.8 issue
                }
              }
            }]

          },
          axisTitle: {
            onReady: function onReady() {
              axisTitleH = AxisRegistry.get('cartesian.axisTitle').call(_);
              return {
                mark: 'g',
                selector: '.axislabelgroup',
                data: [1],
                children: [
                {
                  name: 'axislabel',
                  selector: '.axislabel',
                  mark: 'text',
                  data: [axisTitleH.text],
                  properties: {
                    text: function text(d, i) {
                      return _.axisTitle.hideTitle ? '' : d;
                    },
                    attrs: {
                      x: axisTitleH.x,
                      y: axisTitleH.y,
                      dy: axisTitleH.dy,
                      transform: axisTitleH.transform
                    },
                    styles: _objectSpread({
                      'text-anchor': axisTitleH.textAnchor },
                    axisTitleH.styleObj)

                  }
                }]

              };
            }
          }
        };
        return _axisMark;
      };
    }

    AxisRegistry.add('cartesian.axisPreRenderMarks', _defaultAxisPreRenderMark);

    function updateMinmaxlabelPosition(ticklabelEle, orient, rotationInfo, ticklabeldata, data, scaleObj, chartObj) {
      var minmaxlabelsdata = ticklabeldata.minmaxlabels || {},
        systemconf = chartObj.systemConf;
      if (minmaxlabelsdata.show === true) {
        var axisReversed = data.reversed === true,
          minmaxlabels_fontSize = +utils.getVal(
          getValByPriority([minmaxlabelsdata, ticklabeldata, systemconf.chart, systemconf.canvas, $ZCG], 'fontSize')),

          domain = scaleObj.domain(),
          domainLength = domain.length - 1,
          minmaxlabels = ticklabelEle.filter(function (d, i) {
            return !(d - domain[0]) || !(d - domain[domainLength]);
          });

        if ((orient === 'top' || orient === 'bottom') && rotationInfo.textAnchor === 'middle') {
          minmaxlabels.style('text-anchor', function (d) {
            return !(d - domain[axisReversed ? domainLength : 0]) ? 'start' : 'end';
          });
        } else if (
        (orient === 'left' || orient === 'right') && (
        chartObj.plotarea.top < minmaxlabels_fontSize / 2 || chartObj.plotarea.bottom < minmaxlabels_fontSize / 2))
        {
          minmaxlabels.attr('dy', function (d) {
            return !(d - domain[axisReversed ? domainLength : 0]) ? '-0.3em' : '0.9em';
          });
        }
        applyFont(minmaxlabels, [minmaxlabelsdata, ticklabeldata, systemconf.chart, systemconf.canvas, $ZCG]);
      }
    }

    function _defaultAxisMark() {
      var _ = this,
        styleObj = applyFont(null, [_.config.ticklabel, _.chart.systemConf.chart, _.chart.systemConf.canvas, $ZCG]);

      return function (positionH, axisTitleH, component, transition_, container) {var _attrs6, _attrs7, _attrs8;
        var tickValues =
        component.tickValues == null ?
        component.scale.ticks ?
        component.scale.ticks.apply(component.scale, []) :
        component.scale.domain() :
        component.tickValues;

        _.axisTicks.tickInfo.ticklabelObj = tickValues;

        var tickMap = d3_map();
        tickValues.map(function (d, i) {return tickMap.set(d, i);});

        var events_tick = _.config.ticklabel.events,
          eventDisabled = events_tick != null && validateNullVal(events_tick.enabled, true) == false,
          cursor = eventDisabled ? 'auto' : events_tick ? events_tick.cursor || 'pointer' : 'pointer';

        var attrs = {};

        if (!component.syncTransition) {
          attrs = {
            transform: function transform(d) {
              return positionH.tickG.transform(d);
            }
          };
        }
        var _x_tl = positionH.ticklabel.attrs_key.x, //tl -ticklabel, tm- tickmark
          _y_tl = positionH.ticklabel.attrs_key.y,
          _x_tm = positionH.tickmark.attrs_key.x;
        var _axisMark = {
          renderOnDemand: true,
          datatype: _.datatype,
          column: _.column,
          scale: {
            accessor: function accessor() {

              // return viewParser.encodes[columnIdx].scale;
            } },
          order: _._order,
          config: _.config,
          orient: _.orient,
          mark: {
            mark: 'g',
            selector: '.axisgroups',
            data: [1],
            children: [
            {
              mark: 'path',
              selector: '.domain',
              data: [null],
              order: '.tick',
              config: {
                strokeWidth: pick(_.config.axisline.strokeWidth, 1),
                dashStyle: _.config.axisline.style,
                lineCap: _.config.axisline.lineCap
              },
              properties: {
                attrs: {
                  d: function d() {
                    return positionH.axislinePath;
                  }
                },
                styles: {
                  stroke: _.config.axisline.show === false ? 'transparent' : _.config.axisline.color || '#000',
                  fill: 'none'
                }
              }
            },
            {
              mark: 'g',
              selector: '.tick',
              data: tickValues,
              dataAccessor: function dataAccessor(d) {
                return component.scale(d);
              },
              config: {
                enter: {
                  opacity: 1e-6,
                  transform: function transform(d) {
                    return positionH.tickG.transform(d);
                  }
                }
              },
              anime: {
                update: {
                  transition: transition_,
                  opacity: 1,
                  transform: function transform(d) {
                    var _position = positionH.tickG.position(d);
                    this.__axis = _position;
                    return positionH.tickG.transform(d, _position);
                  }
                },
                exit: {
                  transition: transition_,
                  opacity: 1e-6,
                  transform: function transform(d) {
                    return isFinite(positionH.tickG.position(d)) ?
                    positionH.tickG.transform(d) :
                    this.getAttribute('transform');
                  }
                }
              },
              properties: {
                attrs: attrs
              },
              children: [
              {
                name: 'tickmark',
                selector: '.minorTicks',
                mark: 'line',
                data: function data(d, i) {
                  return [d];
                },
                config: {
                  strokeWidth: pick(_.config.tickmark.strokeWidth, 1)
                },
                properties: {
                  attrs: (_attrs6 = {}, _defineProperty(_attrs6, "".concat(
                  _x_tm, "1"), positionH.tickmark["".concat(_x_tm, "1")]), _defineProperty(_attrs6, "".concat(
                  _x_tm, "2"), positionH.tickmark["".concat(_x_tm, "2")]), _attrs6),

                  styles: {
                    fill: 'none',
                    'shape-rendering': 'crispedges',
                    stroke: _.config.tickmark.color
                  }
                }
              },
              {
                name: 'gridline',
                selector: '.majorTicks',
                mark: 'line',
                data: function data(d, i) {
                  return component.isGridShow && component.renderGrid && positionH.gridline ? [d] : [];
                },
                config: {
                  strokeWidth: pick(_.config.grid.strokeWidth, 1),
                  dashStyle: _.config.grid.style,
                  lineCap: _.config.grid.lineCap
                },
                properties: {
                  attrs: {
                    x1: positionH.gridline && positionH.gridline.x1,
                    x2: positionH.gridline && positionH.gridline.x2,
                    y1: positionH.gridline && positionH.gridline.y1,
                    y2: positionH.gridline && positionH.gridline.y2
                  },
                  styles: {
                    fill: 'none',
                    'shape-rendering': 'crispedges',
                    stroke: _.config.grid.color
                  }
                }
              },
              {
                name: 'ticklabel',
                selector: '.ticklabel',
                mark: 'text',
                datum: function datum() {},
                data: function data(d) {return component.renderTicklabel ? [d] : [];},
                dataAccessor: function dataAccessor(d) {
                  return component.scale(d);
                },
                onEnd: function onEnd(d, i) {
                  //format
                  var f =
                    component.tickFormat == null ?
                    component.scale.tickFormat ?
                    component.scale.tickFormat.apply(component.scale, []) :
                    function (d) {return d;} :
                    component.tickFormat,
                    //update ticklabel element by data, so we can add text only to to the active text node
                    t = createElement('g', '.tick', tickValues, container, null, function (d) {return component.scale(d);}, {
                      remove: false
                    }),
                    t1 = t.select('text.ticklabel');

                  updateMinmaxlabelPosition(
                  t1,
                  _.orient,
                  positionH.ticklabel,
                  _.config.ticklabel,
                  _.config,
                  component.scale,
                  _.chart);

                  t1.each(function (d, i) {
                    f.call(this, this.__data__, tickMap.get(d));
                  });
                  if (_.config.ticklabel.tooltip === true) {
                    d.each(function (d) {
                      addSVGtitleEle(d3_select(this), this.formattedVal);
                    });
                  }
                },
                config: {
                  enter: {}
                },
                properties: {
                  attrs: (_attrs7 = {}, _defineProperty(_attrs7,
                  _x_tl, function (d) {
                    var val = positionH.ticklabel[_x_tl];
                    return positionH.ticklabel.customTransform(d, _x_tl, val);
                  }), _defineProperty(_attrs7,
                  _y_tl, function (d) {
                    var val = positionH.ticklabel[_y_tl];
                    return positionH.ticklabel.customTransform(d, _y_tl, val);
                  }), _defineProperty(_attrs7, "dy",
                  function dy(d) {
                    return _.axisTicks.tickInfo.mode == 'zigzag' && tickMap.get(d) % 2 ?
                    positionH.ticklabel.dy :
                    positionH.ticklabel._dy;
                  }), _defineProperty(_attrs7, "transform",
                  function transform(d) {return positionH.ticklabel.transform1(d, tickMap.get(d));}), _attrs7),

                  styles: _objectSpread({
                    'text-anchor': positionH.ticklabel.textAnchor,
                    cursor: cursor },
                  styleObj)

                }
              }]

            },
            {
              mark: 'g',
              selector: '.zc-subMinorTicks',
              data: component.isSubTickMarkShow && isArray(component.minorGrid) ? [1] : [],
              children: [
              {
                name: 'sub-minor-ticks',
                selector: '.zc-sub-ticks',
                mark: 'line',
                data: component.isSubTickMarkShow ? component.minorGrid : [],
                config: {
                  strokeWidth: pick(_.config.subtickmark.strokeWidth, 1)
                },
                properties: {
                  attrs: (_attrs8 = {}, _defineProperty(_attrs8, "".concat(
                  _x_tm, "1"), positionH.subtickmark["".concat(_x_tm, "1")]), _defineProperty(_attrs8, "".concat(
                  _x_tm, "2"), positionH.subtickmark["".concat(_x_tm, "2")]), _defineProperty(_attrs8, "transform",
                  function transform(d) {
                    return positionH.tickG.transform(d);
                  }), _attrs8),

                  styles: {
                    fill: 'none',
                    'shape-rendering': 'crispedges',
                    stroke: _.config.subtickmark.color
                  }
                }
              }]

            },
            {
              mark: 'g',
              selector: '.zc-subMajorTicks',
              data: component.isMinorGridShow && isArray(component.minorGrid) ? [1] : [],
              children: [
              {
                name: 'sub-major-ticks',
                selector: '.zc-sub-major-ticks',
                mark: 'line',
                data: positionH.gridline && component.isMinorGridShow ? component.minorGrid : [],
                config: {
                  strokeWidth: pick(_.config.minorGrid.strokeWidth, 1),
                  dashStyle: _.config.minorGrid.style,
                  lineCap: _.config.minorGrid.lineCap
                },
                properties: {
                  attrs: {
                    x1: positionH.gridline && positionH.gridline.x1,
                    x2: positionH.gridline && positionH.gridline.x2,
                    y1: positionH.gridline && positionH.gridline.y1,
                    y2: positionH.gridline && positionH.gridline.y2,
                    transform: function transform(d) {
                      return positionH.tickG.transform(d);
                    }
                  },
                  styles: {
                    fill: 'none',
                    'shape-rendering': 'crispedges',
                    stroke: _.config.minorGrid.color
                  }
                }
              }]

            },
            {
              mark: 'g',
              selector: '.axislabelgroup',
              parent: container.node().parentElement,
              data: [1],
              children: [
              {
                mark: 'text',
                selector: '.axislabel',
                data: _.axisTitle.hideTitle ? [] : [axisTitleH.text],
                properties: {
                  text: function text(d, i) {
                    return d;
                  },
                  attrs: {
                    x: axisTitleH.x,
                    y: axisTitleH.y,
                    dy: axisTitleH.dy,
                    transform: axisTitleH.transform
                  },
                  styles: _objectSpread({
                    'text-anchor': axisTitleH.textAnchor },
                  axisTitleH.styleObj)

                }
              }]

            }]

          }
        };
        return _axisMark;
      };
    }

    AxisRegistry.add('cartesian.axisMarks', _defaultAxisMark);

    //$Id$

    function handleOverflowTicks(
    axisgroup,
    orient,
    chartObj,
    rotation,
    overflow,
    scaleObj,
    wrap,
    axisComp,
    labelType,
    ticklabelOptions,
    index) {var
      options = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : {};return function (ticklabelOptions)
      {
        if (overflow == 'none') {
          return doHandleOverflow;
        }
        var plotarea = chartObj.plotarea,
          chartarea = chartObj.chartarea,
          canvasarea = chartObj.canvasarea,
          actChartObj = chartObj.actChartObj || chartObj,
          axisType = actChartObj.dataObject.isAxisCategory ? getAxisType(orient, actChartObj.axes.rotated) : 'y', // Pivot web chart: with multi y FEATURES_PIVOT_23
          hierarchical = actChartObj.dataObject.categoryHierarchy,
          hasDynamicLeafScale =
          chartObj && chartObj.dataObject && chartObj.dataObject.hierarchical && chartObj.dataObject.hierarchical.dynamicLeafScale,
          hasSplitLeavesColumn = hierarchical ? actChartObj.dataObject.hierarchical.pivotLayout.columns.splitColumnLeaves : false,
          xaxisdata = actChartObj.systemConf.chart.axes.xaxis,
          yaxisdata = actChartObj.systemConf.chart.axes.yaxis,
          axisOrder = index || 0,
          axisdata = getAxisData(actChartObj, axisType, axisOrder, !actChartObj.dataObject.isAxisCategory), // Pivot web chart: needMerge should be true
          overflowPattern = overflow == null || overflow == 'ellipsis' ? '..' : '',
          tickmarkdataOption = axisdata.tickmark.align,
          fSize = utils.getVal(
          getValByPriority([ticklabelOptions, actChartObj.systemConf.chart, actChartObj.systemConf.canvas, $ZCG], 'fontSize')),

          ticks,
          ticklabelOptions = labelType == 'ticklabel' ? ticklabelOptions : {},
          tickObj = getAxisObject(actChartObj, axisType, index || 0).ticks,
          isHierarchialLevelType = tickObj ? tickObj.isHierarchialLevelType() : scaleObj.discreteWidth && scaleObj.bandwidth() == null,
          isPolar = options.type === 'polar',
          distBwTicks,
          count,
          dontUseMargin,
          percentLimit = 0.5;

        if (axisgroup == null && labelType == 'ticklabel') {
          ticks =
          axisComp.tickValues() == null ?
          scaleObj.ticks ?
          scaleObj.ticks.apply(scaleObj, [10]) :
          scaleObj.domain() :
          axisComp.tickValues();
          var tickWrap = wrap.selectAll('.tick').data(ticks, scaleObj);
          axisgroup = tickWrap.selectAll('text.ticklabel');
        }

        //Update edge details for hierarchy data and tickmark align option as inbetween
        if (
        labelType == 'ticklabel' &&
        axisComp &&
        !isHierarchialLevelType && (
        tickObj && tickObj.isHierarchy() && axisType == 'x' || tickmarkdataOption == 'between'))
        {
          dontUseMargin = true;
          ticks = ticks || axisComp.tickValues();
          distBwTicks = scale.getRangeBand(scaleObj, ticks, 0);
          var minTick = ticks[0],
            maxTick = ticks[ticks.length - 1];
          if (axisdata.reversed) {
            minTick = ticks[ticks.length - 1], maxTick = ticks[0];
          }

          var outerPadding = mathAbs(distBwTicks.outerPaddingInPixel),
            bandWidth = scaleObj.bandwidth ? scaleObj.bandwidth() / 2 : 0;
        }

        var labelSize = getMaxTickSize(ticklabelOptions, chartarea),
          hasUserLabelSize = defined(ticklabelOptions.width) || defined(ticklabelOptions.maxWidth),
          maxTickSize_Vert = labelSize.vertical,
          maxTickSize_Hori = labelSize.horizontal;

        var edge = getBoundaryEdges(actChartObj),
          margin = getExtraMarginForBoundary(labelType, plotarea, canvasarea, percentLimit);

        if (chartObj.actChartObj || labelType == 'axislabel' && axisgroup.node()) {
          return doHandleOverflow(axisgroup.node());
        } else {
          return doHandleOverflow;
        }

        function getBoundaryEdges(chartObj, _bandwidth) {
          var _bandwidthCopy = pick(_bandwidth, bandWidth);
          var edge = {};
          var scale1 = axisType == 'x' && hasSplitLeavesColumn && chartObj.axes.x.leaves[0] ? chartObj.axes.x.leaves[0].scale : scaleObj;
          if (dontUseMargin) {
            if (orient == 'bottom' || orient == 'top') {
              edge.left = scale1(minTick) - mathAbs(_bandwidthCopy - outerPadding),
              edge.right = scale1(maxTick) + (outerPadding + _bandwidthCopy);
            } else if ((orient == 'left' || orient == 'right') && (rotation == 90 || rotation == 270)) {
              edge.top = scale1(maxTick) - outerPadding, edge.bottom = scale1(minTick) + outerPadding;
            }
          } else {
            edge.top = edge.left = 0;
            edge.right = orient == 'bottom' || orient == 'top' ? getPlotSize(chartObj, 'width', plotarea) : 0;
            edge.bottom = orient == 'bottom' || orient == 'top' ? 0 : getPlotSize(chartObj, 'height', plotarea);
          }

          return edge;
        }

        function getExtraMarginForBoundary(labelType, boundary, canvasBoundary, marginPercent) {
          var margin = {};
          if (dontUseMargin || isPolar) {
            margin.left = margin.right = 0;
            margin.top = margin.bottom = 0;
          } else {
            margin.left =
            labelType == 'axislabel' ?
            marginPercent * (canvasBoundary.width - (boundary.left + boundary.width)) :
            marginPercent * boundary.left, //ZC743 If its axislabel margin right and left should be same, because always axislabel placed at center of plotarea with textanchor middle
            margin.right = marginPercent * (canvasBoundary.width - (boundary.left + boundary.width)),
            margin.top =
            labelType == 'axislabel' ?
            marginPercent * (canvasBoundary.height - (boundary.bottom + boundary.height)) :
            marginPercent * boundary.top,
            margin.bottom =
            labelType == 'axislabel' ?
            marginPercent * (canvasBoundary.height - (boundary.bottom + boundary.height)) :
            marginPercent * boundary.bottom;
          }

          return margin;
        }

        function doHandleOverflow(tickNode, index) {
          if (overflow == 'none') {
            return;
          }
          /*
           * Cropping the text to maximum ticklabel size (according to bounded box of the text)
           */
          var activeNode = tickNode;
          var childNodes = [activeNode.childNodes[0]]; //If the SVG text has title element, the title element will be removed while changing this.textContent as because it modifies all the childNodes of it. So take the text element alone to trim

          // only for multiple line ticklabel, checking tspan
          var tspan = d3_select(activeNode).
          selectAll('tspan').
          nodes();
          if (tspan && tspan.length) {
            tspan.sort(function (a, b) {
              return b.textContent.length - a.textContent.length;
            });
            childNodes = tspan;
          }

          if (!childNodes) {
            return;
          }

          //Change maxTickSize if margin was not needed
          if (dontUseMargin) {
            count = count || wrap.selectAll('text.ticklabel').nodes().length;
            var outerPadding = mathAbs(distBwTicks.outerPaddingInPixel);
            if (orient == 'bottom' || orient == 'top') {
              if (hasUserLabelSize) {
                maxTickSize_Hori = labelSize.horizontal;
              } else if (rotation != 90 && rotation != 270) {
                maxTickSize_Hori = index == 0 || index == count - 1 ? outerPadding * 2 : mathAbs(distBwTicks.rangeBand) * 2; //DEMO_PIVOT_4_1 wrong count value generated till 2.21
              }
            } else if ((orient == 'left' || orient == 'right') && (rotation == 90 || rotation == 270)) {
              maxTickSize_Vert = index == 0 || index == count - 1 ? outerPadding * 2 : mathAbs(distBwTicks.rangeBand) * 2;
            }
          }

          //Iterate childnodes and apply ellipsis for each node
          for (var i = 0; i < childNodes.length; i++) {
            var txtNode = tspan && tspan.length ? childNodes[i] : activeNode,
              initial_textContent = txtNode.textContent,
              clientRect = txtNode.nodeName == 'tspan' ? getTspanBoundingClientRect : getDefaultBoundingClientRect,
              textBounds = clientRect(txtNode),
              initial_textBound = textBounds,
              trimmed,
              overflowLength = -1,
              max = {
                // This should be changed for axis labels
                width: maxTickSize_Hori,
                height: maxTickSize_Vert
              },
              minMargin = dontUseMargin || isPolar ? 0 : fSize; //if margin is very less, tick labels are trimmed unnecessarily. So set minMargin as its height

            //For hierarchy level type, check only for maxWidth
            if (isHierarchialLevelType && labelType == 'ticklabel' && !chartObj.actChartObj) {
              var rb =
              orient == 'left' || orient == 'right' ?
              maxTickSize_Hori :
              Math.abs(scaleObj.discreteWidth(tickNode.__data__)) || maxTickSize_Hori;
              var maxWid = mathMin(maxTickSize_Hori, rb);
              naiveEllipsis(txtNode, txtNode, txtNode.textContent, maxWid, maxTickSize_Vert, textBounds, overflowPattern);
              return;
            }

            //Check for maxwidth and add ellipsis
            if (labelType == 'ticklabel') {
              if (maxTickSize_Hori < textBounds.width) {
                overflowLength = (textBounds.width - maxTickSize_Hori) / textBounds.width;
                var croppedTextLength = mathCeil((1 - overflowLength) * txtNode.textContent.length);
                txtNode.textContent = txtNode.textContent.substring(0, croppedTextLength - 2) + overflowPattern; //TODO: for textOverflow = 'hidden', subtracting 2 letters is necessary?
                textBounds = clientRect(txtNode); //update new textbounds
              }
              if (maxTickSize_Vert < textBounds.height) {
                overflowLength = (textBounds.height - maxTickSize_Vert) / textBounds.height;
                var croppedTextLength = mathCeil((1 - overflowLength) * txtNode.textContent.length);
                txtNode.textContent = txtNode.textContent.substring(0, croppedTextLength - 2) + overflowPattern;
                textBounds = clientRect(txtNode); //update new textbounds
              }
            }

            //calculte new boundary edges and textbounds
            var axisGroupBounds = isPolar ? { left: 0, top: 0 } : getBoundingRect(wrap.selectAll('.domain'));
            var newTextBounds = {
              left: textBounds.left - axisGroupBounds.left,
              right: textBounds.left + textBounds.width - axisGroupBounds.left,
              top: textBounds.top - axisGroupBounds.top,
              bottom: textBounds.top + textBounds.height - axisGroupBounds.top,
              width: textBounds.width,
              height: textBounds.height
            };

            if (options.edge) {
              edge = options.edge(txtNode, textBounds);
            } else if (hasDynamicLeafScale && scaleObj.bandwidth) {
              edge = getBoundaryEdges(chartObj, scaleObj.bandwidth(tickNode.__data__));
            }

            //Trim text based on boundary edges
            if ((orient == 'left' || orient == 'right') && rotation != 0 && rotation != 180 && rotation != 360) {
              if (
              newTextBounds.top + mathMax(minMargin, margin.top) < edge.top ||
              newTextBounds.bottom - mathMax(minMargin, margin.bottom) > edge.bottom)
              {
                trimmed = true;
                trimText(txtNode, txtNode.textContent, newTextBounds, edge, orient, overflowPattern, margin, max, txtNode);
              }
            } else if ((orient == 'bottom' || orient == 'top') && rotation != 90 && rotation != 270) {
              if (
              newTextBounds.left + mathMax(minMargin, margin.left) < edge.left ||
              newTextBounds.right - mathMax(minMargin, margin.right) > edge.right)
              {
                trimmed = true;
                trimText(txtNode, txtNode.textContent, newTextBounds, edge, orient, overflowPattern, margin, max, txtNode);
              }
            }

            if (labelType == 'ticklabel' && !trimmed) {
              var textBounds = clientRect(txtNode);
              if (textBounds.width != initial_textBound.width || textBounds.height != initial_textBound.height) {
                naiveEllipsis(txtNode, activeNode, initial_textContent, max.width, max.height, textBounds, overflowPattern);
              }
            }

            if (txtNode.textContent == overflowPattern) {
              txtNode.textContent = chartObj.actChartObj ? '.' : ''; //hack  while casper automation DOC_CHART_61
            }
          }
        }
      }(ticklabelOptions);}

    //$Id$

    var rendererBoundUtils = {};
    rendererBoundUtils.getAvailableBound = function (plotarea, commonPlotOptions) {
      var chartWidth = plotarea.width,
        chartHeight = plotarea.height,
        outerPaddingX = mathMin(chartWidth / 2, perToPx(commonPlotOptions.outerPadding, chartWidth / 2, 0)),
        outerPaddingY = mathMin(chartHeight / 2, perToPx(commonPlotOptions.outerPadding, chartHeight / 2, 0));

      return {
        x: outerPaddingX,
        y: outerPaddingY,
        width: chartWidth - 2 * outerPaddingX,
        height: chartHeight - 2 * outerPaddingY
      };
    };

    rendererBoundUtils.updatePlotareaByBandWidth = function (chartObj, plotarea_approx) {
      //Changing plot area for bullet chart
      var dataObject = chartObj.dataObject,
        commonPlotOptions;
      if (dataObject.noofBarEnabledSeries || dataObject.isCombinationalChart) {
        dataObject.allChartTypes.some(function (chartType) {
          var chartNmae = DataProcessor.helpers.getChartType(chartType, 'string');
          if (isBarChartType(chartType)) {
            commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[chartNmae];
            return true;
          }
        });
      }

      if (commonPlotOptions && commonPlotOptions.strictBandWidth) {
        var len = dataObject.getCategories('x').length,
          padding = pick(commonPlotOptions.padding, 0.2),
          outerPadding = commonPlotOptions.outerPadding;
        outerPadding = defined(outerPadding) ? outerPadding : 0.2;
        outerPadding = scale.getOuterPadding(
        rotated ? [0, plotarea_approx.width] : [plotarea_approx.height, 0],
        len,
        padding,
        outerPadding);
        //consider plot borderSize in range
        var levelMarkerOptions = commonPlotOptions.levelMarker,
          targetMarkerOptions = commonPlotOptions.targetMarker || {},
          plotarea = chartObj.plotarea,
          rotated = chartObj.axes.rotated;

        var defaultBandWidth =
          (rotated ? plotarea_approx.height : plotarea_approx.width) / (len - padding + 2 * outerPadding) * (1 - padding),
          arr = [],
          levelMarkerBandWidth = validateNullVal(levelMarkerOptions.bandWidth, defaultBandWidth),
          levelMarkerMaxBandWidth = validateNullVal(levelMarkerOptions.maxBandWidth, defaultBandWidth),
          levelMarkerBand = mathMin(levelMarkerBandWidth, levelMarkerMaxBandWidth, defaultBandWidth);

        if (levelMarkerOptions.enabled) {
          arr.push(levelMarkerBand);
        }

        if (targetMarkerOptions.enabled) {
          arr.push(defined(targetMarkerOptions.size) ? mathMin(targetMarkerOptions.size * 10, defaultBandWidth) : 0);
        }

        var barBandWidth = validateNullVal(commonPlotOptions.bandWidth, levelMarkerBand),
          barMaxBandWidth = validateNullVal(commonPlotOptions.maxBandWidth, barBandWidth);

        arr.push(mathMin(barBandWidth, barMaxBandWidth, defaultBandWidth));
        var bandWidth = mathMax.apply(null, arr);

        var step = bandWidth / (1 - padding);
        bandWidth = step * (len - padding + 2 * outerPadding);

        if (rotated) {
          plotarea.height = bandWidth + (plotarea.height - plotarea_approx.height);
          plotarea.top += plotarea.adjust = (plotarea_approx.height - bandWidth) / 2;
        } else {
          plotarea.width = bandWidth + (plotarea.width - plotarea_approx.width);
          plotarea.left += plotarea.adjust = (plotarea_approx.width - bandWidth) / 2;
        }
      }
    };

    /**
     *
     * @param axisInfo
     * @param type
     * @param transform
     * @return {{domain: [number, number]}|{range: number[]}}
     */
    function updateScaleByTransform(axisInfo, type, transform, baseRange) {
      var scale = axisInfo.scale,baseScale = axisInfo.baseScale,zoomScale = axisInfo.zoomScale,baseZoomScale = axisInfo.baseZoomScale,
        domain,
        range,
        constrain = transform.k > 1;

      type = type.toUpperCase();

      if (scale.bandwidth) {
        var originalRange = baseRange || baseScale.range();

        range = originalRange.map(function (d) {return transform["apply".concat(type)](d);});
        if (constrain) {
          range = constrainRange(range, originalRange);
        }
        // fix axis rotated
        scale.range(range);
      } else {
        domain = transform["rescale".concat(type)](baseScale).domain();

        if (constrain) {
          // constrain
          domain = constrainDomain(domain, baseScale.originalDomain || scale.originalDomain, scale.outerPadding);
        }
        scale.domain(domain);
      }

      // for zoom scale if available
      if (zoomScale) {
        var zoomDomain = transform["rescale".concat(type)](baseZoomScale).domain();
        zoomScale.domain(axisInfo.zoomDomain = zoomDomain);
      }

      return { domain: domain, range: range };
    }

    function applyZoomTransform(scaleObj, type, orient, reversed, chart, axisObj) {
      var plotZoom = chart.behaviouralEvents && getPropVal(chart.behaviouralEvents.eventManager, 'behaviours.PLOT_ZOOM');

      if (plotZoom && plotZoom.types && plotZoom.types[type] === true) {
        var transform = plotZoom.instance.getTransform(),
          t0 = _defineProperty({}, type, axisObj),
          // #ZC2260 $newTransform
          newTransform = getZoomTransformFromAxis(transform.k, t0.x, t0.y, chart);

        // apply the transform on redraw
        updateScaleByTransform(axisObj, type, newTransform);
      }
      return scaleObj;
    }

    /**
     *
     * @param k
     * @param xAxis
     * @param yAxis
     * @param chart
     * @return {*}
     */
    function getZoomTransformFromAxis(k, xAxis, yAxis, chart) {
      var x = 0,
        y = 0;

      if (xAxis) {
        x = xAxis.baseZoomScale(xAxis.zoomDomain[0]);
      }
      if (yAxis) {
        y = yAxis.baseZoomScale(yAxis.zoomDomain[0]);
      }
      return d3_zoomIdentity.scale(k).translate(-x, -y);
    }

    /**
     *
     * @param axisObj
     * @param chart
     */
    function createZoomScale(axisObj, chart) {
      // create a normal scale for every axis and apply that when resize
      var zoomEnabled = getPropVal(chart.systemConf, 'chart.zoom.enabled') === true;
      if (zoomEnabled) {
        axisObj.zoomScale = d3_scaleLinear().
        range([0, chart.axes.rotated ? chart.plotarea.height : chart.plotarea.width]).
        domain([0, 100]);
        axisObj.baseZoomScale = axisObj.zoomScale.copy();
      }
    }

    function _numericSize(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,plotRect = helpers.plotRect,side = helpers.side,
        dataObject = chart.dataObject;
      var correction4Datalabels;

      if (type === 'y' && chart.datalabels.hasFixedPosition) {
        var rangeCorrections_datalabels = chart.cache.correction,
          id = "label-".concat(type, "-").concat(order),
          labelCorrection = 0;

        if (isUndefined(rangeCorrections_datalabels[id])) {
          var yEncode = dataObject.getEncode('y', order);
          labelCorrection = LabelRegistry.get('preCalculation')(type, yEncode.seriesData, chart) || 0;
          rangeCorrections_datalabels[id] = [labelCorrection, labelCorrection];
        } else {
          labelCorrection = rangeCorrections_datalabels[id][1] || 0;
        }
        correction4Datalabels = labelCorrection;
      } else {
        correction4Datalabels = 0;
      }

      var gridSize = dataObject.hierarchical ? _pivotNumericSize(helpers) || plotRect[side] : plotRect[side];

      var size = gridSize - correction4Datalabels;
      return size;
    }

    function _pivotNumericSize(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart;

      var processor = chart.dataObject,
        hierarchical = processor.hierarchical,
        isCategoryHierarchy = hierarchical && hierarchical.categoryTree,
        pLayout = hierarchical.pivotLayout,
        rowList = pLayout.getRootNodeList('row'),
        columnList = pLayout.getRootNodeList('column'),
        leavesCount = rowList.getLeavesCount(),
        splitLeavesColumn = columnList.splitColumnLeaves;

      var gridSize;
      if (type == 'y' && isCategoryHierarchy && leavesCount) {
        var rangeCopy = [order * rowList.leafSize + rowList.leafSize, order * rowList.leafSize];
        gridSize = mathAbs(rangeCopy[1] - rangeCopy[0]);
      }
      if (type == 'x' && isCategoryHierarchy && splitLeavesColumn) {
        var rangeCopy = [order * columnList.leafSize, order * columnList.leafSize + columnList.leafSize];
        gridSize = mathAbs(rangeCopy[1] - rangeCopy[0]);
      }
      return gridSize;
    }

    function _plotSizeWithPadding(helpers) {
      var chart = helpers.chart,plotRect = helpers.plotRect,side = helpers.side,plotRect1 = helpers.plotRect1,
        bzsEnabled = _BZS(helpers),
        size = bzsEnabled ? _zoomPlotSize(helpers) : getPlotSize(chart, side, plotRect1),
        padding = getPaddingForPlotSize(helpers, size);

      return size - padding;
    }
    function _plotNPivotGridSize(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,plotRect = helpers.plotRect,side = helpers.side,
        dataObject = chart.dataObject,
        size = _plotSizeWithPadding(helpers);
      if (dataObject.hierarchical) {
        var pivotSize = _pivotLeafGridSize(helpers);
        if (pivotSize) {
          var padding = getPaddingForPlotSize(helpers, size); //but it should be pivotSize
          size = pivotSize - padding;
        }
      }

      return size;
    }

    function _gridSize(helpers, withZoomSize) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,plotRect1 = helpers.plotRect1,side = helpers.side,
        dataObject = chart.dataObject,
        bzsEnabled = _BZS(helpers);
      if (helpers.datatype == NUMERIC_DATATYPE && type == 'y') {
        return _numericSize(helpers);
      } else {
        if (dataObject.hierarchical) {
          return _pivotLeafGridSize(helpers) || getPlotSize(chart, side, plotRect1);
        } else if (bzsEnabled && withZoomSize) {
          return _zoomPlotSize(helpers);
        } else {
          return getPlotSize(chart, side, plotRect1);
        }
      }
    }
    function _pivotLeafGridSize(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart;

      var processor = chart.dataObject,
        hierarchical = processor.hierarchical,
        pLayout = hierarchical.pivotLayout,
        columnList = pLayout.getRootNodeList('column'),
        splitLeavesColumn = columnList.splitColumnLeaves;

      if (splitLeavesColumn) {
        return columnList.leafSize;
      }
    }

    function _zoomPlotSize(helpers) {
      var existingScale = _existingScale(helpers),
        newRange = existingScale.range(),
        zoomPlotSize = mathAbs(newRange[1] - newRange[0]);
      return zoomPlotSize;
    }
    function getPaddingForPlotSize(helpers, size) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,plotRect = helpers.plotRect,
        dataObject = chart.dataObject,
        firstChartName = chart.chartTypes[0].name,
        commonPlotOptions = chart.systemConf.chart.plot.plotoptions[firstChartName],
        outerPadding = dataObject.isAxisCategory ? commonPlotOptions.outerPadding || 0 : 0,
        padding = type === 'x' ? size * outerPadding * 2 : 0;

      return padding;
    }

    function _tickRotation(obj) {
      var alignmentMode = obj.alignMode,
        isRotateMode = obj.alignMode && obj.alignMode.indexOf('rotate') != -1,
        isOldRotateMode = defined(obj.rotation),
        rotation = 0,
        hasPriorityOrder,
        autoRotation = 45,
        hasDefinedAutoRotation;
      if (isRotateMode) {
        var rotationExtract = /\(([^)]+)\)/.exec(alignmentMode);
        rotation = rotationExtract ? parseInt(rotationExtract[1]) : 'auto';
      } else if (isOldRotateMode && !defined(obj.alignMode)) {
        rotation = obj.rotation == 'auto' ? obj.rotation : parseInt(obj.rotation);
        alignmentMode = 'rotate', isRotateMode = true;
      } else if (Array.isArray(alignmentMode) && alignmentMode.length) {
        hasPriorityOrder = true;
        alignmentMode.some(function (d) {
          if (d.indexOf('rotate') != -1) {
            alignmentMode = 'rotate';
            isRotateMode = true;
            var rotationExtract = /\(([^)]+)\)/.exec(d);
            rotation = 'auto';
            hasDefinedAutoRotation = rotationExtract;
            autoRotation = rotationExtract ? parseInt(rotationExtract[1]) : autoRotation;
            return true;
          }
        });
      } else if (!defined(obj.alignMode)) {
        alignmentMode = 'rotate(0)', isRotateMode = true;
      }
      return {
        tickAlignmentMode: alignmentMode,
        tickRotateMode: isRotateMode,
        rotation: rotation,
        hasPriorityOrder: hasPriorityOrder,
        hasDefinedAutoRotation: hasDefinedAutoRotation,
        tickAutoRotation: autoRotation
      };
    }

    function needTickAutoRotate(chartObj, type, order, rotationConfig) {
      var isBranchAxisType;
      if (chartObj.dataObject.categoryHierarchy && type == 'x') {
        isBranchAxisType = isBranchAxis(type, order, chartObj);
      }
      return rotationConfig == 'auto' && !isBranchAxisType;
    }

    function _autoRotation(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,config = helpers.config,
        tickConfig = config.ticklabel,
        rotationConfig = _tickRotation(tickConfig),
        tickRotateMode = rotationConfig.isRotateMode,
        tickRotation = rotationConfig.rotation,
        tickAutoRotation = rotationConfig.tickAutoRotation,
        hasDefinedAutoRotation = rotationConfig.hasDefinedAutoRotation,
        isAutoRotation = needTickAutoRotate(chart, type, order, tickRotation),
        categoryHierarchy = chart.dataObject.categoryHierarchy,
        isBranchAxisType = isCategoryHierarchical(chart) ? isBranchAxis(type, order, chart) : type == 'x' && order > 0,
        rotation = isBranchAxisType ? 0 : tickRotation,
        tickAlignmentMode = rotationConfig.alignmentMode,
        hasTickAlignmentPriority = rotationConfig.hasPriorityOrder;

      if (!isAutoRotation) {
        if (rotation < 0) {
          rotation = 360 - mathAbs(rotation);
        } else if (rotation >= 360) {
          rotation = mathAbs(rotation) % 360;
        }
      }
      if (tickAutoRotation) {
        if (
        categoryHierarchy && type == 'x' && !isBranchAxisType && hasBranchAxis(type, helpers.chart) ||
        !categoryHierarchy && type == 'x' && helpers.chart.axes.x.count > 1)
        {
          tickAutoRotation = 90;
        } else {
          if (tickAutoRotation < 0) {
            tickAutoRotation = 360 - mathAbs(tickAutoRotation);
          } else if (tickAutoRotation > 360) {
            tickAutoRotation = mathAbs(tickAutoRotation) % 360;
          }
        }
      }
      rotationConfig.rotation = rotation;
      rotationConfig.tickAutoRotation = tickAutoRotation;
      return rotationConfig;
    }

    function getScaleForTicks(helpers, extent) {
      var chart = helpers.chart,type = helpers.type,_order = helpers._order,plotRect = helpers.plotRect,
        hierarchical = chart.dataObject.hierarchical,



        scale1 = scale.getScale(chart, chart.dataObject, plotRect, helpers.orient, _order, chart.dataset, type, extent);
      if (chart.dataObject.categoryHierarchy) {
        reConstructPivotScale(scale1, helpers);
      }
      return scale1;
    }

    function reConstructPivotScale(scale, helpers) {
      var chart = helpers.chart,type = helpers.type,order = helpers.order,
        hierarchical = chart.dataObject.hierarchical;
      var rowList = hierarchical.pivotLayout.getRootNodeList('row'),
        columnList = hierarchical.pivotLayout.getRootNodeList('column'),
        rowCount = rowList.getCount(),
        hasMultiCluster = rowList.hasMultiCluster(),
        leafSize = rowList.leafSize,
        axisOrder = getLeafAxisOrder(helpers.axisOrder || 0, null, 'y', chart),
        axis_data = chart.systemConf.chart.axes.yaxis[axisOrder],
        hasSplitLeavesColumns = chart.systemConf.chart.axes.xaxis.splitLeaves;
      if (hasMultiCluster && type == 'y') {
        if (rowCount) {
          var parentLeafRowScale = chart.axes.y.branches[0].scale;
          var rangeCopy = [
          parentLeafRowScale(helpers.axisOrder) + parentLeafRowScale.discreteWidth(helpers.axisOrder),
          parentLeafRowScale(helpers.axisOrder)];

          if (chart.axes.rotated && !axis_data.reversed || !chart.axes.rotated && axis_data.reversed) {
            rangeCopy = rangeCopy.reverse();
          }
          return scale.copy().range(rangeCopy);
        } else {
          var rangeCopy = [helpers.axisOrder * leafSize + leafSize, helpers.axisOrder * leafSize];
          if (chart.axes.rotated) {
            rangeCopy = rangeCopy.reverse();
          }
          return scale.copy().range(rangeCopy);
        }
      } else if (type == 'x' && hasSplitLeavesColumns) {
        var rangeCopy = [helpers.axisOrder * columnList.leafSize, helpers.axisOrder * columnList.leafSize + columnList.leafSize];
        return scale.copy().range(rangeCopy);
      }
    }

    function _logDomain(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,column = helpers.column,config = helpers.config,
        dataObject = chart.dataObject,
        axisInfo = getAxisObject(chart, type, order);
      // clear the existing domain
      axisInfo.logDomain = null;
      var extent = type === 'x' && order === 0 ? chart.viewPortExtent : NULL$1,
        domain = defined(extent) ?
        extent :
        type === 'x' ?
        dataObject.getMinMaxX() :
        dataObject.getMinMaxY(order, UNDEFINED, chart.datalabels.hasFixedPosition);



      // #ZC2805 $domain changed to $dataMinMax
      var dataMinMax = type === 'x' ? dataObject.getMinMaxX(0) : dataObject.getMinMaxY(order, 0),
        addBaseline = !arrayIncludes(dataMinMax),
        domainCopy = dataMinMax.slice(0),
        usePadding = !(dataObject.isPercentChart || dataObject.hasLevelMarker || dataObject.isWaterfallEnabled),
        adjustToBase = null,
        yEncode = dataObject.getEncode('y', order);

      // FEATURES_LOGAXIS_45
      if (dataMinMax[0] === 0 && dataMinMax[1] === 0) {
        column.scaleType = null;
        domain = type === 'x' ? dataObject.getMinMaxX(0) : dataObject.getMinMaxY(order, UNDEFINED, chart.datalabels.hasFixedPosition);
        column.scaleType = LOG;
      }

      // type y case CXZA_LEGEND_26
      if (yEncode && _hasDefaultBase(yEncode, chart.dataObject, chart) && addBaseline && type === 'y' && !defined(config.minRange)) {
        adjustToBase = 0;
        domainCopy.push(0);
        domainCopy = d3_extent(domainCopy);
      }

      var logTickH = {
        dataMinMax: dataMinMax,
        usePadding: usePadding,
        axisObj: config,
        adjustToBase: adjustToBase,
        hasFixedPosition: chart.datalabels.hasFixedPosition,
        axisInfo: axisInfo,
        domainCopy: domainCopy,
        domain: domain
      };
      dataObject.logTickH = logTickH;
      return logTickH;
    }

    function pivot_checkers(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,
        dataObject = chart.dataObject,systemConf = chart.systemConf,
        hierarchical = dataObject.hierarchical;
      var _pivot_checkers = {
        isHierarchy: function isHierarchy() {
          var axesObj = chart.axes;
          return type == 'x' && axesObj.x.count > 1 || dataObject.categoryHierarchy && type == 'y' && axesObj.y.count > 1;
        },
        isHierarchialLevelType: function isHierarchialLevelType() {
          if (hierarchical) {
            var tag = type == 'x' ? 'column' : 'row',
              nodeList = hierarchical.pivotLayout.getRootNodeList(tag),
              branchCount = nodeList.getCount(),
              leavesCount = nodeList.getLeavesCount();

            //TODO need to use the above callback function
            var axesObj = chart.axes;
            var isHierarchy =
            type == 'x' && axesObj.x.count > 1 || dataObject.categoryHierarchy && type == 'y' && axesObj.y.count > 1;
            return (
              type == 'x' && isHierarchy && order > leavesCount - 1 ||
              type == 'y' && isHierarchy && branchCount && order > leavesCount - 1);

          }
        }
      };
      return _pivot_checkers;
    }

    function ticklabelGetter(helpers, _pivot_checkers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,
        dataObject = chart.dataObject,systemConf = chart.systemConf,
        hierarchical = dataObject.hierarchical;
      var _tick_getter = {
        getActualTicklabel: function getActualTicklabel(tickValueObj) {
          var a = tickValueObj,
            b = a.ticks,
            value;
          if (hierarchical && _pivot_checkers.isHierarchy() && !_pivot_checkers.isHierarchialLevelType() && a.tickValueIndices) {
            value = function value(i) {
              var includes = a.tickValueIndices.indexOf(i);
              if (includes != -1) {
                return b[includes];
              } else {
                return null;
              }
            };
          } else if (chart.dataObject.isWaterfallEnabled && a.tickValueIndices) {
            value = function value(i) {
              return b[i];
            };
          } else {
            value = function value(i) {
              return b[i];
            };
          }
          return value;
        },
        getTicksforAxisComp: function getTicksforAxisComp(tickValueObj) {
          var datatype = chart.dataset.getDataType(type, order);
          if (
          _pivot_checkers.isHierarchy(chart, type) &&
          chart.dataObject.hierarchical.categoryTree && (
          datatype == ORDINAL_DATATYPE &&
          type == 'x' &&
          !chart.dataObject.hierarchical.pivotLayout.columns.splitColumnLeaves ||
          datatype == 'ordinalNonLinear') ||
          hierarchical && _pivot_checkers.isHierarchialLevelType() && chart.dataObject.hierarchical.groupByTime)
          {
            return null; // To be handled in TickFormats. No need to filter ticks (for hierarchy and ordinal)
          } else if (chart.dataObject.isWaterfallEnabled && type == 'x') {
            return tickValueObj.tickValueIndices || null;
          } else {
            return tickValueObj.ticks;
          }
        }
      };
      return _tick_getter;
    }

    function tickParser(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,config = helpers.config,plotRect = helpers.plotRect,datatype = helpers.datatype,column = helpers.column,
        dataObject = chart.dataObject,dataset = chart.dataset,systemConf = chart.systemConf;

      var originalDataType = column.datatype,
        hierachical = dataObject.hierarchical,
        scaleType = column.scaleType,
        side = isRotatedChart(type, chart.axes.rotated) ? 'height' : 'width',
        maxTickSize = getMaxTickSize(config.ticklabel, plotRect),
        axisInfo = getAxisObject(chart, type, order);

      var _h = tick_parser_helpers(_objectSpread(_objectSpread({}, helpers), {}, { side: side }));

      return _h;
    }

    var tick_parser_helpers = function tick_parser_helpers(helpers) {
      var chart = helpers.chart,type = helpers.type,config = helpers.config,plotRect = helpers.plotRect,datatype = helpers.datatype,order = helpers.order,maxSize = helpers.maxSize,
        dataObject = chart.dataObject,dataset = chart.dataset,systemConf = chart.systemConf,
        processor = chart.dataObject,
        hierarchical = processor.hierarchical,
        oldTickInfo = _existingPrerenderComp(helpers),
        firstChartName = chart.chartTypes[0].name,
        commonPlotOptions = chart.systemConf.chart.plot.plotoptions[firstChartName],
        pivot_helpers,
        _pivot_checkers = pivot_checkers(helpers),
        _tick_getter = ticklabelGetter(helpers, _pivot_checkers);
      if (hierarchical) {
        pivot_helpers = pivot_tick_parser_helpers(helpers);
      }
      var tick_helpers = {
        domain: function domain() {return _domain(helpers);},
        scale: function scale(extent) {return _scale(helpers, null, extent);},
        simpleScale: function simpleScale() {return _scale(helpers, true);},
        size: function size() {return _size(helpers);},
        orient: function orient() {return _orient(helpers);},
        filter: function filter() {return helpers.chart.renderVisiblePointsOnly;},
        useTickAsIndices: hierarchical ? pivot_helpers.useTickAsIndices : datatype == ORDINAL_DATATYPE && processor.isWaterfallEnabled,
        styles: function styles() {return _styles(helpers);},
        rotation: function rotation() {return _autoRotation(helpers);},
        format: function format() {return _format$1(helpers);},
        formatter: function formatter() {return _formatter(helpers);},
        formatAccessor: _formatAccessor,
        side: function side() {return _side(chart, type);},
        groupby: function groupby() {return _hasGroupby(helpers);},
        maxSize: function maxSize() {return oldTickInfo ? oldTickInfo.maxTickSize : getMaxTickSize(config.ticklabel, plotRect);},
        autoScrollX: function autoScrollX() {return (
            (datatype == ORDINAL_DATATYPE || datatype == ORDINAL_NON_LINEAR_DATATYPE) && (
            systemConf.chart.width === 'auto' || systemConf.chart.height === 'auto'));},
        autoScrollY: function autoScrollY() {return (systemConf.chart.width === 'auto' || systemConf.chart.height === 'auto') && hierarchical && type == 'y';},
        chartPadding: function chartPadding() {return dataObject.isAxisCategory ? commonPlotOptions.padding || 0.2 : 0;},
        chartOuterPadding: function chartOuterPadding() {return dataObject.isAxisCategory ? commonPlotOptions.outerPadding || 0 : 0;},
        logTickH: function logTickH() {return _logDomain(helpers);},
        scrollThickness: function scrollThickness() {return getPropVal(chart.systemConf, 'chart.scroll.categoryThickness');},
        chartRect: function chartRect() {return chart.chartarea;},
        plotSize: function plotSize() {return _gridSize(helpers, true);},
        plotSize_no_zoom: function plotSize_no_zoom() {return _gridSize(helpers, false);},
        bzsEnabled: function bzsEnabled() {return _BZS(helpers);},
        filteredTickIndices: function filteredTickIndices(ticks) {return processor.isWaterfallEnabled && _existingScale(helpers) && isArray$1(ticks);},
        subFormatType: _subFormatType,
        margin: function margin() {return getMargin(config.ticklabel);},
        padding: function padding(margin) {return getTickPadding(helpers.orient, margin, isTickInnerOrient(config, type, chart));},
        getActualTicklabel: _tick_getter.getActualTicklabel,
        getTicksforAxisComp: _tick_getter.getTicksforAxisComp,
        isHierarchy: _pivot_checkers.isHierarchy,
        isHierarchialLevelType: _pivot_checkers.isHierarchialLevelType
      };
      return _objectSpread(_objectSpread({}, tick_helpers), pivot_helpers);
    };
    function _side(chart, type) {
      return isRotatedChart(type, chart.axes.rotated) ? 'height' : 'width';
    }

    function pivot_tick_parser_helpers(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,
        dataObject = chart.dataObject,systemConf = chart.systemConf;

      var processor = chart.dataObject,
        hierarchical = processor.hierarchical,
        isCategoryHierarchy = hierarchical && hierarchical.categoryTree,
        pLayout = hierarchical.pivotLayout,
        rowList = pLayout.getRootNodeList('row'),
        columnList = pLayout.getRootNodeList('column'),
        splitLeavesColumn = columnList.splitColumnLeaves;

      var pivot_tick_helpers = {
        useTickAsIndices: hierarchical.categoryTree && type == 'x' && !splitLeavesColumn && order == 0,
        autoScrollY: function autoScrollY() {
          var domainLength = rowList.count ? rowList.getDomainForBranch(0).length : 0;
          return (
            (systemConf.chart.width === 'auto' || systemConf.chart.height === 'auto') &&
            type == 'y' &&
            rowList.count &&
            order == domainLength - 1);

        },
        pivotLeafSize: function pivotLeafSize() {
          return { width: 0, height: rowList.leafSize };
        },
        pivotLeafCount: function pivotLeafCount() {return rowList.getLeavesCount();},
        isBranchType: function isBranchType() {return isCategoryHierarchy ? isBranchAxis(type, order, chart) : type == 'x' && order > 0;},
        isLeafType: function isLeafType() {
          var isBranchAxisType = isCategoryHierarchy ? isBranchAxis(type, order, chart) : type == 'x' && order > 0;
          return (
            isCategoryHierarchy && type == 'x' && !isBranchAxisType && hasBranchAxis(type, chart) ||
            !isCategoryHierarchy && type == 'x' && chart.axes.x.count > 1);

        }
      };
      return pivot_tick_helpers;
    }

    function _BZS(helpers) {
      var chart = helpers.chart,
        behaviours = getPropVal(chart, 'behaviouralEvents.eventManager.behaviours') || {},
        _brush_zoom_scroll_enabled = behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL;
      return _brush_zoom_scroll_enabled;
    }
    function _scale(helpers, simpleD3Mode, extent) {
      var chart = helpers.chart,type = helpers.type,order = helpers.order,column = helpers.column,
        axisInfo = getAxisObject(chart, type, order),
        behaviours = getPropVal(chart, 'behaviouralEvents.eventManager.behaviours') || {},
        scale;
      if (behaviours.PLOT_ZOOM || behaviours.PLOT_BRUSH || behaviours.CHART_SCROLL) {
        scale = axisInfo.scale;
      }
      if (!scale) {
        if (simpleD3Mode) {
          var scaleType = column.scaleType || 'linear';
          scale = getD3Scale(scaleType);
          scale.isD3 = true;
        } else {
          scale = getScaleForTicks(helpers, extent);
        }
      }
      return scale;
    }
    function _existingPrerenderComp(helpers) {
      return helpers.axisInfo.prerenderComp && helpers.axisInfo.prerenderComp.axisTicks.tickInfo;
    }
    function _existingScale(helpers) {
      var chart = helpers.chart,type = helpers.type,order = helpers.order,
        axisInfo = getAxisObject(chart, type, order),
        scale = axisInfo.scale;
      return scale;
    }

    function _orient() {}

    function _domain(helpers) {
      if (helpers.datatype == NUMERIC_DATATYPE || helpers.datatype == TIME_DATATYPE) {
        return _linearDomain(helpers);
      } else {
        return _ordinalDomain(helpers);
      }
    }

    function _size(helpers) {
      if (helpers.datatype == NUMERIC_DATATYPE) {
        return _numericSize(helpers);
      } else if (helpers.datatype == TIME_DATATYPE) {
        return _plotNPivotGridSize(helpers); //TODO code cleanup
      } else if (helpers.datatype == ORDINAL_DATATYPE || helpers.datatype == ORDINAL_NON_LINEAR_DATATYPE) {
        return _plotNPivotGridSize(helpers); //TODO code cleanup
      }
    }

    function _styles(helpers) {
      var tickConfig = helpers.config.ticklabel,
        systemConf = helpers.chart.systemConf;
      return {
        fontSize: parseFloat(utils.getVal(getValByPriority([tickConfig, systemConf.chart, systemConf.canvas, $ZCG], 'fontSize'))),
        fontFamily: utils.getVal(getValByPriority([tickConfig, systemConf.chart, systemConf.canvas, $ZCG], 'fontFamily'))
      };
    }

    function _hasGroupby(helpers) {
      var formatConfig = _format$1(helpers),
        hasTimeGroupBy =
        isArray$1(formatConfig.groupby) && formatConfig.groupby.length > 0 ||
        formatConfig.groupby === 'AUTO' && formatConfig.subfunction !== 'YEAR';

      if (hasTimeGroupBy && formatConfig.groupby === 'AUTO') {
        //#ZC1015
        formatConfig.AUTO_GROUP_ORDER = DataProcessor.HierarchicalTimeDataAdapter.getAutoGroupOrder(formatConfig.subfunction).reverse();
      }
      return hasTimeGroupBy;
    }

    function _format$1(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,column = helpers.column,
        isMergedAxis = hasMergedAxis(helpers),
        formatConfig = pick(isMergedAxis ? merged_axis_column_intersect(order, chart) : column[column.datatype], {});

      return formatConfig;
    }

    function _formatter(helpers) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,datatype = helpers.datatype;
      return type === 'y' && chart.dataObject.isPercentChart ? getFormattedValueByPercent : getFormattedValue;
    }

    function _formatAccessor(helpers, tickH) {
      var type = helpers.type,order = helpers.order,chart = helpers.chart,datatype = helpers.datatype,column = helpers.column,
        formatter = tickH.formatter,maxSize = tickH.maxSize,styles = tickH.styles,format = tickH.format,groupby = tickH.groupby,rotationConfig = tickH.rotationConfig,
        needTickConfigWrap = rotationConfig.tickAlignmentMode == 'wrapOnSpace' || rotationConfig.tickAlignmentMode == 'wrapAll',
        specifierIndex = groupby ? order : null;
      return function (value) {
        var formattedValue = formatter(format, value, column.datatype, chart, 'axis', null, null, specifierIndex);
        formattedValue = needTickConfigWrap ?
        formatTickWrapByMode(formattedValue, rotationConfig.tickAlignmentMode, maxSize.horizontal, maxSize.vertical, styles.fontSize) :
        formattedValue;
        return formattedValue;
      };
    }

    function _subFormatType(formatConfig, timeData) {
      var _subFormatType = formatConfig.subfunction;
      if (!defined(_subFormatType) || _subFormatType === 'AUTO') {
        // set sub function
        var info = getAutoTimeSubFunction(timeData);
        _subFormatType = formatConfig.subfunction = info.subFunction;
      }
      return _subFormatType;
    }

    AxisRegistry.add('tickH', tickParser);

    var axis_parser_helpers = function axis_parser_helpers(chart, config) {
      var processor = chart.dataObject,
        dataset = chart.dataset,
        rotated = chart.axes.rotated,
        hierarchical = processor.hierarchical,
        pivot_helpers;
      if (hierarchical) {
        pivot_helpers = pivot_axis_parser_helpers(chart);
      }

      var helpers = {
        order: function order(type, _order2) {
          if (hierarchical) {
            return pivot_helpers.order(type, _order2);
          }
          return _order2;
        },
        orient: function orient(type, order) {
          if (config.orient) {
            return config.orient;
          }
          if (hierarchical) {
            return pivot_helpers.orient(type, order);
          }
          if (type == 'x') {
            if (order == 0) {
              return rotated ? 'left' : 'bottom';
            } else {
              return rotated ? 'right' : 'top';
            }
          } else {
            if (order == 0) {
              return rotated ? 'bottom' : 'left';
            } else {
              return rotated ? 'top' : 'right';
            }
          }
        },
        datatype: function datatype(type, order) {return dataset.getDataType(type, order);},
        column: function column(type, order) {
          var columnIdx = dataset.getColumnIdx(type, order),
            columns = chart.dataSplicer.getColumns();
          return columns[columnIdx];
        },
        axisInfo: function axisInfo(type, order) {return getAxisObject(chart, type, order);},
        rotated: rotated
      };
      return helpers;
    };
    var pivot_axis_parser_helpers = function pivot_axis_parser_helpers(chart) {
      var processor = chart.dataObject,
        hierarchical = processor.hierarchical,
        isCategoryHierarchy = hierarchical && hierarchical.categoryTree,
        pLayout = hierarchical.pivotLayout,
        rowList = pLayout.getRootNodeList('row'),
        columnList = pLayout.getRootNodeList('column'),
        leavesCount = rowList.getLeavesCount(),
        clustersCount = rowList.getClustersCount(),
        splitLeavesColumn = columnList.splitColumnLeaves,
        hasRows = isCategoryHierarchy && hierarchical.hasRows(),
        rotated = chart.axes.rotated;

      var helpers = {
        order: function order(type, _order3) {
          return type == 'y' && isCategoryHierarchy ?
          rowList.hasMultiCluster() && _order3 < leavesCount ?
          _order3 % clustersCount :
          0 :
          _order3;
        },
        orient: function orient(type, order) {
          if (type == 'x') {
            return rotated ? 'left' : 'bottom';
          } else {
            if (order == 0 || hasRows) {
              return rotated ? 'bottom' : 'left';
            } else {
              return rotated ? 'top' : 'right';
            }
          }
        }
      };

      return helpers;
    };

    AxisRegistry.add('axisH', axis_parser_helpers);

    function axislabelParser(tickH) {
      var type = this.type,order = this.order,chart = this.chart,config = this.config,plotRect = this.plotRect,datatype = this.datatype,column = this.column,orient = this.orient,
        dataObject = chart.dataObject,dataset = chart.dataset,systemConf = chart.systemConf,
        axislabeldata = config.label;

      var axislabel_parser_helpers = function axislabel_parser_helpers() {
        var axislabel_helpers = {
          hideAxislabel: function hideAxislabel() {
            var intelligenceDim = chart.canvasarea[orient == 'bottom' || orient == 'top' ? 'height' : 'width'];
            // return;
            return (
              axislabeldata.show === false ||
              !defined(axislabeldata.text) ||
              axislabeldata.text === '' ||
              !dimension_based_intelligence(chart, "".concat(type, "axislabel"), intelligenceDim) ||
              tickH.isHierarchy() && !showAxisLabelForTree(type, order, chart) ||
              isFacet(chart) && // Pivot web chart: if no branches are there, hide the axis label
              dataObject.isPolarAxisCategory &&
              type == 'y' &&
              !dataObject.hierarchical.pivotLayout.getRootNodeList('row').branches.length);

          },
          axislabelData: function axislabelData() {
            var hierarchical = dataObject.hierarchical,
              isCategoryHierarchy = hierarchical && hierarchical.categoryTree;
            if (type == 'y' && isCategoryHierarchy) {
              var isBranchAxisType = isBranchAxis(type, order, chart);
              if (isBranchAxisType) {
                var branchLabel = {
                  label: {
                    text: column.columnname
                  }
                };
                return mergeJSON$1(config, branchLabel, true);
              }
            } else {
              return axislabeldata;
            }
          },
          margin: function margin() {return getMargin(config.label);},
          branchLabelData: function branchLabelData() {
            var hierarchical = dataObject.hierarchical;
            var branchLabelData;
            if (type == 'y' && hierarchical && hierarchical.categoryTree) {
              var isBranchAxisType = isBranchAxis(type, order, chart);
              if (isBranchAxisType) {
                var branchLabel = {
                  label: {
                    text: column.columnname
                  }
                };
                branchLabelData = mergeJSON$1(config, branchLabel, true);
              }
            }
            return branchLabelData || config;
          }
        };
        return axislabel_helpers;
      };
      return axislabel_parser_helpers();
    }

    AxisRegistry.add('axisTitleH', axislabelParser);

    //$Id$

    axis.ticks = function (chartObj, axisdata, type, axisorder, orient, plotarea) {
      var ticks = {};

      var dataObject = chartObj.dataObject,
        systemConf = chartObj.systemConf,
        container = chartObj.svg,
        tickvalues,
        intelligenceDim = chartObj.canvasarea[orient == 'bottom' || orient == 'top' ? 'height' : 'width'],
        minorTickValues;

      ticks.isHierarchy = isHierarchy, ticks.isHierarchialLevelType = isHierarchialLevelType;
      var datatype = chartObj.dataset.getDataType(type, axisorder),
        axisrotated = chartObj.axes.rotated;

      var axislabeldata = axisdata.label || {};
      var axisticklabeldata = axisdata.ticklabel || {};
      var axistickmarkdata = axisdata.tickmark || {};

      var ticklabelFontSize = parseFloat(
        utils.getVal(getValByPriority([axisticklabeldata, systemConf.chart, systemConf.canvas, $ZCG], 'fontSize'))),

        ticklabelFontFamily = utils.getVal(getValByPriority([axisticklabeldata, systemConf.chart, systemConf.canvas, $ZCG], 'fontFamily'));

      var rotation =
      axisticklabeldata != null && axisticklabeldata.rotation != null && axisticklabeldata.rotation != 'auto' ?
      axisticklabeldata.rotation :
      0;
      //For hierarchy only rotate 0 available
      if (isHierarchy()) {
        rotation = 0;
      }
      rotation = rotation == null || rotation == '' ? 0 : parseFloat(rotation);
      rotation = rotation < 0 ? 360 - mathAbs(rotation) : rotation;
      rotation = rotation > 360 ? mathAbs(rotation) % 360 : rotation;

      var hideAxisLabel =
      axislabeldata.show === false ||
      !defined(axislabeldata.text) ||
      axislabeldata.text === '' ||
      !dimension_based_intelligence(chartObj, "".concat(type, "axislabel"), intelligenceDim) ||
      isHierarchy() && !showAxisLabelForTree(type, axisorder, chartObj) ||
      isFacet(chartObj) && // Pivot web chart: if no branches are there, hide the axis label
      dataObject.isPolarAxisCategory &&
      type == 'y' &&
      !dataObject.hierarchical.pivotLayout.getRootNodeList('row').branches.length;

      var marginAxisLabel_right, marginAxisLabel_left, marginAxisLabel_bottom, marginAxisLabel_top;

      if (hideAxisLabel) {
        marginAxisLabel_right = marginAxisLabel_left = marginAxisLabel_bottom = marginAxisLabel_top = 0;
      } else {
        marginAxisLabel_top = pick(axislabeldata.marginTop, 5);
        marginAxisLabel_bottom = pick(axislabeldata.marginBottom, 5);
        marginAxisLabel_left = pick(axislabeldata.marginLeft, 5);
        marginAxisLabel_right = pick(axislabeldata.marginRight, 5);
      }

      var marginTickLabel = getMargin(axisticklabeldata);

      var metaData = chartObj.systemConf.metadata;
      var columnidx = chartObj.dataset.getColumnIdx(type, axisorder);
      var column = metaData.columns[columnidx];
      var dt = column.datatype;
      var metaConf = column[dt];
      var hierachical = dataObject.hierarchical;

      var isMergedAxis = type == 'y' && !hierachical ? metaData.axes.y[axisorder].length > 1 : false;
      var formatConf = metaConf;
      formatConf = isMergedAxis && type == 'y' ? merged_axis_column_intersect(axisorder, chartObj) : metaConf;

      this.preCalcAxisLen = 0;
      var tickmarkSize = pick(axistickmarkdata.size, 6);
      var branchLabelData;
      if (type == 'y' && hierachical && hierachical.categoryTree) {
        var isBranchAxisType = isBranchAxis(type, axisorder, chartObj);
        if (isBranchAxisType) {
          var branchLabel = {
            label: {
              text: column.columnname
            }
          };
          branchLabelData = mergeJSON$1(axisdata, branchLabel, true);
        }
      }

      ticks.preCalcApproxAxisLength = function (plotarea) {
        var extent = null;
        if (type === 'x' && axisorder === 0) {
          extent = chartObj.viewPortExtent;
        }

        /**
         * Calculating the tick values here
         *  TODO need to check
         */

        var axes = getAxisObject(chartObj, type, axisorder);

        var tickHelper = {
          axisRotated: axisrotated,
          axisOrder: axisorder,
          chart: chartObj,
          orient: orient
        };

        if (!axes.Ticks) {
          axes.Ticks = new axis.Ticks(type, axisdata, plotarea, tickHelper);
        }

        this.tickValueObj = ticks.getTickValues(plotarea.width, plotarea.height, extent, true, null, axes.Ticks, plotarea);

        // end calculating tick values

        var selector = type == 'x' ? "".concat(type, "-axis-").concat(axisorder) : "".concat(type, "-axis-").concat(axisorder);
        var axisG = chartObj.svg.selectAll("g.".concat(type, "-axis")),
          axisWrap = appendEle(axisG, 'g', [axisdata], '.', 'class', selector);

        var dummygroup = appendEle(axisWrap, 'g', [axisdata], '.', 'class', 'axisgroup');
        dummygroup.selectAll('line.majorTicks').style('display', '');

        // var dummygroup = container.append("g").attr("class","dummy").style("visibility","hidden");
        var axisarea = this.tickValueObj.axisgroup;
        var width = axisarea.width,
          height = axisarea.height,
          maxWidth = axisticklabeldata.maxWidth,
          maxHeight = axisticklabeldata.maxHeight;

        if ((orient === 'left' || orient === 'right') && defined(axisticklabeldata.width)) {
          width = perToPx(getPriorityValue(axisticklabeldata.width, maxWidth) || axis.ticks.maxTickSizeRatio_Hori, plotarea.width);
        } else if (defined(axisticklabeldata.height)) {
          height = perToPx(getPriorityValue(axisticklabeldata.height, maxHeight) || axis.ticks.maxTickSizeRatio_Vert, plotarea.height);
        }

        axisarea = this.preCalcTickLen = {
          x: axisarea.left,
          y: axisarea.top,
          width: width,
          height: height
        };

        var isHorizontal = type === 'x' && !axisrotated,
          isVertical = !isHorizontal;

        var axisLabelProperties = {
          systemConf: systemConf,
          bound: axisarea,
          horizontal: isHorizontal,
          vertical: isVertical,
          axisOrder: axisorder,
          plotRect: plotarea,
          hide: hideAxisLabel,
          tickObj: this.tickValueObj,
          type: type,
          chartObj: chartObj
        };

        /**
         * Adding the axis label here for the only first time. Next time just calls the transform method.
         */
        var axisSize = 0;
        var axisdata_merged = branchLabelData || axisdata;
        if (axes.axisLabel && axes.axisLabel.order == axisorder) {
          var axisAreaDim = getAxisAreaDim(type, axisorder, orient, chartObj, plotarea);
          axes.axisLabel.show = !hideAxisLabel;
          axes.axisLabel.transformLabel(axisarea, axisAreaDim, orient);
        } else {
          axes.axisLabel = new axis.AxisLabel(axisdata_merged, axisLabelProperties, orient, axisWrap);
        }

        if (!hideAxisLabel) {
          axisSize = axes.axisLabel.getBBox().height;
          switch (orient) {
            case 'left':{
                var width_new = this.tickValueObj.inlineToPlot ?
                0 :
                this.tickValueObj.isInline ?
                axisarea.width :
                axisarea.width + marginTickLabel.left;
                this.preCalcAxisLen = width_new + marginAxisLabel_right + axisSize + marginAxisLabel_left;
                break;
              }
            case 'right':{
                var width_new = this.tickValueObj.inlineToPlot ?
                0 :
                this.tickValueObj.isInline ?
                axisarea.width :
                axisarea.width + marginTickLabel.right;
                this.preCalcAxisLen = width_new + marginAxisLabel_left + axisSize + marginAxisLabel_right;
                break;
              }
            case 'bottom':{
                var height_new = this.tickValueObj.inlineToPlot ?
                0 :
                this.tickValueObj.isInline ?
                axisarea.height :
                axisarea.height + marginTickLabel.bottom;
                this.preCalcAxisLen = height_new + marginAxisLabel_bottom + axisSize + marginAxisLabel_top;
                break;
              }
            case 'top':{
                var height_new = this.tickValueObj.inlineToPlot ?
                0 :
                this.tickValueObj.isInline ?
                axisarea.height :
                axisarea.height + marginTickLabel.top;
                this.preCalcAxisLen = height_new + marginAxisLabel_top + axisSize + marginAxisLabel_bottom;
                break;
              }}

        } else {
          this.preCalcAxisLen =
          orient === 'bottom' || orient == 'top' ? axisarea.height + marginTickLabel.bottom : axisarea.width + marginTickLabel.left;
        }
        // dummygroup.remove()
        return this.preCalcAxisLen;
      };

      ticks.getTickValues = function (width, height, zmInterval, isPreCalc, tickcount, Ticks, newPlotArea) {
        var tickValueObj = {};

        var tickHelper = {
          axisRotated: axisrotated,
          axisOrder: axisorder,
          chart: chartObj,
          orient: orient,
          extent: zmInterval,
          maxTickSize: this.tickValueObj ? this.tickValueObj.maxTickSize : null
        };

        var tickValuesInfo = Ticks.getTicks(plotarea, tickcount, tickHelper),
          useHTML = defined(axisticklabeldata.showAs);
        rotation = isNaN(tickValuesInfo.rotation) ? rotation : tickValuesInfo.rotation;
        var prop = tickValuesInfo.tickMargin,
          marginInfo = getTickPadding(orient, marginTickLabel, isTickInnerOrient(axisdata, type, chartObj)),
          rotationInfo = getTickRotateInfo(orient, rotation, null, null, tickmarkSize, marginInfo, this.tickValueObj),
          x = orient === 'left' || orient === 'right' ? 'x' : 'y',
          rotateIndex = orient === 'left' || orient === 'right' ? 1 : 2;
        prop[x] +=
        this.tickValueObj && this.tickValueObj.isInline && !this.tickValueObj.inlineToPlot ? rotationInfo.rotate[rotateIndex] : 0; //prop.x contains only tickmark padding. so update long ticksize value with tickmarksize in prop.x
        prop.dy = rotationInfo.dy;
        rotationInfo.rotate[rotateIndex] = prop[x]; //assign the same to rotate info
        datatype = chartObj.dataset.getDataType(type, axisorder);
        var plotArea = pick(newPlotArea, plotarea);
        var dummygroup = container.append('g').attr('class', 'dummy'),
          left = orient == 'right' ? plotArea.left + plotArea.width : plotArea.left,
          top = orient == 'bottom' ? plotArea.top + plotArea.height : plotArea.top;

        dummygroup.attr('transform', "translate(".concat(left, ",").concat(top, ")"));

        var tickgroup = dummygroup.append('g').attr('class', 'tick');
        var dummyBox = calcDummyTextBox(tickgroup, tickValuesInfo.longestTickValue.formattedVal, prop, rotation, useHTML, tickValuesInfo);
        dummyBox.call(function (selection) {
          tickValueObj = getPreciseLongTickSize(
          plotArea,
          selection,
          dummygroup,
          tickgroup,
          tickValuesInfo,
          defined(tickcount),
          useHTML,
          rotationInfo);

        });

        dummygroup.remove();
        return tickValueObj;
      };

      ticks.getActualTicklabel = function () {
        var a = this.tickValueObj,
          b = a.ticks,
          value;
        if (this.isHierarchy() && !this.isHierarchialLevelType() && a.tickValueIndices) {
          value = function value(i) {
            var includes = a.tickValueIndices.indexOf(i);
            if (includes != -1) {
              return b[includes];
            } else {
              return null;
            }
          };
        } else if (chartObj.dataObject.isWaterfallEnabled && a.tickValueIndices) {
          value = function value(i) {
            return b[i];
          };
        } else {
          value = function value(i) {
            return b[i];
          };
        }
        return value;
      };

      ticks.getTicksforAxisComp = function () {
        var datatype = chartObj.dataset.getDataType(type, axisorder);
        if (
        isHierarchy(chartObj, type) &&
        chartObj.dataObject.hierarchical.categoryTree && (
        datatype == ORDINAL_DATATYPE && type == 'x' && !chartObj.dataObject.hierarchical.pivotLayout.columns.splitColumnLeaves ||
        datatype == 'ordinalNonLinear') ||
        isHierarchialLevelType() && chartObj.dataObject.hierarchical.groupByTime)
        {
          return null; // To be handled in TickFormats. No need to filter ticks (for hierarchy and ordinal)
        } else if (chartObj.dataObject.isWaterfallEnabled && type == 'x') {
          return this.tickValueObj.tickValueIndices || null;
        } else {
          return this.tickValueObj.ticks;
        }
      };

      function isHierarchialLevelType() {
        var hierarchical = chartObj.dataObject.hierarchical;

        if (hierarchical) {
          var tag = type == 'x' ? 'column' : 'row',
            nodeList = hierarchical.pivotLayout.getRootNodeList(tag),
            branchCount = nodeList.getCount(),
            leavesCount = nodeList.getLeavesCount();
          return (
            type == 'x' && isHierarchy() && axisorder > leavesCount - 1 ||
            type == 'y' && isHierarchy() && branchCount && axisorder > leavesCount - 1);

        }
      }

      function isHierarchy() {
        var axesObj = chartObj.axes;
        return type == 'x' && axesObj.x.count > 1 || dataObject.categoryHierarchy && type == 'y' && axesObj.y.count > 1;
      }

      function getCustomTickContent(actualTickGroup) {
        var tspan = actualTickGroup.
          selectAll('text.dummyText').
          selectAll('tspan').
          nodes(),
          image = actualTickGroup.
          selectAll('g.image').
          selectAll('image', 'img').
          nodes(),
          childArray = [];

        if (tspan && tspan.length) {
          tspan.forEach(function (d) {
            childArray.push(d.outerHTML);
          });
        }
        if (image && image.length) {
          image.forEach(function (d) {
            childArray.push(d.outerHTML);
          });
        }
        return childArray;
      }
      function getPreciseLongTickSize(plotarea, dummyText, dummygroup, tickgroup, tickValuesInfo, iswebChart, useHTML, rotationInfo) {
        var tickValueObj;

        var refContainer = dummyText;
        var hasTimeAutoFormat = datatype === TIME_DATATYPE && hasAutoFormat(formatConf);

        var tickvalues_formatted = tickValuesInfo.formatterTickValues;
        tickvalues = tickValuesInfo.rawTickValues;
        minorTickValues = tickValuesInfo.minorTickValues;
        var longtick = tickValuesInfo.longestTickValue,
          maxTickSize = tickValuesInfo.maxTickSize,
          tickValueIndices = tickValuesInfo.tickValueIndices,
          scaleObj = tickValuesInfo.scale;

        // custom tick values.
        var customTickStyles, customTickValues;
        if (defined(tickValuesInfo.customTickInfo) && tickValuesInfo.customTickInfo.length) {
          customTickStyles = tickValuesInfo.customTickInfo.styles;
          customTickValues = tickValuesInfo.customTickInfo.userRawTicks;
        }

        var tickvalues_SortedIndex = sortByIndices(tickvalues_formatted);

        var textWidth = function textWidth(text, index) {
          var style, dimension;
          if (defined(customTickStyles)) {
            style = customTickStyles[index];
          }

          dimension = getTextBound(text, ticklabelFontSize, ticklabelFontFamily, style);

          if (useHTML) {
            return dimension.width * dimension.height;
          }

          return orient == 'left' || orient == 'right' ? dimension.width : dimension.width * dimension.height;
        };
        if (useHTML) {
          //Need to sort the ticklabels by finding text width
          var formattedCustomTickValuesSize = tickvalues_formatted.map(function (d, i) {
            return textWidth(d, i);
          });
          tickvalues_SortedIndex = sortByIndices(formattedCustomTickValuesSize, 'integer');
        }

        if (!iswebChart) {
          var plotWidth = getPlotSize(chartObj, 'width', plotarea),
            plotHeight = getPlotSize(chartObj, 'height', plotarea);

          dummygroup.
          append('line').
          attr('class', 'domain').
          attrs({
            x1: 0,
            y1: 0,
            x2: orient == 'bottom' || orient == 'top' ? plotWidth : 0.0001, // phantomjs 1.9.8 issue
            y2: orient == 'bottom' || orient == 'top' ? 0.0001 : plotHeight // // phantomjs 1.9.8 issue
          }).
          style('stroke', 'black');

          var overflow = axisticklabeldata.textOverflow == NONE ? '' : axisticklabeldata.textOverflow;
          var isFinalLongtick = false;
          var co = -1,
            sortIdx; // dummyText content has been changed if the ticklabels are filtered and the already defined maxTick is also filtered
          var tempLongtick = longtick.actualVal,
            tempFormattedLongTick = longtick.formattedVal,
            tempFormattedLongTickHTML = tempFormattedLongTick;

          if (useHTML) {
            tempFormattedLongTick = getCurrentCustomTick(tickValuesInfo.longestTickValue, null, tickValuesInfo);
            tempFormattedLongTickHTML = getCustomTickContent(tickgroup);
          }

          wrapTextContent(dummyText, tempFormattedLongTick, null, useHTML);

          // var rotationInfo = getTickRotateInfo(orient, rotation, dummyText, null, tickmarkSize, marginInfo);
          tickRotate(dummyText, rotationInfo, tickValuesInfo);
          var pos = (scaleObj(tempLongtick) || 0) + (scaleObj.bandwidth && !scaleObj.discreteWidth ? scaleObj.bandwidth() / 2 : 0); //scale(tempLongtick) || 0 (Test_496.json)
          pos = orient == 'bottom' || orient == 'top' ? "".concat(pos, ",0") : "0,".concat(pos);
          tickgroup.attr('transform', "translate(".concat(pos, ")"));

          handleOverflowTicks(
          dummyText,
          orient,
          {
            svg: chartObj.svg,
            canvasarea: chartObj.canvasarea,
            plotarea: plotarea,
            chartarea: chartObj.chartarea,
            legendarea: chartObj.legendarea,
            actChartObj: chartObj
          },
          rotation,
          overflow,
          scaleObj,
          dummygroup,
          null,
          'ticklabel',
          axisticklabeldata,
          axisorder);


          var curTick, maxTick, nextTick;
          var curIdx, maxIdx;
          //Initialize curtick,maxtick
          maxTick = curTick = useHTML ? getCustomTickContent(tickgroup) : getTextContent(dummyText); //(hasTimeAutoFormat ? tempLongtick : longtick.formattedVal)
          //Initialize curtick,maxtick indices
          curIdx = maxIdx = tickvalues_SortedIndex[co];
          var currentTextContent,
            maxTextContent = getTextContent(dummyText);
          while (datatype != 'ordinalNonLinear' && !isFinalLongtick && co < tickvalues.length) {
            co = co + 1;
            sortIdx = tickvalues_SortedIndex[co];
            var pos = (scaleObj(tempLongtick) || 0) + (scaleObj.bandwidth == null ? 0 : scaleObj.bandwidth() / 2);
            pos = orient == 'bottom' || orient == 'top' ? "".concat(pos, ",0") : "0,".concat(pos);
            tickgroup.attr('transform', "translate(".concat(pos, ")"));
            handleOverflowTicks(
            dummyText,
            orient,
            {
              svg: chartObj.svg,
              canvasarea: chartObj.canvasarea,
              plotarea: plotarea,
              chartarea: chartObj.chartarea,
              legendarea: chartObj.legendarea,
              actChartObj: chartObj
            },
            rotation,
            overflow,
            scaleObj,
            dummygroup,
            null,
            'ticklabel',
            axisticklabeldata,
            axisorder);
            // Test_462.json

            //Updating maxLength Tick which is longest tick after handle overflow //ZR506
            curTick = useHTML ? getCustomTickContent(tickgroup) : getTextContent(dummyText);
            currentTextContent = getTextContent(dummyText);
            //compare maxtick with curtick
            if (textWidth(currentTextContent, curIdx) > textWidth(maxTextContent, maxIdx)) {
              tempFormattedLongTick = curTick;
              if (useHTML) {
                // tempFormattedLongTick = getCurrentCustomTick(null, sortIdx, tickValuesInfo);
                //update custom tick html content here (updated saved custom tick value while changine next tick)
                tempFormattedLongTickHTML = getCustomTickContent(tickgroup);
              }
              maxTick = tempFormattedLongTick;
              maxIdx = sortIdx;
              maxTextContent = currentTextContent;
            }
            //Apply maxtick to refgroup
            wrapTextContent(dummyText, maxTick, null, useHTML);

            //check overflow and next tick
            var isLastTick = !tickvalues.length || co === tickvalues.length - 1 || tickvalues.length === 1;
            nextTick = isLastTick ? null : hasTimeAutoFormat ? tickvalues_formatted[sortIdx] : tickvalues_formatted[sortIdx] || '';

            var isoverflow = isLastTick ? false : textWidth(currentTextContent, curIdx) < textWidth(nextTick, sortIdx);

            //set next tick to refgroup
            if (isoverflow) {
              tempLongtick = tickvalues[sortIdx]; //ZC2005
              curTick = nextTick;
              curIdx = sortIdx;
              tempFormattedLongTick = nextTick;
              if (useHTML) {
                //update custom tick value while changine next tick here
                tempFormattedLongTick = getCurrentCustomTick(null, sortIdx, tickValuesInfo);
                // tempFormattedLongTick = getCustomTickContent(tickgroup);
              }
              wrapTextContent(dummyText, tempFormattedLongTick, null, useHTML);
            } else {
              isFinalLongtick = true;
            }
          }
        }

        var referenceLongTickSize = refContainer.node().getBoundingClientRect();
        var refAxisgroupSize = dummygroup.node().getBoundingClientRect();
        // var isInline = tickValuesInfo.mode == 'inline' && !tickValuesInfo.inlineToPlot,
        //     w = orient === "left" || orient === "right" ? "width" : "height";
        // chartObj.tickarea[orient] = (isInline) ? refAxisgroupSize[w] : 0;
        tickValueObj = {
          ticks: tickvalues,
          minorTickValues: minorTickValues,
          rotation: rotation,
          longTickSize: referenceLongTickSize,
          longtick: longtick,
          axisgroup: refAxisgroupSize,
          customTicks: customTickValues,
          mode: tickValuesInfo.mode,
          isInline: tickValuesInfo.isInline,
          inlineToPlot: tickValuesInfo.inlineToPlot,
          maxTickSize: maxTickSize,
          showGrid: axisdata.grid.show && axisdata.grid.color != TRANSPARENT
        };
        if (tickValueIndices) {
          tickValueObj.tickValueIndices = tickValueIndices;
        }
        return tickValueObj;
      }

      /**
       *
       * @param longTick
       * @param index
       * @param tickInfo
       */
      function getCurrentCustomTick(longTick, index, tickInfo) {
        return tickInfo.customTickInfo.userRawTicks[defined(index) ? index : longTick.index];
      }

      function calcDummyTextBox(g, text, prop, rotation, useHTML, tickValueInfo) {
        var dummyText = appendEle(g, 'text', [1], '.', 'class', 'dummyText');
        dummyText.
        attrs({
          x: prop.x || 0,
          y: prop.y || 0,
          dy: prop.dy || 0
        }).
        attr('transform', "rotate(".concat(rotation, " ").concat(prop.x, " ").concat(prop.y, ")")); //7-spacing bw tickmark anad ticklabel

        if (useHTML) {
          text = getCurrentCustomTick(tickValueInfo.longestTickValue, null, tickValueInfo);
        } else {
          dummyText.text(text);
        }

        wrapTextContent(dummyText, text, null, useHTML);
        applyFont(dummyText, [axisticklabeldata, systemConf.chart, systemConf.canvas, $ZCG]);
        return dummyText;
      }
      function tickRotate(ticklabels, rotationInfo, tickValuesInfo) {
        ticklabels.
        attrs({
          dy: tickValuesInfo.mode == 'zigzag' ? rotationInfo.dy1 || rotationInfo.dy : rotationInfo.dy,
          transform: "rotate(".concat(rotationInfo.rotate[0], " ").concat(rotationInfo.rotate[1], " ").concat(rotationInfo.rotate[2], ")")
        }).
        styles({
          'text-anchor': rotationInfo.textAnchor
        });
      }

      return ticks;
    };

    axis.ticks.maxTickSizeRatio_Vert = '50%';
    axis.ticks.maxTickSizeRatio_Hori = '50%';

    axis.constructTickObj = function (chartObj, chartWidth, chartHeight, orient, plotarea_approx, update) {
      /*
       constructing tick object for all axes which contains precalculated approximate axis area,tick values
       For calculating plot area precisely,first we are rendering left,right axes, for that we should have bottom axes area
       so we are pre calculating the left ,right axes area,From that we will get plotarea.width
       From plot area.width,we have calculate exact bottom axis area
       From exact bottom axis area, we will get plot area,height
       From plotarea.height,we will draw left right axes precisely
       Here wile calculating left/right axes, plotarea_approx is going to change
       But while calculating bottom axis exact plotarea height is going to change
       */
      var systemconf = chartObj.systemConf;

      var type,
        axisdata;

      type = orient == 'left' && chartObj.axes.rotated || orient == 'bottom' && !chartObj.axes.rotated ? 'x' : 'y';
      var axesCount = getAxesCount(chartObj, type, orient);

      var processor = chartObj.dataObject,
        hierarchical = processor.hierarchical,
        categoryHierarchical = hierarchical && hierarchical.categoryTree,
        clustersCount,
        branchCount,
        leavesCount,
        hasMultiCluster,
        leafAxisArea;

      if (hierarchical) {
        var tag = type == 'x' ? 'column' : 'row',
          nodeList = hierarchical.pivotLayout.getRootNodeList(tag);
        branchCount = nodeList.getCount();
        clustersCount = nodeList.getClustersCount();
        leavesCount = nodeList.getLeavesCount();
        hasMultiCluster = nodeList.hasMultiCluster();
      }
      var scroll = chartObj.scroll,
        _scrollOrient = systemconf.chart && systemconf.chart.scroll && systemconf.chart.scroll.orient;
      if (_scrollOrient) {
        var axisType;
        if (chartObj.axes.rotated) {
          if (_scrollOrient === 'bottom' || _scrollOrient === 'top') {
            axisType = 'y';
          } else {
            axisType = 'x';
          }
        } else {
          if (_scrollOrient === 'bottom' || _scrollOrient === 'top') {
            axisType = 'x';
          } else {
            axisType = 'y';
          }
        }
        if (type === axisType && scroll) {
          scroll.initialize();
        }
      }

      for (var i = 0; i < axesCount; i++) {
        var yaxisData = systemconf.chart.axes.yaxis,
          isLeafAxisType,
          leafAxisOrder;
        if (type == 'y' && categoryHierarchical) {
          isLeafAxisType = isLeafAxis(type, i, chartObj);
          leafAxisOrder = getLeafAxisOrder(i, clustersCount);
        }
        var axisOrder_pivot = pick(leafAxisOrder, i);
        // if (i > 0 && type == 'y' && ((!hierarchical) || (hierarchical && i<hierarchical.leafRows.count))) {
        if (i > 0 && type == 'y' && (!hierarchical || hierarchical && isLeafAxisType)) {
          // axisdata = update &&  yaxisData[axisOrder_pivot].merged ? yaxisData[axisOrder_pivot] : mergeJSON(yaxisData[axisOrder_pivot], yaxisData[0], false);
          var isupdate = update && yaxisData[axisOrder_pivot].merged;
          axisdata = getAxisData(chartObj, 'y', i, !isupdate);
          var dt = yaxisData[axisOrder_pivot] != null && yaxisData[axisOrder_pivot] !== '' ? yaxisData[axisOrder_pivot] : {};
          axisdata.interval = dt.interval;
          axisdata.tickCount = dt.tickCount;
          axisdata.minRange = dt.minRange;
          axisdata.maxRange = dt.maxRange;
          axisdata.categories = dt.categories; //Test_523.json
          yaxisData[axisOrder_pivot] = axisdata;
          yaxisData[axisOrder_pivot].merged = true;
        }
        var isMultilevelX = type == 'x' && i > 0;
        var needMerge = (hierarchical || isMultilevelX) && isBranchAxis(type, i, chartObj) && !update;
        axisdata = getAxisData(chartObj, type, i, needMerge);
        // axisdata =
        //     type == 'x'
        //         ? systemconf.chart.axes.xaxis
        //         : hierarchical
        //         ? isLeafAxisType
        //             ? yaxisData[axisOrder_pivot]
        //             : yaxisData[0]
        //         : yaxisData[i];
        orient =
        axisdata.orient || (
        type == 'x' ?
        chartObj.axes.rotated ?
        'left' :
        'bottom' :
        chartObj.axes.rotated ?
        defined(hierarchical) ?
        'bottom' :
        i == 0 ?
        'bottom' :
        'top' :
        defined(hierarchical) ?
        'left' :
        i == 0 ?
        'left' :
        'right'); //TODO use common getAxisOrient Func
        var dim = orient == 'bottom' || orient == 'top' ? chartHeight : chartWidth;
        var axisShow = isAxisEnabled(axisdata, type, i, chartObj) && dimension_based_intelligence(chartObj, "".concat(type, "axis"), dim);

        if (axisShow) {
          // //TODO AXIS PARSER Make all as separate utils. becz future teams may nee this too
          var axis_helpers = {
            type: type,
            chart: chartObj,
            order: i,
            config: axisdata,
            plotRect: plotarea_approx,
            needCalcAxisG: true,
            prerender: true
          };
          // let axis_parser = new AxisParser(axis_helpers);

          var axisParser_helpers = axis_parser_helpers(chartObj, axisdata),
            parserH = {
              axisH: axisParser_helpers,
              tickH: tickParser,
              titleH: axislabelParser
            },
            cartesianAxisRegistry = AxisRegistry.get('cartesian.prerender'),
            axis_prerender = new cartesianAxisRegistry(axis_helpers, parserH);

          var axisView = getAxisViewModel(chartObj, type, orient, i);
          if (axis_prerender) {
            axis_prerender.axisView = axisView;
          }

          axis_prerender.preRender();
          var axisObj = getAxisObject(chartObj, type, i);
          axisObj.prerenderComp = axis_prerender;
          var tickH = axis_prerender.axisTicks.tickH;
          if (type == 'y' && !axisObj) {
            axisObj = {};
          }
          if (type == 'x' && !axisObj) {
            axisObj = i > 0 ? {} : axisObj;
          }

          var isInner = isTickInnerOrient(axisdata, type, chartObj),
            axisarea = 0,
            axisLabelEnabled = getPropVal(axisdata, 'label.show') === true;
          // axisObj.ticks = axis.ticks(chartObj, axisdata, type, i, orient, plotarea_approx);
          var tickObj = axisObj.ticks = {};

          tickObj.getActualTicklabel = tickH.getActualTicklabel;
          tickObj.getTicksforAxisComp = tickH.getTicksforAxisComp;
          tickObj.isHierarchy = tickH.isHierarchy;
          tickObj.isHierarchialLevelType = tickH.isHierarchialLevelType;
          /**
           * We do not subtract plot height if the axis is X and tick orient is set to `inner`
           */
          // #ZC2245
          if (!(isInner && type === 'x') || axisLabelEnabled) {
            // axisarea = axisObj.ticks.preCalcApproxAxisLength(plotarea_approx);
            var axisTicks = axis_prerender.axisTicks,axisTitle = axis_prerender.axisTitle;
            tickObj.tickValueObj = _objectSpread(_objectSpread(_objectSpread({}, axisTicks.tickInfo), axisTicks.precalculate), axisTitle.precalculate);
            tickObj.preCalcAxisLen = axisTitle.precalculate.preCalcAxisLen;
            axisarea = axisTitle.precalculate.preCalcAxisLen;
          }

          var ygroup = getAxisObject(chartObj, 'y', i);
          var hasMultiLeaves = chartObj.dataObject.hierarchical && (hasMultiCluster || branchCount),
            isLeafScale = hasMultiLeaves && i <= leavesCount - 1,
            isPreviousLeafScale = hasMultiLeaves && i <= leavesCount - 2;
          if (hasMultiLeaves && isLeafScale) {
            leafAxisArea = i == 0 ? axisarea : mathMax(leafAxisArea, axisarea);
            chartObj.axes[type].maxLeafAxisArea = leafAxisArea;
          } else {
            leafAxisArea = axisarea;
          }
          var _axisEvaluator = void 0;
          if (chartObj.viewFlow) {
            // let layout = getAxisLayout(orient);
            var axisParserObj = getAxisViewModel(chartObj, type, orient, i);
            _axisEvaluator = axisParserObj && axisParserObj.spec && axisParserObj.spec.evaluator;
          }
          if (_axisEvaluator) {
            _axisEvaluator.call(chartObj, plotarea_approx, leafAxisArea);
          } else if (!(type === 'y' && ygroup.disabled || isPreviousLeafScale)) {
            var plotarea = chartObj.plotarea;
            if (orient == 'left') {
              plotarea_approx.left += leafAxisArea;
              plotarea_approx.width = plotarea_approx.width - leafAxisArea;

              plotarea.left += leafAxisArea;
              plotarea.width -= leafAxisArea;
            } else if (orient == 'right') {
              plotarea_approx.width = plotarea_approx.width - leafAxisArea;

              plotarea.width = plotarea_approx.width;
            } else if (orient == 'bottom') {
              plotarea.height = plotarea.height - leafAxisArea;
              plotarea.bottom += leafAxisArea;

              plotarea_approx.height = plotarea.height;
              plotarea_approx.bottom += plotarea.bottom;
            } else if (orient == 'top') {
              plotarea.height = plotarea.height - leafAxisArea;
              plotarea.top += leafAxisArea;

              plotarea_approx.height = plotarea.height;
              plotarea_approx.top += plotarea.top;
            }
          }
        } else {
          // reset axis label and tick label
          var axes = type === 'y' ? chartObj.axes.y.groups[i] : chartObj.axes.x;
          if (axes) {
            axes.axisLabel = axes.Ticks = null;
          }
        }
      }

      if (type === 'y' && scroll && !_scrollOrient) {
        scroll.initialize();
      }
      if (_scrollOrient && scroll) {
        scroll.updatePositionScale();
      }
    };

    var getPriorityValue = function getPriorityValue(constant, max) {
      if (defined(constant) && defined(constant)) {
        return constant > max ? max : constant;
      } else {
        return constant || max;
      }
    };

    //$Id$

    axis.render = function (chartObj, chartWidth, chartHeight, update) {
      var systemconf = chartObj.systemConf,
        dataObject = chartObj.dataObject;
      var plotBorderDrawn = {
          left: false,
          right: false,
          top: false,
          bottom: false
        },
        wrap = chartObj.wrap,
        axes_animation_duration = get_animation_duration(),
        dataSplicer = chartObj.dataSplicer,
        metadata_axes = dataSplicer.getEncode(),
        metadata_columns = dataSplicer.getColumns(),
        yMajorTicksIndex = 0,
        xMajorTicksIndex = 0,
        // data processor helpers

        dataProcessorHelpers = DataProcessor.helpers,
        getParsedYAxisOrder = dataProcessorHelpers.getParsedYAxisOrder;

      chartObj.axes.animationDuration = axes_animation_duration;

      if (chartObj.legend.isSingleLayout) {
        // construct zscale
        chartObj.zscale = chartObj.dataObject.hasZaxis ? chartObj.scales[0].create() : null;
      }

      chartObj.datalabels.hasFixedPosition = chartObj.datalabels.moduleExists && hasFixedDatalabels(chartObj);
      chartObj.tickarea = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      /*
       construct ticks
       */
      //copy of plotarea
      var plotarea_approx = {
        left: chartObj.plotarea.left,
        top: chartObj.plotarea.top,
        width: chartObj.plotarea.width,
        height: chartObj.plotarea.height
      };

      if (chartObj.dataObject.hierarchical) {
        var defaultRefDim_row = chartObj.axes.rotated ? 'width' : 'height',
          customDim_row =
          chartObj.systemConf.chart[defaultRefDim_row] == 'auto' ?
          null :
          chartObj.systemConf.chart[defaultRefDim_row] || chartObj.plotarea[defaultRefDim_row],
          defaultRefDim_col = chartObj.axes.rotated ? 'height' : 'width',
          customDim_col =
          chartObj.systemConf.chart[defaultRefDim_col] == 'auto' ?
          null :
          chartObj.systemConf.chart[defaultRefDim_col] || chartObj.plotarea[defaultRefDim_col];
        chartObj.dataObject.hierarchical.pivotLayout.leafSize(customDim_row, customDim_col);
        // chartObj.dataObject.hierarchical.setLeafHeight();
        // if (!chartObj.axes.rotated) { // pivot12 - axisrotated throws error ZC2715
        scale.setRowScale(chartObj, 'row', true);
        // }
      }
      // if (chartObj.viewParser) {
      //
      // }
      axis.constructTickObj(chartObj, chartWidth, chartHeight, 'left', plotarea_approx, update);
      axis.constructTickObj(chartObj, chartWidth, chartHeight, 'bottom', plotarea_approx, update);

      clearCorrectionCache(chartObj);

      if (chartObj.dataObject.hierarchical) {
        var defaultRefDim_row = chartObj.axes.rotated ? 'width' : 'height',
          customDim_row =
          chartObj.systemConf.chart[defaultRefDim_row] == 'auto' ?
          null :
          chartObj.systemConf.chart[defaultRefDim_row] || chartObj.plotarea[defaultRefDim_row],
          defaultRefDim_col = chartObj.axes.rotated ? 'height' : 'width',
          customDim_col =
          chartObj.systemConf.chart[defaultRefDim_col] == 'auto' ?
          null :
          chartObj.systemConf.chart[defaultRefDim_col] || chartObj.plotarea[defaultRefDim_col];

        // chartObj.dataObject.hierarchical.findLabelWidth();
        chartObj.dataObject.hierarchical.pivotLayout.leafSize(customDim_row, customDim_col);

        // chartObj.dataObject.hierarchical.setLeafHeight();
        scale.setRowScale(chartObj, 'row', true);
      }

      if (chartObj.legend.isSingleLayout) {
        chartObj.zscale = chartObj.dataObject.hasZaxis ? chartObj.scales[0].create() : null;
      }

      rendererBoundUtils.updatePlotareaByBandWidth(chartObj, plotarea_approx);

      //Left
      var scale1 = scale.constructor(chartObj, 'left');
      var type1 = chartObj.axes.rotated ? 'x' : 'y';

      // type = (orient == 'left' && chartObj.axes.rotated) || (orient == 'bottom' && !chartObj.axes.rotated) ? 'x' : 'y';
      var axesCount1 = getAxesCount(chartObj, type1, 'left');
      for (var i = 0; i < axesCount1; i++) {
        var axis_left = createAxis('left', i);
        var axisModel = getAxisViewModel(chartObj, type1, 'left', i),
          scaleComp = scale1[i].scale;
        if (axisModel && axisModel.scale) {
          scaleComp = axisModel.scale.component;
          axisModel.scale.component.__type__ = "GOD";
        }
        axis_left = setAxisProp(scaleComp, 'left', i, update);
      }

      //Bottom
      var scale2 = scale.constructor(chartObj, 'bottom');
      var type2 = chartObj.axes.rotated ? 'y' : 'x';
      var axesCount2 = getAxesCount(chartObj, type2, 'bottom');
      for (var i = 0; i < axesCount2; i++) {
        var axis_bottom = createAxis('bottom', i);
        var _axisModel = getAxisViewModel(chartObj, type2, 'bottom', i),
          _scaleComp = scale2[i].scale;
        if (_axisModel && _axisModel.scale) {
          _scaleComp = _axisModel.scale.component;
        }
        axis_bottom = setAxisProp(_scaleComp, 'bottom', i, update);
      }
      //Todo need to check the order flow
      //draw axis at the end of creating axis prop
      for (var i = 0; i < scale1.length; i++) {
        var axisObj = getAxisObject(chartObj, type1, i);
        if (axisObj.component != null) {
          drawAxes(axisObj.component, i, type1, update);
        }
      }
      //draw axis at the end of creating axis prop
      for (var i = 0; i < scale2.length; i++) {
        var axisObj = getAxisObject(chartObj, type2, i);
        if (axisObj.component != null) {
          drawAxes(axisObj.component, i, type2, update);
        }
      }

      if (chartObj.dataset.getDataType('x') == ORDINAL_DATATYPE) {
        scale.barBandwidth(chartObj);
      }

      function get_animation_duration() {
        var axes_animation = systemconf.chart.axes.animation || {},
          enabled = axes_animation.enabled;

        if (!defined(enabled)) {
          var serdata =
          chartObj._isAxisCategory() || chartObj.isNonAxisMultiSeriesCategory ? chartObj.seriesdata : chartObj.seriesdata.slice(0, 1);
          enabled = serdata.some(function (d, i) {
            var type = chartObj.chartTypes[i].name;
            return getAnimationConf(systemconf.chart.plot.plotoptions[type], d.plotoptions, chartObj, type).enabled;
          });
        }

        return enabled ? pick(axes_animation.duration, 600) : 0;
      }
      //To bring axis line front
      function updateAxisLine(orient, axisdata, wrap, axisComp, isaxis, type, index) {
        // To bring axis line front, make plotarea border color as axis line color
        var plotBorderData = systemconf.chart.plot.border;

        var plotareaBorderEle = chartObj.staticPaneSVG.selectAll('g.plotareaBorder-property');
        var bkpInf = null;

        if (defined(plotBorderData) && plotBorderData.show === true) {
          chartObj.drawPlotBorder();
          wrap.selectAll('path.domain').style('stroke', TRANSPARENT);
        } else {
          var axislineData = axisdata.axisline;
          var axislineClr = axislineData.show == false || axislineData.color == null ? TRANSPARENT : axislineData.color;
          var axislineWidth = validateNullVal(axislineData.strokeWidth, 1);
          var axislineStyle = axislineData.style || 'solid';
          var isInline = isTickInnerOrient(axisdata, type, chartObj) && !axisComp.tickObj.tickValueObj.inlineToPlot;
          var tickLength = orient == 'left' || orient == 'right' ? axisComp.preCalcTickLen().width : axisComp.preCalcTickLen().height;
          var offset = isInline ? tickLength : 0;
          var axislineEle = appendEle(plotareaBorderEle, 'line', [1], '.', 'class', orient);

          if (isaxis == false || isAxisEnabled(axisdata, type, index, chartObj) == false || wrap.style('display') == NONE) {
            axislineEle.style('stroke', TRANSPARENT);
            return;
          }
          if (axislineData.zindex != 'back') {
            //=='front'
            var x1, x2, y1, y2;
            //0.5 correction for D3V4 translate
            if (orient == 'bottom') {
              x1 = -chartObj.tickarea.left,
              x2 = chartObj.plotarea.width + chartObj.tickarea.right,
              y1 = chartObj.plotarea.height + 0.5 + offset,
              y2 = chartObj.plotarea.height + 0.5 + offset;
            } else if (orient == 'left') {
              x1 = 0.5 - offset, x2 = 0.5 - offset, y1 = 0, y2 = chartObj.plotarea.height + chartObj.tickarea.bottom;
            } else if (orient == 'right') {
              x1 = chartObj.plotarea.width + 0.5 + offset,
              x2 = chartObj.plotarea.width + 0.5 + offset,
              y1 = 0,
              y2 = chartObj.plotarea.height + chartObj.tickarea.bottom;
            } else if (orient == 'top') {
              x1 = -chartObj.tickarea.left,
              x2 = chartObj.plotarea.width + chartObj.tickarea.right,
              y1 = 0.5 - offset,
              y2 = 0.5 - offset;
            }

            axislineEle.
            styles({
              'stroke-width': axislineWidth,
              stroke: axislineClr,
              'shape-rendering': 'crispedges',
              'stroke-dasharray': getDashArray(axislineStyle, axislineWidth)
            }).
            attrs({
              x1: x1,
              x2: x2,
              y1: y1,
              y2: y2
            });

            bkpInf = {
              size: axislineWidth,
              clr: axislineClr
            };
            plotareaBorderEle.node()["border-".concat(orient)] = bkpInf;

            wrap.selectAll('path.domain').style('stroke', TRANSPARENT);
          } else if (axislineData.zindex == 'back') {
            axislineEle.style('stroke', TRANSPARENT);
          }
        }
      }

      function getAxisOrient(data, type, index) {
        var orient = data.orient;
        var axesRotated = chartObj.axes.rotated,
          hierarchical = chartObj.dataObject.hierarchical,
          hasRows = chartObj.dataObject.categoryHierarchy && hierarchical.hasRows();
        if (orient) {
          return orient;
        } else if (type == 'x') {
          if (index == 0 || hierarchical) {
            orient = axesRotated ? 'left' : 'bottom';
          } else {
            orient = axesRotated ? 'right' : 'top';
          }
        } else {
          if (index == 0 || hasRows) {
            orient = axesRotated ? 'bottom' : 'left';
          } else {
            orient = axesRotated ? 'top' : 'right';
          }
        }
        return orient;
      }

      function createAxis(orient, index) {
        var axes = [];
        switch (orient) {
          case 'left':
            axes = chartObj.axes.rotated ? createAxisComp('x', index, orient) : createAxisComp('y', index, orient);
            break;
          case 'bottom':
            axes = chartObj.axes.rotated ? createAxisComp('y', index, orient) : createAxisComp('x', index, orient);
            break;}

        return axes;
      }

      function setAxisProp(scaleObj, orient, i, update) {
        var type = orient == 'left' ? chartObj.axes.rotated ? 'x' : 'y' : chartObj.axes.rotated ? 'y' : 'x';
        var axisObj = getAxisObject(chartObj, type, i);

        return setAxisCompConfig(axisObj, type, scaleObj, orient, i, update);
      }

      function createAxisComp(type, index, orient) {
        var axes = getAxisObject(chartObj, type, index),
          axisDataOrder = getAxisDataIndex('y', index, chartObj);
        var axis_data = getAxisData(chartObj, type, index);

        // first axis disabled. on redraw it is enabled
        var axisComp = axes.component;
        if (axisComp) {
          return axisComp;
        }

        var show = isAxisEnabled(axis_data, type, index, chartObj);
        axes.component =
        type == 'x' ?
        show && dimension_based_intelligence(chartObj, 'xaxis', chartHeight) ?
        axis.get() :
        null :
        show ?
        axis.get() :
        null;

        return axisComp;
      }

      function drawAxes(axisObj, index, type, update) {
        var axes = [];
        axes = drawAxisComp(axisObj, type, index, update);
        return axes;
      }

      function setAxisCompConfig(axis, type, scaleObj, orient, index, update) {
        var axisObj = axis.component,
          hierarchyObj = chartObj.dataObject.hierarchical,
          hierarchical = hierarchyObj && hierarchyObj.categoryTree,
          hasMultiCluster = hierarchical ? hierarchyObj.pivotLayout.getRootNodeList('row').hasMultiCluster() : false,
          hasRows,
          isLastLeafScale,
          axesObj = systemconf.chart.axes,
          axisdata = getAxisData(chartObj, type, index, false),
          // axisdata = type == 'x' ? axesObj.xaxis : axesObj.yaxis[getAxisDataIndex('y', index, chartObj)],
          orient = getAxisOrient(axisdata, type, index),
          dim = orient == 'bottom' || orient == 'top' ? chartHeight : chartWidth,
          isaxis = isAxisEnabled(axisdata, type, index, chartObj) === true && dimension_based_intelligence(chartObj, "".concat(type, "axis"), dim),
          ticklabelMargin = getMargin(axisdata.ticklabel),
          tickPadding = getTickPadding(orient, ticklabelMargin, isTickInnerOrient(axisdata, type, chartObj)),
          plotarea = chartObj.plotarea;

        if (hierarchical) {
          var leavesCount = hierarchyObj.pivotLayout.getRootNodeList('row').getLeavesCount();
          hasRows = hierarchical ? hierarchyObj.hasRows() : null, isLastLeafScale = hasRows && index == leavesCount - 1;
        }
        var ygroup = getAxisObject(chartObj, 'y', index);
        if (type === 'y' && (!isaxis || ygroup.disabled)) {
          yMajorTicksIndex++;
        }
        if (axisObj && !plotBorderDrawn[orient]) {
          var disabledYaxis = type === 'y' && ygroup.disabled;
          axisObj.plotBorderDrawn = !isaxis || disabledYaxis ? axisObj.plotBorderDrawn : true;
          plotBorderDrawn[orient] = axisObj.plotBorderDrawn;
        }

        // set it to the axis object
        axis.index = index;
        axis.reversed = axisdata.reversed;
        // clear zoom info before finding the base scale
        axis.baseScale = scale.getScale(chartObj, dataObject, plotarea, orient, index, chartObj.dataset, type, UNDEFINED, UNDEFINED, false);
        axis.scale.originalDomain = axis.baseScale.originalDomain;

        createZoomScale(axis, chartObj);
        applyZoomTransform(scaleObj, type, orient, axisdata.reversed, chartObj, axis);

        // #ZC2209
        scaleObj.ordinalRange = null;
        scaleObj.ordinalRange = getOrdinalRange(scaleObj);

        if (isaxis) {
          // if (1) {
          // //TODO AXIS PARSER Make all as separate utils. becz future teams may nee this too
          var axisObject = getAxisObject(chartObj, type, index),
            tickObj = axisObject.ticks,
            oldTickObj_preCalcAxisLen = tickObj.preCalcAxisLen,
            axis_prerender = axisObject.prerenderComp;
          axis_prerender.preRender(plotarea_approx);

          var axisTicks = axis_prerender.axisTicks,axisTitle = axis_prerender.axisTitle;
          tickObj.tickValueObj = _objectSpread(_objectSpread(_objectSpread({}, axisTicks.tickInfo), axisTicks.precalculate), axisTitle.precalculate);
          tickObj.preCalcAxisLen = axisTitle.precalculate.preCalcAxisLen;
          tickObj.preCalcTickLen = axisTicks.precalculate.preCalcTickLen;

          var yaxisComp = chartObj.axes.y.groups,
            oldAxisLen = hasRows ? chartObj.axes[type].maxLeafAxisArea : oldTickObj_preCalcAxisLen,
            preCalcTickLen = axisTicks.tickInfo.longTickSize,
            adjustVal = tickObj.preCalcAxisLen - oldAxisLen,
            tickValueObj = tickObj.tickValueObj,
            canProcessAdjustment = hasRows ? isLastLeafScale : true,
            selector = type == 'x' ? "".concat(type, "-axis-").concat(index) : "".concat(type, "-axis-").concat(index),
            axisWrap = appendEle(wrap.selectAll("g.".concat(type, "-axis")), 'g', isaxis ? [axisdata] : [], '.', 'class', selector);
          axisWrap.attr('filter', null); //reset filter attribute on redraw

          // LOGx
          if (isArray$1(axisObject.logDomain)) {
            scaleObj.domain(axisObject.logDomain);
          }

          if (mathAbs(adjustVal) > 1 && canProcessAdjustment) {
            adjustPlotarea(orient, adjustVal);
            plotarea_approx = chartObj.plotarea;
          }

          if (axisObj != null) {
            var isMergedAxis = type == 'y' && !hierarchical ? metadata_axes.y[index].length > 1 : false,
              hasTimegroupBy = tickObj && tickObj.isHierarchy() && chartObj.dataObject.hierarchical.groupByTime,
              columnidx = chartObj.dataset.getColumnIdx(type, hasTimegroupBy ? 0 : index), //column index should be 0 for multi level x axis
              columns = chartObj.dataSplicer.getColumns(),
              datatype = columns[columnidx].datatype;
            datatype =
            tickObj && tickObj.isHierarchialLevelType() && chartObj.dataObject.categoryHierarchy ? ORDINAL_DATATYPE : datatype;
            var formatConf = columns[columnidx][datatype];
            formatConf = isMergedAxis && type == 'y' ? merged_axis_column_intersect(index, chartObj) : formatConf;
            // formatConf.subfunction = axis_parser.subFormatType;
            var axisFormat = formatConf && (formatConf.axisformat || formatConf.format),
              tickSize = validateNullVal(axisdata.tickmark.size, 6),
              subTickSize = validateNullVal(axisdata.subtickmark.size, 6),
              formattingFunction = dataObject.isPercentChart && type == 'y' ? getFormattedValueByPercent : getFormattedValue,
              specifierIndex = hasTimegroupBy ? index : null,
              isMultiLineTick =
              !(tickObj && tickObj.isHierarchy()) &&
              formatConf &&
              axisFormat &&
              axisFormat.specifier &&
              axisFormat.specifier.constructor == Array ||
              tickValueObj.mode == 'wrapOnSpace' ||
              tickValueObj.mode == 'wrapAll';
            var isInline = tickValueObj.isInline && !tickValueObj.inlineToPlot,
              w = orient === 'left' || orient === 'right' ? 'width' : 'height';
            chartObj.tickarea[orient] =
            isInline && axisObj.plotBorderDrawn ? tickValueObj.axisgroup[w] : chartObj.tickarea[orient] || 0;
            axisObj.
            tickOrient(tickValueObj.isInline ? 'inner' : 'outer').
            orient(orient).
            scale(scaleObj).
            tickPadding(tickPadding).
            tickSize(tickSize).
            subTickSize(subTickSize).
            tickSizeOuter(0).
            majorTicks(
            index === (type === 'y' ? yMajorTicksIndex : xMajorTicksIndex) || hierarchical ?
            getMajorTicks(orient, type, tickValueObj, index) :
            null).

            plotarea(chartObj.plotarea).
            systemconf(chartObj.systemConf).
            tickRotation(tickValueObj.rotation).
            preCalcTickLen(tickObj.preCalcTickLen).
            chartObj(chartObj).
            columnIndices(isMergedAxis && type == 'y' ? metadata_axes.y[index] : [columnidx]).
            isMultiLineTick(isMultiLineTick).
            minorGrid(tickValueObj.minorTickValues);

            var format = formatConf != null ? formatConf.axisformat || formatConf.format : null;
            if (format && format.specifier == 'auto' && !scaleObj.bandwidth) {
              axisObj.tickValues(tickObj.getTicksforAxisComp(tickValueObj)).tickFormat(function (d, i) {
                var x = scaleObj,
                  formattedValue = x.tickFormat()(d);
                d3_select(this).text(formattedValue);
                this.formattedVal = formattedValue;
              });
            } else {
              axisObj.tickValues(tickObj.getTicksforAxisComp(tickValueObj));
              var tickPos = tickObj.getActualTicklabel(tickValueObj);
              var maxWidth = tickObj.tickValueObj.maxTickSize.horizontal,
                maxHeight = tickObj.tickValueObj.maxTickSize.vertical,
                fSize = utils.getVal(
                getValByPriority([axisdata.ticklabel, chartObj.systemConf.chart, chartObj.systemConf.canvas, $ZCG], 'fontSize')),

                needTickConfigWrap = tickObj.tickValueObj.mode == 'wrapOnSpace' || tickObj.tickValueObj.mode == 'wrapAll',
                isMultiLine = axisObj.isMultiLineTick(),
                isCustomLabel = defined(axisdata.ticklabel.showAs),
                args = [
                null,
                orient,
                chartObj,
                tickValueObj.rotation,
                axisdata.ticklabel.textOverflow,
                axisObj.scale(),
                axisWrap,
                axisObj,
                'ticklabel',
                axisdata.ticklabel,
                index],

                doOverflow = handleOverflowTicks.apply(null, args);
              var previousTick;
              var tickFormat = function tickFormat(d, i) {
                var tick = tickPos(i);
                var formattedValue = formattingFunction(formatConf, tick, datatype, chartObj, 'axis', null, null, specifierIndex);
                d3_select(this).text(formattedValue);
                this.formattedVal = formattedValue;
                var isLastTick = i == tickValueObj.ticks.length - 1;
                if (isMultiLine) {
                  if (needTickConfigWrap) {
                    formattedValue = formatTickWrapByMode(
                    formattedValue,
                    tickObj.tickValueObj.mode,
                    maxWidth,
                    maxHeight,
                    fSize);

                  }
                  wrapTextContent(d3_select(this), formattedValue, { orient: orient });
                } else if (isCustomLabel) {
                  if (defined(tickObj.tickValueObj.customTicks[i])) {
                    this.innerHTML = '';
                    wrapTextContent(d3_select(this), tickObj.tickValueObj.customTicks[i], null, true);
                    var textContent = getTextContent(d3_select(this));
                    this.formattedVal = isArray$1(textContent) ? textContent.join(' ') : textContent;
                  }
                }

                doOverflow(this, i);
                var minmaxlabels = axisdata.ticklabel.minmaxlabels,
                  continoustType =
                  (datatype == NUMERIC_DATATYPE || datatype == TIME_DATATYPE) && tickObj && !tickObj.isHierarchialLevelType();
                if (continoustType && minmaxlabels && minmaxlabels.show && !minmaxlabels.excludeIntervals) {
                  if (i == 1) {
                    if (doTicksOverlaps(previousTick, this, tickValueObj.rotation, orient)) {
                      this.style.display = 'none';
                    }
                  } else if (isLastTick) {
                    if (doTicksOverlaps(previousTick, this, tickValueObj.rotation, orient)) {
                      previousTick.style.display = 'none';
                    }
                  }
                }
                previousTick = this;
                // return formattedValue;
              };
              axisObj.tickFormat(tickFormat);
            }

            axisObj.tickObj = tickObj;
            axisObj.hideAxisLabel = !dimension_based_intelligence(chartObj, "".concat(type, "axislabel"), dim); //hide axislabel by intelligence
          }
        }

        return axisObj;
      }

      function drawAxisComp(axisComp, type, index, update) {
        var hierarchical = chartObj.dataObject.categoryHierarchy;
        var axesObj = systemconf.chart.axes,
          yaxisdataOrder = hierarchical ? getAxisDataIndex('y', index, chartObj) : index,
          axisdata = getAxisData(chartObj, type, index, false);
        // axisdata = type == 'x' ? axesObj.xaxis : axesObj.yaxis[yaxisdataOrder];
        var ticklabeldata = axisdata.ticklabel;
        var orient = getAxisOrient(axisdata, type, index);
        var dim = orient == 'bottom' || orient == 'top' ? chartHeight : chartWidth;
        var isaxis = isAxisEnabled(axisdata, type, index, chartObj) === true && dimension_based_intelligence(chartObj, "".concat(type, "axis"), dim);
        var selector = type == 'x' ? "".concat(type, "-axis-").concat(index) : "".concat(type, "-axis-").concat(index);
        var axisWrap = appendEle(wrap.selectAll("g.".concat(type, "-axis")), 'g', isaxis ? [axisdata] : [], '.', 'class', selector);
        var axisObj = getAxisObject(chartObj, type, index),
          axesCount = chartObj.axes[type].count;

        if (index > axesCount - 1) {
          appendEle(wrap.selectAll("g.".concat(type, "-axis")), 'g', [], '.', 'class', selector);
          if (axisComp.plotBorderDrawn == true) {
            updateAxisLine(orient, axisdata, axisWrap, axisComp, false, type, index);
          }
          return;
        }
        var ygroup = getAxisObject(chartObj, type, index);
        //call adjust wrap here, without considering isAxis show or not (For multiY axis - toggle show option)
        axisWrap.style('display', type === 'y' && ygroup.disabled ? NONE : null);

        var strictAdjust = !chartObj.dataObject.isAxisCategory && index === chartObj.axes[type].count - 1;
        if (type === 'x' && isaxis) {
          adjustXAxiswrap(axisdata, index, axisComp, true, strictAdjust);
        } else if (isaxis) {
          adjustYAxeswrap(axisdata, index, axisComp, strictAdjust, true);
        }

        if (isaxis) {
          var tickObj = axisObj.ticks.tickValueObj;
          chartObj.plotarea = axisComp.plotarea();

          axisWrap.
          transition().
          duration(axes_animation_duration).
          call(axisComp, type, index);

          if (type == 'y' && axisComp.plotBorderDrawn == true) {
            updateAxisLine(orient, axisdata, axisWrap, axisComp, isaxis, type, index);
          } else if (type == 'x' && doUpdateAxisLine(chartObj, type, index)) {
            updateAxisLine(orient, axisdata, axisWrap, axisComp, isaxis, type, index);
          }
        } else {
          if (axisComp.plotBorderDrawn == true) {
            updateAxisLine(orient, axisdata, axisWrap, axisComp, isaxis, type, index);
          }
        }

        //Initializing chart brush before drawing x axes
        // let scrollSettings = getPropVal(systemconf.chart, 'scroll') || {};
        //
        // //Initializing chart brush before pre rrendering X tick obj
        // if (type === 'y' && scrollSettings.enabled === true) {
        //     chartObj.scroll.setPosition(chartObj.plotarea);
        // }
      }

      function doUpdateAxisLine(chartObj, type, index) {
        var _hierarchical = chartObj.dataObject.hierarchical;

        if (_hierarchical && !chartObj.dataObject.isAxisCategory && !hasColorColumnInNonAxis(chartObj)) {
          var nodeList = _hierarchical.pivotLayout.getRootNodeList(type === 'x' ? 'column' : 'row');
          return index === nodeList.getLeavesCount();
        } else {
          return index === 0;
        }
      }

      function adjustXAxiswrap(data, index, axis_comp, isDraw, strictMode) {
        //need to change name axis_comp and axisComp - code modularization
        var usedAxisSpace = {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
        var axisCount = chartObj.axes.x.count;
        var hierarchical = chartObj.dataObject.categoryHierarchy,
          offset = 0;
        var hasMultiCluster, nodeListCount, leavesCount;
        if (hierarchical) {
          var pivotLayout = chartObj.dataObject.hierarchical.pivotLayout,
            nodeList = pivotLayout.getRootNodeList('column');
          nodeListCount = nodeList.getCount();
          hasMultiCluster = nodeList.hasMultiCluster();
          leavesCount = nodeList.getLeavesCount();
        }
        if (index == 0 || strictMode) {
          for (var i = 0; i < axisCount; i++) {
            var axisData = getAxisData(chartObj, 'x', i);

            if (isAxisEnabled(axisData, 'x', i, chartObj)) {
              var axisObj = getAxisObject(chartObj, 'x', i);
              var axisComp = axisObj.component;
              var xorient = axis_comp.orient();
              var xwrapboxWid = isDraw ?
              getTickLabelWidth(data.label, data.ticklabel, axisComp.preCalcTickLen(), chartObj, 'x', i, xorient) :
              axisComp.tickLabelWidth();
              var xwrap = wrap.selectAll(".x-axis-".concat(i));
              var isLeafScale = hierarchical && i < leavesCount - 1;
              var axisView = getAxisViewModel(chartObj, 'x', xorient, i);
              var transX =
              xorient == 'right' ?
              chartObj.plotarea.left + chartObj.plotarea.width + usedAxisSpace.right :
              chartObj.plotarea.left - usedAxisSpace.left;
              var transY =
              chartObj.axes.rotated || xorient == 'top' ?
              chartObj.plotarea.top - usedAxisSpace.top :
              chartObj.plotarea.top + chartObj.plotarea.height + usedAxisSpace[xorient];
              if (axisView && axisView.conf && axisView.conf.transform) {
                var transform = invokeFunction(axisView.conf.transform, [transX, transY], chartObj);
                transX = transform[0];
                transY = transform[1];
              } else {
                usedAxisSpace[xorient] += isLeafScale && i !== leavesCount - 1 ? 0 : xwrapboxWid;
              }

              xwrap.attr('transform', "translate(".concat(transX, ",").concat(transY, ")"));
              xwrap.attr('x', transX);
              xwrap.attr('y', transY);

              if (nodeListCount || hasMultiCluster) {
                if (i == 0) {
                  offset = xwrapboxWid;
                }

                if (nodeListCount && i > leavesCount - 1) {
                  if (axisComp.majorTicks()) {
                    //axisrotated case need to handle
                    var _attr7 = xorient == 'left' || xorient == 'right' ? 'x2' : 'y2',
                      sign = xorient === 'top' || xorient === 'left' ? 1 : -1;
                    axisComp.majorTicks()[_attr7] += sign * offset;
                    offset += xwrapboxWid;
                  }
                }
              }
            }
          }
          var xwrap = wrap.selectAll('g.x-axis-0');

          // if (chartObj.axes.rotated) {
          //     xwrap
          //         .selectAll("line.majorTicks")
          //         .attr("x2", chartObj.plotarea.width)
          // }
          // updateAxisLine(xorient, data, xwrap, axis);
        }
      }

      function adjustYAxeswrap(data, index, axis_comp, strictMode, isDraw) {
        var yaxisData = systemconf.chart.axes.yaxis,
          yaxesLength = chartObj.axes.y.count;
        var yaxis0_wrap = wrap.selectAll('.y-axis-0');
        var yaxis0_orient = yaxisData[0].orient || (chartObj.axes.rotated ? 'bottom' : yaxisData[0].orient || 'left');
        var hierarchical = chartObj.dataObject.categoryHierarchy;
        if (strictMode || index == 0) {
          var usedAxisSpace = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
          var offset = 0;
          for (var j = 0; j < yaxesLength; j++) {
            var axisData = getAxisData(chartObj, 'y', j),
              ydata = axisData,
              show = isAxisEnabled(axisData, 'y', j, chartObj);
            if (show) {
              var orient = ydata.orient;
              orient =
              orient || (
              chartObj.axes.rotated ?
              j == 0 || hierarchical ?
              'bottom' :
              'top' :
              ydata.orient != null ?
              ydata.orient :
              j == 0 || hierarchical ?
              'left' :
              'right'); //TODO use common getAxisOrient Func
              var dim = orient == 'bottom' || orient == 'top' ? chartHeight : chartWidth;
              var isaxis = show === true && dimension_based_intelligence(chartObj, 'y' + 'axis', dim);
              if (isaxis) {
                var axisView = getAxisViewModel(chartObj, 'y', orient, j);
                var _hasMultiCluster6 = void 0,nodeListCount = void 0,leavesCount = void 0;
                if (hierarchical) {
                  var pivotLayout = chartObj.dataObject.hierarchical.pivotLayout,
                    nodeList = pivotLayout.getRootNodeList('row');
                  nodeListCount = nodeList.getCount();
                  _hasMultiCluster6 = nodeList.hasMultiCluster();
                  leavesCount = nodeList.getLeavesCount();
                }
                var ygroup = getAxisObject(chartObj, 'y', j);
                // var ygroup = hierarchical && (hierarchical.pivotLayout.rows.getCount() || hierarchical.pivotLayout.rows.hasMultiCluster()) ? j >  chartObj.axes.y.leafScales.length-1 ? chartObj.axes.y.rowGrids[j-chartObj.axes.y.leafScales.length] : chartObj.axes.y.leafScales[j] : chartObj.axes.y.groups[j];
                var axisComp = ygroup.component;

                var isLeafScale = hierarchical && j < leavesCount - 1;

                var ywrap = wrap.selectAll(".y-axis-".concat(j));
                var disabled = ywrap.style('display') == NONE;
                var ywrapboxWid = disabled ?
                axisComp.tickLabelWidth() :
                getTickLabelWidth(ydata.label, ydata.ticklabel, axisComp.preCalcTickLen(), chartObj, 'y', j, orient);

                var translateX =
                  orient == 'bottom' || orient == 'top' ?
                  chartObj.plotarea.left :
                  orient === 'left' ?
                  chartObj.plotarea.left - usedAxisSpace[orient] :
                  chartObj.plotarea.left + chartObj.plotarea.width + usedAxisSpace[orient],
                  translateY =
                  orient == 'left' || orient == 'right' ?
                  chartObj.plotarea.top :
                  orient === 'bottom' ?
                  chartObj.plotarea.height + chartObj.plotarea.top + usedAxisSpace[orient] :
                  chartObj.plotarea.top - usedAxisSpace[orient];
                // if(isLeafScale && j > 0){
                //     translateY += chartObj.axes.y.leafScales[j-1].scale.range()[1];
                // }
                if (axisView && axisView.conf && axisView.conf.transform) {
                  var transform = invokeFunction(axisView.conf.transform, [translateX, translateY], chartObj);
                  translateX = transform[0];
                  translateY = transform[1];
                } else {
                  usedAxisSpace[orient] += ygroup.disabled || isLeafScale && j !== leavesCount - 1 ? 0 : ywrapboxWid;
                }


                ywrap.attr('transform', "translate(".concat(translateX, ",").concat(translateY, ")"));

                // handleOverflowTicks_init(ywrap, axisComp, chartObj, ydata, axisComp.orient());

                //Bringing Axis line to front
                if (axisComp && axisComp.plotBorderDrawn == true) {
                  updateAxisLine(orient, ydata, ywrap, axis_comp, 'y', j);
                }

                if (nodeListCount || _hasMultiCluster6) {
                  if (j == 0) {
                    offset = ywrapboxWid;
                  }

                  if (nodeListCount && j > leavesCount - 1) {
                    if (axisComp.majorTicks()) {
                      //axisrotated case need to handle
                      var _attr8 = orient == 'left' || orient == 'right' ? 'x2' : 'y2',
                        sign = orient === 'top' || orient === 'left' ? 1 : -1;
                      axisComp.majorTicks()[_attr8] += sign * offset;
                      offset += ywrapboxWid;
                    }
                  }
                }
              }
            }
          }

          !chartObj.axes.rotated ?
          yaxis0_wrap.
          selectAll('line.majorTicks').
          attr('x2', yaxis0_orient == 'right' ? -chartObj.plotarea.width : chartObj.plotarea.width) :
          null;
        }
      }

      function getTickLabelWidth(labeldata, ticklabeldata, preCalcTickLen, chartObj, type, axisOrder, orient) {
        var axisLabelMargin = {
            top: 0,
            right: 0,
            bottom: 5,
            left: 0
          },
          curTickLabelWidth = 0,
          labelSize = 0,
          axisObj = getAxisObject(chartObj, type, axisOrder),
          axisComp = axisObj.component,
          tickComp = axisObj.ticks;

        if (type === 'clr') {
          labelSize = 0;
        } else {
          labelSize = axisObj.axisLabel.getBBox().height;
        }
        var hideAxisLabel =
        axisComp.hideAxisLabel ||
        labeldata.show === false ||
        !defined(labeldata.text) ||
        labeldata.text === '' ||
        tickComp.isHierarchy() && !showAxisLabelForTree(type, axisOrder, chartObj);
        if (hideAxisLabel) {
          axisLabelMargin.top = axisLabelMargin.bottom = axisLabelMargin.left = axisLabelMargin.right = 0;
        } else {
          axisLabelMargin.top = pick(labeldata.marginTop, 5);
          axisLabelMargin.bottom = pick(labeldata.marginBottom, 5);
          axisLabelMargin.left = pick(labeldata.marginLeft, 5);
          axisLabelMargin.right = pick(labeldata.marginRight, 5);
        }

        var marginTickLabel_right = pick(ticklabeldata.marginRight, 5),
          marginTickLabel_left = pick(ticklabeldata.marginLeft, 5),
          marginTickLabel_bottom = pick(ticklabeldata.marginBottom, 5),
          marginTickLabel_top = pick(ticklabeldata.marginTop, 5);

        switch (orient) {
          case 'top':
            curTickLabelWidth = preCalcTickLen != null ? preCalcTickLen.height + marginTickLabel_top + axisLabelMargin.bottom : 0;
            curTickLabelWidth = curTickLabelWidth + labelSize + axisLabelMargin.top;
            break;
          case 'bottom':
            curTickLabelWidth = preCalcTickLen != null ? preCalcTickLen.height + marginTickLabel_bottom + axisLabelMargin.top : 0; //7 -> spacing between tickmark and ticklabels,axisLabelMargin.bottom -space bw ticklabel and axislabel
            curTickLabelWidth = curTickLabelWidth + labelSize + axisLabelMargin.bottom;
            break;
          case 'left':
            curTickLabelWidth = preCalcTickLen != null ? preCalcTickLen.width + marginTickLabel_left + axisLabelMargin.right : 0;
            curTickLabelWidth = curTickLabelWidth + labelSize + axisLabelMargin.left;
            break;
          case 'right':
            curTickLabelWidth = preCalcTickLen != null ? preCalcTickLen.width + marginTickLabel_right + axisLabelMargin.left : 0;
            curTickLabelWidth = curTickLabelWidth + labelSize + axisLabelMargin.right;
            break;}

        axisComp.tickLabelWidth(curTickLabelWidth);
        return curTickLabelWidth;
      }
      function getMajorTicks(orient, type, tickValueObj) {
        var x1, y1, x2, y2;
        x1 = y1 = x2 = y2 = 0;

        var isInline = tickValueObj.isInline && !tickValueObj.inlineToPlot,
          longTick = tickValueObj.longTickSize,
          inlineOffset = isInline ? orient == 'left' || orient == 'right' ? longTick.width : 0 : 0; //adjust inline offfset only for left, right orient as gridline overlaps with  ticks

        if (orient == 'bottom') {
          y1 = inlineOffset;
          y2 = -chartObj.plotarea.height;
        } else if (orient == 'top') {
          y1 = -inlineOffset;
          y2 = chartObj.plotarea.height;
        } else if (orient == 'left') {
          x1 = -inlineOffset;
          x2 = chartObj.plotarea.width;
        } else if (orient == 'right') {
          x1 = inlineOffset;
          x2 = -chartObj.plotarea.width;
        }

        if (type === 'x' && chartObj.datalabels.hasFixedPosition) {
          var yaxiscolumnorder = chartObj.axes.y.groups.
            map(function (d) {
              return d.disabled;
            }).
            indexOf(false), // First enabled yaxis
            axisReversed = systemconf.chart.axes.yaxis[yaxiscolumnorder].reversed,
            correction = getGridLineCorrection(yaxiscolumnorder);

          if (orient == 'bottom') {
            axisReversed ? y1 -= correction : y2 += correction;
          } else if (orient == 'top') {
            axisReversed ? y2 -= correction : y1 += correction;
          } else if (orient == 'left') {
            axisReversed ? x1 += correction : x2 -= correction;
          } else if (orient == 'right') {
            axisReversed ? x2 += correction : x1 -= correction;
          }
        }

        return {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        };
      }

      function getGridLineCorrection(index) {
        var yscale = scale.getScale(chartObj, chartObj.dataObject, chartObj.plotarea, chartObj.axes.y.orient, index, chartObj.dataset, 'y'),
          origRange = yscale.origRange,
          datatypeY = chartObj.dataset.getDataType('y', index),
          maxRange;

        if (datatypeY === ORDINAL_DATATYPE) {
          var domain = yscale.domain();
          maxRange = yscale(domain[domain.length - 1]) + yscale.bandwidth() / 2;
        } else {
          var domain = chartObj.dataObject.getMinMaxY(index, 0, chartObj.datalabels.hasFixedPosition);
          maxRange = yscale(domain[1]);
        }
        return mathMin(mathAbs(maxRange - origRange[0]), mathAbs(maxRange - origRange[1]));
      }

      function adjustPlotarea(orient, adjustVal) {
        var plotarea = chartObj.plotarea;
        if (orient === 'left') {
          plotarea.left += adjustVal;
          plotarea.width -= adjustVal;
        } else if (orient === 'right') {
          plotarea.width -= adjustVal;
        } else if (orient === 'bottom') {
          plotarea.height -= adjustVal;
          plotarea.bottom += adjustVal;
        } else {
          plotarea.height -= adjustVal;
          plotarea.top += adjustVal;
        }
      }

      function addorremoveAxis(axisWrap, axisComp, data, index, type, mode) {
        //Now only type is "Y" as multiY axis is available
        /*
         *For multiY axis charts alone,
         *mode - add, add the axis  mode - remove ,filtering or remove axis
         *Change the plotarea width, left with respect to the axis wrap width
         */
        //Reset plotborderdrawn and g.plotareaBorder-property
        plotBorderDrawn = {
          left: false,
          right: false,
          top: false,
          bottom: false
        };
        chartObj.staticPaneSVG.
        selectAll('g.plotareaBorder-property').
        selectAll('line').
        style('stroke', TRANSPARENT);
        var orient = axisComp.orient();
        var majorTicks = axisComp.majorTicks();
        var wrapWid = axisComp.tickLabelWidth();
        if (!(axisWrap.style('display') === 'none' && mode === 'remove')) {
          if (orient == 'left' || orient == 'right') {
            chartObj.plotarea.width = mode == 'add' ? chartObj.plotarea.width - wrapWid : chartObj.plotarea.width + wrapWid;
            chartObj.plotarea.left =
            orient == 'left' ?
            mode == 'add' ?
            chartObj.plotarea.left + wrapWid :
            chartObj.plotarea.left - wrapWid :
            chartObj.plotarea.left;
          } else {
            chartObj.plotarea.height = mode == 'add' ? chartObj.plotarea.height - wrapWid : chartObj.plotarea.height + wrapWid;
            chartObj.plotarea.top =
            orient == 'top' ?
            mode == 'add' ?
            chartObj.plotarea.top + wrapWid :
            chartObj.plotarea.top - wrapWid :
            chartObj.plotarea.top;
          }
        }

        var co = 0;
        var display = mode == 'add' ? '' : NONE;
        axisWrap.style('display', display);
        axisWrap.attr('filter', true); //To be used to check in updatescale func whether to call new tickObj or reuse it
        if (mode == 'add') {
          axisWrap.style('display', null);
        }

        for (var i = 0; i < chartObj.axes.y.groups.length; i++) {
          var ywrap = wrap.selectAll("g.y-axis-".concat(i));
          var curAxisComp = chartObj.axes.y.groups[i].component;
          var curAxisOrient = curAxisComp.orient();
          var curMajorTicks = curAxisComp.majorTicks();
          var curAxisData = systemconf.chart.axes.yaxis[i] || systemconf.chart.axes.yaxis[0];

          //Translate the yaxis wraps according to added/removed axiswrap width
          // adjustYAxeswrap(data, index, curAxisComp, true);

          if (ywrap.node()) {
            //If the axis to be removed have majorticks, then draw the major ticks for next upcoming axis
            if (ywrap.style('display') != NONE && co == 0) {
              curMajorTicks = getMajorTicks(curAxisOrient, type, curAxisComp.tickObj.tickValueObj, i);
              curAxisComp.majorTicks(curMajorTicks);
              ywrap.
              transition().
              duration(0).
              call(curAxisComp, type, i, true);
              co++;
            } else if (curMajorTicks != null && co > 0) {
              curAxisComp.majorTicks(null);
              ywrap.
              transition().
              duration(0).
              call(curAxisComp, type, i, true);
            }
            //set proper curAxisComp.plotBorderDrawn according to their visibility in order
            //for multi y axis on redraw need to check both visibility and display status
            if (ywrap.style('display') !== NONE && !plotBorderDrawn[curAxisOrient]) {
              plotBorderDrawn[curAxisOrient] = true;
              curAxisComp.plotBorderDrawn = true;
            } else {
              curAxisComp.plotBorderDrawn = false;
              //Set axisline color for the other components where plotBorderDrawn = false
              if (ywrap.style('display') == '' || ywrap.style('display') == 'inline') {
                ywrap.selectAll('path.domain').style('stroke', curAxisData.axisline.color);
              } else {
                ywrap.selectAll('path.domain').style('stroke', TRANSPARENT);
              }
            }
          }
        }
        adjustYAxeswrap(data, index, axisComp, true);
      }
      chartObj.updateZscale = function () {
        if (chartObj.legend.isSingleLayout && chartObj.dataObject.hasZaxis) {
          var scaleComponent = arrayFind(chartObj.scales, function (_) {return _.id === 'z-0';}),
            domain = scaleComponent._parseDomain();
          chartObj.zscale.domain(domain);
        }
      };

      chartObj.updateScale = function (serData, type, zmInterval, axisorder, range) {var useExistingScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;return function (axisorder) {
          var order = (serData == null || isArray$1(serData) ? serData : serData.yaxiscolumnorder) || axisorder;

          var yaxiscolumnorder = type == 'y' ? getParsedYAxisOrder(order) : 0,
            axisorder = type == 'x' && defined(axisorder) ? axisorder : yaxiscolumnorder,
            axiswrap = wrap.selectAll("g.".concat(type, "-axis-").concat(axisorder)),
            axes = getAxisObject(chartObj, type, axisorder),
            tickObj = axes.ticks,
            axisdata = getAxisData(chartObj, type, axisorder, false),
            ticklabeldata = axisdata.ticklabel,
            orient = axes.component ? axes.component.orient() : getAxisOrient(axisdata, type, yaxiscolumnorder),
            dim = orient == 'bottom' || orient == 'top' ? chartHeight : chartWidth,
            isaxis =
            isAxisEnabled(axisdata, type, type === 'x' ? 0 : yaxiscolumnorder, chartObj) === true &&
            dimension_based_intelligence(chartObj, "".concat(type, "axis"), dim),
            dataset = chartObj.dataset;

          var hierarchical = type == 'y' ? chartObj.dataObject.categoryHierarchy : chartObj.dataObject.hierarchical,
            columnidx = chartObj.dataset.getColumnIdx(type, yaxiscolumnorder),
            datatype = metadata_columns[columnidx].datatype,
            datatype =
            tickObj && tickObj.isHierarchialLevelType() && chartObj.dataObject.hierarchical.categoryTree ? ORDINAL_DATATYPE : datatype,
            formatConf = metadata_columns[columnidx][datatype],
            hasTimegroupBy = tickObj && tickObj.isHierarchy() && chartObj.dataObject.hierarchical.groupByTime,
            specifierIndex = hasTimegroupBy ? axisorder : null,
            getExtentVal = function getExtentVal() {
              if (chartObj.dataObject.pivot) {
                return axes.scale.domain();
              }
              var cType = chartObj.chartTypes[0].name;
              var outerPadding = systemconf.chart.plot.plotoptions[cType].outerPadding;
              return dataset.getDataType(type, axisorder) === ORDINAL_DATATYPE ?
              dataObject.getCategories(type, axisorder) :
              type === 'x' ?
              chartObj.dataObject.getMinMaxX(validateNullVal(outerPadding, 0.2)) :
              chartObj.dataObject.getMinMaxY(yaxiscolumnorder);
            },
            isNoData = false,
            plotarea = chartObj.plotarea,
            domain = zmInterval,
            newScale,
            behaviours = chartObj.behaviouralEvents.eventManager.behaviours,
            hasCustomBehaviours = Object.keys(behaviours).length > 0,
            hasPlotZoom = behaviours.PLOT_ZOOM && behaviours.PLOT_ZOOM.types && behaviours.PLOT_ZOOM.types[type],
            applySmoothEffect =
            hasPlotZoom || behaviours.CHART_SCROLL && chartObj.scroll && chartObj.scroll.settings.smooth && type === 'x',
            /**
             *
             * @param domain
             * @param applyZoom
             */
            getScale = function getScale(domain) {var applyZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
              newScale = scale.getScale(chartObj, dataObject, plotarea, orient, axisorder, dataset, type, domain, UNDEFINED, applyZoom);
              if (chartObj.dataObject.pivot) {
                // for pivot chart scale should get already updated by scale.setRowScale, scale.setColumnScale
                newScale = axes.scale;
              }
              newScale.ordinalRange = getOrdinalRange(newScale);
              return newScale;
            },
            // #ZC2225 $axisorder

            /**
             * updates the params of axis and scale to get a smooth effect
             * @param domain
             * @param range
             */
            updateZoomInfo = function updateZoomInfo(domain, range) {
              domain && axes.scale.domain(axes.domain = domain);
              range && axes.scale.range(axes.range = range);

              if (axes.scale.bandwidth) {
                axes.scale.ordinalRange = null;
              }
              zmInterval = domain;
              axes.eventscale = axes.scale;
            };

          if (!zmInterval) {
            var t0 = getExtentVal() || [];
            isNoData = t0[0] === 'NoData' && t0[1] === 'NoData';
          }

          // when plot brushed to only one data. the bar inter padding is set to 0
          // when reseted the zoom  we need re-enable the padding
          // #ZC2172
          if (axes.scale.bandwidth && !applySmoothEffect && axes.domain && axes.domain.length === 1) {
            useExistingScale = false;

            // update the domain if available
            if (isArray$1(domain)) {
              axes.domain = domain;
            }
          }

          if (!useExistingScale) {
            // chartObj.cache.correction = {}; // bubblepie3 filter bar legend and undo
            // for ordinal smooth effect we don't change the domain for x axis
            if (type === 'x' && applySmoothEffect && axes.scale.bandwidth) {
              zmInterval = null;
            }

            // #ZC2845 CXZA_LOGAXIS_19
            if (axes.logDomain) {
              var logDomain = axes.logDomain;
              axes.logDomain = null;
              var _extent = getExtentVal();
              if (_extent[0] === 0 && _extent[1] === 0) {
                axes.logDomain = null;
              } else {
                axes.logDomain = logDomain;
              }
            }

            newScale = getScale(zmInterval);
            axes.eventscale = axes.scale = newScale;

            // if zoom is there update, apply it
            if (applySmoothEffect) {
              // base scale should be the whole scale
              axes.baseScale = getScale(UNDEFINED, false);
              newScale.originalDomain = axes.baseScale.originalDomain;

              // get the transform
              var transform;
              if (hasPlotZoom) {
                transform = behaviours.PLOT_ZOOM.instance.getTransform();
              } else {
                transform = chartObj.scroll.transform;
              }

              if (transform) {var _updateScaleByTransfo =
                updateScaleByTransform(axes, fixBrushDirection(type, chartObj.axes.rotated), transform);domain = _updateScaleByTransfo.domain;range = _updateScaleByTransfo.range;
                // update the scale
                updateZoomInfo(domain, range);
              }
            }
          }

          //Update scale
          if (useExistingScale) {
            updateZoomInfo(applySmoothEffect ? null : zmInterval, range);

            // set animation duration 0 for zoom
            chartObj.axes.animationDuration = chartObj.disableAnimation ? 0 : axes_animation_duration;
          }

          var removeAxis = type == 'y' && !axiswrap.empty() && isNoData,
            enableAxis =
            type == 'y' &&
            !axiswrap.empty() &&
            axisdata.disabled != true &&
            axiswrap.style('display') == NONE &&
            !!axiswrap.attr('filter');

          //Update axis
          if (removeAxis) {
            //Check again; no updation in ordinal y scale
            //No need to update the scale and axis
            if (isaxis) {
              addorremoveAxis(axiswrap, axes.component, axisdata, yaxiscolumnorder, 'y', 'remove');
            }
          } else if (enableAxis && !hasCustomBehaviours) {
            // currently while enabling axes, we do not update the tick labels.
            // for zoom we need to update it.
            if (isaxis) {
              addorremoveAxis(axiswrap, axes.component, axisdata, yaxiscolumnorder, 'y', 'add');
            }
          } else {
            if (dataObject.isBubbleEnabled && type == 'y' && !applySmoothEffect) {
              axes.eventscale = axes.scale = scale.getScale(
              chartObj,
              dataObject,
              chartObj.plotarea,
              orient,
              yaxiscolumnorder,
              chartObj.dataset,
              'y');

            }

            // when a axis is disabled and zoom the chart, the zoom effect does not apply on the disabled axis.
            // currently we are not updating the ticks for multi y axis while legend filter.
            // but if the chart is zoomed we should update the ticklabels once enabled the axis
            if (isaxis && hasCustomBehaviours && enableAxis) {
              addorremoveAxis(axiswrap, axes.component, axisdata, yaxiscolumnorder, 'y', 'add');
            }

            if (isaxis) {
              axes.component.scale(axes.scale);
              //set axisconfig
              var hasTimegroupBy = tickObj && tickObj.isHierarchy() && chartObj.dataObject.hierarchical.groupByTime,
                columnidx = chartObj.dataset.getColumnIdx(type, hasTimegroupBy ? 0 : axisorder), //column index should be 0 for multi level x axis
                datatype = metadata_columns[columnidx].datatype,
                isMergedAxis = type == 'y' && !hierarchical ? metadata_axes.y[axisorder].length > 1 : false;
              datatype =
              tickObj && tickObj.isHierarchialLevelType() && chartObj.dataObject.categoryHierarchy ? ORDINAL_DATATYPE : datatype;
              formatConf = metadata_columns[columnidx][datatype];
              formatConf = isMergedAxis && type == 'y' ? merged_axis_column_intersect(yaxiscolumnorder, chartObj) : formatConf;
              var formattingFunction = dataObject.isPercentChart && type == 'y' ? getFormattedValueByPercent : getFormattedValue;
              var formatConf_axis = formatConf != null ? formatConf.axisformat || formatConf.format : null;
              var tickObj = axes.ticks,
                _oldpreCalcTickLen = tickObj.preCalcTickLen;
              var oldLongTickSize =
              orient == 'bottom' || orient == 'top' ?
              tickObj.tickValueObj.longTickSize.height :
              tickObj.tickValueObj.longTickSize.width;

              var axis_prerender = axes.prerenderComp;
              axis_prerender.preRenderTickG(chartObj.plotarea);

              var axisTicks = axis_prerender.axisTicks,axisTitle = axis_prerender.axisTitle;
              tickObj.tickValueObj = _objectSpread(_objectSpread(_objectSpread({}, axisTicks.tickInfo), axisTicks.precalculate), axisTitle.precalculate);
              tickObj.preCalcAxisLen = axisTitle.precalculate.preCalcAxisLen;

              tickObj.preCalcTickLen = _oldpreCalcTickLen; //TODO MUST CHANGE object from referenc; reuse tickobj referernce
              // formatConf.subfunction = axis_parser.subFormatType;
              var tickValueObj = tickObj.tickValueObj;
              // var tickValueObj = axes.prerenderComp.axisticks.tickInfo;
              // var tickValueObj = tickObj.getTickValues(
              //     chartObj.plotarea.width,
              //     chartObj.plotarea.height,
              //     zmInterval,
              //     false,
              //     null,
              //     axes.Ticks,
              //     chartObj.plotarea
              // );

              if (isArray$1(axes.logDomain) && !useExistingScale) {
                axes.scale.domain(axes.logDomain);
                axes.eventscale.domain(axes.logDomain);
              }

              tickObj.tickValueObj = tickValueObj;
              var curLongTickSize =
              orient == 'bottom' || orient == 'top' ?
              tickObj.tickValueObj.longTickSize.height :
              tickObj.tickValueObj.longTickSize.width;
              var preCalcTickLen = tickObj.preCalcTickLen;

              var adjustVal =
              oldLongTickSize > curLongTickSize ?
              curLongTickSize - oldLongTickSize :
              oldLongTickSize < curLongTickSize ?
              curLongTickSize - oldLongTickSize :
              0;
              orient == 'bottom' || orient == 'top' ?
              preCalcTickLen.height = preCalcTickLen.height + adjustVal :
              preCalcTickLen.width = preCalcTickLen.width + adjustVal;

              //FEATURESEVENTS_COMBO_7_1 -> reassigned adjusted tickObj.precalcTickLen to tickObj.tickValueObj.preCalcTickLen
              // tickObj.tickValueObj.preCalcTickLen.width = preCalcTickLen.width;
              // tickObj.tickValueObj.preCalcTickLen.height = preCalcTickLen.height;

              var fullUpation = !axiswrap.empty() && axiswrap.style('display') === NONE && type === 'y';
              if (fullUpation) {
                axiswrap.style('display', null);
              }
              //set tick formats - multi line tick with format conf
              var tickValues = tickObj.getTicksforAxisComp(tickValueObj),
                tickLabelWidth = getTickLabelWidth(
                axisdata.label,
                axisdata.ticklabel,
                axes.component.preCalcTickLen(),
                chartObj,
                type,
                axisorder,
                orient);

              axes.component.
              tickValues(tickValues).
              tickRotation(tickValueObj.rotation).
              minorGrid(tickObj.tickValueObj.minorTickValues).
              preCalcTickLen(tickObj.preCalcTickLen);
              axes.component.tickLabelWidth(tickLabelWidth);
              var tickPos = tickObj.getActualTicklabel(tickValueObj);
              var maxWidth = tickObj.tickValueObj.maxTickSize.horizontal,
                maxHeight = tickObj.tickValueObj.maxTickSize.vertical,
                fSize = utils.getVal(
                getValByPriority([axisdata.ticklabel, chartObj.systemConf.chart, chartObj.systemConf.canvas, $ZCG], 'fontSize')),

                needTickConfigWrap = tickObj.tickValueObj.mode == 'wrapOnSpace' || tickObj.tickValueObj.mode == 'wrapAll',
                isMultiLine = axes.component.isMultiLineTick(),
                isCustomLabel = defined(axisdata.ticklabel.showAs),
                args_tick = [
                null,
                orient,
                chartObj,
                tickValueObj.rotation,
                axisdata.ticklabel.textOverflow,
                axes.scale,
                axiswrap, //	ZC2090
                axes.component,
                'ticklabel',
                axisdata.ticklabel,
                axisorder],

                doOverflow = handleOverflowTicks.apply(null, args_tick);
              var previousTick;
              var tickFormat = function tickFormat(d, i) {
                var tick = tickPos(i);
                var formattedValue = formattingFunction(formatConf, tick, datatype, chartObj, 'axis', null, null, specifierIndex);
                d3_select(this).text(formattedValue);
                var isLastTick = i == tickValueObj.ticks.length - 1;
                this.formattedVal = formattedValue;
                if (isMultiLine) {
                  if (needTickConfigWrap) {
                    formattedValue = formatTickWrapByMode(formattedValue, tickObj.tickValueObj.mode, maxWidth, maxHeight, fSize);
                  }
                  wrapTextContent(d3_select(this), formattedValue, { orient: orient });
                } else if (isCustomLabel) {
                  if (defined(tickObj.tickValueObj.customTicks[i])) {
                    this.innerHTML = '';
                    wrapTextContent(d3_select(this), tickObj.tickValueObj.customTicks[i], null, true);
                  }
                }
                doOverflow(this, i);
                var minmaxlabels = axisdata.ticklabel.minmaxlabels,
                  continoustType =
                  (datatype == NUMERIC_DATATYPE || datatype == TIME_DATATYPE) && tickObj && !tickObj.isHierarchialLevelType();
                if (continoustType && minmaxlabels && minmaxlabels.show && !minmaxlabels.excludeIntervals) {
                  if (i == 1) {
                    if (doTicksOverlaps(previousTick, this, tickValueObj.rotation, orient)) {
                      this.style.display = 'none';
                    }
                  } else if (isLastTick) {
                    if (doTicksOverlaps(previousTick, this, tickValueObj.rotation, orient)) {
                      previousTick.style.display = 'none';
                    }
                  }
                }
                previousTick = this;
              };

              if (formatConf_axis && formatConf_axis.specifier == 'auto' && !axes.scale.bandwidth) {
                axes.component.tickFormat(function (d, i) {
                  d3_select(this).text(axes.scale.tickFormat()(d));
                });
              } else {
                axes.component.tickFormat(tickFormat);
              }

              //call axis

              if (axes.component.isMultiLineTick() || defined(ticklabeldata.showAs)) {
                axiswrap.call(axes.component, type, axisorder);
              } else {
                axiswrap.
                transition().
                duration(axes_animation_duration).
                call(axes.component, type, axisorder);
              }

              //Adjust wrap positions

              if (fullUpation) {
                addorremoveAxis(axiswrap, axes.component, axisdata, yaxiscolumnorder, 'y', 'add');
              }

              if (mathAbs(adjustVal) > 1) {
                //Bug IdZC795 //hack ; hav to change logic for redraw in zoom

                if (!fullUpation) {
                  adjustPlotarea(orient, adjustVal);
                }
                var type_opp = type === 'x' ? 'y' : 'x',
                  oppositeAxis = type_opp === 'x' ? [chartObj.axes.x] : chartObj.axes.y.groups;

                // #ZC2034
                oppositeAxis.forEach(function (axisInfo) {
                  // #ZC2283 $!axisInfo.disabled
                  if (!axisInfo.disabled) {
                    if (applySmoothEffect) {
                      domain = axisInfo.domain;range = axisInfo.range;
                      // update the range of the [type_opp]
                      chartObj.updateScale(serData, type_opp, domain, axisInfo.index, range, false);
                    } else {
                      chartObj.updateScale(serData, type_opp, null, axisInfo.index);
                    }
                  }
                });
                chartObj.drawPlotareaClippath();
                chartObj.updatePlotareaProp();
              }
              if (type === 'y') {
                axiswrap.styles({
                  display: null,
                  visibility: 'visible'
                });
                adjustYAxeswrap(axisdata, yaxiscolumnorder, axes.component, true);
              } else {
                adjustXAxiswrap(axisdata, axisorder, axes.component);
              }

              var PW = chartObj.plotarea.width;
              !chartObj.axes.rotated && type == 'y' ?
              wrap.
              selectAll(".y-axis-".concat(yaxiscolumnorder)).
              selectAll('line.majorTicks').
              attr('x2', orient != 'right' ? PW : -PW) :
              null;
              if (axes.component.plotBorderDrawn == true) {
                updateAxisLine(orient, axisdata, axiswrap, axes.component, type, axisorder);
              }
            }
          }
        }(axisorder);};
    };

    function clearCorrectionCache(chartObj) {
      for (var key in chartObj.cache.correction.domainCorrection) {



        // if (!(key.indexOf('-y') > -1) && key !== 'measure') {
        //     chartObj.cache.correction.domainCorrection[key] = null;
        // }
      }for (var key in chartObj.cache.correction) {if (key !== 'domainCorrection') {chartObj.cache.correction[key] = null;
        }
      }
    }

    //$Id$

    function getClippathIdForAxis(chartObj, tickObj, orient, type, axisOrder) {
      //#ZC1174 Chrome crash (66.0.3359.139)
      var plotAreaClone = simpleClone(chartObj.plotarea);
      plotAreaClone.chartId = chartObj.id;
      var hierarchical = chartObj.dataObject.hierarchical;
      var defs = appendEle(chartObj.svg, 'defs', [1]),
        id = generateIdByPropValue(plotAreaClone, type + axisOrder),
        clipPath = appendEle(defs, 'clipPath', [1], '#', 'id', id),
        clipRect = appendEle(clipPath, 'rect', [1]),
        xaxisdata = chartObj.systemConf.chart.axes.xaxis,
        yaxisdata = chartObj.systemConf.chart.axes.yaxis,
        data = getAxisData(chartObj, type, axisOrder, false);

      var rect = {},
        axisRect = tickObj.axisgroup,
        percentLimit = 0.5,
        margin = {
          left: percentLimit * chartObj.plotarea.left,
          right: percentLimit * (chartObj.canvasarea.width - (chartObj.plotarea.left + chartObj.plotarea.width)),
          top: percentLimit * chartObj.plotarea.top,
          bottom: percentLimit * chartObj.plotarea.bottom
        },
        axisArea_child = 0;

      if (hierarchical) {
        axisArea_child = getAxisAreaForLowerOrder(type, axisOrder, chartObj);
      }

      switch (orient) {
        case 'top':{
            rect.x = -margin.left;
            rect.y = -axisRect.height;

            rect.height = axisRect.height + axisArea_child + chartObj.plotarea.height;
            rect.width = axisRect.width + margin.left + margin.right;
            break;
          }
        case 'right':{
            rect.x = -chartObj.plotarea.width;
            rect.y = -margin.top;
            rect.width = axisRect.width + chartObj.plotarea.width + (data.axisline.strokeWidth || 1);
            rect.height = axisRect.height + margin.top + margin.bottom;
            break;
          }
        case 'bottom':{
            rect.x = -margin.left;
            rect.y = -chartObj.plotarea.height - axisArea_child;
            rect.height = axisRect.height + axisArea_child + chartObj.plotarea.height;
            rect.width = axisRect.width + margin.left + margin.right;
            break;
          }
        case 'left':{
            rect.x = -axisRect.width;
            rect.y = -margin.top;
            rect.width = axisRect.width + chartObj.plotarea.width + axisArea_child + (data.axisline.strokeWidth || 1);
            rect.height = axisRect.height + margin.top + margin.bottom;
            break;
          }}


      clipRect.attrs(rect);
      return id;
    }

    var ELEMENT_SELECTOR = d3_map();

    var STYLE_SELECTOR = d3_map();

    var ATTR_MAP = d3_map();

    var PLOT_MODULES = d3_set();
    var NON_PLOT_MODULES = d3_set();

    var SERIES_TYPES = d3_set();

    ATTR_MAP.set('row', 'levelByRow');
    ATTR_MAP.set('column', 'levelByColumn');

    ELEMENT_SELECTOR.set('bar', 'path.zc_bar');
    ELEMENT_SELECTOR.set('bar.levelMarker', 'path.zc_levelMarker');
    ELEMENT_SELECTOR.set('area', 'path.area');
    ELEMENT_SELECTOR.set('line', 'path.line');
    ELEMENT_SELECTOR.set('scatter', 'g.scatter');
    ELEMENT_SELECTOR.set('bubble', 'g.scatter');
    ELEMENT_SELECTOR.set('pie', 'path.zc_pie');
    ELEMENT_SELECTOR.set('funnel', 'path.zc_funnel');
    ELEMENT_SELECTOR.set('pyramid', 'g.pyramidsection');
    ELEMENT_SELECTOR.set('sunburst', 'path.zc_sunburst');
    ELEMENT_SELECTOR.set('treemap', 'path.zc_treemap');
    ELEMENT_SELECTOR.set('packedbubble', 'circle.zc_packedbubble');
    ELEMENT_SELECTOR.set('wordcloud', 'text.zc_wordcloud');
    ELEMENT_SELECTOR.set('web', 'path.area');
    ELEMENT_SELECTOR.set('tick', 'g.tick');
    ELEMENT_SELECTOR.set('tick_child', 'text.ticklabel');
    ELEMENT_SELECTOR.set('axislabel', 'text.axislabel');
    ELEMENT_SELECTOR.set('label', 'text');
    ELEMENT_SELECTOR.set('boundbox', 'path.zc_label_background');
    ELEMENT_SELECTOR.set('connector', 'path.zc_label_connector');

    STYLE_SELECTOR.set('area', ['opacity', 'fillOpacity']);

    PLOT_MODULES.add(['label', 'series', 'boundbox', 'connector']);
    NON_PLOT_MODULES.add(['tick']);

    function highlightByOpacity(nodes) {
      var chart = this;

      if (!nodes) {
        return;
      }

      if (nodes.resetMode) {
        highlightTick(nodes.selected, chart, true);
        highlightTick(nodes.unSelected, chart, true);
      } else {
        highlightTick(nodes.reset, chart, true);
        highlightTick(nodes.unSelected, chart, false);
        highlightTick(nodes.selected, chart, true);
      }
    }
    function highlightTick(nodes, chart, active) {
      var defaultStyleValue_fade = 0.1;
      nodes.each(function (element, key) {
        var params = getDefaultTickFilterStyle(chart, key),
          styleAttr = params[0],
          styleValue = active ? params[1] : defaultStyleValue_fade;
        element.style(styleAttr, styleValue);
      });
    }

    function getDefaultTickFilterStyle(chart, type) {
      var defaultStyleAttr = 'opacity',
        defaultStyleValue_active = 1;
      if (charttypenames.has(charttype[type])) {
        var styleSelector = STYLE_SELECTOR.get(type),
          params = styleSelector && styleSelector[1] || defaultStyleAttr,
          styleAttr = styleSelector && styleSelector[0] || defaultStyleAttr,
          plotoptions = chart.systemConf.chart.plot.plotoptions[type],
          styleValue = plotoptions && plotoptions[params] || defaultStyleValue_active;
        return [styleAttr, styleValue];
      }
      return [defaultStyleAttr, defaultStyleValue_active]; //default opacity for axis tick, label
    }

    function selectTickFilterNodes(chart, parent, tag, query, chartTypes, axisType) {
      var result = {
        selected: d3_map(),
        unSelected: d3_map(),
        reset: d3_map()
      };
      var preSelection = parent;

      var modules = axisType ?
      d3_merge([['tick', 'label', 'boundbox', 'connector', 'bar.levelMarker'], chartTypes]) :
      d3_merge([['label', 'boundbox', 'connector'], chartTypes]);

      modules.map(function (d) {
        var parentWrap = parent && parent.get(d) || getParentWrap(d, chart, axisType),
          element = ELEMENT_SELECTOR.get(d),
          filterChildElement = ELEMENT_SELECTOR.get("".concat(d, "_child")),
          attr = tag == 'row' ? 'levelbyrow' : 'levelbycolumn';
        preSelection = parent && !NON_PLOT_MODULES.has(d);
        var filter = selectAllByQuery(parentWrap, attr, query, element, preSelection, filterChildElement);

        result.selected.set(d, filter.selected);
        result.unSelected.set(d, filter.unSelected);

        if (d == 'tick') {
          result.reset.set(d, filter.reset);
        }
      });

      return result;
    }

    function getParentWrap(module, chart, axisType) {
      if (module == 'label' || module == 'boundbox' || module == 'connector') {
        return chart.staticPaneSVG.select('g.labelholder');
      } else if (module == 'tick' || module == 'axislabel') {
        return chart.wrap.selectAll(".".concat(axisType, "-axis"));
      } else {
        return chart.svg.select('.seriesholder');
      }
    }
    function selectAllByQuery(parent, attr, value, element, preSelection, filterChildElement) {
      var querySelector = preSelection ? 'filter' : 'selectAll';

      var pointsSelected = parent[querySelector]("".concat(element, "[").concat(attr, "^=\"").concat(value, "\"]")),
        pointsNotSelected = parent[querySelector]("".concat(element, ":not([").concat(attr, "^=\"").concat(value, "\"])")),
        reset = parent[querySelector]("".concat(element));

      if (filterChildElement) {
        pointsSelected = pointsSelected[querySelector]("".concat(filterChildElement)),
        pointsNotSelected = pointsNotSelected[querySelector]("".concat(filterChildElement));
      }

      return {
        selected: pointsSelected,
        unSelected: pointsNotSelected,
        reset: reset
      };
    }

    function selectDependentNodesFromTickInfo(args) {
      var chart = this,
        unique_cTypes = getUniqueChartTypes(chart),
        cTypes = unique_cTypes.values(),
        column = args.columnInfo.data[0],
        hierarchical = chart.dataObject.hierarchical,
        axisType = args.axisType,
        element = args.element,
        parentG = element.parentNode,
        tag = axisType == 'x' ? 'column' : 'row',
        tag_invert = axisType == 'x' ? 'row' : 'column',
        attr = tag == 'row' ? 'levelbyrow' : 'levelbycolumn',
        query = parentG.getAttribute(attr),
        cache = chart.cache.hierarchical[tag],
        itemIndex = cache.itemIndex = column.itemIndex,
        nodeList = hierarchical.pivotLayout.getRootNodeList(tag),
        branchCount = nodeList.getCount(),
        leavesCount = nodeList.getLeavesCount(),
        axisOrder = column.axisOrder, // axisOrder starts from top to bottom
        depth = cache.depth = branchCount + leavesCount - axisOrder - 1, // depth starts from bottom to top  (axisOrder to depth)
        data = nodeList.getNodesAtDepth(axisOrder),
        currentData = data[itemIndex],
        selectedData = nodeList.getAllChildren(currentData),
        query_invert = chart.cache.hierarchical[tag_invert].query,
        previousSelection,
        resetMode = cache.query == query;

      cTypes =
      unique_cTypes.has('line') && ($Browser.SAFARI || $Browser.IE) ?
      cTypes.concat(['scatter']) :
      unique_cTypes.has('area') ?
      cTypes.concat(['line', 'scatter']) :
      cTypes;

      if (query_invert) {
        var oldNodes = selectTickFilterNodes(chart, null, tag_invert, query_invert, cTypes);
        previousSelection = oldNodes.selected;
      }

      var nodes = selectTickFilterNodes(chart, previousSelection, tag, query, cTypes, axisType);
      nodes.resetMode = resetMode;

      if (isArray$1(cache.data)) {
        setState(cache.data, false);
      }
      // restore if same tick clicked twice
      if (cache.query === query) {
        // reset state to false
        cache.data = cache.query = cache.active = cache.depth = cache.itemIndex = cache.isLeaf = null; // clear it
      } else {
        // for current selection set to active mode
        setState(selectedData, true);
        cache.data = selectedData;
        cache.active = true;
        cache.query = query;
      }

      return nodes;
    }

    /**
     *
     * @param {[Array]} data array of data
     * @param {Boolean} isActive
     */
    function setState(data, isActive) {
      var state = function state(point) {
        point.active = isActive;
      };
      data.forEach(state);
    }

    var tickFilterMap = {};

    tickFilterMap._defaultBehavior = {
      handler: '',
      selection: selectDependentNodesFromTickInfo,
      action: highlightByOpacity
    };

    function ZC_AXIS_TICK_FILTER(args) {
      var chart = this,
        column = args.columnInfo.data[0],
        axisType = args.axisType,
        event = args.event;

      //supports only for ORDINAL datatype
      if (column.datatype == NUMERIC_DATATYPE) {
        return;
      }

      if (!chart.cache.hierarchical) {
        chart.cache.hierarchical = {
          row: {},
          column: {}
        };
      }

      var selection = tickFilterMap._defaultBehavior.selection.call(this, args);

      tickFilterMap._defaultBehavior.action.call(this, selection);
    }

    var customGestureList = {};

    var setCustomGesture = function setCustomGesture(name, gesture) {
      customGestureList[name] = gesture;
    };

    function CustomGesture(name, selection, module, defaulthandler) {
      if (!customGestureList[name]) {
        throw "unknown gesture : ".concat(name);
      } else {
        var handler;
        switch (module) {
          case 'plot':{
              handler = ZC_PLOT_CUSTOM_GESTURE;
              break;
            }

          case 'axis':{
              handler = defaulthandler || Registry.getComponent('AxisEventHandler');
              break;
            }

          case 'legend':{
              handler = defaulthandler || '';
              break;
            }}

        var gestureListener = customGestureList[name].call(this, selection, handler);
      }
    }

    function ZC_PLOT_CUSTOM_GESTURE(type, event, point, i, element) {
      var chart = this.chart,
        eventManager = this.eventManager;

      // // dont proceed hover while zoom and brush
      if (chart.zooming || chart.brushing) {
        return false;
      }

      if (chart.chartRendered) {
        this.clearOldActions();
        // if (d3_event().defaultPrevented) return;

        // let USING Brush Bubble
        var useBubble = $Browser.isTouchDevice && chart.isAxisCategory && chart.systemConf.chart.brush.enabled;
        if (chart.stopPropogate !== false && !useBubble) {
          d3_event().stopPropagation();
        }

        eventManager.eventType = type;
        eventManager.targetEvent = chart.eventHandler.targetEvent = d3_event();

        var isSingleSrcEvt = this.isSingleSource();
        var node = this.getSourceNode();
        var mouse = this.getRelativeMousePosition(node, isSingleSrcEvt);
        var pointFound = point && (point.constructor === Object || point.constructor === Array || !isSingleSrcEvt);
        point = !isSingleSrcEvt ? point.constructor === Object ? point : eventManager.selectionManager.nearest : point;
        if (pointFound) {
          point = this.toNewObject(point);
        }

        //find point

        if (!pointFound) {
          point = eventManager.getData('mousemove', mouse);
          if (!point.selectionSet.length) {
            var handlers = chart.eventHandler.handlers;
            handlers.mouseout.call(this);
            return;
          }
        }

        //associate default behaviors
        eventManager.associateBehaviours(eventManager.eventType, point, mouse);
      }
    }

    Registry.setComponent('setCustomGesture', setCustomGesture);
    Registry.setComponent('CustomGesture', CustomGesture);

    //$Id$

    function bindEventHandlerForTicks(chartObj, tickG, ticklabels, tickImages, ticklabeldata, columnInfo, type, axisOrder) {var _this19 = this;
      var events_tick = ticklabeldata.events,
        eventDisabled = events_tick != null && validateNullVal(events_tick.enabled, true) == false;

      var axisObj = getAxisObject(chartObj, type, axisOrder),
        tickComp = axisObj && axisObj.ticks,
        tickObj = tickComp && tickComp.tickValueObj;

      var customHandlerFn = {
        mousemove: events_tick ? events_tick.mousemove : null,
        mouseout: events_tick ? events_tick.mouseout : null,
        click: events_tick ? events_tick.click : null,
        dblclick: events_tick ? events_tick.doubleclick : null,
        tap: events_tick ? events_tick.tap : null,
        tapHold: events_tick ? events_tick.taphold : null,
        tapHoldEnd: events_tick ? events_tick.tapholdend : null,
        dbltap: events_tick ? events_tick.doubletap : null
      };

      if (!eventDisabled) {
        var defaultHandlers = {
          click: defaultTickFilter,
          tap: defaultTickFilter
        };
        var callCustomHandler = function callCustomHandler(eventType, targetEvent, d, i, element) {
          var callback = customHandlerFn[eventType] || events_tick && events_tick[eventType];
          if (callback) {
            invokeFunction(callback, targetEvent, getDatawithColumnInfo(columnInfo, d, i, axisOrder), chartObj, element);
          }
        };
        var mouseHandlers = {
          mousemove: function mousemove(d, i) {
            var targetEvent = d3_event();
            callCustomHandler('mousemove', targetEvent, d, i, _this19);
          },
          mouseout: function mouseout(d, i) {
            var targetEvent = d3_event();
            callCustomHandler('mouseout', targetEvent, d, i, _this19);
          },
          click: function click(d, i) {
            var targetEvent = d3_event();
            callCustomHandler('click', targetEvent, d, i, this);
            if (!customHandlerFn.click || customHandlerFn.click && targetEvent.allowDefault) {
              defaultHandlers.click.call(this, columnInfo, d, i, axisOrder, false, type);
            }
          },
          dblclick: function dblclick(d, i) {
            var targetEvent = d3_event();
            callCustomHandler('dblclick', targetEvent, d, i, _this19);
          }
        };
        var touchHandlers = {
          tapHold: function tapHold(d, i) {
            var targetEvent = d3_event();
            callCustomHandler('tapHold', targetEvent, d, i);
          },
          tapHoldEnd: function tapHoldEnd(d, i) {
            var targetEvent = d3_event();
            callCustomHandler('tapHoldEnd', targetEvent, d, i);
          },
          tap: function tap(d, i) {
            var targetEvent = d3_event();

            callCustomHandler('tap', targetEvent, d, i);
            if (!customHandlerFn.tap || customHandlerFn.tap && targetEvent.allowDefault) {
              defaultHandlers.tap.call(this, columnInfo, d, i, axisOrder, false, type);
            }
          },
          dbltap: function dbltap(d, i) {
            var targetEvent = d3_event();
            callCustomHandler('dbltap', targetEvent, d, i);
          }
        };

        // cursor
        if (tickImages) {
          var cursor = eventDisabled ? 'auto' : events_tick ? events_tick.cursor || 'pointer' : 'pointer';
          tickImages.style('cursor', cursor);
        }

        attachevents(ticklabels, mouseHandlers, touchHandlers);
        if (tickImages) {
          attachevents(tickImages, mouseHandlers, touchHandlers);
        }

        if (tickObj && tickObj.customTickInfo && tickObj.customTickInfo.customGroup) {
          attachevents(tickG.selectAll('g.customTick'), mouseHandlers, touchHandlers);
        }

        if (customGestureList) {
          var gestureKeys = Object.keys(customGestureList),
            _CustomGesture = Registry.getComponent('CustomGesture');
          gestureKeys.map(function (d) {
            _CustomGesture.call(_this19, d, ticklabels, 'axis', callCustomHandler);
          });
        }
      }
      function defaultTickFilter(columnInfo, d, i, axisOrder, useDefault, type) {
        if (chartObj.dataObject.hierarchical && chartObj.dataObject.hierarchical.categoryTree) {
          var cType = chartObj.chartTypes[0],
            isBranchAxisType = isBranchAxis(type, axisOrder, chartObj);

          if ((cType.name === 'area' || cType.name === 'line') && !isBranchAxisType) {
            return;
          }

          var args = {
            event: d3_event(),
            columnInfo: getDatawithColumnInfo(columnInfo, d, i, axisOrder),
            axisType: type,
            element: this
          };

          ZC_AXIS_TICK_FILTER.call(chartObj, args);
          // invokeFunction(axis.TickLabelFilter, d3_event(), getDatawithColumnInfo(columnInfo, d, i, axisOrder), chartObj, true, type);
        }
      }

      function getDatawithColumnInfo(columnInfo, d, itemIndex, axisOrder) {
        //d.d => for new axis parser marks which is not implemented for polar axis
        columnInfo.data = columnInfo.data.map(function (dt) {
          var _data = defined(d) ? d.d || d : null;
          dt.value = dt.datatype === TIME_DATATYPE ? generateDateVal(d, null, dt.time).getTime() : _data;

          dt.itemIndex = itemIndex;
          dt.levelindex = pick(dt.levelindex, axisOrder);
          dt.axisOrder = axisOrder;

          return dt;
        });
        return columnInfo;
      }
      Registry.setComponent('AxisEventHandler', callCustomHandler);
    }

    //For nonlinear ordinal scaleObj there is dynamic rangeband for every data. so we are centering it here.
    function centeringTicklabel(g, scaleObj, orient) {
      g.nodes().forEach(function (tickG, i) {
        // if(scaleObj.discreteWidth(i)){
        var keyIndex = orient == 'left' || orient == 'right' ? 1 : 0;
        var old_transform = [0, 0]; //d3.transform(tickG.getAttribute("transform")).translate;
        var rangeBand_nonLinear = scaleObj.discreteWidth(i) / 2;

        old_transform[keyIndex] = old_transform[keyIndex] + rangeBand_nonLinear;
        tickG.setAttribute('transform', "translate(".concat(old_transform[0], ",").concat(old_transform[1], ")"));
        // }
      });
    }

    //$Id$

    var identity$1 = function identity$1(x) {
      return x;
    };
    function translateX(x) {
      return "translate(".concat(x + 0.5, ",0)");
    }

    function translateY(y) {
      return "translate(0,".concat(y + 0.5, ")");
    }

    function number$1(scale1) {
      return function (d) {
        return +scale1(d);
      };
    }

    function center$1(scale1) {
      var offset = Math.max(0, scale1.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
      if (scale1.round()) {
        offset = Math.round(offset);
      }
      return function (d) {
        return +scale1(d) + offset;
      };
    }

    function center1(scale1) {
      return function (d, i) {
        var offset = Math.max(0, scale1.bandwidth(d) - 1) / 2; // Adjust for 0.5px offset.
        // if (scale1.round()) {
        offset = Math.round(offset);
        // }
        return +scale1(d) + offset;
      };
    }

    function entering() {
      return !this.__axis;
    }

    function d3axis(context, args, data) {
      var tickArguments = [],
        chart = args.chart,
        axis = args.axis,
        tickObj = axis.ticks.tickValueObj,
        tickValues = args.tickValues,
        tickFormat = args.tickFormat,
        tickSizeInner = args.tickSizeInner,
        tickSizeOuter = args.tickSizeOuter,
        subTickSize = args.isSubTickMarkShow ? args.subTickSize : 0,
        gridSize = args.gridSize,
        tickPadding = args.tickPadding,
        rotation = args.rotation,
        orient = args.orient,
        scale1 = args.scale,
        isInline = tickObj && tickObj.isInline,
        isInwardPlot = tickObj && tickObj.inlineToPlot,
        k = orient === 'top' || orient === 'left' ? -1 : 1,
        l = isInwardPlot ? -k : k,
        m = isInline ? -k : k,
        x = orient === 'left' || orient === 'right' ? 'x' : 'y',
        w = orient === 'left' || orient === 'right' ? 'width' : 'height',
        y = x == 'x' ? 'y' : 'x',
        transform = orient === 'top' || orient === 'bottom' ? translateX : translateY,
        h = chart.dataObject.isPolarAxisCategory ? 'H' : 'h',
        labeldata = data.label,
        ticklabeldata = data.ticklabel,
        events_tick = ticklabeldata.events,
        tickmarkdata = data.tickmark,
        subtickmark = data.subtickmark,
        axisline = data.axisline,
        griddata = data.grid,
        minorGridData = data.minorGrid || {},
        tickTransform = data.tickTransform,
        renderGrid = args.renderGrid,
        renderTicklabel = args.renderTicklabel,
        showGrid = args.isGridShow,
        showMinorGrid = args.isMinorGridShow,
        isSubTickMarkShow = args.isSubTickMarkShow,
        eventDisabled = events_tick != null && validateNullVal(events_tick.enabled, true) == false,
        cursor = eventDisabled ? 'auto' : events_tick ? events_tick.cursor || 'pointer' : 'pointer',
        plotBorderData = chart.systemConf.chart.plot.border,
        minorGridValues = args.minorGrid,
        isLevelType = axis.ticks.isHierarchialLevelType();

      var epsilon = 1e-6;

      var values = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments) : scale1.domain() : tickValues,
        format = tickFormat == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments) : identity$1 : tickFormat,
        spacing = isInline && !isInwardPlot ? tickObj.longTickSize[w] : Math.max(tickSizeInner, subTickSize, 0) + tickPadding,
        tickmarkStart = isInline && !isInwardPlot ? tickObj.axisgroup[w] : 0,
        range = scale1.origRange ? scale1.origRange : scale1.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale1.bandwidth ? scale1.discreteWidth ? isLevelType ? number$1 : center1 : center$1 : number$1)(scale1.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll('.domain').data([null]),
        tick = selection.
        selectAll('.tick').
        data(values, scale1).
        order(),
        tickExit = tick.exit(),
        tickEnter = tick.
        enter().
        append('g').
        attr('class', 'tick'),
        minorTicks = tick.select('line.minorTicks'),
        majorTicks = gridSize && griddata.show ? tick.select('line.majorTicks') : tick.select('line.majorTicks').remove(),
        ticklabel = tick.select('text').attr('class', 'ticklabel');

      // minor grid
      showMinorGrid = showMinorGrid && isArray(minorGridValues);
      isSubTickMarkShow = isSubTickMarkShow && isArray(minorGridValues);

      var subGridGroup = createElement('g', '.minorGrid', showMinorGrid ? [1] : [], selection);
      var minorGrids = createElement('line', '.minor-grid', showMinorGrid ? minorGridValues : [], subGridGroup);

      // minor grid
      var subTicksGroup = createElement('g', '.subTicks', isSubTickMarkShow ? [1] : [], selection);
      var subTicks = createElement('line', '.sub-ticks', isSubTickMarkShow ? minorGridValues : [], subTicksGroup);

      var transition_ = chart.racing && chart.racing.syncTransition || selection.transition(context);

      path = path.
      merge(path.enter().insert('path', '.tick')).
      attr('class', 'domain').
      styles({
        stroke: axisline.show === false ? 'transparent' : axisline.color || '#000',
        'stroke-width': pick(axisline.strokeWidth, 1),
        'stroke-dasharray': getDashArray(axisline.style, pick(axisline.strokeWidth, 1)),
        'stroke-linecap': getLineCap(axisline.lineCap, axisline.style)
      });

      tick = tick.merge(tickEnter);

      var applyMinorTickStyles = function applyMinorTickStyles(selection, config, size, applyTransform) {
        if (applyTransform) {
          selection.attr('transform', function (d) {return transform(position(d));});
        }

        selection.
        attr("".concat(x, "1"), k * tickmarkStart).
        attr("".concat(x, "2"), k * tickmarkStart + m * size).
        styles({
          fill: 'none',
          'shape-rendering': 'crispedges',
          'stroke-width': config.strokeWidth,
          stroke: config.color
        });
      };

      // #ZC1998
      minorTicks = createElement('line', '.minorTicks', [1], tick);
      applyMinorTickStyles(minorTicks, tickmarkdata, tickSizeInner);

      //
      // .attr(`${x}1`, k * tickmarkStart)
      // .attr(`${x}2`, k * tickmarkStart + m * tickSizeInner)
      // .styles({
      //     fill: 'none',
      //     'shape-rendering': 'crispedges',
      //     'stroke-width': tickmarkdata.strokeWidth,
      //     stroke: tickmarkdata.color
      // });

      if (subtickmark) {
        applyMinorTickStyles(subTicks, subtickmark, subTickSize, true);
      }

      // subTicks
      //     .attr('transform', d => transform(position(d)))
      //     .attr(`${x}1`, k * tickmarkStart)
      //     .attr(`${x}2`, k * tickmarkStart + m * minorTickSize)
      //     .styles({
      //         fill: 'none',
      //         'shape-rendering': 'crispedges',
      //         'stroke-width': minorTickmarkdata.strokeWidth,
      //         stroke: minorTickmarkdata.color
      //     });

      //
      var applyGridStyles = function applyGridStyles(selection, config) {
        var strokeWidth = pick(config.strokeWidth, 1),
          strokeDashArray = getDashArray(config.style, strokeWidth),
          strokeLineCap = getLineCap(config.lineCap, config.style);

        // #ZC1998
        selection.
        attr('stroke', '#000').
        attrs({
          x1: gridSize.x1,
          y1: gridSize.y1,
          x2: gridSize.x2,
          y2: gridSize.y2
        }).
        styles({
          fill: 'none',
          'shape-rendering': 'crispedges',
          'stroke-width': strokeWidth,
          stroke: config.color,
          'stroke-dasharray': strokeDashArray,
          'stroke-linecap': strokeLineCap
        });
      };

      if (renderGrid && gridSize && showGrid) {
        // apply major grid styles
        majorTicks = createElement('line', '.majorTicks', [1], tick);
        applyGridStyles(majorTicks, griddata);
      }

      if (renderGrid && showMinorGrid && gridSize) {
        // apply styles to minor grid
        // apply the transform
        minorGrids.attr('transform', function (d) {return transform(position(d));});
        applyGridStyles(minorGrids, minorGridData);
      }

      var hierarchy = [ticklabeldata, chart.systemConf.chart, chart.systemConf.canvas, $ZCG],
        fSize = utils.getVal(getValByPriority(hierarchy, 'fontSize')),
        fFamily = getValByPriority(hierarchy, 'fontFamily'),
        fWeight = getValByPriority(hierarchy, 'fontWeight'),
        fStyle = getValByPriority(hierarchy, 'fontStyle'),
        fShadow = getValByPriority(hierarchy, 'textShadow'),
        fColor = getValByPriority(hierarchy, 'fontColor'),
        txtDec = getValByPriority(hierarchy, 'textDecoration'),
        strokeColor = getValByPriority(hierarchy, 'strokeColor');
      // #ZC2801 subTickSize
      var rotationInfo = getTickRotateInfo(orient, rotation, null, null, Math.max(tickmarkdata.size, subTickSize), tickPadding, tickObj);

      ticklabel = ticklabel.merge(tickEnter.append('text')); //TODO Check appending ticklabels

      var ticklabelPosition = function ticklabelPosition(d, attr, val, callback) {
        if (callback) {
          var customTickTransform = invokeFunction(callback, d, scale1, chart);
          val += attr == 'x' ? customTickTransform[0] : customTickTransform[1];
        }
        return val;
      };
      if (renderTicklabel) {
        ticklabel.
        attr('class', 'ticklabel').
        style('font-size', "".concat(fSize, "px")).
        style('font-family', fFamily).
        style('font-weight', fWeight).
        style('font-style', fStyle).
        style('text-shadow', fShadow).
        style('text-decoration', txtDec).
        style('fill', fColor).
        style('text-anchor', rotationInfo.textAnchor).
        style('cursor', cursor).
        style(x, l * spacing).
        attr(x, function (d) {
          return ticklabelPosition(d, x, l * spacing, tickTransform);
        }).
        attr(y, function (d) {
          return ticklabelPosition(d, y, 0, tickTransform);
        }).
        attr('dy', function (d, i) {
          return tickObj && tickObj.mode == 'zigzag' && i % 2 && rotationInfo.dy1 ? rotationInfo.dy1 : rotationInfo.dy;
        }).
        attr('transform', function (d) {
          var t = [0, 0];
          if (tickTransform) {
            t = invokeFunction(tickTransform, d, scale1, chart);
          }
          return "rotate(".concat(rotationInfo.rotate[0], " ").concat(rotationInfo.rotate[1] + t[0], " ").concat(rotationInfo.rotate[2] + t[1], ")");
        });
        updateMinmaxlabelPosition(ticklabel, orient, rotationInfo, ticklabeldata, data, scale1, chart);
        if (axis.ticks.isHierarchialLevelType()) {
          ticklabel.call(centeringTicklabel, scale1, orient);
        }
      }
      //HANDLE OVERFLOW MISMATCH occur if transition applied to tick transform.
      //Need to handle overlap by data and scale, not by posiiton
      if (chart.racing && chart.racing.syncTransition) {
        tick.transition(transition_).attr('transform', function (d) {
          return transform(position(d));
        });
      } else {
        tick.attr('transform', function (d) {
          return transform(position(d));
        });
      }

      if (context !== selection) {
        // path = path.transition(context);
        tick = tick.transition(context);
        minorTicks = minorTicks.transition(context);
        ticklabel = ticklabel.transition(context);
        minorGrids = minorGrids.transition(context);
        subTicks = subTicks.transition(context);

        // TODO AARTHI DOUBT
        tickExit = tickExit.
        transition(transition_).
        attr('opacity', epsilon).
        attr('transform', function (d) {
          return isFinite(d = position(d)) ? transform(d) : this.getAttribute('transform');
        });

        tickEnter.attr('opacity', epsilon).attr('transform', function (d) {
          var p = this.parentNode.__axis;
          return transform(p && isFinite(p = p(d)) ? position(d) : position(d));
        });
      }

      tickExit.remove();

      path.attr(
      'd',
      orient === 'left' || orient == 'right' ? "M".concat(
      k * (tickSizeOuter + tickmarkStart), ",").concat(range0).concat(h, "0.5V").concat(range1, "H").concat(k * (tickSizeOuter + tickmarkStart)) : "M".concat(
      range0, ",").concat(k * tickSizeOuter, "V0.5H").concat(range1, "V").concat(k * tickSizeOuter));


      tick.attr('opacity', 1).attr('transform', function (d) {
        return transform(position(d));
      });
      if (tickObj && tickObj.isInline && defined(plotBorderData) && plotBorderData.show === true) {
        var isLeftOrRight = orient == 'left' || orient == 'right',
          translateIndex = isLeftOrRight ? 1 : 0,
          pos = isLeftOrRight ? fSize * parseFloat(rotationInfo.dy) : 0,
          margin = isLeftOrRight ?
          [0, chart.plotarea.height] :
          [chart.plotarea.left + chart.plotarea.left * 0.05, chart.plotarea.width + chart.plotarea.width * 0.05];
        tick.style('display', function () {
          var translate = getSvgTransform(this).translate[translateIndex];
          return isWithinRange$1(pos + translate, margin) ? '' : 'none';
        });
      }
      minorTicks.attr("".concat(x, "2"), k * tickmarkStart + m * tickSizeInner);

      selection.
      filter(entering).
      attr('fill', 'none').
      attr('font-size', 10).
      attr('font-family', 'sans-serif').
      attr('text-anchor', orient === 'right' ? 'start' : orient === 'left' ? 'end' : 'middle');

      selection.each(function () {
        this.__axis = position;
      });

      // ticklabel
      //     .attr(x, k * spacing);
      if (renderTicklabel) {
        ticklabel.each(format);

        if (ticklabeldata.tooltip === true) {
          ticklabel.each(function (d) {
            addSVGtitleEle(d3_select(this), this.formattedVal);
          });
        }
      }
    }

    //$Id$

    axis.get = function () {
      var axisComp;
      var scaleObj,
        ticks,
        tickArguments = [],
        tickValues = null,
        tickFormat = null,
        tickSizeInner = 6,
        tickSizeOuter = 6,
        subTickSize = 6,
        tickPadding = 3,
        changeOfOrient,
        changeOfTickOrient;

      var majorTicks = null,
        plotarea,
        ticklabeldata,
        tickmarkdata,
        labeldata,
        griddata,
        minorGridData,
        subTickMarkData,
        tickLabelWidth = null,
        tickRotation = 0,
        systemconf,
        chartObj,
        preCalcTickLen,
        orient,
        tickOrient,
        columnIndices,
        isMultiLineTick,
        animationDuration,
        minorGrid,
        isPolar;

      function chart(selection, type, axisOrder, redraw) {
        selection.each(function (data) {
          var container = d3_select(this);

          labeldata = data.label;
          ticklabeldata = data.ticklabel;
          tickmarkdata = data.tickmark;
          griddata = data.grid;
          minorGridData = data.minorGrid || {};
          subTickMarkData = data.subtickmark || {};

          var dataSplicer = chartObj.dataSplicer,
            metadata_columns = dataSplicer.getColumns();

          var axisObj = getAxisObject(chartObj, type, axisOrder),
            tickComp = axisObj.ticks,
            tickObj = tickComp.tickValueObj,
            hierarchical = chartObj.dataObject.hierarchical,
            isCategoryhierarchical = chartObj.dataObject.categoryHierarchy,
            isBranchType = isCategoryhierarchical && isBranchAxis(type, axisOrder, chartObj),
            isGridShow = griddata.show,
            hasMinorGridPositions = isArray$1(minorGrid) && minorGrid.length > 0,
            isMinorGridShow = minorGridData.show && hasMinorGridPositions,
            isSubTickMarkShow = (subTickMarkData.count > 0 || defined(subTickMarkData.interval)) && hasMinorGridPositions,
            isHierarchialLevelType = tickComp.isHierarchialLevelType(),
            hasCustomTickLabel = defined(ticklabeldata.showAs);

          tickRotation = pick(tickRotation, 0);
          var rotation = tickRotation < 0 ? 360 - mathAbs(tickRotation) : tickRotation;
          rotation = rotation > 360 ? mathAbs(rotation) - 360 : rotation;

          if (changeOfOrient) {
            container.
            selectAll('g.axisgroup').
            selectAll('*').
            remove(); //To retain axislabel we are removing only de generated axisgroup

            container.selectAll('g.axisgroup').attr('transform', null);

            container.
            selectAll('g.axislabelgroup').
            attr('transform', null).
            attr('clip-path', null);
          }
          var g = appendEle(container, 'g', [data], '.', 'class', 'axisgroup');
          if (changeOfTickOrient) {
            container.selectAll("g#ticklabelG_".concat(chartObj.id)).remove();
          }
          var tickLabelInlineG;
          if (tickObj && tickObj.inlineToPlot) {
            container.
            selectAll('g.axisgroup').
            selectAll('*').
            remove();

            var gId = "ticklabelG_".concat(chartObj.id);
            tickLabelInlineG = appendEle(container, 'g', [1], '#', 'id', gId);
            tickLabelInlineG.style('pointer-events', 'visible');
            var shadowEle = appendEle(chartObj.staticPaneSVG, 'use', [1]);
            shadowEle.attr('xlink:href', "#ticklabelG_".concat(chartObj.id));
            shadowEle.attr('x', container.attr('x'));
            shadowEle.attr('y', container.attr('y'));
          }

          if (ticks) {
            axisComp.ticks(ticks[0], ticks[1]);
          }

          // add clip-path
          if (
          chartObj._isAxisCategory() &&
          type !== 'clr' &&
          !(!chartObj.dataObject.isAxisCategory && hierarchical && hierarchical.pivot && isLeafAxis(type, axisOrder, chartObj)) // Pivot non axis chart(Web chart) - no clip path for leaf axis
          ) {
            var id = getClippathIdForAxis(chartObj, tickObj, orient, type, axisOrder);
            g.attr('clip-path', "url(".concat(chartObj.defsLocation, "#").concat(id, ")"));
            if (tickObj.inlineToPlot) {
              tickLabelInlineG.attr('clip-path', "url(".concat(chartObj.defsLocation, "#").concat(id, ")"));
            }
          }

          animationDuration = chartObj.axes.animationDuration;

          //call d3-axis
          var args = {
            tickValues: tickValues,
            tickFormat: tickFormat,
            tickSizeInner: tickSizeInner,
            tickSizeOuter: tickSizeOuter,
            subTickSize: subTickSize,
            gridSize: majorTicks,
            tickPadding: tickPadding,
            orient: orient,
            rotation: rotation,
            scale: scaleObj,
            chart: chartObj,
            axis: axisObj,
            minorGrid: minorGrid,
            syncTransition: chartObj.racing && chartObj.racing.syncTransition
          };
          tickComp.majorTicks = majorTicks;
          var transition_ = chartObj.racing && chartObj.racing.syncTransition || g.transition().duration(animationDuration);
          /*
          Use axis parser
           */
          var isLinear = isPolar ? false : true,
            preRenderC = axisObj.prerenderComp,
            positionH,
            axisTitleH,
            markInfo,
            markExtender,
            marks;
          if (isLinear) {
            var markParser = 'cartesian.axisMarks';
            if (preRenderC.axisView) {
              markParser = preRenderC.axisView.conf.markParser || markParser;
              markExtender = preRenderC.axisView.conf.markExtender;
            }
            positionH = getPositionForTicks.call(axisObj.prerenderComp, true, scaleObj);
            axisTitleH = AxisRegistry.get('cartesian.axisTitle').call(axisObj.prerenderComp);
            markInfo = AxisRegistry.get(markParser).call(preRenderC);
          }
          if (type === 'clr' || hasCustomTickLabel || isMultiLineTick) {
            args.renderGrid = true;
            args.renderTicklabel = tickObj.inlineToPlot ? false : true;
            args.isGridShow = isGridShow;

            if (isLinear) {
              marks = markInfo(positionH, axisTitleH, args, transition_, g).mark;
              if (markExtender) {
                marks = invokeFunction(markExtender, marks, preRenderC);
              }
              renderDom(marks, g);
            } else {
              g.call(d3axis, args, data);
            }

            // g.call(d3axis, args, data);
            if (tickObj.inlineToPlot) {
              args.renderGrid = false;
              args.renderTicklabel = true;
              marks = markInfo(positionH, axisTitleH, args, transition_, g).mark;
              if (markExtender) {
                marks = invokeFunction(markExtender, marks.mark, preRenderC);
              }
              renderDom(marks, tickLabelInlineG);
              // tickLabelInlineG.call(d3axis, args, data);
            }
          } else {
            args.renderGrid = true;
            args.renderTicklabel = tickObj.inlineToPlot ? false : true;
            args.isGridShow = isGridShow;
            args.isMinorGridShow = isMinorGridShow;
            args.isSubTickMarkShow = isSubTickMarkShow;

            if (isLinear) {
              marks = markInfo(positionH, axisTitleH, args, transition_, g).mark;
              if (markExtender) {
                marks = invokeFunction(markExtender, marks, preRenderC);
              }
              renderDom(marks, g);
            } else {
              g.transition(transition_).call(d3axis, args, data);
            }
            // g.transition(transition_).call(d3axis, args, data);
            if (tickObj.inlineToPlot) {
              args.renderGrid = false;
              args.renderTicklabel = true;
              tickLabelInlineG.
              transition().
              duration(150).
              call(d3axis, args, data);
            }
          }

          var tickG0 = g.selectAll('.tick');
          var ticks1 =
          tickValues == null ?
          scaleObj.ticks ?
          scaleObj.ticks.apply(scaleObj, [tickG0.nodes().length]) :
          scaleObj.domain() :
          tickValues;
          var tickData = isLinear ? preRenderC.axisTicks.tickInfo.ticklabelObj : ticks1,
            tickDataAccessor = isLinear ? function (d) {return preRenderC.axisTicks.tickInfo.scale(d);} : scaleObj;
          var tickG = g.selectAll('.tick').data(tickData, tickDataAccessor);
          var majorticksUpdate = tickG.select('line.majorTicks');
          var axisLabel = container.selectAll('text.axislabel');

          // Apply ticklabel properties

          var ticklabelG_ = tickObj.inlineToPlot ? tickLabelInlineG : g,
            ticklabels = ticklabelG_.selectAll('text.ticklabel').data(tickData, tickDataAccessor),
            tickImages = hasCustomTickLabel ? g.selectAll(' g.image').data(tickData, tickDataAccessor) : null;
          if (isHierarchialLevelType) {
            extendTickmarkLineLength(tickG, type, axisOrder, 'minorTicks');
            if (isBranchType && isGridShow) {
              extendTickmarkLineLength(tickG, type, axisOrder, 'majorTicks');
            }
          }
          var rotationInfo = getTickRotateInfo(orient, rotation, ticklabels, axisComp, tickmarkdata.size);

          var columnInfo = {
            data: columnIndices.map(function (d) {
              return mergeJSON$1(
              metadata_columns[d],
              {
                columnindex: d
              },
              true);

            })
          };
          bindEventHandlerForTicks(chartObj, ticklabelG_, ticklabels, tickImages, ticklabeldata, columnInfo, type, axisOrder);

          //Add attribute level to the ticks
          if (type !== 'clr' && chartObj.dataObject.hierarchical && chartObj.dataObject.hierarchical.categoryTree) {
            setLevelAttributeForTick(tickG, ticklabels, axisLabel, type, axisOrder, columnInfo.data[0].datatype);
          }

          // Apply tickmarks properties
          if (!isHierarchialLevelType && tickmarkdata.align == 'between') {
            drawTickLinesBetweenTicklabels(scaleObj, tickG, 'minorTicks', type, axisOrder);
          }
          if (type !== 'clr') {
            axisLabel = container.selectAll('text.axislabel');
            var axisAreaDim = getAxisAreaDim(type, axisOrder, orient, chartObj, plotarea);
            // axisLabel.transformLabel(preCalcTickLen, axisAreaDim, orient);
            var axisLabelRotation = orient == 'left' ? 270 : orient == 'right' ? 90 : 0;
            handleOverflowTicks(axisLabel, orient, chartObj, axisLabelRotation, 'ellipsis', scaleObj, g, chart, 'axislabel');
            if (labeldata.tooltip === true) {
              addSVGtitleEle(axisLabel, axisTitleH.text);
            }
          }

          if (majorTicks && isGridShow) {
            if ((scaleObj.bandwidth || scaleObj.discreteWidth) && tickmarkdata.align == 'between') {
              drawTickLinesBetweenTicklabels(scaleObj, tickG, 'majorTicks', type, axisOrder);
            }
            if (type !== 'clr') {
              //To bring axis line front, make grid lines overlapped with axis line transparent
              var range = scaleObj.range();
              var firstVal =
              chart.tickValues() == null ?
              null :
              scaleObj(chart.tickValues()[0]) + (scaleObj.bandwidth ? scaleObj.bandwidth() / 2 : 0);
              var plotBorderData = chartObj.systemConf.chart.plot.border,
                type_opp = type === 'x' ? 'y' : 'x',
                oppositeAxisData = getAxisData(chartObj, type_opp, 0, false);

              var plotareaBorderColor = plotBorderData === true ? plotBorderData.color : oppositeAxisData.axisline.color;
              if (
              defined(firstVal) &&
              griddata.color !== 'transparent' &&
              plotareaBorderColor !== 'transparent' &&
              range[0] === firstVal &&
              !(type == 'y' && isCategoryhierarchical && hierarchical.hasRows()))
              {
                d3_select(majorticksUpdate.nodes()[0]).style('stroke', 'transparent');
              }
            }
          }

          //BaseLine
          var baseLineData = data.baseline;
          if (baseLineData != null) {
            var baseLine = appendEle(
            g,
            'line',
            baseLineData.show === true && scaleObj.domain()[0] <= baseLineData.value && baseLineData.value < scaleObj.domain()[1] ?
            [1] :
            [],
            '.',
            'class',
            'zeroBase');

            baseLine.
            attrs({
              x1: orient == 'left' || orient == 'right' ? 0 : scaleObj(baseLineData.value),
              y1: orient == 'left' || orient == 'right' ? scaleObj(baseLineData.value) : -plotarea.height,
              x2: orient == 'left' || orient == 'right' ? plotarea.width : scaleObj(baseLineData.value),
              y2: orient == 'left' || orient == 'right' ? scaleObj(baseLineData.value) : 0
            }).
            styles({
              fill: NONE,
              stroke: baseLineData.color,
              'shape-rendering': 'crispedges',
              'stroke-width': baseLineData.strokeWidth
            });
          }
        });
        return chart;
      }

      chart.axis = axisComp;

      chart.scale = function (_) {
        if (!arguments.length) {
          return scaleObj;
        }
        scaleObj = _;
        if (axisComp) {
          axisComp.scale(scaleObj);
        } else {
          axisComp = d3_axis(orient, scaleObj);
          axisComp.scale(scaleObj);
          // d3_rebind(chart, axis, 'ticks', 'tickValues', 'tickSubdivide', 'tickSize', 'tickSizeOuter', 'tickPadding', 'tickFormat');
          // d3_rebind(chart, scale, 'domain', 'range', 'rangeBand', 'rangeBands', 'ticks');
        }

        return chart;
      };
      chart.systemconf = function (_) {
        if (!arguments.length) {
          return systemconf;
        }
        systemconf = _;
        return chart;
      };
      chart.orient = function (_) {
        if (!arguments.length) {
          return orient;
        }
        if (defined(orient)) {
          //Axis rotated in redraw, need to re-initiate the axis component
          if (orient != _) {
            changeOfOrient = true;
            chartObj.staticPaneSVG.
            selectAll('g.plotareaBorder-property').
            selectAll('*').
            remove(); //#ZC1295
            axisComp = null;
          } else {
            changeOfOrient = false;
          }
        }
        orient = _;
        return chart;
      };

      chart.tickOrient = function (_) {
        if (!arguments.length) {
          return tickOrient;
        }
        if (defined(tickOrient)) {
          //Axis rotated in redraw, need to re-initiate the axis component
          if (tickOrient != _) {
            changeOfTickOrient = true;
          } else {
            changeOfTickOrient = false;
          }
        }
        tickOrient = _;
        return chart;
      };

      chart.tickArguments = function (_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.prototype.slice.call(_), chart) : tickArguments.slice();
      };

      chart.tickValues = function (_) {
        return arguments.length ? (
        tickValues = _ == null ? null : Array.prototype.slice.call(_), chart) :
        tickValues && tickValues.slice();
      };

      chart.tickFormat = function (_) {
        return arguments.length ? (tickFormat = _, chart) : tickFormat;
      };

      chart.tickSize = function (_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, chart) : tickSizeInner;
      };

      chart.subTickSize = function (_) {
        return arguments.length ? (subTickSize = +_, chart) : subTickSize;
      };

      chart.tickSizeInner = function (_) {
        return arguments.length ? (tickSizeInner = +_, chart) : tickSizeInner;
      };

      chart.tickSizeOuter = function (_) {
        return arguments.length ? (tickSizeOuter = +_, chart) : tickSizeOuter;
      };

      chart.tickPadding = function (_) {
        return arguments.length ? (tickPadding = +_, chart) : tickPadding;
      };
      chart.ticks = function () {
        if (!arguments.length) {
          return ticks;
        }
        ticks = arguments;
        return chart;
      };

      chart.majorTicks = function (_) {
        if (!arguments.length) {
          return majorTicks;
        }
        majorTicks = _;
        return chart;
      };

      chart.minorGrid = function (_) {
        if (!arguments.length) {
          return minorGrid;
        }
        minorGrid = _;
        return chart;
      };

      chart.plotarea = function (_) {
        if (!arguments.length) {
          return plotarea;
        }
        plotarea = _;
        return chart;
      };

      chart.tickLabelWidth = function (_) {
        if (!arguments.length) {
          return tickLabelWidth;
        }
        tickLabelWidth = _;
        return chart;
      };
      chart.tickRotation = function (_) {
        if (!arguments.length) {
          return tickRotation;
        }
        tickRotation = _;
        return chart;
      };
      chart.preCalcTickLen = function (_) {
        if (!arguments.length) {
          return preCalcTickLen;
        }
        preCalcTickLen = _;
        return chart;
      };
      chart.chartObj = function (_) {
        if (!arguments.length) {
          return chartObj;
        }
        chartObj = _;
        return chart;
      };
      chart.columnIndices = function (_) {
        if (!arguments.length) {
          return columnIndices;
        }
        columnIndices = _;
        return chart;
      };
      chart.isMultiLineTick = function (_) {
        if (!arguments.length) {
          return isMultiLineTick;
        }
        isMultiLineTick = _;
        return chart;
      };

      chart.polar = function (_) {
        if (!arguments.length) {
          return isPolar;
        }
        isPolar = _;
        return chart;
      };

      //To align the tick lines (grid lines or tick mark) in between the ticklabels
      function drawTickLinesBetweenTicklabels(scaleObj, tickG, type, axisType, axisOrder) {
        /*
        Remove old minor/major tickAlign elements
         */
        tickG.selectAll("line#".concat(type, "Align")).remove();

        var x1,
          y1,
          x2,
          y2,
          ticks = tickG.nodes(),
          startTickG = d3_select(tickG.node()),
          lastTickG = d3_select(ticks[ticks.length - 1]),
          tickLineNode = tickG.selectAll("line.".concat(type, ":not(#minorTicksAlign)")), // css selector is faster.
          lastTickLineNode = lastTickG.selectAll("line.".concat(type)),
          newStartTickLineNode = appendEle(startTickG, 'line', [1], '#', 'id', "".concat(type, "Align")),
          axisObj = getAxisObject(chartObj, axisType, axisOrder),
          isHierarchialLevelType = axisObj.ticks.isHierarchialLevelType();

        var adjustDistance = getNewPositionForTickmark(scaleObj, isHierarchialLevelType);
        if (type == 'minorTicks') {
          x2 = orient == 'bottom' || orient == 'top' ? 0 : -tickmarkdata.size,
          y2 = orient == 'bottom' ? tickmarkdata.size : orient == 'top' ? -tickmarkdata.size : 0;
          applyStyleForTickmark(tickmarkdata, newStartTickLineNode);
        } else {
          var ticklabelWidth = getAxisAreaForLowerOrder(axisType, axisOrder, chartObj);
          var key = orient == 'left' || orient == 'right' ? 'x1' : 'y1',
            value = orient == 'left' || orient == 'top' ? ticklabelWidth : -ticklabelWidth;
          x1 = key == 'x1' ? value : majorTicks.x1, y1 = key == 'y1' ? value : majorTicks.y1;
          x2 = majorTicks.x2, y2 = majorTicks.y2;
          applyStyleForGrid(griddata, newStartTickLineNode);
        }

        if (scaleObj.bandwidth || scaleObj.discreteWidth) {
          tickLineNode.attr('transform', "translate(".concat(adjustDistance.mid, ")"));
          lastTickLineNode.attr('transform', "translate(".concat(adjustDistance.end, ")"));
          newStartTickLineNode.attr('transform', "translate(".concat(adjustDistance.start, ")")).attrs({
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          });
        } else {
          var co = 0;
          tickLineNode.attr('transform', function (d, i) {
            var pos = getNewPositionForTickmark(scaleObj, isHierarchialLevelType, co++);
            return "translate(".concat(pos.mid, ")");
          });
          lastTickLineNode.attr('transform', "translate(".concat(adjustDistance.end, ")"));
          newStartTickLineNode.attr('transform', "translate(".concat(adjustDistance.start, ")")).attrs({
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          });
        }
      }

      function getNewPositionForTickmark(scaleObj, isHierarchialLevelType, index) {
        var startPos, midPos, endPos, value_1, value_2;
        if (scaleObj.bandwidth && !isHierarchialLevelType) {
          var rangeBand = scaleObj.bandwidth(),
            ordinalRanges = scaleObj.ordinalRange,
            outerPadding = scaleObj.outerPaddingPx + rangeBand / 2, //(ordinalRanges[0] - rangeExtent[0])+(rangeBand/2),
            diffBand = scaleObj.domain().length > 1 ? ordinalRanges[1] - ordinalRanges[0] - rangeBand : 0;
          value_1 = rangeBand / 2 + diffBand / 2, value_2 = mathMin(outerPadding, value_1);
        } else if (isHierarchialLevelType) {
          value_1 = 0, value_2 = 0;
        } else {
          var _categories;
          if (chartObj.dataObject.hierarchical) {
            var nodelist = chartObj.dataObject.hierarchical.pivotLayout.getRootNodeList('column');
            _categories = nodelist.getDomainForCluster(0);
          } else {
            _categories = chart.tickValues();
          }
          // var categories = chartObj.dataObject.hierarchical ? chartObj.dataObject.hierarchical.leaves.key.list : chart.tickValues(),
          var continousRangeBand = scale.getContinuousRangeBand(scaleObj, _categories, index),
            rangeBand = continousRangeBand.rangeBand;
          value_1 = rangeBand, value_2 = continousRangeBand.outerPaddingInPixel;
        }

        // midPos = (orient == "bottom" || orient == "top") ? (value_1 + ",0") : ("0,"+value_1),
        // startPos = (orient == "bottom" || orient == "top") ? ((-value_2) + ",0") : ("0,"+(-value_2)),
        // endPos = (orient == "bottom" || orient == "top") ? (value_2 + ",0") : ("0,"+value_2);

        //0.5 compensation for new change in D3V4 translate
        var adjustFactor = scaleObj.bandwidth ? 0.5 : 0;
        if (orient === 'bottom' || orient == 'top') {
          startPos = "".concat(-(value_2 - adjustFactor), ",0");
          midPos = "".concat(value_1 + adjustFactor, ",0");
          endPos = "".concat(value_2 + adjustFactor, ",0");
        } else {
          startPos = "0,".concat(-value_2 + adjustFactor);
          midPos = "0,".concat(value_1 + adjustFactor);
          endPos = "0,".concat(value_2 + adjustFactor);
        }

        return {
          start: startPos,
          mid: midPos,
          end: endPos
        };
      }

      // For hierarchy level type, tickmark line should get extend based on the last rendered axis ticklabel width

      function extendTickmarkLineLength(tickG, type, axisOrder, tickType) {
        var axisObj = getAxisObject(chartObj, type, axisOrder),
          axisComp1 = axisObj.component,
          tickConfig = tickType == 'minorTicks' ? tickmarkdata : griddata;
        var tickLineNode = tickG.selectAll("line.".concat(tickType));
        var ticklabelWidth = getAxisAreaForLowerOrder(type, axisOrder, chartObj);
        axisObj.ticks.tickValueObj.tickMarkSize = ticklabelWidth + axisComp1.tickSize();
        var index = axisOrder;

        var key = orient == 'left' || orient == 'right' ? 'x1' : 'y1',
          value = orient == 'left' || orient == 'top' ? ticklabelWidth : -ticklabelWidth;

        var nullKey = orient == 'left' ? 'y1' : 'x1';

        var pivotLayout = chartObj.dataObject.hierarchical.pivotLayout;
        var finalDepth = chartObj.axes[type].count - 1;
        if (index === finalDepth) {
          var y2 = orient == 'bottom' ? tickmarkdata.size : 0;
          var ticks = tickG.nodes();
          tickG.selectAll("line#".concat(tickType, "Align")).remove();
          var endTickG = d3_select(ticks[ticks.length - 1]);
          var newEndTickmark = appendEle(endTickG, 'line', [1], '#', 'id', "".concat(tickType, "Align"));
          var scaleObj = axisObj.scale;
          var domainLen = scaleObj.domain().length;
          var toTranslate =
          orient == 'top' || orient == 'bottom' ? "".concat(
          scaleObj.discreteWidth(domainLen - 1), ",0") : "0,".concat(
          scaleObj.discreteWidth(domainLen - 1));
          var key2 = orient == 'left' || orient == 'right' ? 'x2' : 'y2',
            value2;
          if (tickType == 'minorTicks') {
            value2 = orient == 'left' || orient == 'top' ? -tickmarkdata.size : tickmarkdata.size;
          } else {
            value2 = orient == 'left' || orient == 'top' ? ticklabelWidth + plotarea.width : -(ticklabelWidth + plotarea.height);
          }

          newEndTickmark.
          attr('transform', "translate(".concat(toTranslate, ")")).
          attr(key, value).
          attr(key2, value2);
          if (tickType == 'minorTicks') {
            applyStyleForTickmark(tickConfig, newEndTickmark);
          } else {
            applyStyleForGrid(tickConfig, newEndTickmark);
          }
        }

        tickLineNode.attr(nullKey, null);
        tickLineNode.attr(key, value);
      }

      function applyStyleForTickmark(data, ele) {
        ele.styles({
          fill: 'none',
          'shape-rendering': 'crispedges',
          'stroke-width': data.strokeWidth,
          stroke: data.color
        });
      }
      function applyStyleForGrid(data, ele) {
        var strokeWidth = pick(data.strokeWidth, 1),
          strokeDashArray = getDashArray(data.style, strokeWidth),
          strokeLineCap = getLineCap(data.lineCap, griddata.style);
        ele.styles({
          fill: 'none',
          'shape-rendering': 'crispedges',
          'stroke-width': strokeWidth,
          stroke: griddata.color,
          'stroke-dasharray': strokeDashArray,
          'stroke-linecap': strokeLineCap
        });
      }

      function setLevelAttributeForTick(tickG, ticklabels, axisLabel, type, axisOrder, datatype) {
        var pivotLayout = chartObj.dataObject.hierarchical.pivotLayout,
          tag = type == 'x' ? 'column' : 'row',
          nodeList = pivotLayout.getRootNodeList(tag),
          isBranchType = isBranchAxis(type, axisOrder, chartObj),
          nodes,
          nodeIdx;
        if (isBranchType) {
          var branchIdx = axisOrder - nodeList.getLeavesCount(),
            nodes = nodeList.getBranchNodes(branchIdx);
        } else {
          var hasSplitLeafAxis =
          tag == 'column' && nodeList.splitColumnLeaves && chartObj.axes[type].leaves.length ||
          tag == 'row' && datatype == 'numeric';
          nodes = hasSplitLeafAxis ? nodeList.getBranchNodes(0) : nodeList.getClusterNodes(0);
          nodeIdx = hasSplitLeafAxis ? chartObj.axes[type].leaves[axisOrder].parentBranchIdx : null;
        }
        if (nodes) {
          tickG.
          attr('levelbycolumn', function (d, i) {
            var idx = pick(nodeIdx, i);
            return nodes[idx] ? nodes[idx].levelByColumn : null;
          }).
          attr('levelbyrow', function (d, i) {
            var idx = pick(nodeIdx, i);
            return nodes[idx] ? nodes[idx].levelByRow : null;
          });

          if (datatype == 'numeric') {
            axisLabel.attr('levelbycolumn', nodes[nodeIdx || 0].levelByColumn);
            axisLabel.attr('levelbyrow', nodes[nodeIdx || 0].levelByRow);
          }
          var cache = chartObj.cache.hierarchical && chartObj.cache.hierarchical[tag],
            key = tag == 'row' ? 'levelByRow' : 'levelByColumn';
          if (cache && cache.active) {
            var query = cache.query;
            ticklabels.style('opacity', function (d, i) {
              var idx = pick(nodeIdx, i),
                activeTick = nodes[idx][key].startsWith(query);
              if (activeTick) {
                return 1;
              } else {
                return 0.1;
              }
            });
          }
        }
      }

      return chart;
    };

    /**
     *
     * @param {Event} event
     * @param {Object} info data with column info
     * @param {Chart} chart chartInstance
     * @param {Boolean} isDefault if true sets default styles else doesn't
     */

    axis.TickLabelFilter = function (event, info, chart, isDefault, axisType) {
      info = info.data[0];

      //supports only for ORDINAL datatype
      if (info.datatype == NUMERIC_DATATYPE || info.datatype == TIME_DATATYPE) {
        return;
      }

      // create a cache to save the state
      if (!chart.cache.hierarchical) {
        chart.cache.hierarchical = {
          rows: {},
          columns: {}
        };
      }

      var hierarchical = chart.dataObject.hierarchical,
        itemIndex = info.itemIndex,
        tag = axisType == 'x' ? 'column' : 'row',
        cache = tag == 'row' ? chart.cache.hierarchical.rows : chart.cache.hierarchical.columns,
        nodeList = hierarchical.pivotLayout.getRootNodeList(tag),
        branchCount = nodeList.getCount(),
        leavesCount = nodeList.getLeavesCount(),
        axisOrder = info.axisOrder, // axisOrder starts from top to bottom
        depth = branchCount + leavesCount - axisOrder - 1, // depth starts from bottom to top  (axisOrder to depth)
        isBranchAxisType = isBranchAxis(axisType, axisOrder, chart),
        data = nodeList.getNodesAtDepth(axisOrder),
        currentData = data[itemIndex],
        selectedData = nodeList.getAllChildren(currentData),
        key = chart.dataObject.pivot ? tag == 'row' ? 'levelByRow' : 'levelByColumn' : 'level',
        oppositeKey = chart.dataObject.pivot ? tag == 'row' ? 'levelByColumn' : 'levelByRow' : 'level',
        oppositeTag = chart.dataObject.pivot ? tag == 'row' ? 'columns' : 'rows' : 'level',
        query = axis.TickLabelFilter.getQuery(selectedData[0], depth, key),
        query1 = chart.cache.hierarchical[oppositeTag].query;

      var cType = chart.chartTypes[0];

      if ((cType.name === 'area' || cType.name === 'line') && !isBranchAxisType) {
        return;
      }

      // to check the last tick label is clicked.
      cache.lastQuery = query;

      // apply default style
      if (isDefault) {
        var selection;
        if (query1) {
          var oldNodes = axis.TickLabelFilter.getSelectedNodes(chart, null, oppositeKey, query1);
          selection = oldNodes.selected;
        }
        var nodes = axis.TickLabelFilter.getSelectedNodes(chart, selection, key, query);
        axis.TickLabelFilter.getSelectedTickNodes(chart, nodes, axisType, axisOrder, itemIndex, query, key);
        applyDefaultStyles(chart, nodes, cache.query !== query);
      }

      // restore if same tick clicked twice
      if (cache.query === query) {
        if (isArray$1(cache.data)) {
          axis.TickLabelFilter.setState(cache.data, false);
        }
        // reset state to false
        cache.data = cache.query = cache.active = cache.depth = cache.itemIndex = cache.isLeaf = null; // clear it
      } else {
        // reset state to false
        if (isArray$1(cache.data)) {
          axis.TickLabelFilter.setState(cache.data, false);
        }
        // for current selection set to active mode
        axis.TickLabelFilter.setState(selectedData, true);
        cache.query = query;
        cache.data = selectedData;
        cache.active = true;
        cache.depth = depth;
        cache.itemIndex = itemIndex;
        cache.isLeaf = currentData.leaf;
      }
    };

    /**
     *
     * @param {Chart} chart
     * @param query
     * @param active
     */
    function applyDefaultStyles(chart, nodes, active) {
      if (!nodes) {
        return;
      }

      if (active === true) {
        nodes.selected.series.style('opacity', 1);
        nodes.unSelected.series.style('opacity', 0.1);

        nodes.selected.labels.style('opacity', 1);
        nodes.unSelected.labels.style('opacity', 0.1);

        nodes.reset.tick.style('opacity', 1);
        nodes.unSelected.tick.style('opacity', 0.1);
        nodes.selected.tick.style('opacity', 1);
      } else {
        nodes.selected.series.style('opacity', 1);
        nodes.unSelected.series.style('opacity', 1);

        nodes.selected.labels.style('opacity', 1);
        nodes.unSelected.labels.style('opacity', 1);

        nodes.unSelected.tick.style('opacity', 1);
        nodes.selected.tick.style('opacity', 1);
      }
    }
    axis.TickLabelFilter.getSelectedTickNodes = function (chart, parentObj, axisType, axisOrder, tickIndex, query, selector) {
      if (!parentObj) {
        return;
      }

      var parentWrap = chart.wrap.selectAll(".".concat(axisType, "-axis")),
        wrap = chart.wrap.selectAll(".".concat(axisType, "-axis-").concat(axisOrder));
      var tickSelected = wrap.selectAll("g.tick:nth-child(".concat(tickIndex + 2, ")")); // +2 refers for path.domain child and child index starts from 0

      parentObj.selected.tick = parentWrap.selectAll("g.tick[".concat(selector, "^=\"").concat(query, "\"]")).selectAll('text.ticklabel');
      parentObj.unSelected.tick = parentWrap.selectAll("g.tick:not([".concat(selector, "^=\"").concat(query, "\"])")).selectAll('text.ticklabel');
      parentObj.reset.tick = parentWrap.selectAll('g.tick').selectAll('text.ticklabel');

      return parentObj;
    };
    axis.TickLabelFilter.getSelectedNodes = function (chart, preSelection, selector, query) {
      var cType = chart.chartTypes[0],
        parent = preSelection ? preSelection.series : chart.svg.select('.seriesholder');
      var labels = preSelection ? preSelection.labels : chart.staticPaneSVG.select('g.labelholder');

      var querySelector = preSelection ? 'filter' : 'selectAll';

      var labelSelected = labels[querySelector]("text[".concat(selector, "^=\"").concat(query, "\"],") + "path[".concat(selector, "^=\"").concat(query, "\"]")),
        labelNotSelected = labels[querySelector]("text:not([level^=\"".concat(query, "\"]), ") + "path:not([".concat(selector, "^=\"").concat(query, "\"])"));

      var pointsSelected, pointsNotSelected;

      if (cType.name === 'bar' || cType.name === 'area' || cType.name === 'line') {
        pointsSelected = parent[querySelector]("path[".concat(selector, "^=\"").concat(query, "\"]"));
        pointsNotSelected = parent[querySelector]("path:not([".concat(selector, "^=\"").concat(query, "\"])"));
      } else if (cType.name === 'scatter' || cType.name === 'bubble') {
        pointsSelected = parent[querySelector]("g.scatter[".concat(selector, "^=\"").concat(query, "\"]"));
        pointsNotSelected = parent[querySelector]("g.scatter:not([".concat(selector, "^=\"").concat(query, "\"])"));
      } else {
        return;
      }

      return {
        selected: {
          labels: labelSelected,
          series: pointsSelected
        },
        unSelected: {
          labels: labelNotSelected,
          series: pointsNotSelected
        },
        reset: {}
      };
    };

    /**
     *
     * @param {[Array]} data array of data
     * @param {Boolean} isActive
     */
    axis.TickLabelFilter.setState = function (data, isActive) {
      var state = function state(point) {
        point.active = isActive;
      };
      data.forEach(state);
    };

    /**
     *
     * @param {Chart} chart
     * @param {Boolean} onDisable if the new series disabled.
     */
    axis.TickLabelFilter.updateTickEventHandler = function (chart, onDisable, axisType) {
      var tag = axisType == 'x' ? 'column' : 'row',
        cache = chart.cache.hierarchical && chart.cache.hierarchical[tag],
        onVisible = !onDisable;

      if (defined(cache) && defined(cache.data)) {
        var hierarchical = chart.dataObject.hierarchical,
          firstPoint;
        var key = tag == 'row' ? 'levelByRow' : 'levelByColumn';

        if (cache.data) {
          // for the visible point sorting and taking first point
          var visiblePoints = cache.data.filter(function (point) {
            return !point.seriesDisabled;
          });

          // when a series is made disable
          if (onDisable) {
            if (visiblePoints.length) {
              cache.query = axis.TickLabelFilter.getQuery(visiblePoints[0], cache.depth, key);
            } else {
              cache.query = '-1';
            }
          }

          // when a series is made visible
          if (onVisible) {
            firstPoint = visiblePoints[0];

            var indexes = firstPoint[key].
              split('_').
              slice(0, cache.depth + 1).
              map(Number),
              depth = indexes.length - 1,
              itemIndex = indexes[indexes.length - 1],
              columnList = hierarchical.pivotLayout.getRootNodeList('column'),
              branchCount = columnList.getCount(),
              leavesCount = columnList.getLeavesCount(),
              axisOrder = branchCount + leavesCount - depth - 1, //depth to axisorder
              parent = columnList.getNodesAtDepth(axisOrder),
              currentData = parent[itemIndex],
              // parent = hierarchical.getCategoriesByLevelIndices(indexes),
              data = columnList.getAllChildren(currentData);

            cache.query = axis.TickLabelFilter.getQuery(firstPoint, cache.depth, key);
            cache.data = data;
            axis.TickLabelFilter.setState(data, true);
          }
        }
      }
    };

    axis.TickLabelFilter.getQuery = function (point, depth, key) {
      key = key || 'level';
      var indexes = point[key].
      split('_').
      slice(0, depth + 1).
      map(Number);
      return "".concat(indexes.slice(0, depth + 1).join('_'), "_");
    };

    function PolarTickHandler(wrap, available, config, chartObj, scaleObj, axisComponent) {
      var overflow = config.textOverflow || 'ellipsis',
        _className = 'ticklabel',
        trimmed = false,
        edge = function edge(node, textBound) {
          var anchor = d3_select(node).attr('text-anchor'),
            gTransform = getSvgTransform(node.parentNode),
            gTranslate = gTransform.translate,
            textTransform = getSvgTransform(node),
            textTranslate = textTransform.translate,
            obj = {};

          if (anchor === MIDDLE_ALIGN) {
            var mid = (textBound.left + textBound.right) / 2;
            obj.left = mid - available;
            obj.right = mid + available;
          } else if (anchor === END_ALIGN) {
            obj.right = textBound.left + textBound.width;
            obj.left = obj.right - gTranslate[0] - textTranslate[0] - available;
          } else {
            obj.left = textBound.left;
            obj.right = obj.left - gTranslate[0] - textTranslate[0] + available;
          }

          trimmed = trimmed || textBound.left < obj.left || textBound.right > obj.right; // TODO: enhance

          return obj;
        },
        options = { edge: edge, type: 'polar' },
        args = [NULL$1, BOTTOM_ALIGN, chartObj, 0, overflow, scaleObj, wrap, axisComponent, _className, config, 0, options],
        overflowHandler = handleOverflowTicks.apply(void 0, args);

      return function () {
        var tickLabels = wrap.selectAll("".concat(TEXT_ELEMENT, ".").concat(_className));

        tickLabels.each(function (d, i) {
          overflowHandler(this, i);
        });

        chartObj.cache.polarAxis = { trimmed: trimmed }; // TODO: enhance
      };
    }

    //

    function PolarTickOverlap(wrap, scale) {
      var tickLabels = wrap.selectAll("".concat(TEXT_ELEMENT, ".ticklabel")),_getPartition =
        getPartition(tickLabels, scale),right = _getPartition.right,left = _getPartition.left,
        maxJumps = mathMax(findJumps(right), findJumps(left)),
        jump = 0;

      if (!maxJumps) {
        return;
      }

      tickLabels.each(function () {
        if (jump && jump <= maxJumps) {
          d3_select(this).style('display', 'none');
        }
        jump = jump === maxJumps ? 0 : jump + 1;
      });

      var visibleTickLabels = tickLabels.filter(function () {
        return d3_select(this).style('display') !== 'none';
      });var _getPartition2 =

      getPartition(visibleTickLabels, scale);right = _getPartition2.right;left = _getPartition2.left;
      maxJumps = mathMax(findJumps(right), findJumps(left));

      if (!maxJumps) {
        return;
      }

      handleOverlap(right);
      handleOverlap(left);
    }

    function getPartition(tickLabels, scale) {
      var right = [],
        left = [];

      tickLabels.each(function (d) {
        var angle = scale(d),
          ele = d3_select(this),
          info = { bb: bbox(this), xy: getSvgTransform(this.parentNode).translate, ele: ele };

        if (angle === 0 || angle === mathPI || angle === mathPI * 2) {
          right.push(info);
          left.push(info);
        } else if (angle > 0 && angle < mathPI) {
          right.push(info);
        } else {
          left.push(info);
        }
      });

      return { left: left, right: right };
    }

    function findJumps(arr) {
      var maxJumps = 0;
      arr.sort(function (a, b) {return a.xy[1] - b.xy[1];});

      for (var i = 0; i < arr.length - 1; i++) {
        var reached = false,
          jumps = 0,
          refRect = createRect(arr[i]);
        for (var j = i + 1; j < arr.length && !reached; j++) {
          var curRect = createRect(arr[j]);

          if (!doOverlap(refRect, curRect)) {
            reached = true;
          } else {
            jumps++;
          }
        }

        maxJumps = mathMax(maxJumps, jumps);
      }
      return maxJumps;
    }

    function handleOverlap(arr) {
      for (var i = 0; i < arr.length - 1; i++) {
        if (arr[i].hidden) {
          return;
        }

        var reached = false,
          refRect = createRect(arr[i]);

        for (var j = i + 1; j < arr.length && !reached; j++) {
          var ele = arr[j].ele,
            curRect = createRect(arr[j]);

          if (doOverlap(refRect, curRect)) {
            arr[j].hidden = true;
            ele.style('display', 'none');
          } else {
            reached = true;
          }
        }
      }
    }

    function createRect(obj) {
      var bb = obj.bb,xy = obj.xy;
      return {
        x1: bb.x + xy[0],
        y1: bb.y + xy[1],
        x2: bb.x + bb.width + xy[0],
        y2: bb.y + bb.height + xy[1]
      };
    }

    //$Id$

    function polarToXY(r, a) {
      a = a - mathPI / 2;
      return [mathCos(a) * r, mathSin(a) * r];
    }
    Registry.setComponent('geometryUtils.polarToCartesian', polarToXY);

    function d0_360(a) {
      var a = a % (2 * mathPI);
      return a < 0 ? a + 2 * mathPI : a;
    }

    function polarRefPoint(bb, w, h, r, SW) {
      var leftWidth = 0 - (bb.x - 0.5 * SW),
        rightWidth = bb.width + SW - leftWidth,
        topHeight = 0 - (bb.y - 0.5 * SW),
        bottomHeight = bb.height + SW - topHeight;
      var leftWidthRemaining = r - leftWidth,
        rightWidthRemaining = r - rightWidth,
        topHeightRemaining = r - topHeight,
        bottomHeightRemaining = r - bottomHeight;
      return [w / 2 - leftWidthRemaining / 2 + rightWidthRemaining / 2, h / 2 - topHeightRemaining / 2 + bottomHeightRemaining / 2];
    }

    function getDY(angle) {
      return d3_scaleLinear().
      range([0, 1]).
      domain([angle < mathPI ? mathPI / 2 : 3 * mathPI / 2, mathPI])(angle);
    }
    Registry.setComponent('geometryUtils.dyFromAngle', getDY);

    function isAngleInside(theta1, theta2, angle) {
      if (theta2 < theta1) {
        //Swap the start and end angle if endangle is less than start angle
        theta2 = theta1 + ((theta1 = theta2) - theta2);
      }
      if (theta1 < 0 && theta2 < 0) {
        theta1 = theta1 + 2 * mathPI, theta2 = theta2 + 2 * mathPI;
      }
      if (theta1 < 0 && theta2 >= 0) {
        if (angle < 0) {
          theta2 = 2 * mathPI;
        } else {
          theta1 = 0;
        }
      }
      angle = angle < 0 ? angle + mathPI * 2 : angle; //Mapping [-Math.PI,Math.PI] to [0,2*Math.PI]
      return theta1 <= angle && angle <= theta2;
    }
    Registry.setComponent('geometryUtils.isAngleInside', isAngleInside);

    function radianToDegree(rad) {
      return rad * 180 / mathPI;
    }

    /*
     * Returns the inner radius for pie | dial chart. If the inner radius is in percentage. It converts to pixel and considers bandWidth & maxBandWidth
     * @param {Object} commonPlotOptions
     * @param {String} | {Number} rad
     * @return {Number} inner radius
     */
    function getInnerRadius(commonPlotOptions, rad) {
      var hasCustomBandWidth =
        defined(commonPlotOptions.bandWidth) || commonPlotOptions.levelMarker && defined(commonPlotOptions.levelMarker.bandWidth),
        hasCustomMaxBandWidth =
        defined(commonPlotOptions.maxBandWidth) ||
        commonPlotOptions.levelMarker && defined(commonPlotOptions.levelMarker.maxBandWidth);
      var innerRadius = mathMax(0, perToPx(commonPlotOptions.innerRadius, rad, 0));
      if (hasCustomBandWidth || hasCustomMaxBandWidth) {
        var bandWidth = defined(commonPlotOptions.bandWidth) ? perToPx(commonPlotOptions.bandWidth, rad, 0) : rad - innerRadius,
          levelMarkerBandWidth = defined(commonPlotOptions.levelMarker.bandWidth) ?
          perToPx(commonPlotOptions.levelMarker.bandWidth, rad, 0) :
          rad - innerRadius,
          maxBandWidth = validateNullVal(commonPlotOptions.maxBandWidth, rad),
          maxLevelMarkerBandWidth = validateNullVal(commonPlotOptions.levelMarker.maxBandWidth, rad);

        bandWidth = mathMin(bandWidth, maxBandWidth);
        levelMarkerBandWidth = mathMin(levelMarkerBandWidth, maxLevelMarkerBandWidth);

        return rad - mathMax(bandWidth, levelMarkerBandWidth);
      } else {
        // #ZC1724
        return mathMin(innerRadius, rad);
      }
    }

    //$Id$

    var dialUtils = function dialUtils() {};

    dialUtils.getValueWithinRange = function (value, range) {
      return mathMin(mathMax(value, range[0]), range[1]);
    };

    dialUtils.getNeedlePolygon = function (needleConf, plotarea_approx, innerRadius) {
      var wid = pick(needleConf.width / 2, 7),
        IR = -perToPx(needleConf.innerRadius, plotarea_approx.radius, 0),
        OR = -perToPx(needleConf.radius, plotarea_approx.radius, innerRadius) + needleConf.padding,
        minNeedleHeight = -3 * wid;
      OR = mathMin(OR, minNeedleHeight);

      switch (needleConf.type) {
        case 'clock':
          return (
            "M".concat(wid, " ").concat(IR, " A").concat(wid, " ").concat(wid, " 0 0 1 ").concat(-wid, " ").concat(IR, " A").concat(wid, " ").concat(wid, " 0 0 1 ").concat(wid, " ").concat(IR, " ") + "M0 ".concat(
            IR - wid, " L0 ").concat(OR, " M").concat(-wid, " ").concat(wid + OR, " L0 ").concat(OR, " L").concat(wid, " ").concat(wid + OR, " L0 ").concat(OR));

        case 'sharp':
          return "M".concat(wid, " ").concat(IR, " L", 0, " ").concat(IR + wid, " L").concat(-wid, " ").concat(IR, " L0 ").concat(OR, " L").concat(wid, " ").concat(IR);
        default:
          return "M".concat(wid, " ").concat(IR, " A").concat(wid, " ").concat(wid, " 0 0 1 ").concat(-wid, " ").concat(IR, " L0") + " ".concat(OR, " L").concat(wid, " ").concat(IR);}

    };

    dialUtils.createLevelsNColors = function (data, levelMarkerConf, color, minMax) {
      var levels = [],
        levelmarkerClr = [],
        dt = data[0].data[0],
        origValues = dt[0][levelMarkerConf.dataindex] || levelMarkerConf.values || [],
        useRanges = dt[0][levelMarkerConf.dataindex] || [],
        clr = levelMarkerConf.color,
        cornerRadius = levelMarkerConf.cornerRadius,
        padAngle = levelMarkerConf.padAngle,
        startLevelsFromBeginning = defined(cornerRadius) && !defined(padAngle),
        ranges;

      if (isArray$1(useRanges[0])) {
        ranges = useRanges;
      } else {
        ranges = levelMarkerConf.ranges;
      }

      if (!(origValues instanceof Array)) {
        origValues = [origValues];
      }
      if (clr === undefined && origValues.length <= 1) {
        clr = ['#d1d1d1'];
      }

      // if user define the ranges use it directly
      if (ranges) {
        if (startLevelsFromBeginning) {
          ranges = ranges.slice(0);
          ranges.forEach(function (d) {
            d[0] = minMax[0];
          });
          ranges.reverse();
          clr = clr.slice(0);
          clr.length = ranges.length;
          clr.reverse();
        }

        ranges.forEach(function (d, i) {return d._color = clr[i];});

        return {
          values: ranges,
          colors: clr
        };
      }

      if (origValues.length > 0) {
        var thValues = origValues.slice(0);
        if (!clr) {
          //If colors are not specified, create monochrome colors
          var baseClr = color,
            domain = [0, thValues.length - 1],
            range = [levelMarkerConf.colorGamma[0], levelMarkerConf.colorGamma[1]];
          var monoClrGen = getMonochromeColor(baseClr, domain, range);
        }

        var prev = minMax[0],
          minimum = prev;

        if (startLevelsFromBeginning) {
          if (minimum < 0 && !arrayIncludes(thValues, 0)) {
            thValues.push(0);
          }
          thValues.sort(d3_ascending);

          // remove the first value
          if (prev === thValues[0]) {
            thValues = thValues.slice(1, thValues.length);
          }

          thValues.forEach(function (d, i) {
            var currentValue = dialUtils.getValueWithinRange(d, minMax);
            levelmarkerClr[i] = !clr ? monoClrGen(i) : clr[i];
            levels[i] = [minimum, currentValue];
          });

          levels.reverse();
          levelmarkerClr.reverse();
        } else {
          thValues.sort(d3_ascending);
          thValues.forEach(function (d, i) {
            var thIdx = origValues.indexOf(d);
            var currentValue = dialUtils.getValueWithinRange(d, minMax),
              nextValue = dialUtils.getValueWithinRange(defined(thValues[i + 1]) ? thValues[i + 1] : 0, minMax);
            levels[i] = currentValue < 0 ? [currentValue, nextValue] : [prev, currentValue];
            levelmarkerClr[i] = !clr ? monoClrGen(i) : clr[thIdx]; //if clr is null, monochrome colors will be applied using 'i', else user specified color is picked up using 'thIdx'
            prev = currentValue < 0 ? nextValue : currentValue;
          });
        }
      } else {
        dt.forEach(function (d, i) {
          levels[i] = minMax.slice(0);
          levelmarkerClr[i] = (clr instanceof Array ? clr[i] : clr) || '#d1d1d1';
        });
      }

      levels.forEach(function (d, i) {return d._color = levelmarkerClr[i];});

      return {
        values: levels,
        colors: levelmarkerClr
      };
    };

    //svgRenderer.js

    /**
     *
     * @param chartObj
     * @param args
     * @returns {{}}
     */
    plot.svgRenderer = function (chartObj, args) {
      var svgRenderer = {};
      var systemconf = chartObj.systemConf,
        helpers = DataProcessor.helpers;

      svgRenderer.draw = function (update) {
        var waitForOverview = chartObj.scroll && !chartObj.scroll.initialized && chartObj.scroll.visible;

        // we draw only after the scroll has rendered and a view is set
        if (waitForOverview) {
          return false;
        }

        if (chartObj.dataset.getDataType('x') == ORDINAL_DATATYPE && chartObj.isAxisCategory) {
          scale.barBandwidth(chartObj);
        }

        var type,
          isRendererCalled = [];
        chartObj.chartRendered = false;
        var isComboChart = chartObj.dataObject.isCombinationalChart;
        var orderedSeriesdata = isComboChart ? renderer_helpers.arrangeSeriesRenderingOrder(chartObj) : chartObj.seriesdata,
          hierarchical = chartObj.dataObject.hierarchical,
          facetRendering = hierarchical && hierarchical.facetRendering,
          gridlist = [{ data: orderedSeriesdata }];
        if (facetRendering) {
          var pivotLayout = facetRendering && hierarchical.pivotLayout,
            layers = pivotLayout.getRootNodeList('layer'),
            panes = layers.panes;
          gridlist = objectValues(panes);
        }
        if (chartObj.isAxisedHierarchyChart) {
          var dataAdapterObj = new (Registry.getComponent('hierarchyDataAdapter'))(chartObj.seriesdata, chartObj.preProcessor);
          gridlist = [{ data: dataAdapterObj.getData() }];
        }
        var renderCounter = 0;
        if (chartObj.viewFlow && chartObj.viewFlow.marks._default.chart.length) {
          var marks_plot = chartObj.viewFlow.marks._default.chart;
          gridlist = [{ data: marks_plot }];
        }
        gridlist.forEach(function (grid, gridIdx) {
          args.barDatasetIndex = 0;
          grid.data.forEach(function (d, i) {
            var currOrdereddata = facetRendering ?
            renderer_helpers.arrangeSeriesRenderingOrder(chartObj, grid.data, renderCounter, true) :
            orderedSeriesdata;
            var currentRenderData = facetRendering ? d.node : d;
            var renderingOrder = isComboChart ? facetRendering ? i : currOrdereddata[i].seriesidx : i;

            var rendererIdx = facetRendering ? isComboChart ? renderCounter++ : renderCounter++ : renderingOrder;
            var layerIdx = facetRendering ? d.layer : 0;

            type = helpers.getChartType(currentRenderData.type || chartObj.userdata.seriesdata.type, NUMERIC_DATATYPE);
            if ((type == charttype.bubblepie || hasColorColumnInNonAxis(chartObj)) && isUndefined(chartObj.bubblePieRendererIndex)) {
              chartObj.bubblePieRendererIndex = renderingOrder;
            }

            var chartName = charttypenames.get(type);

            if (chartObj.renderer[rendererIdx] == null) {
              chartObj.renderer[rendererIdx] = createSVGRenderer(chartName, chartObj);
              chartObj.rendererConf[rendererIdx] = new plot.rendererConf();
            }
            chartObj.renderer[rendererIdx].chartRendered = false;

            if (i == 0) {
              stateChangeListener(chartObj, systemconf.chart.plot.events, 'plot', 'init');
              chartObj.hideLoading(chartObj.container);
            }
            //Update rendererProp before interval, as this need for highlighter object. For certain animation, setInterval is called
            renderer_helpers.setRendererProp(
            chartObj,
            chartObj.renderer[rendererIdx],
            currOrdereddata,
            renderingOrder,
            i,
            args,
            rendererIdx,
            type,
            layerIdx);

          });
        });

        var renderCounter = 0;
        gridlist.forEach(function (grid, gridIdx) {
          args.barDatasetIndex = 0;
          grid.data.forEach(function (d, i) {
            var currUnOrdereddata = facetRendering || chartObj.isAxisedHierarchyChart ? grid.data : chartObj.seriesdata,
              currOrdereddata =
              facetRendering || chartObj.isAxisedHierarchyChart ?
              renderer_helpers.arrangeSeriesRenderingOrder(chartObj, grid.data, renderCounter, true) :
              orderedSeriesdata,
              currentRenderData = facetRendering ? d.node : d;
            var renderingOrder = isComboChart ? facetRendering ? i : currOrdereddata[i].seriesidx : i;
            var rendererIdx = facetRendering ? isComboChart ? renderCounter++ : renderCounter++ : renderingOrder;
            if (
            renderingOrder > 0 && (
            !chartObj._isAxisCategory() || chartObj.isAxisedHierarchyChart) &&
            !chartObj.dataObject.isPolarAxisCategory)
            {
              chartObj.renderer[rendererIdx].chartRendered = true;
              return;
            }

            type = helpers.getChartType(currentRenderData.type || chartObj.userdata.seriesdata.type, NUMERIC_DATATYPE);
            var animated = [],
              chartName = charttypenames.get(type),
              plotoptions = currOrdereddata.plotoptions,
              commonPlotOptions = systemconf.chart.plot.plotoptions[chartName];
            var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, chartName);
            var isAnimationEnable = animationOptions.enabled,
              animationType = animationOptions.type;

            var isAxisCategory = isCategoryOf(chartObj, type, 'axis'),
              isPolarAxisCategory = isCategoryOf(chartObj, type, 'polarAxis');

            if (
            isAnimationEnable &&
            !update && (
            isScatterChartType(type) || isAreaChartType(type)) &&
            [
            ALLSERIES_ANIMATION,
            POINTTWEEN_ANIMATION,
            VERTPATHTWEENALL_ANIMATION,
            FADEALL_ANIMATION,
            VERTICALALL_ANIMATION,
            SIZING_ANIMATION,
            SIZINGRANDOM_ANIMATION].
            indexOf(animationType) < 0)
            {
              isRendererCalled[rendererIdx] = false;
              chartObj.timerObj[chartObj.timerObj.length] = animated[rendererIdx] = setInterval(function () {
                if (chartObj.renderer[rendererIdx].chartRendered) {
                  clearInterval(animated[rendererIdx]);
                }
                //isRendererCalled - every renderer should be called only once not at every 10 seconds. All the renderers except first one should wait until previous renderer is rendered
                if (
                !isRendererCalled[rendererIdx] && (
                rendererIdx == 0 || rendererIdx > 0 && chartObj.renderer[rendererIdx - 1].chartRendered))
                {
                  drawSVG(chartObj, currUnOrdereddata, chartObj.renderer[rendererIdx]);
                  isRendererCalled[rendererIdx] = true;
                }
              }, 10);
            } else {
              // pivot non-axis chart: for all color series it will be rendered in single renderer only
              if (chartObj._isAxisCategory() && !isAxisCategory && !isPolarAxisCategory && i != 0) {
                chartObj.renderer[rendererIdx].chartRendered = true;
                return;
              }
              // renderer_helpers.setRendererProp(chartObj, chartObj.renderer[curSeriesidx], currOrdereddata, curSeriesidx, i, args);
              drawSVG(chartObj, currUnOrdereddata, chartObj.renderer[rendererIdx]);
            }
          });
        });
        if (chartObj.systemConf.chart.plot.datalabels.renderOnInit) {
          var datalabelEvents = chartObj.systemConf.chart.plot.datalabels.events;
          stateChangeListener(chartObj, datalabelEvents, 'plot', 'init');
          var dataLabelComponent = Registry.getComponent('labelRenderer');
          dataLabelComponent(args.labelQueue, args.labelArray, chartObj);
          stateChangeListener(chartObj, datalabelEvents, 'plot', update ? 'onreload' : 'onload');
        }
        renderer_helpers.renderCompletedEvents(chartObj, update, args);
      };
      return svgRenderer;
    };

    var createSVGRenderer = plot.svgRenderer.createSVGRenderer = function (chartName, chartObj) {
      chartName = getChartName(chartName);
      if (
      isFacet(chartObj) &&
      hasColorColumnInNonAxis(chartObj) &&
      arrayIncludes([PIE_CHARTNAME, FUNNEL_CHARTNAME, PYRAMID_CHARTNAME], chartName))
      {
        chartName = 'bubblepie';
      }

      return new svg_plot_renderer[chartName]();
    };

    var drawSVG = plot.svgRenderer.drawSVG = function (chartObj, renderdata, renderercollection, update) {
      if (update) {
        renderercollection.update();
      } else {
        if (chartObj.viewFlow && chartObj.viewFlow.marks._default.chart.length) {
          var marks_plot = chartObj.viewFlow.marks._default.chart;
          renderdata = marks_plot;
        }
        clearTimeout(renderercollection.renderedTimer);
        // TODO y scroll flickering

        var wrap = chartObj.wrap.data([chartObj.systemConf]),
          plotArea = getPlotBoundingRect(chartObj),
          bound = renderercollection.commonRendererProp().params.bound;

        var seriesHolderWrap = transformWrap(wrap, 'seriesholder', {
          x: plotArea.left,
          y: plotArea.top
        });
        var hierarchical = chartObj.dataObject.hierarchical;
        if (hierarchical && hierarchical.facetRendering) {
          var rowid = renderdata[0].row || 0,
            columnid = renderdata[0].column || 0,
            paneid = "".concat(rowid, "_").concat(columnid),
            chartType = getChartTypeByIndex(chartObj, paneid, 0).value;

          var gridWrap = createElement('g', ".grid".concat(paneid), [1], seriesHolderWrap);
          gridWrap.datum(renderdata).call(renderercollection);

          transformRendererWrap(gridWrap);
          if (!arrayIncludes(chartcategory.axis, chartType)) {
            transformWrap(seriesHolderWrap, "grid".concat(rowid, "_").concat(columnid), bound);
          }
        } else {
          seriesHolderWrap.datum(renderdata).call(renderercollection);
          transformRendererWrap(wrap.selectAll('g.seriesholder'));
        }

        transformWrap(chartObj.staticPaneSVG, 'labelholder', {
          x: plotArea.left,
          y: plotArea.top
        });
      }

      function transformWrap(wrap, selection, translate) {
        return wrap.select("g.".concat(selection)).attr('transform', "translate(".concat(translate.x, ",").concat(translate.y, ")")); //No I18N
      }

      function transformRendererWrap(wrap) {
        if (!chartObj.dataObject.isPolarAxisCategory) {
          return;
        }

        wrap.selectAll(function () {
          return this.childNodes;
        }).attr('transform', "translate(".concat(chartObj.plotarea_approx.x, ",").concat(chartObj.plotarea_approx.y, ")"));
      }
    };

    function minMaxLabel(spec) {
      var config = spec.config,radius = spec.radius,innerRadius = spec.innerRadius,data = spec.data,globalFont = spec.globalFont,scale = spec.scale,element = spec.element,format = spec.format,
        show = config.show,align = config.align,showAs = config.showAs,_config$padding = config.padding,padding = _config$padding === void 0 ? 5 : _config$padding,

        labelData = show ? showAs === 'min' ? [data[0]] : showAs === 'max' ? [data[1]] : data : [],
        r = _radius();

      var gEle = createElement('g', '.minmaxlabelsGroup', [1], element),
        lableEle = createElement(TEXT_ELEMENT, '.minmaxlabels', labelData, gEle);

      applyFont(lableEle, [config].concat(_toConsumableArray(globalFont), [$ZCG]));
      lableEle.
      attrs({
        'text-anchor': _textAnchor,
        dy: _dy,
        transform: _transform
      }).
      text(format);

      /*
      var edge = {
      	"left" : -w / 2,
      	"top" : -h / 2,
      	"right" : w / 2,
      	"bottom" : h / 2
      }
      callTrimText(minmaxLabel, chartObj, [0,0], 0, edge);
      */

      // Helpers
      function _textAnchor(d) {
        var a = d0_360(scale(d));

        return align === CENTER_ALIGN ?
        MIDDLE_ALIGN :
        a % mathPI == 0 ?
        MIDDLE_ALIGN :
        align === INNER_ALIGN && a < mathPI || align !== INNER_ALIGN && a > mathPI ?
        END_ALIGN :
        null;
      }

      function _dy(d) {
        var a = d0_360(scale(d));

        if (align === CENTER_ALIGN) {
          return '1em';
        } else if (align === INNER_ALIGN) {
          return !(a > mathPI / 2 && a < 3 * mathPI / 2) ? "".concat(-getDY(a), "em") : null;
        } else {
          return a > mathPI / 2 && a < 3 * mathPI / 2 ? "".concat(getDY(a), "em") : null;
        }
      }

      function _transform(d) {
        var xy = polarToXY(r, scale(d)),
          pad = align === CENTER_ALIGN ? padding : 0;

        return translateString([xy[0], xy[1] + pad]);
      }

      function _radius() {
        return align === INNER_ALIGN ? innerRadius - padding : align === CENTER_ALIGN ? (radius + innerRadius) / 2 : radius + padding;
      }
    }

    //customThresholdtext.js

    function getCustomThresholdText(text, data, colInfo, chartObj) {
      var dataType = colInfo.datatype,
        format = colInfo[dataType],
        type = 'threshold',
        decode = false;

      return text.replace(CUSTOM_VALUE_PATTERN, function ($1, index) {
        var val = '';
        if (isArray$1(data[index])) {
          val = getFormattedValue(format, data[index][0], dataType, chartObj, type, decode);
          val += " - ".concat(getFormattedValue(format, data[index][1], dataType, chartObj, type, decode));
        } else {
          val = getFormattedValue(format, data[index], dataType, chartObj, type, decode);
        }
        return val;
      });
    }

    function MinmaxLabelSpec(chartObj, options) {
      var scale = options.scale,radius = options.radius,innerRadius = options.innerRadius,element = options.element,type = options.type,index = options.index,
        commonPlotOptions = getPlotConfig(chartObj),
        config = commonPlotOptions.minmaxlabels,
        text = config.text,
        data = scale.domain(),
        column = chartObj.dataset.getColumn(type, index);

      return {
        config: config,
        radius: radius,
        innerRadius: innerRadius,
        data: data,
        scale: scale,
        element: element,
        globalFont: [chartObj.systemConf.chart, chartObj.systemConf.canvas],
        format: function format(d, i) {
          return text && defined(text[i]) ?
          getCustomThresholdText("".concat(text[i]), data, column, chartObj) :
          getFormat(chartObj, type, index, 'minmaxlabels')(d);
        }
      };
    }

    //

    var props = ['interval', 'tickCount', 'tickMultiples']; // TODO: tickMultiples

    // TODO: new parser
    function getPolarTickValues(options) {
      var chartObj = options.chartObj,type = options.type,index = options.index,config = options.config,scale = options.scale,radius = options.radius,plotarea = options.plotarea,container = options.container,
        tickValues;
      if (props.some(function (_) {return defined(config[_]);})) {
        var range = scale.range(),
          circumference = 2 * radius * mathAbs(range[1] - range[0]),
          axes = getAxisObject$1(chartObj, type, index),
          ticksObj = axis.ticks(chartObj, config, type, index, 'left', plotarea);

        axes.ticks = ticksObj;
        scale.range([0, circumference]);
        ticksObj.preCalcApproxAxisLength(plotarea);

        var tickVal = ticksObj.getTickValues(circumference, circumference, null, null, null, axes.Ticks);
        container.selectAll('g.axislabelgroup').remove();
        tickValues = tickVal.ticks;
      }

      return tickValues;
    }

    //$Id$

    axis.polar = function () {
      var scaleObj, chartObj, radius, columnIndices, tickFormat, tickValues, columnInfo;

      function axis_polar(g) {
        g.each(function (data) {
          var g = d3_select(this);
          var systemconf = chartObj.systemConf,
            axisline = data.axisline,
            tickmark = data.tickmark,
            subtickmark = data.subtickmark || {},
            grid = data.grid,
            ticklabel = data.ticklabel,
            events_tick = ticklabel.events,
            mousemoveFn,
            mouseoutFn,
            clickFn,
            dblclickFn,
            cursor,
            eventDisabled;

          if (events_tick != null) {
            eventDisabled = validateNullVal(events_tick.enabled, true) == false;
            mousemoveFn = events_tick.mousemove;
            mouseoutFn = events_tick.mouseout;
            clickFn = events_tick.click;
            dblclickFn = events_tick.doubleclick;
            cursor = events_tick.cursor;
          }

          var tickOrient = data.tickOrient,
            axislineSize = axisline.show ? validateNullVal(axisline.strokeWidth, 1) : 0,
            gridSize = validateNullVal(grid.strokeWidth, 1),
            ticklabelPad = validateNullVal(ticklabel.marginLeft, 5),
            tickmarkSize = validateNullVal(tickmark.size, 3),
            subtickmarkSize = validateNullVal(subtickmark.size, 2),
            subticksCount = +subtickmark.count || 0;

          var ticks = tickValues || (scaleObj.ticks ? scaleObj.ticks() : scaleObj.domain()),
            subticks = d3_svg_axisSubdivide(scaleObj, ticks, subticksCount),
            range = scaleObj.range();

          var subticksGroup = appendEle(g, 'g', [1], '.', 'class', 'subticksGroup');
          subticksGroup.style('stroke', subtickmark.color);
          var subtick = appendEle(subticksGroup, LINE_ELEMENT, subticks);

          var ticksGroup = appendEle(g, 'g', [1], '.', 'class', 'ticksGroup');
          var tick = appendEle(ticksGroup, 'g', ticks, '.', 'class', 'tick');

          var path = appendEle(g, PATH_ELEMENT, axisline.show ? [1] : [], '.', 'class', 'domain');
          path.attr('d', function () {
            var path = d3_arc().
            innerRadius(radius - 1).
            outerRadius(radius).
            startAngle(range[0]).
            endAngle(range[1])(1);
            return "M".concat(path.split(/L|M/gi)[1]);
          }).styles({
            //Axis line properties
            stroke: axisline.color,
            fill: NONE,
            'stroke-width': axislineSize,
            'stroke-dasharray': getDashArray(axisline.style, axislineSize),
            'stroke-linecap': getLineCap(axisline.lineCap, axisline.style),
            'pointer-events': NONE
          });

          appendEle(tick, LINE_ELEMENT, [1], '.', 'class', 'tickmark');
          appendEle(tick, LINE_ELEMENT, [1], '.', 'class', 'grid');
          appendEle(tick, TEXT_ELEMENT, [1], '.', 'class', 'ticklabel');
          var text = tick.select("".concat(TEXT_ELEMENT, ".ticklabel")),
            line = tick.select("".concat(LINE_ELEMENT, ".tickmark")),
            gridLine = tick.select("".concat(LINE_ELEMENT, ".grid"));

          text.style('cursor', cursor || POINTER).
          style('pointer-events', eventDisabled ? NONE : NULL$1).
          attr('index', function (d, i) {
            return i;
          }).
          text(function (d) {
            return tickFormat(d);
          });
          applyFont(text, [ticklabel, systemconf.chart, systemconf.canvas, $ZCG]);

          columnInfo = {
            data: columnIndices.map(function (d) {
              return mergeJSON$1(
              chartObj.systemConf.metadata.columns[d],
              {
                columnindex: d
              },
              true);

            })
          };

          var mousemove = function mousemove(d) {
              callback(mousemoveFn, d3_event(), d);
            },
            mouseout = function mouseout(d) {
              callback(mouseoutFn, d3_event(), d);
            },
            click = function click(d) {
              callback(clickFn, d3_event(), d);
            },
            dblclick = function dblclick(d) {
              callback(dblclickFn, d3_event(), d);
            };
          var mouseHandlers = {
              mousemove: mousemove,
              mouseout: mouseout,
              click: click,
              dblclick: dblclick
            },
            touchHandlers = {
              singletouchmove: mousemove,
              touchend: mouseout,
              tap: click,
              dbltap: dblclick
            };
          attachevents(text, mouseHandlers, touchHandlers);

          var tickRad, textRad, tickmarkRad, subtickmarkRad;
          switch (tickOrient) {
            case INNER_ALIGN:
              tickRad = radius - axislineSize / 2;
              textRad = -(tickmarkSize + ticklabelPad);
              tickmarkRad = -tickmarkSize;
              subtickmarkRad = -subtickmarkSize;
              break;
            default:
              tickRad = radius + axislineSize / 2;
              textRad = tickmarkSize + ticklabelPad;
              tickmarkRad = tickmarkSize;
              subtickmarkRad = subtickmarkSize;}

          tick.attr('transform', function (d) {
            var xy = polarToXY(tickRad, scaleObj(d));
            return "translate(".concat(xy[0], ",").concat(xy[1], ")");
          });
          text.attrs({
            dy: function dy(d) {
              var a = d0_360(scaleObj(d));
              return tickOrient == INNER_ALIGN ?
              !(a > mathPI / 2 && a < 3 * mathPI / 2) ? "".concat(
              -getDY(a), "em") :
              null :
              a > mathPI / 2 && a < 3 * mathPI / 2 ? "".concat(
              getDY(a), "em") :
              null;
            },
            'text-anchor': function textAnchor(d) {
              var a = d0_360(scaleObj(d));
              return a % mathPI == 0 ?
              'middle' :
              tickOrient == INNER_ALIGN && a < mathPI || tickOrient != INNER_ALIGN && a > mathPI ?
              'end' :
              null;
            },
            transform: function transform(d) {
              var xy = polarToXY(textRad, scaleObj(d));
              return "translate(".concat(xy[0], ",").concat(xy[1], ")");
            }
          });
          line.attrs({
            x2: function x2(d) {
              return polarToXY(tickmarkRad, scaleObj(d))[0];
            },
            y2: function y2(d) {
              return polarToXY(tickmarkRad, scaleObj(d))[1];
            }
          }).styles({
            stroke: tickmark.color,
            'stroke-width': tickmark.strokeWidth
          }); //tickmark properties

          gridLine.
          attrs({
            x2: function x2(d) {
              return polarToXY(-radius, scaleObj(d))[0];
            },
            y2: function y2(d) {
              return polarToXY(-radius, scaleObj(d))[1];
            }
          }).
          styles({
            stroke: grid.color,
            'stroke-width': gridSize,
            'stroke-dasharray': getDashArray(grid.style, gridSize),
            'stroke-linecap': getLineCap(grid.lineCap, grid.style)
          }); //grid properties

          subtick.attrs({
            x2: function x2(d) {
              return polarToXY(subtickmarkRad, scaleObj(d))[0];
            },
            y2: function y2(d) {
              return polarToXY(subtickmarkRad, scaleObj(d))[1];
            },
            transform: function transform(d) {
              var xy = polarToXY(tickRad, scaleObj(d));
              return "translate(".concat(xy[0], ",").concat(xy[1], ")");
            }
          });
        });
      }

      axis_polar.scale = function (x) {
        if (!arguments.length) {
          return scaleObj;
        }
        scaleObj = x;
        return axis_polar;
      };
      axis_polar.chartObj = function (x) {
        if (!arguments.length) {
          return chartObj;
        }
        chartObj = x;
        return axis_polar;
      };
      axis_polar.radius = function (x) {
        if (!arguments.length) {
          return radius;
        }
        radius = x;
        return axis_polar;
      };
      axis_polar.columnIndices = function (_) {
        if (!arguments.length) {
          return columnIndices;
        }
        columnIndices = _;
        return axis_polar;
      };
      axis_polar.tickValues = function (_) {
        if (!arguments.length) {
          return tickValues;
        }
        tickValues = _;
        return axis_polar;
      };
      axis_polar.tickFormat = function (_) {
        if (!arguments.length) {
          return tickFormat;
        }
        tickFormat = _;
        return axis_polar;
      };
      return axis_polar;

      function d3_svg_axisSubdivide(scaleObj, ticks, m) {
        subticks = [];
        if (m && ticks.length > 1) {
          var extent = d3_scaleExtent(scaleObj.domain()),
            subticks,
            i = -1,
            n = ticks.length,
            d = (ticks[1] - ticks[0]) / ++m,
            j,
            v;
          while (++i < n) {
            for (j = m; --j > 0;) {
              if ((v = +ticks[i] - j * d) >= extent[0]) {
                subticks.push(v);
              }
            }
          }
          for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
            subticks.push(v);
          }
        }
        return subticks;
      }

      function d3_scaleExtent(domain) {
        var start = domain[0],
          stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }

      function callback(func, e, d) {
        if (func != null) {
          columnInfo.data = columnInfo.data.map(function (dt) {
            dt.value = d;
            return dt;
          });
          invokeFunction(func, e, columnInfo, chartObj);
        }
      }
    };

    //$Id$

    axis.polar.render = function (chartObj) {
      var types = chartObj.dataObject.isPolarAxisCategory ? ['x', 'y'] : ['y'],
        plotarea = chartObj.plotarea,
        facetRendering = isFacet(chartObj);

      chartObj.plotarea_approx = null;
      types.forEach(function (type) {
        var wrap = createElement('g', ".".concat(type, "-axis"), [1], chartObj.wrap.selectAll('g.chartgroup'));
        setRange4Scale(chartObj, type);

        if (facetRendering) {
          var gridList = getGridList(chartObj.dataObject);
          chartObj.cache.polar = chartObj.cache.polar || {};

          gridList.forEach(function (grid) {
            var row = grid.row,column = grid.column,
              axisOrder = type === 'x' ? 0 : row,
              axisObj = getAxisObject$1(chartObj, type, axisOrder),
              bound = renderer_helpers.getBound(chartObj, grid.data[0]),
              axisDataOrder = type === 'x' ? 0 : getAxisDataIndex(type, axisOrder, chartObj);

            var axisWrap = createElement('g', ".".concat(type, "-axis-").concat(row, "-").concat(column), [1], wrap);
            transformWrap(axisWrap, [plotarea.left + bound.x, plotarea.top + bound.y]);

            drawAxisComp(chartObj, axisObj, type, axisDataOrder, axisWrap, bound, chartObj.plotarea_approx);

            chartObj.cache.polar["".concat(row, "-").concat(column)] = bound.polar;
          });
        } else {
          var axisObj = getAxisObject$1(chartObj, type),
            bound = renderer_helpers.getBound(chartObj);

          var axisWrap = createElement('g', ".".concat(type, "-axis-0"), [1], wrap);
          transformWrap(axisWrap, [plotarea.left, plotarea.top]);

          drawAxisComp(chartObj, axisObj, type, 0, axisWrap, bound);
        }
      });
    };

    function drawAxisComp(chartObj, axisObj) {var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'y';var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var container = arguments.length > 4 ? arguments[4] : undefined;var bound = arguments.length > 5 ? arguments[5] : undefined;var polarMeta = arguments.length > 6 ? arguments[6] : undefined;
      var mode = getMode(chartObj, type),
        comp = mode === 'polar' ? drawPolarAxisComp : drawAngularAxisComp;

      comp(chartObj, axisObj, type, index, container, bound, polarMeta);
    }

    function drawPolarAxisComp(chartObj, axisObj) {var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'y';var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var container = arguments.length > 4 ? arguments[4] : undefined;var bound = arguments.length > 5 ? arguments[5] : undefined;var polarMeta = arguments.length > 6 ? arguments[6] : undefined;
      var systemconf = chartObj.systemConf,
        renderer = chartObj.renderer[0],
        plotarea = bound,
        chart = chartObj.chartTypes[0],
        cType = chart.value,
        chartName = chart.name;

      var commonPlotOptions = systemconf.chart.plot.plotoptions[chartName];
      var axis_data = getAxisData(chartObj, type, index),
        outerPadding = +commonPlotOptions.outerPadding || 0,
        maxRadius = +commonPlotOptions.maxRadius || 0;
      var isDial = cType === charttype.dial;

      var show = isAxis(chartObj, type, axis_data);
      var axislineSize = show && axis_data.axisline.show ? validateNullVal(axis_data.axisline.strokeWidth, 1) : 0,
        ticklabelPad = validateNullVal(axis_data.ticklabel.marginLeft, 5),
        tickmarkSize = validateNullVal(axis_data.tickmark.size, 3),
        subtickmarkSize = axis_data.subtickmark ? validateNullVal(axis_data.subtickmark.size, 2) : 0,
        ticklabelFontsize = utils.getVal(
        axis_data.ticklabel.fontSize || systemconf.chart.fontSize || systemconf.canvas.fontSize || $ZCG.fontSize),

        orient = axis_data.orient || OUTER_ALIGN,
        tickOrient = axis_data.tickOrient,
        textOverlap = axis_data.ticklabel.textOverlap || 'hidden',
        _childNodes = function _childNodes(ele) {return (
            ele.selectAll(function () {
              return this.childNodes;
            }));};

      var w = plotarea.width - 2 * outerPadding,
        h = plotarea.height - 2 * outerPadding,
        radius = pick(polarMeta && polarMeta.radius, mathMin(w, h) / 2),
        innerRadius = pick(polarMeta && polarMeta.innerRadius, getInnerRadius(commonPlotOptions, radius)),
        padding = show ? +commonPlotOptions.padding || 0 : 0;
      chartObj.plotarea_approx = { x: 0, y: 0, innerRadius: innerRadius };

      var scaleObj = axisObj.scale;
      var range = scaleObj.range();

      var columnIdx = chartObj.dataset.getColumnIdx(type, index),
        dataObject = chartObj.dataObject,
        categories =
        dataObject.isPolarAxisCategory &&
        dataObject.categoryHierarchy &&
        dataObject.hierarchical.pivotLayout.columns.count &&
        !dataObject.hierarchical.pivotLayout.columns.splitColumnLeaves &&
        dataObject.getCategories(type, index),
        tickValues = getPolarTickValues({ chartObj: chartObj, type: type, index: index, config: axis_data, scale: scaleObj, radius: radius, plotarea: plotarea, container: container });
      scaleObj.range(range); // Resetting range that is changed in getPolarTickValues

      var axisRadius = pick(
        polarMeta && polarMeta.axisRadius,
        orient == INNER_ALIGN ?
        tickOrient === OUTER_ALIGN ?
        innerRadius - padding - axislineSize / 2 - mathMax(subtickmarkSize, tickmarkSize + ticklabelPad + ticklabelFontsize) :
        innerRadius :
        radius),

        tickFormat = function tickFormat(d, i) {
          var val = categories ? categories[d] : d; // ZC2682
          return getFormat(chartObj, type, index, 'axis')(val, i);
        };

      var axisComponent = axis.
      polar().
      scale(scaleObj).
      chartObj(chartObj).
      radius(axisRadius).
      columnIndices([columnIdx]).
      tickFormat(tickFormat).
      tickValues(tickValues);

      _childNodes(container).attr('transform', null);
      var wrap = createElement('g', '.axisgroup', show ? [axis_data] : [], container),
        getTickHandler = function getTickHandler() {
          var args = [wrap, w / 2, axis_data.ticklabel, chartObj, scaleObj, axisComponent];
          return PolarTickHandler.apply(void 0, args);
        },
        addTooltip = function addTooltip() {
          if (axis_data.ticklabel.tooltip === true) {
            var ticklabelEle = wrap.selectAll(TEXT_ELEMENT);
            ticklabelEle.each(function (d) {
              addSVGtitleEle(d3_select(this), tickFormat(d));
            });
          }
        },
        renderAxis = function renderAxis() {
          wrap.selectAll("".concat(TEXT_ELEMENT, ".ticklabel")).style('display', null);
          wrap.call(axisComponent).
          call(getTickHandler()).
          call(function () {return textOverlap === 'hidden' ? PolarTickOverlap(wrap, scaleObj) : null;}).
          call(addTooltip);
        };

      renderAxis();
      container.style('visibility', 'hidden');

      if (isDial) {
        drawMinMaxLabel(radius);
      }

      if (!polarMeta) {
        //dummy arc
        var arc = d3_arc().
        innerRadius(
        !isDial ||
        commonPlotOptions.needle.show ||
        chartObj.datalabels.moduleExists && isDatalabelEnabled(commonPlotOptions.datalabels, chartObj) ?
        0 :
        innerRadius).

        outerRadius(radius).
        startAngle(range[0]).
        endAngle(range[1]);
        var dummyArc = appendEle(container, PATH_ELEMENT, [1], '.', 'class', 'dummyArc').attr('d', arc(1));

        //Minmax label and datalabel - dial chart
        var datalabel = createElement('g', '.datalabel', [1], container);
        var targetMarkerSeries = createElement('g', '.targetSeries', [1], container);
        var gridList;
        if (isDial) {
          var hierarchical = chartObj.dataObject.hierarchical,
            facetRendering = hierarchical && hierarchical.facetRendering;

          if (facetRendering) {
            gridList = getGridList(chartObj.dataObject);
          } else {
            gridList = [{ data: chartObj.seriesdata }];
          }

          if (!renderer) {
            var curSeriesidx = 0;
            renderer = chartObj.renderer[curSeriesidx] = createSVGRenderer(chartName, chartObj);
            chartObj.rendererConf = [];
            chartObj.rendererConf[curSeriesidx] = new plot.rendererConf(); // TODO: PIVOT
            renderer_helpers.setRendererProp(
            chartObj,
            renderer,
            gridList[0].data,
            curSeriesidx,
            curSeriesidx,
            [],
            curSeriesidx,
            null,
            curSeriesidx);

          }

          renderer.firedList = {};
          var dialLabelRenderer = LabelRegistry.get('dial');
          if (!dialLabelRenderer._empty) {
            datalabel.call(
            dialLabelRenderer().
            renderer(renderer).
            args([chartObj.seriesdata, 0]),
            chartObj.labelHandler,
            datalabel);

          }

          drawTargetMarker(radius, gridList);

          //needle calculation
          var needleWidth = +commonPlotOptions.needle.width / 2 || 7;
          var cir = appendEle(datalabel, 'circle', commonPlotOptions.needle.show ? [1] : []);
          cir.attrs({
            r: needleWidth,
            transform: "translate(".concat(needleWidth, ",").concat(needleWidth, ")")
          });
        }

        //calculating new radius
        var arcBound = bbox(dummyArc),
          bb = bbox(container),
          heightPercent = arcBound.height / radius,
          widthPercent = arcBound.width / radius,
          newradius = radius + mathMin((w - bb.width) / widthPercent, (h - bb.height) / heightPercent),
          firedList = {};

        if (isDial) {
          var firedList = fireElementsNgetList();
          var bb = bbox(container);
          newradius = radius + mathMin((w - bb.width) / widthPercent, (h - bb.height) / heightPercent);
          newradius = newradius > maxRadius ? maxRadius : newradius; // Setting maximum to the radius
          newradius = isFinite(newradius) && newradius > 0 ? newradius : 0;
        }

        innerRadius =
        getInnerRadius(commonPlotOptions, newradius) - (orient == INNER_ALIGN ? (+commonPlotOptions.strokeWidth || 0) / 2 : 0);
        axisRadius =
        (orient == INNER_ALIGN ?
        tickOrient == INNER_ALIGN ?
        innerRadius :
        innerRadius - (getMinRadius(radius) - radius) :
        newradius) - (
        tickOrient == INNER_ALIGN ? axislineSize / 2 : 0) - (
        orient == INNER_ALIGN ? padding : 0);
        axisComponent.radius(axisRadius);
        if (!firedList.axisgroup) {
          renderAxis();
        }
        arc.outerRadius(newradius).innerRadius(
        !isDial ||
        commonPlotOptions.needle.show ||
        chartObj.datalabels.moduleExists && isDatalabelEnabled(commonPlotOptions.datalabels, chartObj) ?
        0 :
        innerRadius);

        dummyArc.attr('d', arc(1));
        if (isDial) {
          !firedList.minmaxlabels ? drawMinMaxLabel(newradius) : null;
          drawTargetMarker(newradius, gridList);
        }

        //Reference point calculation
        var arcBound = bbox(dummyArc);
        var bb = bbox(container);
        var pt = polarRefPoint(bb, plotarea.width, plotarea.height, newradius, 0);

        // TODO: enhance
        if (chartObj.cache.polarAxis.trimmed) {
          pt[0] = plotarea.width / 2;
        }

        var arcRad =
        (tickOrient == INNER_ALIGN && orient == OUTER_ALIGN ?
        getMinRadius(newradius) :
        newradius - (orient == INNER_ALIGN ? 0 : axislineSize / 2)) - (orient == INNER_ALIGN ? 0 : padding);
        var dwidth = tickOrient == INNER_ALIGN ? (newradius - arcRad) * widthPercent : 0,
          dheight = tickOrient == INNER_ALIGN ? (newradius - arcRad) * heightPercent : 0;

        polarMeta = {
          x: pt[0],
          y: pt[1],
          width: arcBound.width - axislineSize - dwidth,
          height: arcBound.height - axislineSize - dheight,
          radius: arcRad,
          actualRadius: newradius,
          innerRadius: innerRadius,
          axisRadius: axisRadius
        };

        dummyArc.remove();
        datalabel.remove();
        targetMarkerSeries.remove();
      }

      _childNodes(container).attr('transform', "translate(".concat(polarMeta.x, ",").concat(polarMeta.y, ")"));
      container.style('visibility', null);

      if (chartObj.dataObject.isPolarAxisCategory) {
        container.selectAll("".concat(PATH_ELEMENT, ".domain")).attr('d', function () {return grid(polarMeta.radius, scaleObj, axis_data);});
      }

      chartObj.plotarea_approx = polarMeta;
      bound.polar = polarMeta;

      function getMinRadius(rad) {
        var a = [],
          subtickRad =
          rad + ((orient == OUTER_ALIGN ? axislineSize : axislineSize / 2) + subtickmarkSize * (tickOrient == INNER_ALIGN ? -1 : 1)),
          func = tickOrient == INNER_ALIGN ? d3_min : d3_max;
        wrap.selectAll(TEXT_ELEMENT).each(function (d) {
          var bb = bbox(this),
            textRad =
            rad +
            ((orient == OUTER_ALIGN ? axislineSize : axislineSize / 2) + tickmarkSize + ticklabelPad) * (
            tickOrient == INNER_ALIGN ? -1 : 1);
          var xy = polarToXY(textRad, scale(d));
          var arr = [
          xyToRadius(xy[0] + bb.x, xy[1] + bb.y),
          xyToRadius(xy[0] + bb.x, xy[1] + bb.y + bb.height),
          xyToRadius(xy[0] + bb.x + bb.width, xy[1] + bb.y),
          xyToRadius(xy[0] + bb.x + bb.width, xy[1] + bb.y + bb.height),
          subtickRad];

          a.push(func(arr));
        });
        return func(a);
      }

      function drawMinMaxLabel(radius) {
        var options = { radius: radius, innerRadius: innerRadius, type: type, index: index, scale: scaleObj, element: container },
          minmaxLabelSpec = MinmaxLabelSpec(chartObj, options);
        minMaxLabel(minmaxLabelSpec);
      }

      function drawTargetMarker(radius, gridList) {
        // Draw all the target markers. So that we can get correct radius
        gridList.forEach(function (grid, i) {
          var wrap = createElement('g', ".targetSeries-".concat(i), [1], targetMarkerSeries);
          dialUtils.targetMarker(wrap, radius, innerRadius, chartObj, grid.data, undefined, wrap);
        });
      }

      function fireElementsNgetList() {
        var firedList = {};

        fireElement(firedList, 'axisgroup');
        fireElement(firedList, 'minmaxlabels');
        fireElement(firedList, 'targetSeries');

        return renderer.firedList = firedList;
      }

      function fireElement(firedList, type) {
        var selector = ['.targetSeries', '.datalabel', '.minmaxlabels', '.axisgroup'].filter(function (d) {return d !== ".".concat(type);}).join();
        container.selectAll(selector).style('display', NONE);
        var bb_axis = bbox(container),
          newradius = radius + mathMin((w - bb_axis.width) / widthPercent, (h - bb_axis.height) / heightPercent),
          maxWidth = perToPx(type === 'minmaxlabels' ? commonPlotOptions.minmaxlabels.maxWidth : null, radius, perToPx('50%', radius));

        if (newradius < radius - maxWidth || radius <= 0 || !isFinite(newradius)) {
          firedList[type] = true;
          container.selectAll(".".concat(type)).remove();
        }
        container.selectAll(selector).style('display', null);
      }
    }

    function drawAngularAxisComp(chartObj, axisObj) {var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'y';var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;var container = arguments.length > 4 ? arguments[4] : undefined;var bound = arguments.length > 5 ? arguments[5] : undefined;return function (axisObj) {
        var yaxis_data = chartObj.systemConf.chart.axes.yaxis[index],
          show = isAxis(chartObj, type, yaxis_data),
          polarMeta = bound.polar,
          radius = polarMeta.radius;

        var orient = yaxis_data.orient || RIGHT_ALIGN,
          tickSize = validateNullVal(yaxis_data.tickmark.size, 6),
          tickPadding = validateNullVal(yaxis_data.ticklabel[orient == LEFT_ALIGN ? 'marginRight' : 'marginLeft'], 3);

        var yscale = axisObj.scale,
          range = yscale.range(),
          xScale = getAxisObject$1(chartObj, 'x', 0).scale;

        yscale = yscale.copy().range([range[1], range[0]]); // For tick values, it should be reversed

        var plotarea_approx = {
          left: chartObj.plotarea.left,
          top: chartObj.plotarea.top,
          width: radius,
          height: radius
        };
        var axes = getAxisObject$1(chartObj, type, index);
        var ticksObj = axis.ticks(chartObj, yaxis_data, 'y', index, orient, plotarea_approx);
        axes.ticks = ticksObj;
        ticksObj.preCalcApproxAxisLength(plotarea_approx);

        // test
        var tickVal = ticksObj.getTickValues(radius, radius, null, null, radius / 20, axes.Ticks);

        var metaData = chartObj.userdata.metadata;
        var isMergedAxis = metaData.axes.y[index].length > 1; //For merged axis, need not to apply formatting
        var columnidx = chartObj.dataset.getColumnIdx(type, index);
        // var datatype = metaData.columns[columnidx].datatype;
        // var formatConf = isMergedAxis && type == 'y' ? merged_axis_column_intersect(index, chartObj) : metaData.columns[columnidx][datatype];
        // var formattingFunction = chartObj.dataObject.isStackedPercentChart && type == 'y' ? getFormattedValueByPercent : getFormattedValue;

        // #ZC2806
        if (isArray$1(axes.logDomain)) {
          yscale.domain(axes.logDomain);
        }

        var axisObj = axis.
        get().
        orient(orient).
        scale(yscale).
        tickPadding(tickPadding).
        tickSize(tickSize, 0).
        plotarea({
          width: radius,
          height: radius
        }).
        systemconf(chartObj.systemConf).
        chartObj(chartObj).
        tickRotation(tickVal.rotation).
        preCalcTickLen(ticksObj.preCalcTickLen).
        tickValues(tickVal.ticks).
        tickFormat(function (d) {
          var formattedValue = getFormat(chartObj, type, index, 'axis')(d);
          d3_select(this).text(formattedValue);
        }).
        columnIndices(isMergedAxis && type == 'y' ? metaData.axes.y[index] : [columnidx]).
        polar(true);

        var _transform = getSvgTransform(container).translate;
        container.
        datum(yaxis_data).
        call(axisObj, type, index).
        attr('transform', "translate(".concat(polarMeta.x + _transform[0], ",").concat(polarMeta.y - radius + _transform[1], ")"));

        if (!show) {
          container.remove();
        }

        var ticks = container.selectAll('.tick');
        ticks.append(PATH_ELEMENT);
        var gridLine = ticks.select(PATH_ELEMENT);

        gridLine.
        attr('transform', function (d) {return "".concat('translate(0' + ',').concat(radius - yscale(d), ")");}).
        attr('d', function (d) {return grid(radius - yscale(d), xScale, yaxis_data);}).
        styles({
          fill: NONE,
          stroke: yaxis_data.grid.color,
          'stroke-width': yaxis_data.grid.strokeWidth
        });
      }(axisObj);}

    function setRange4Scale(chartObj, type) {
      var mode = getMode(chartObj, type),
        facetRendering = isFacet(chartObj);

      if (facetRendering) {
        // Set range
        var axisObjs = getAxisObjects(chartObj, type),
          range;

        axisObjs.forEach(function (_, i) {
          var axisConfig = getAxisData(chartObj, type, i);

          if (mode === 'polar') {
            range = getPolarRange(chartObj, type);
          } else {
            var radius = chartObj.plotarea_approx.radius;
            range = axisConfig.reversed && !chartObj.dataObject.isstacked() ? [radius, 0] : [0, radius];
          }

          var scale = _.scale;
          if (scale) {
            scale.range(range);
            scale.origRange = range;
          }
        });
      } else {
        var axisConfig = getAxisData(chartObj, type, 0);
        // Create scale
        var obj = scale.constructor(chartObj, type == 'x' ? BOTTOM_ALIGN : LEFT_ALIGN);

        // web axis rotated: CX_ZA_SINGLECOL_3_6
        if (chartObj.axes.rotated && type === 'x') {
          chartObj.axes.x.scale = obj[0].scale;
        }

        if (mode !== 'polar') {
          var radius = chartObj.plotarea_approx.radius,
            _range2 = axisConfig.reversed && !chartObj.dataObject.isstacked() ? [radius, 0] : [0, radius],
            _scale6 = obj[0].scale;

          _scale6.range(_range2);
          _scale6.origRange = _range2;
        }
        // TODO
      }
    }

    function getMode(chartObj, type) {
      return chartObj.chartTypes[0].value === charttype.dial ? 'polar' : type === 'x' ? 'polar' : 'angular';
    }

    function isAxis(chartObj, type, axisConfig) {
      var canvasarea = chartObj.canvasarea;

      return (
        (axisConfig.show || axisConfig._backup && axisConfig._backup.show) &&
        dimension_based_intelligence(chartObj, "".concat(type, "axis"), mathMin(canvasarea.width, canvasarea.height)));

    }

    function transformWrap(ele, translate) {
      ele.attr('transform', translateString(translate));
    }

    function xyToRadius(x, y) {
      return mathSQRT(mathPow(x, 2) + mathPow(y, 2));
    }

    function grid(r, scaleObj, axisConfig) {
      var range = scaleObj.range();
      if (axisConfig.grid.type === 'arc') {
        var path = d3_arc().
        innerRadius(r - 1).
        outerRadius(r).
        startAngle(range[0]).
        endAngle(range[1])(1);
        return "M".concat(path.split(/L|M/gi)[1]);
      }
      var tickValues = scaleObj.ticks ? scaleObj.ticks() : scaleObj.domain();
      var path = tickValues.reduce(function (prev, cur, i) {
        var a = scaleObj(cur);
        var xy = polarToXY(r, a);
        return "".concat(prev, "L").concat(xy[0], " ").concat(xy[1], " ");
      }, '');
      return "M".concat(path.substring(1), "Z");
    }

    var _polarAxisRenderer = axis.polar.render;

    //$Id$

    var gradient_helpers = {
      getDimension: function getDimension(chartObj, seriesIndex, paneid) {
        if (chartObj.dataObject.isPolarAxisCategory) {
          var r = chartObj.plotarea_approx.radius;
          return {
            r: r,
            x1: -r,
            x2: r,
            y1: -r,
            y2: r
          };
        } else if (chartObj._isAxisCategory()) {
          var rp = chartObj.rendererConf[seriesIndex].params,
            cType_Obj = getChartTypeByIndex(chartObj, paneid, seriesIndex),
            cType = cType_Obj.value,
            axes = chartObj.systemConf.chart.axes,
            xReversed = axes.xaxis.reversed,
            yReversed = axes.yaxis[rp.yaxiscolumnorder].reversed,
            xScale = rp.xscale,
            yScale = rp.yscale,
            xRange = xScale.range(),
            yRange = yScale.range(),
            getAdjustedRange = function getAdjustedRange(scaleObj, range) {
              if (scaleObj.bandwidth && (isAreaChartType(cType) || cType === charttype.line)) {
                //Test_900.json filter Oct and Nov, the line gradient should be rendered correctly
                var bwBy2 = scaleObj.bandwidth() / 2;
                var sign = range[0] < range[1] ? 1 : -1;
                return [range[0] + bwBy2 * sign, range[1] - bwBy2 * sign];
              }
              return range;
            };

          xRange = getAdjustedRange(xScale, xRange);
          yRange = getAdjustedRange(yScale, yRange);

          if (rp.axisrotated) {
            return {
              x1: yRange[+!yReversed],
              x2: yRange[+!!yReversed],
              y1: xRange[+!xReversed],
              y2: xRange[+!!xReversed]
            };
          } else {
            return {
              x1: xRange[+!!xReversed],
              x2: xRange[+!xReversed],
              y1: yRange[+!!yReversed],
              y2: yRange[+!yReversed]
            };
          }
        }
      }
    };

    function getStops(gradient, properties, color, type) {
      var stopoffset = properties.stopOffset,
        stopopacity = properties.stopOpacity,
        stopcolor = properties.stopColor,
        colorgamma = properties.colorGamma || [1, 0],
        spread = properties.spreadMethod,
        radius =
        type == 'radial' ?
        +properties.radius :
        mathMax(mathAbs((+properties.x2 || 0) - (+properties.x1 || 0)), mathAbs((+properties.y2 || 0) - (+properties.y1 || 0)));
      stopoffset = stopoffset || ['0%', '100%'];
      stopcolor =
      (typeof stopcolor === 'function' ? stopcolor(color) : stopcolor) ||
      stopoffset.map(function (d, i) {
        return getColorCopy(color, colorgamma[i] || 0, 'brighter', d3_hsl);
      });
      stopopacity = stopopacity || [1, 1];

      if (!supportsSpreadMethod(spread)) {
        var newStopoffset = [],
          newStopColor = [],
          newStopOpacity = [],
          step = 0,
          repeat = 0;
        while (step < 100) {
          for (var i = 0, len = stopoffset.length; i < len; i++) {
            var newOffset = mathMin(parseFloat(stopoffset[i]) / 100 * radius + step, 100);
            newStopoffset.push("".concat(newOffset, "%"));
            newStopOpacity.push(repeat % 2 != 0 ? stopopacity[stopopacity.length - 1 - i] : stopopacity[i]);
            newStopColor.push(repeat % 2 != 0 ? stopcolor[stopcolor.length - 1 - i] : stopcolor[i]);
          }
          step += radius;
          repeat += spread === 'reflect' ? 1 : 0;
        }
        stopoffset = newStopoffset;
        stopcolor = newStopColor;
        stopopacity = newStopOpacity;
      }
      return {
        offset: stopoffset,
        color: stopcolor,
        opacity: stopopacity
      };
    }

    function supportsSpreadMethod(spreadMethod) {
      return !((spreadMethod === 'repeat' || spreadMethod === 'reflect') && ($Browser.IS_IOS || $Browser.SAFARI));
    }

    //$Id$

    var canvas_gradients = function canvas_gradients() {};

    var types = {};

    canvas_gradients.create = function (context, patternName, properties, offset) {
      if (/threshold/gi.test(patternName)) {
        return types[patternName](context, properties, offset);
      } else {
        var safari = $Browser.SAFARI;
        $Browser.SAFARI = 0;
        var stop = getStops({}, properties, properties.color, patternName);
        var gradient = types[patternName](context, properties, stop);
        $Browser.SAFARI = safari;
        return gradient;
      }
    };
    canvas_gradients.canvasGradientFill = types.canvasGradientFill = function (
    properties,
    gradientID,
    offset,
    returnSVGimage,
    base64,
    chartObj)
    {
      if (!defined(chartObj.context)) {
        chartObj.context = document.createElement('canvas').getContext('2d');
      }
      return properties && properties.type ?
      canvas_gradients[properties.type](properties, gradientID, offset, returnSVGimage, base64, chartObj) :
      null;
    };

    canvas_gradients.linear = types.linear = function (properties, gradientID, offset, returnSVGimage, base64, chartObj) {
      var context = chartObj.context,
        dimension = properties.dimension,
        spread = properties.spreadMethod,
        x1 = +properties.x1 || 0,
        x2 = +properties.x2 || 0,
        y1 = +properties.y1 || 0,
        y2 = +properties.y2 || 0,
        stops = getStops({}, properties, properties.color, 'linear');
      var dim = supportsSpreadMethod(spread) ? 100 : mathMax(mathAbs(x2 - x1), mathAbs(y2 - y1)),
        boundX1,
        boundX2,
        boundY1,
        boundY2;

      if (isArray$1(dimension)) {
        boundX1 = 0;
        boundX2 = dimension[0];
        boundY1 = 0;
        boundY2 = dimension[1];
      } else {
        boundX1 = dimension.x1 || 0;
        boundX2 = dimension.x2 || 0;
        boundY1 = dimension.y1 || 0;
        boundY2 = dimension.y2 || 0;
      }

      var xScale = d3_scaleLinear().
        domain([0, 100]).
        range([boundX1, boundX2].sort(d3_ascending)), // bar20.json -> sorting in ascending order
        yScale = d3_scaleLinear().
        domain([0, 100]).
        range([boundY1, boundY2].sort(d3_ascending)),
        x0 = xScale(x1 * 100 / dim),
        x1 = xScale(x2 * 100 / dim),
        y0 = yScale(y1 * 100 / dim),
        y1 = yScale(y2 * 100 / dim);

      var gradient = context.createLinearGradient(x0, y0, x1, y1);
      addStop(gradient, stops, properties.opacity);
      return gradient;
    };

    canvas_gradients.radial = types.radial = function (properties, gradientID, offset, returnSVGimage, base64, chartObj) {
      var context = chartObj.context,
        dimension = properties.dimension,
        spread = properties.spreadMethod,
        stops = getStops({}, properties, properties.color, 'radial'),
        r = isArray$1(dimension) ? defined(dimension[2]) ? dimension[2] : dimension[0] : dimension.r,
        w = !isArray$1(dimension) ? dimension.x2 - dimension.x1 : r,
        h = !isArray$1(dimension) ? dimension.y2 - dimension.y1 : r,
        x = w / 100 * properties.x || 0,
        y = h / 100 * properties.y || 0,
        radius = supportsSpreadMethod(spread) ? r / 100 * properties.radius : r;

      var gradient = context.createRadialGradient(x, y, 0, x, y, radius);
      addStop(gradient, stops, properties.opacity);
      return gradient;
    };

    canvas_gradients.thresholdLinear = types.thresholdLinear = function (properties, gradientID, offset, returnSVGimage, base64, chartObj) {
      var context = chartObj.context;
      var stop = {
        opacity: [],
        offset: [],
        color: []
      };
      offset.forEach(function (d) {
        stop.opacity.push(1);
        stop.offset.push(d.offset);
        stop.color.push(d.color);
      });

      var gradient = context.createLinearGradient(properties.x1, properties.y1, properties.x2, properties.y2);
      addStop(gradient, stop, properties.opacity);
      return gradient;
    };

    var addStop = function addStop(gradient, stop, stopOpacity) {
      var n = stop.offset.length,
        i = -1;
      stopOpacity = stopOpacity || 1;
      while (++i < n) {
        var opacity = mathAbs(1 - (validateNullVal(stop.opacity[i], 1) + stopOpacity)),
          color = rgba_canvas(stop.color[i], opacity),
          offset = parseFloat(stop.offset[i]) / 100;

        if (isWithinRange$1(offset, [0, 1])) {
          // offset should be within 0 and 1
          gradient.addColorStop(offset, color);
        }
      }
    };

    effects.canvas_gradients = canvas_gradients;

    //$Id$

    var canvasUtils = function () {
      var utils_canvas = {};

      utils_canvas.drawPath = function (ctx, pathString) {
        SVGParser.drawPath(pathString, ctx);
      };

      utils_canvas.getRadianAngle = function (degreeValue) {
        return degreeValue * mathPI / 180;
      };

      utils_canvas.constant = function (x) {
        return function constant() {
          return x;
        };
      };

      utils_canvas.pointX = function (p) {
        return p[0];
      };

      utils_canvas.pointY = function (p) {
        return p[1];
      };

      utils_canvas.rgba = function (color, opacity) {
        opacity = pick(opacity, 1);
        var rgb = d3_rgb(color);
        return "rgba(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ",").concat(opacity * rgb.opacity, ")");
      };

      utils_canvas.roundedRect = function (context, x, y, width, height, radius, yReversed, axisrotated) {
        var path = roundedRect(x, y, width, height, radius, yReversed, axisrotated);
        SVGParser.drawPath(path, context);
      };

      utils_canvas.boundBoxWithHook = function (context, pathDescription) {
        SVGParser.drawPath(pathDescription, context);
      };

      utils_canvas.getFontStyles = function (chartObj, dataLabels, color, isInnerLabel, seriesIndex, isStackLabel) {
        return applyDatalabelFonts(null, dataLabels, chartObj, color, isInnerLabel, seriesIndex, isStackLabel);
      };
      return utils_canvas;
    }();

    function copyCanvasData(context) {
      return context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    }

    /**
     *
     * @param data
     * @param color
     */
    function colorizeImageData(data) {var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'gray';
      var rgb = d3_rgb(color);
      var d = data.data;
      for (var i = 0; i < d.length; i += 4) {
        var med = d[i] + d[i + 1] + d[i + 2];
        if (color === 'grayscale') {
          d[i] = rgb.r = d[i + 1] = d[i + 2] = med;
        } else if (med !== 0) {
          d[i] = rgb.r;
          d[i + 1] = rgb.g;
          d[i + 2] = rgb.b;
          d[i + 3] = rgb.opacity * 255;
        }
      }
    }

    //$Id$

    var canvas_patterns = function canvas_patterns() {};
    // #ZC1836
    var CANVAS_PATTERN_STORE = d3_map();
    var PATTERN_IMG_CACHE = d3_map();

    canvas_patterns.canvasPatternFill = function (prop, clr, returnURL) {
      var pattern, image, canvas, context;
      canvas = document.createElement('canvas');
      context = canvas.getContext('2d');
      if (prop.ele) {
        image = generateCanvasPatternBySVGimage(prop, clr);
      } else {
        image = generateCanvasPatternByProp(prop, clr);
      }
      pattern = context.createPattern(image, 'repeat');
      return pattern;
    };
    canvas_patterns.imageFill = function (options, callback) {
      var image = fillSVGimageInCanvas(options.name, options, callback);
    };

    /**
     * TODO merge with effects.get
     *
     * @param url
     * @param options
     * @param callback
     */
    function fillSVGimageInCanvas(url, options, callback) {
      var repeat_mode = options.repeatMode || 'repeat',
        /**
         * It returns the cache key for the pattern. It includes the dimension and the actual url.
         * Because the dimension can change for bubble charts.
         *
         * @param dimension
         * @return {string}
         */
        get_pattern_cache_key = function get_pattern_cache_key(dimension) {
          return "".concat(url, "-").concat(repeat_mode, "-").concat(~~dimension.x, "-").concat(~~dimension.y, "-").concat(~~dimension.width, "-").concat(~~dimension.height);
        },
        /**
         * It returns a canvas pattern with the given loaded image and dimension.
         *
         * @param {Image} img
         * @param dimension
         * @param options
         * @return {CanvasPattern}
         */
        get_pattern_by_img = function get_pattern_by_img(img, dimension, options) {
          var patternCanvas = document.createElement('canvas');
          patternCanvas.width = dimension.width;
          patternCanvas.height = dimension.height;
          patternCanvas.getContext('2d').drawImage(img, 0, 0, patternCanvas.width, patternCanvas.height);
          return options.context.createPattern(patternCanvas, repeat_mode);
        },
        /**
         *
         * It takes care of the calculation of the dimension and caching the pattern.
         *
         * @param {Image} img
         * @param options
         * @return {{pattern: *, dimension: *}}
         */
        get_cached_pattern = function get_cached_pattern(img, options) {
          var dimension = getImageSize4CanvasPattern(img, options),
            cache_key = get_pattern_cache_key(dimension),
            pattern = CANVAS_PATTERN_STORE.get(cache_key);

          /**
           * if the pattern is not found create with the given image and cache it
           */
          if (!defined(pattern)) {
            pattern = get_pattern_by_img(img, dimension, options);
            CANVAS_PATTERN_STORE.set(cache_key, pattern);
          }

          return { pattern: pattern, dimension: dimension };
        },
        cache_image = PATTERN_IMG_CACHE.get(url);

      if (defined(cache_image)) {
        /**
         * #ZC1836
         *
         * Here we are using the cached image to create the pattern.
         */
        var _get_cached_pattern2 = get_cached_pattern(cache_image, options),pattern = _get_cached_pattern2.pattern,dimension = _get_cached_pattern2.dimension;
        callback(options.context, pattern, dimension);
      } else {
        var img = new Image();
        img.onload = function () {
          // cache the image
          if (!PATTERN_IMG_CACHE.has(url)) {
            PATTERN_IMG_CACHE.set(url, img);
          }
          var _get_cached_pattern3 = get_cached_pattern(img, options),pattern = _get_cached_pattern3.pattern,dimension = _get_cached_pattern3.dimension;
          callback(options.context, pattern, dimension);
        };
        img.src = url;
      }
    }

    function getImageSize4CanvasPattern(imageObj, options) {
      var x = 0,
        y = 0,
        w = imageObj.naturalWidth,
        h = imageObj.naturalHeight,
        computedWidth = validateNullVal(options.width, 50),
        computedHeight = validateNullVal(options.height, 50);

      if (options.repeatMode === 'no-repeat') {
        if (h > w) {
          var remaining = computedWidth - computedWidth * (w / h);
          x = remaining / 2;
          computedWidth -= remaining;
        } else {
          var remaining = computedHeight - computedHeight * (h / w);
          y = remaining / 2;
          computedHeight -= remaining;
        }
      }

      return {
        x: x,
        y: y,
        width: computedWidth,
        height: computedHeight
      };
    }

    function generateCanvasPatternBySVGimage(properties, color) {
      var pattern = effects.get(effects.svg_patterns, 'svgPatternFill', properties, { returnSVGimage: true, base64: true });
      fillSVGimageInCanvas(pattern.url, pattern);
    }

    function generateCanvasPatternByProp(properties, color) {
      var patternID = "zp".concat(generateIdByPropValue(properties, 'canvasFill'));
      var canvas = CANVAS_PATTERN_STORE.get(patternID); //get from cache store
      if (!defined(canvas)) {
        var patternCanvas = document.createElement('canvas');

        var bgClr_base = properties.bgClr || properties.bgClr_base,
          stroke_base = properties.stroke || properties.stroke_base;
        var regExp = /\{\{([a-z]+)\}\}/;

        var symbolTypes = properties.type.split(','),
          noOfSymbols = symbolTypes.length,
          isSize_function = typeof properties.size == 'function',
          isTranslate_function = properties.translate && typeof properties.translate == 'function',
          size = isSize_function ? properties.size(properties.width) : (properties.size || '').split(','),
          strokeWidth = properties.strokeWidth.split(','),
          fillColor = bgClr_base.split(','),
          stroke = stroke_base.split(','),
          fillOpacity = (properties.fillOpacity || '').split(','),
          strokeOpacity = (properties.strokeOpacity || '').split(','),
          translate = isTranslate_function ?
          properties.translate(properties.width) :
          properties.translate ?
          /\[.*?\]/g.test(properties.translate) ?
          JSON.parse(properties.translate) :
          properties.translate.split(',') :
          null;
        size = properties.width && !isSize_function ? getPatternSize(properties, size) : size;

        patternCanvas.width = size[0];
        patternCanvas.height = size[0];

        var patternCanvas_context = patternCanvas.getContext('2d');

        for (var j = 0; j < noOfSymbols; j++) {
          var stroke_cur = isNull(stroke[j] || stroke[0]) ?
            properties.stroke_base :
            (stroke[j] || stroke[0]) == 'static' ?
            properties.customStaticClr :
            stroke[j] || stroke[0],
            fill_cur = isNull(fillColor[j] || fillColor[0]) ?
            properties.bgClr_base :
            (fillColor[j] || fillColor[0]) == 'static' ?
            properties.customStaticClr :
            fillColor[j] || fillColor[0],
            trans_init = (size[j] || size[0]) / 2,
            trans_final = [trans_init, trans_init];
          stroke_cur = regExp.test(stroke_cur) ?
          getColorCopy(properties.stroke_base, 1, stroke_cur.replace(regExp, '$1'), d3_hsl) :
          stroke_cur;
          fill_cur = regExp.test(fill_cur) ? getColorCopy(properties.bgClr_base, 1, fill_cur.replace(regExp, '$1'), d3_hsl) : fill_cur;

          if (translate) {
            var subTranslate = translate[j] || translate[0];
            if (isArray$1(subTranslate)) {
              trans_final = [trans_init + parseFloat(subTranslate[0]), trans_init + parseFloat(subTranslate[1])];
            } else {
              var trans = trans_init + parseFloat(subTranslate);
              trans_final = [trans, trans];
            }
          }

          patternCanvas_context.save();
          patternCanvas_context.translate(trans_final[0], trans_final[1]);
          patternCanvas_context.beginPath();
          patternCanvas_context.lineWidth = strokeWidth[j] || strokeWidth[0];
          patternCanvas_context.fillStyle = rgba_canvas(fill_cur, fillOpacity[j] || fillOpacity[0]);
          patternCanvas_context.strokeStyle = stroke_cur;

          if (symbolTypes[j] === 'circle') {
            patternCanvas_context.arc(0, 0, size[j] / 2, 0, mathPI * 2, false);
          } else {
            var patternPath = getSVGsymbol(symbolTypes[j])(size[j] || size[0]);
            canvasUtils.drawPath(patternCanvas_context, patternPath);
          }

          patternCanvas_context.fill();
          patternCanvas_context.stroke();
          patternCanvas_context.closePath();
          patternCanvas_context.restore();
        }
        CANVAS_PATTERN_STORE.set(patternID, patternCanvas); //save to cache store
        canvas = patternCanvas;
      }
      return canvas;
    }

    effects.canvas_patterns = canvas_patterns;
    Registry.setComponent('patterns.canvas', canvas_patterns);

    //$Id$

    function getFontSizeByHierarchy(conf, chartObj) {
      var systemconf = chartObj.systemConf;
      return +utils.getVal(getValByPriority([conf, systemconf.chart.plot.datalabels, systemconf.chart, systemconf.canvas], 'fontSize'));
    }

    function getFontFamilyByHierarchy(config, chartInstance) {
      var systemConf = chartInstance.systemConf;
      return utils.getVal(getValByPriority([config, systemConf.chart, systemConf.canvas, $ZCG], 'fontFamily'));
    }

    //$Id$

    function dataLabelTextContent(chartObj, rp, conf) {var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'datalabels';var total = arguments.length > 4 ? arguments[4] : undefined;var seriespos = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;var yrangePos = arguments.length > 6 ? arguments[6] : undefined;var paneid = arguments.length > 7 ? arguments[7] : undefined;
      var yColumn = chartObj.seriesdata[seriespos] && chartObj.seriesdata[seriespos].yaxiscolumnorder || [0, 0], //We need the yaxis order and column order. But, rp.yaxiscolumnorder - returns only the yaxis order
        cType = getChartTypeByIndex(chartObj, paneid, seriespos),
        dataProcessorHelpers = DataProcessor.helpers,
        dataObject = chartObj.dataObject,
        columns = chartObj.systemConf.metadata.columns,
        isGeoMap = chartObj.isGeoMap;

      rp = rp || {
        stacked: false,
        commonPlotOptions: chartObj.systemConf.chart.plot.plotoptions[cType.name],
        yaxiscolumnorder: dataProcessorHelpers.getParsedYAxisOrder(yColumn)
      };
      var dataset = chartObj.dataset,
        yaxiscolumnorder = rp.yaxiscolumnorder,
        stacked = rp.stacked,
        yscale = rp.yscale,
        isBubblePie = isMultiPieChartType(cType.value),
        piedataindex = validateNullVal(rp.commonPlotOptions.dataindex, 3),
        rendererIndex = getRendererIndex({ paneid: paneid }, chartObj, 0),
        getProcessedNodeFunc = chartObj.renderer[rendererIndex] && chartObj.renderer[rendererIndex].getProcessedNode,
        labelMeta = chartObj.systemConf.metadata.axes.label,
        labelIndex = labelMeta && labelMeta[0],
        hasLabelIndex = type === DATALABELS_LABELTYPE && defined(labelIndex),
        isStackLabel = type == STACKLABELS_LABELTYPE,
        showAs = hasLabelIndex ? columns[labelIndex] ? "{{val(".concat(labelIndex, ")}}") : labelIndex.toString() : conf.showAs,
        isShowAsDefined =
        [X_SHOWAS, Y_SHOWAS, Z_SHOWAS, PERCENT_SHOWAS, SPLITPERCENT_SHOWAS, MAXPERCENT_SHOWAS, GEO_SHOWAS].indexOf(showAs) != -1,
        hasPercentShowAs = [PERCENT_SHOWAS, SPLITPERCENT_SHOWAS, MAXPERCENT_SHOWAS].indexOf(showAs) != -1,
        hasShowAsFunction = typeof showAs === 'function' || typeof window[showAs] === 'function',
        datatype,
        formatConf,
        formattingFunc,
        newShowAs;

      /**
       * #ZC2050
       * in case of any custom behavior we use the base scale for y axis
       * since after applying zoom or brush the domain may change
       */
      if (chartObj.renderVisiblePointsOnly && !chartObj.isGeoMap) {
        yscale = getAxisObject(chartObj, 'y', yaxiscolumnorder).baseScale || yscale;
      }

      if (!isShowAsDefined && !hasShowAsFunction) {
        newShowAs = getTspanTemplate(showAs);
      }

      if (!hasLabelIndex) {
        var axisType = hasLabelIndex ?
        'label' :
        showAs == X_SHOWAS ?
        X_SHOWAS :
        showAs == Z_SHOWAS && defined(dataset.zidx) ?
        Z_SHOWAS :
        isGeoMap ?
        GEO_SHOWAS :
        Y_SHOWAS;
        datatype = columns[dataset.getColumnIdx(axisType, yColumn)].datatype;
        formatConf = dataset.getColumn(axisType, yColumn)[datatype];
        formattingFunc = hasPercentShowAs ? getFormattedValueByPercent : getFormattedValue;

        if (isBubblePie && !hasShowAsFunction && hasPercentShowAs) {
          var col = columns.filter(function (c) {
            return c.dataindex === piedataindex;
          })[0];
          col = defined(col) ? col : dataset.getColumnIdx(axisType, yColumn);
          datatype = col.datatype;
          formatConf = col[datatype];
        }
      }

      var textContent = function textContent(dt) {var itemIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var bound = arguments.length > 2 ? arguments[2] : undefined;
        var d = isStackLabel ? dt[1] : dt;
        var node = dataObject.isHierarchy && getProcessedNodeFunc && getProcessedNodeFunc(d);
        if (isShowAsDefined) {
          var value = NULL$1;
          switch (showAs) {
            case PERCENT_SHOWAS:
            case SPLITPERCENT_SHOWAS:
            case MAXPERCENT_SHOWAS:
              var t = total,
                v = isStackLabel ?
                d :
                stacked || dataObject.isPercentChart ?
                d.y :
                isBubblePie ?
                d[piedataindex] :
                node && node.children && node.value || d.value || dataset.getY(d, yaxiscolumnorder, yrangePos);

              if (stacked && !dataObject.isPercentChart && type == DATALABELS_LABELTYPE) {
                t = getStackedTotal(chartObj, seriespos, d, showAs);
              } else if (typeof total === 'function') {
                t = total(d, showAs);
              } else if (!defined(t)) {
                if (showAs === MAXPERCENT_SHOWAS || !yscale) {
                  var domain = dataObject.ZC_BAR_getRangeY(yaxiscolumnorder);
                  t = v < 0 && v >= domain[0] ? -domain[0] : domain[1];
                } else {
                  t = (yscale.originalDomain || yscale.domain())[1];
                }
              }

              value = v / t * 100 || 0; //if t=0 and v=0, the 'value' holds NaN
              break;
            case X_SHOWAS:
              value = !(node && node.children) ? dataset.getActualX(d) : UNDEFINED;
              break;
            case Z_SHOWAS:
              if (defined(dataset.zidx)) {
                value = dataset.getZ(d);
              }
              break;
            case GEO_SHOWAS:
              value = dataset.getGeo(d);
              break;
            default:
              value = isStackLabel ?
              d :
              dataObject.isHierarchy ?
              node && node.children && node.value || d.value || dataset.getY(d, yaxiscolumnorder) :
              dataset.getY(d, yaxiscolumnorder, yrangePos);}

          return formattingFunc(formatConf, value, datatype, chartObj, type);
        } else if (hasShowAsFunction) {
          return invokeFunction(showAs, dt, bound, chartObj);
        } else {
          var _isMultiColoring = isMultiColorChart(cType.name, chartObj),
            color = isStackLabel ? NULL$1 : getRawColor(chartObj, _isMultiColoring ? itemIndex : seriespos, d, seriespos, paneid);

          return dataset.getCustomizedVal(
          chartObj,
          newShowAs,
          seriespos,
          NULL$1,
          NULL$1,
          d,
          type,
          color,
          textContent.contentType !== 'html',
          NULL$1,
          yrangePos);

        }
      };

      //Find the content type of the data labels
      textContent.contentType =
      !isShowAsDefined && (hasShowAsFunction || isArray$1(showAs) || showAs.indexOf('<tspan') != -1) ? 'html' : 'text';
      textContent.multiLine = textContent.contentType === 'html' && !hasShowAsFunction && isArray$1(showAs) && showAs.length > 1;
      textContent.hasShowAsFunction = hasShowAsFunction;
      return textContent;
    }
    Registry.setComponent('dataLabel.getContent', dataLabelTextContent);

    function getDy4MultiLine(ele, dataLabels, dy, text, display) {
      var DY = dy,
        actualDY,
        content = text,
        visibleTspan = getVisibleTspan(ele),
        lineCount = (visibleTspan.length - 1) * 1.1;

      if (!visibleTspan.length) {
        display = false;
      } else if (dataLabels.showAs.length !== visibleTspan.length) {
        d3_select(visibleTspan[0]).attr('dy', null);
        content = ele.html();
      }

      if (DY === -0.3) {
        DY -= lineCount;
        actualDY = DY + lineCount;
      } else if (DY === 0.3) {
        DY -= lineCount / 2;
        actualDY = DY + lineCount / 2;
      }

      return [DY, actualDY, content, display];
    }

    //$Id$

    /*
     * PENDING:
     * *Bound box for stack labels
     */
    function barLabel() {
      var renderer, args;
      var textDirection,
        rotation,
        dataProcessorHelpers = DataProcessor.helpers;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var currentdata = args[0],
            index = args[1],
            labelType = args[2] || DATALABELS_LABELTYPE,
            yrangePos = args[3],
            columnindex = args[4],
            rendererIndex = pick(labelHandler.rendererIndex, index),
            paneid = labelHandler.paneid,
            rp = renderer.commonRendererProp().params,
            dataindex = defined(columnindex) ? rp.chartObj.systemConf.metadata.columns[columnindex].dataindex : null,
            plotoptions = currentdata.plotoptions,
            dataLabels,
            chartObj = rp.chartObj,
            systemconf = chartObj.systemConf,
            commonPlotOptions = rp.commonPlotOptions,
            dataset = rp.dataset,
            stacked = rp.stacked,
            yscale = rp.yscale,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            labelArray = getLabelArray(rp, paneid),
            isStackedLabels = labelType === STACKLABELS_LABELTYPE,
            cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
            isRangeChartType = cType_Obj.name == BOXPLOT_CHARTNAME || cType_Obj.name == BARRANGE_CHARTNAME, //consider median for boxplot
            hasRangePos = isRangeChartType && defined(yrangePos), //consider median for boxplot
            isCanvasMode = chartObj.plot.renderer.mode === 'canvas',
            axisrotated = rp.axisrotated;

          var renderWithinPlot = true,
            renderOnInit = chartObj.systemConf.chart.plot.datalabels.renderOnInit;

          // #ZC2228
          if (!renderOnInit) {
            var behaviours = chartObj.behaviouralEvents.eventManager.behaviours;
            if (behaviours.PLOT_ZOOM || behaviours.CHART_SCROLL && !axisrotated) {
              renderWithinPlot = false;
            }
          }

          dataLabels = getMergedDatalabelOptions(commonPlotOptions, isStackedLabels ? NULL$1 : plotoptions, chartObj, index, paneid);

          if (isStackedLabels) {
            dataLabels = dataLabels.stackLabels;
          }
          var showlabel = isStackedLabels ? isStacklabelEnabled(dataLabels, chartObj) : isDatalabelEnabled(dataLabels, chartObj);

          if (currentdata.disabled || !showlabel || !isStackedLabels && isSeriesFiltered(chartObj, paneid, index)) {
            return;
          }

          var currentPlotBound = getPlotBound(chartObj);
          var textOverlap = dataLabels.textOverlap, //hidden | adjust | clip
            labelPos = getValignforBarLabels(chartObj, index, labelType), //bottom | top | middle
            showZeros = dataLabels.showZeros,
            multiColoring = isMultiColoring(commonPlotOptions, chartObj),
            left = currentPlotBound.left,
            top = currentPlotBound.top,
            right = currentPlotBound.right,
            bottom = currentPlotBound.bottom,
            rectBound = chartObj.svg.node().getBoundingClientRect(),
            rectBoundLeft = rectBound.left + chartObj.plotarea.left,
            rectBoundTop = rectBound.top + chartObj.plotarea.top,
            dim = (axisrotated ? chartObj.plotarea.width : chartObj.plotarea.height) * 0.75,
            GLT = dataLabelTextContent(chartObj, rp, dataLabels, labelType, NULL$1, index, yrangePos, paneid),
            contentType = GLT.contentType || 'text',
            isMultiLine = contentType === 'html' && GLT.multiLine,
            isFixedTopPostion = labelPos === FIXEDTOP_ALIGN,
            isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
            isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder),
            yaxisReversed = systemconf.chart.axes.yaxis[yaxiscolumnorder || 0].reversed,
            barW = chartObj.barscale2.bandwidth() || 0,
            fontSize = getFontSizeByHierarchy(dataLabels, chartObj),
            datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder);

          // if (isFixedTopPostion && !chartObj.cache.correction['label-y-' + yaxiscolumnorder]) {
          //     return;
          // }

          var boundBoxPadding = 0,
            boundBoxStrokeWidth = 0,
            hookHeight = 0,
            hookWidth = 0,
            boundBoxRadius = 0;
          if (isBoundBoxEnabled(dataLabels, chartObj)) {
            var boundBoxOptions = getMergedBoundBoxOptions(dataLabels, chartObj);
            var hookOptions = getBoundBoxHookConf(boundBoxOptions.hook);
            boundBoxPadding = getBoundBoxPadding(dataLabels, chartObj);
            boundBoxStrokeWidth = getBoundBoxStrokeWidth(dataLabels, chartObj);
            hookHeight = stacked || labelPos === MIDDLE_ALIGN ? 0 : hookOptions.height;
            hookWidth = hookOptions.width;
            boundBoxRadius = boundBoxOptions.radius;
          }

          var clip = textOverlap === 'clip',
            handleOverlapping = systemconf.chart.plot.datalabels.handleOverlapping && textOverlap !== NONE,
            padding =
            mathMax(0, validateNullVal(dataLabels.padding, 2)) +
            boundBoxPadding +
            hookHeight + (
            isFixedTopPostion && boundBoxStrokeWidth ? boundBoxStrokeWidth / 2 - 1 : 0),
            fixedTopPosition = isFixedTopPostion && getFixedTopPosition();
          padding = padding > dim ? dim : padding;
          textDirection = dataLabels.textDirection;
          textDirection =
          !textDirection || stacked && !isStackedLabels ? axisrotated ? VERTICAL_ALIGN : HORIZONTAL_ALIGN : textDirection;
          rotation = axisrotated ? textDirection == HORIZONTAL_ALIGN ? 90 : 0 : textDirection == HORIZONTAL_ALIGN ? 0 : 270;
          var commonOption = renderer.commonOption;
          var getParamValue = function getParamValue() {
            return chartObj.dataObject.getTransRectValue.apply(chartObj.dataObject, toArray(arguments));
          };

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), TEXT_ELEMENT, [1], '.', 'class', 'temp_label');
          var updateHandler = labelHandler.update,
            queue = labelHandler.add;
          if (chartObj.viewFlow && chartObj.viewFlow.marks._default.label.length) {
            var marks_plot = chartObj.viewFlow.marks._default.label[index];
            currentdata = marks_plot.data;
          }
          currentdata.data.forEach(function (d, i) {
            var dataUpdate =
            renderer.seriesdataAfterUpdate && !isStackedLabels ? renderer.seriesdataAfterUpdate[i] : currentdata.data[i];

            if (isStackedLabels) {
              var scrollOptions = systemconf.chart.scroll;
              if (scrollOptions && scrollOptions.enabled) {
                // #ZC1374
                dataUpdate = getVisibleData(dataUpdate, rp.xscale.domain());
              }

              if (isFixedTopPostion && yscale.domain()[0] < 0) {
                dataUpdate = getUniqueDataByX(dataUpdate);
              }
            }

            var commonProperties = [];
            applyDatalabelFonts(temp_label, dataLabels, chartObj, rp.color, false, index);
            temp_label.style('opacity', 0);

            dataUpdate.forEach(function (d, j) {
              var text,
                boundBox = NULL$1,
                display = true,
                flip = yaxisReversed ? -1 : 1,
                isNeg = isStackedLabels ? d[1] < 0 : dataset.getY(d, yaxiscolumnorder) < 0;

              temp_label[contentType](function () {
                if (isStackedLabels) {
                  var yVal = d[1],
                    xVal = d[0];
                  text = !showZeros && yVal == 0 ? NULL$1 : GLT(d, j);
                } else if (
                isCatNullX(dataset.getX(d)) ||
                isCatNullY(dataset.getY(d, yaxiscolumnorder)) ||
                !showZeros && dataset.getY(d, yaxiscolumnorder) == 0)
                {
                  text = NULL$1;
                } else {
                  text = GLT(d, j);
                }
                return text;
              });

              if (isMultiLine) {
                translateTspan(temp_label, 0);
              }

              var X, Y, DY, ANCHOR, HOOKPOSITION, actualDY;
              boundBox = bbox(temp_label.node());
              var widthToBeAdded = 0,
                heightToBeAdded = 0;

              if (isStackedLabels) {
                // boundBox = bbox(temp_label.node());
                var x = commonOption.bandwidth1(d[0]) + commonOption.bandwidth2(commonOption.stackGroupIndex), //ZC1419
                  y = yscale(d[2] || d[1]); //For waterfall charts, there will be cascaded value
                X = axisrotated ? y : x;
                Y = axisrotated ? x : y;
                if (axisrotated) {
                  if (textDirection == HORIZONTAL_ALIGN) {
                    X += (isNeg ? -padding : padding) * flip;
                    DY = yaxisReversed ? isNeg ? '-0.3em' : '1em' : isNeg ? '1em' : '-0.3em';
                  } else {
                    Y += barW / 2;
                    DY = '0.3em';
                    if (isFixedTopPostion) {
                      X = fixedTopPosition + padding * flip + (isMultiLine ? 0 : 0) * flip;
                      ANCHOR = yaxisReversed ? 'end' : NULL$1;
                    } else {
                      X += (isNeg ? -padding : padding) * flip;
                      ANCHOR = yaxisReversed ? isNeg ? NULL$1 : 'end' : isNeg ? 'end' : NULL$1;

                      if (isMultiLine) {
                        X += boundBox.width / 2 * (isNeg ? -1 : 1) * flip;
                      }
                    }
                  }
                } else {
                  X += barW / 2;
                  Y += (isNeg ? padding : -padding) * flip;
                  if (textDirection == VERTICAL_ALIGN) {
                    DY = '0.3em';
                    ANCHOR = yaxisReversed ? isNeg ? NULL$1 : 'end' : isNeg ? 'end' : NULL$1;
                  } else {
                    ANCHOR = 'middle';
                    if (isFixedTopPostion) {
                      Y = fixedTopPosition - padding * flip;
                      DY = yaxisReversed ? '1em' : '-0.3em';
                    } else {
                      DY = yaxisReversed ? isNeg ? '-0.3em' : '1em' : isNeg ? '1em' : '-0.3em';
                    }
                  }
                }
              } else {
                // var b = boundBox = bbox(temp_label.node()),
                var b = boundBox,
                  x =
                  defined(dataindex) && axisrotated ?
                  rp.yscale(d[dataindex][yrangePos] || d[dataindex]) :
                  getParamValue('x', d, i, j, commonOption, null, yrangePos) || 0,
                  y =
                  defined(dataindex) && !axisrotated ?
                  rp.yscale(d[dataindex][yrangePos] || d[dataindex]) :
                  getParamValue('y', d, i, j, commonOption, null, yrangePos) || 0, //consider median for boxplot {d[dataindex] is not an array}
                  width = getParamValue('width', d, i, j, commonOption) || 0,
                  height = getParamValue('height', d, i, j, commonOption) || 0,
                  CLIP = clip;
                X = x;
                Y = y;
                var hasNegRange = hasRangePos && defined(dataindex) ? d[dataindex][0] > d[dataindex][1] : null,
                  isInverted = yaxisReversed ? hasNegRange ? true : false : hasNegRange ? true : false,
                  isInverted_yAlign = yaxisReversed && axisrotated ? !isInverted : isInverted,
                  curYalignPos = isInverted_yAlign ? 1 - yrangePos : yrangePos, //For negRange invert yrangePos
                  curYHookPos = yaxisReversed ?
                  hasNegRange ?
                  yrangePos :
                  1 - yrangePos :
                  hasNegRange ?
                  1 - yrangePos :
                  yrangePos,
                  flip = isRangeChartType && hasRangePos ? yaxisReversed && !axisrotated ? -1 : 1 : flip; //NEED TO CHECK ZC2039

                if (axisrotated) {
                  if (stacked) {
                    Y += height / 2;
                    DY = '0.3em';
                    if (labelPos == MIDDLE_ALIGN) {
                      X += width / 2 * flip;
                      ANCHOR = 'middle';
                    } else if (labelPos == TOP_ALIGN) {
                      X += (isNeg ? padding : width - padding) * flip;
                      ANCHOR = yaxisReversed ? isNeg ? 'end' : NULL$1 : isNeg ? NULL$1 : 'end';

                      if (isMultiLine && !isFixedTopPostion) {
                        X += b.width / 2 * (isNeg ? 1 : -1) * flip;
                      }
                    } else {
                      X += (isNeg ? width - padding : padding) * flip;
                      ANCHOR = yaxisReversed ? isNeg ? NULL$1 : 'end' : isNeg ? 'end' : NULL$1;

                      if (isMultiLine && !isFixedTopPostion) {
                        X += b.width / 2 * (isNeg ? -1 : 1) * flip;
                      }
                    }
                  } else {
                    if (textDirection == VERTICAL_ALIGN) {
                      heightToBeAdded = getSizeToBeAdded(boundBox.height, boundBoxPadding, boundBoxRadius, hookWidth);
                      Y += height / 2 + heightToBeAdded / 2;
                      DY = '0.3em';
                      CLIP = CLIP && labelPos != TOP_ALIGN && b.width > width;
                      HOOKPOSITION = yaxisReversed ? isNeg ? LEFT_ALIGN : RIGHT_ALIGN : isNeg ? RIGHT_ALIGN : LEFT_ALIGN;

                      if (isFixedTopPostion) {
                        ANCHOR = yaxisReversed ? 'end' : NULL$1;
                        X = fixedTopPosition + padding * flip + (isMultiLine ? 0 : 0) * flip;
                        HOOKPOSITION = yaxisReversed ? RIGHT_ALIGN : LEFT_ALIGN;
                      } else if (!CLIP) {
                        ANCHOR = yaxisReversed ? isNeg ? NULL$1 : 'end' : isNeg ? 'end' : NULL$1;
                        if (labelPos == MIDDLE_ALIGN) {
                          X += (b.width > width ? isNeg ? width : 0 : width / 2) * flip;
                          ANCHOR = b.width > width ? ANCHOR : 'middle';
                        } else if (labelPos == TOP_ALIGN) {
                          if (isRangeChartType) {
                            if (hasRangePos) {
                              X += (curYalignPos == 0 ? -padding : padding) * flip;
                              ANCHOR = curYalignPos == 0 ? 'end' : NULL$1;
                              HOOKPOSITION = curYHookPos == 0 ? RIGHT_ALIGN : LEFT_ALIGN;
                            } else {
                              // X += (b.width > width ? (isNeg ? width : 0) : width / 2) * flip;
                              ANCHOR = 'middle';
                              HOOKPOSITION = NULL$1;
                            }
                          } else {
                            X += (isNeg ? -padding : width + padding) * flip;
                          }
                          // X += (isNeg ? -padding : width + padding) * flip;
                        } else {
                          X += (isNeg ? width - padding : padding) * flip;
                        }

                        if (isMultiLine && !(labelPos === MIDDLE_ALIGN && b.width <= width)) {
                          X += (isNeg ? -boundBox.width / 2 : boundBox.width / 2) * flip;
                        }
                      } else {
                        if (labelPos == BOTTOM_ALIGN) {
                          X += yaxisReversed ? isNeg ? -width + padding : -width : isNeg ? 0 : padding;
                        } else if (labelPos == MIDDLE_ALIGN) {
                          X += yaxisReversed ? -width + boundBoxPadding : boundBoxPadding;
                        }
                      }
                    } else {
                      widthToBeAdded = getSizeToBeAdded(boundBox.width, boundBoxPadding, boundBoxRadius, hookWidth);
                      DY = yaxisReversed ? isNeg ? '-0.3em' : '1em' : isNeg ? '1em' : '-0.3em';
                      CLIP = CLIP && b.width > height;
                      HOOKPOSITION = yaxisReversed ? isNeg ? BOTTOM_ALIGN : TOP_ALIGN : isNeg ? TOP_ALIGN : BOTTOM_ALIGN;

                      if (labelPos == MIDDLE_ALIGN) {
                        if (b.height > width) {
                          if (isMultiLine) {
                            X += (yaxisReversed ? isNeg ? width : 0 : isNeg ? 0 : width) * flip;
                            X += yaxisReversed ? b.height / 2 * (isNeg ? 1 : -1) : 0;
                          } else {
                            X += (yaxisReversed ? isNeg ? 0 : width : isNeg ? width : 0) * flip;
                          }
                        } else {
                          X += width / 2 * flip;
                        }
                        DY = b.height > width ? DY : '0.3em';
                      } else if (labelPos == TOP_ALIGN) {
                        if (isRangeChartType) {
                          if (hasRangePos) {
                            X += (curYalignPos == 0 ? -padding : padding) * flip;
                            ANCHOR = curYalignPos == 0 ? 'end' : NULL$1;
                            HOOKPOSITION = curYHookPos == 0 ? RIGHT_ALIGN : LEFT_ALIGN;
                            DY = curYHookPos == 0 ? '1em' : '-0.3em';
                            // DY = yaxisReversed ? (isNeg ? '-0.3em' : '1em') : isNeg ? '1em' : '-0.3em';
                          } else {
                            // X += (b.width > width ? (isNeg ? width : 0) : width / 2) * flip;
                            ANCHOR = 'middle';
                            HOOKPOSITION = NULL$1;
                          }
                        } else {
                          X += (isNeg ? -padding : width + padding) * flip;
                        }
                      } else {
                        X += (isNeg ? width - padding : padding) * flip;
                      }
                      if (!CLIP) {
                        Y += height / 2;
                        ANCHOR = 'middle';
                        if (labelPos == MIDDLE_ALIGN) {
                          DY = '0.3em';
                        }
                      } else {
                        X += widthToBeAdded / 2;
                        Y += boundBoxPadding;
                      }
                    }
                  }
                } else {
                  if (stacked) {
                    X += width / 2;
                    ANCHOR = 'middle';
                    if (labelPos == MIDDLE_ALIGN) {
                      Y += height / 2 * flip;
                      DY = '0.3em';
                    } else if (labelPos == TOP_ALIGN) {
                      Y += (isNeg ? height - padding : padding) * flip;
                      DY = yaxisReversed ? isNeg ? '1em' : '-0.3em' : isNeg ? '-0.3em' : '1em';
                    } else {
                      Y += (isNeg ? padding : height - padding) * flip;
                      DY = yaxisReversed ? isNeg ? '-0.3em' : '1em' : isNeg ? '1em' : '-0.3em';
                    }
                  } else {
                    if (textDirection == VERTICAL_ALIGN) {
                      heightToBeAdded = getSizeToBeAdded(boundBox.height, boundBoxPadding, boundBoxRadius, hookWidth);
                      var BW = !yaxisReversed && isNeg || yaxisReversed && !isNeg ? b.width : 0;
                      CLIP = CLIP && labelPos != TOP_ALIGN && b.width + padding > height;
                      DY = '0.3em';
                      HOOKPOSITION = yaxisReversed ? isNeg ? LEFT_ALIGN : RIGHT_ALIGN : isNeg ? RIGHT_ALIGN : LEFT_ALIGN;

                      if (!CLIP) {
                        X += width / 2;
                        if (labelPos == MIDDLE_ALIGN) {
                          if (b.width > height) {
                            if (isMultiLine) {
                              Y += (isNeg ? boundBox.width / 2 : height - boundBox.width / 2) * flip;
                            } else {
                              Y += (isNeg ? 0 : height) * flip + BW;
                            }
                          } else {
                            Y += height / 2 * flip;
                          }
                          ANCHOR = b.width > height ? NULL$1 : 'middle';
                        } else if (labelPos == TOP_ALIGN) {
                          Y += (isNeg ? height + padding : -padding) * flip + BW;
                          if (isMultiLine) {
                            Y -= boundBox.width / 2;
                          }
                        } else {
                          Y += (isNeg ? padding : height - padding) * flip + BW;
                          if (isMultiLine) {
                            Y -= boundBox.width / 2;
                          }
                        }
                      } else {
                        X += width / 2;
                        if (labelPos == MIDDLE_ALIGN) {
                          Y += yaxisReversed ? boundBoxPadding : height - boundBoxPadding;
                        } else {
                          Y += yaxisReversed ? isNeg ? -padding : 0 : height + (isNeg ? 0 : -padding);
                        }
                      }
                    } else {
                      widthToBeAdded = getSizeToBeAdded(boundBox.width, boundBoxPadding, boundBoxRadius, hookWidth);
                      CLIP = CLIP && b.width + 2 * boundBoxPadding > width;
                      DY = yaxisReversed ?
                      isNeg || curYalignPos == 0 ?
                      '-0.3em' :
                      '1em' :
                      isNeg || curYalignPos == 0 ?
                      '1em' :
                      '-0.3em';
                      HOOKPOSITION = yaxisReversed ? isNeg ? BOTTOM_ALIGN : TOP_ALIGN : isNeg ? TOP_ALIGN : BOTTOM_ALIGN;

                      if (isFixedTopPostion) {
                        Y = fixedTopPosition - padding * flip;
                        HOOKPOSITION = yaxisReversed ? TOP_ALIGN : BOTTOM_ALIGN;
                        DY = yaxisReversed ? '1em' : '-0.3em';
                      } else if (labelPos == MIDDLE_ALIGN) {
                        Y += (b.height < height ? height / 2 : isNeg ? 0 : height) * flip;
                        DY = b.height < height ? '0.3em' : DY;
                      } else if (labelPos == TOP_ALIGN) {
                        Y += (isNeg && !hasRangePos ? height + padding : curYalignPos == 0 ? padding : -padding) * flip;
                        HOOKPOSITION = isRangeChartType ?
                        hasRangePos ?
                        curYHookPos == 0 ?
                        TOP_ALIGN :
                        BOTTOM_ALIGN :
                        NULL$1 :
                        HOOKPOSITION;
                      } else {
                        Y += (isNeg ? padding : height - padding) * flip;
                      }
                      if (!CLIP) {
                        X += width / 2;
                        ANCHOR = 'middle';
                      } else {
                        X += boundBoxPadding;
                      }
                    }
                  }
                }
              }

              if (isMultiLine) {
                var t = getDy4MultiLine(temp_label, dataLabels, parseFloat(DY), text, display);
                DY = "".concat(t[0], "em");
                actualDY = t[1]; //check
                text = t[2];
                display = t[3];

                if (!CLIP && !isFixedTopPostion) {
                  ANCHOR = 'middle';
                }
              }

              temp_label.attrs({
                x: X,
                y: Y,
                dy: DY,
                'text-anchor': ANCHOR,
                transform: "rotate(".concat(rotation, " ").concat(X, " ").concat(Y, ")")
              });

              if (isFixedTopPostion && display !== false) {
                var maxWidth = perToPx(defined(dataLabels.maxWidth) ? dataLabels.maxWidth : '30%', chartObj.plotarea.width);
                if (contentType === 'html') {
                  translateTspan(temp_label, X);
                  var bb = bbox(temp_label.node()),
                    edge = {
                      left: bb.x,
                      top: bb.y,
                      right: bb.x + maxWidth,
                      bottom: bb.y + bb.height
                    },
                    actualWidth = bb.width;
                  var tspanInfo = getTspanBound(temp_label, fontSize);
                  trimAllTspan(temp_label, chartObj, [0, 0], 0, edge, tspanInfo);
                  text = temp_label.html();
                } else {
                  var bb = bbox(temp_label.node()),
                    edge = {
                      left: bb.x,
                      top: bb.y,
                      right: bb.x + maxWidth,
                      bottom: bb.y + bb.height
                    };
                  callTrimText(temp_label, chartObj, [0, 0], 0, edge);
                  text = temp_label.text();
                }
              }

              var xDiff = 0,
                yDiff = 0,
                adjustX = 0,
                adjustY = 0;
              HOOKPOSITION = labelPos === MIDDLE_ALIGN ? NULL$1 : HOOKPOSITION; // There is no hook for middle datalabels
              if (axisrotated) {
                adjustY = (textDirection === HORIZONTAL_ALIGN ? widthToBeAdded : heightToBeAdded) / 2;
              } else {
                adjustX = (textDirection === HORIZONTAL_ALIGN ? widthToBeAdded : heightToBeAdded) / 2;
              }

              if (!clip) {
                if (isMultiLine) {
                  translateTspan(temp_label, X);
                }
                var adjust = boundBoxPadding + boundBoxStrokeWidth / 2,
                  scrolledX = 0, //chartObj.chartRendered ? (chartObj.scrolledX || 0) : 0,
                  scrolledY = 0; //chartObj.chartRendered ? (chartObj.scrolledY || 0) : 0;

                var b = temp_label.node().getBoundingClientRect(),
                  leftPos = b.left - rectBoundLeft - adjust - adjustX - scrolledX,
                  rightPos = leftPos + b.width + 2 * adjust + 2 * adjustX,
                  topPos = b.top - rectBoundTop - adjust - adjustY - scrolledY,
                  bottomPos = topPos + b.height + 2 * adjust + 2 * adjustY;

                if (renderWithinPlot) {
                  var newX = X + (leftPos < left ? left - leftPos : rightPos > right ? -(rightPos - right) : 0);
                  if (newX != X && !(isFixedTopPostion && axisrotated)) {
                    xDiff = newX - X;
                    X = newX;
                  }
                  var newY = Y + (topPos < top ? top - topPos : bottomPos > bottom ? -(bottomPos - bottom) : 0);
                  if (newY != Y && !(isFixedTopPostion && !axisrotated)) {
                    yDiff = newY - Y;
                    Y = newY;
                  }
                }
              }

              /**
               * Overlapping handle
               */

              var isWithinClrRange = isWithinColorRange(dataset.getClr(d), chartObj);
              display = display && (isStackedLabels || isWithinClrRange);
              if (handleOverlapping) {
                if (stacked && !isStackedLabels) {
                  temp_label //Test_828.json
                  .attrs({
                    x: X,
                    y: Y
                  });
                  if (isMultiLine) {
                    translateTspan(temp_label, X);
                  }
                  boundBox = bbox(temp_label.node());
                  var x = getParamValue('x', d, i, j, commonOption) || 0,
                    y = getParamValue('y', d, i, j, commonOption) || 0,
                    height = getParamValue('height', d, i, j, commonOption) || 0,
                    width = getParamValue('width', d, i, j, commonOption) || 0;

                  if (yaxisReversed) {
                    axisrotated ? x -= width : y -= height;
                  }

                  var labelBound = {
                      x1: boundBox.x - boundBoxPadding,
                      y1: boundBox.y - boundBoxPadding,
                      x2: boundBox.x + boundBox.width + boundBoxPadding,
                      y2: boundBox.y + boundBox.height + boundBoxPadding
                    },
                    barBound = {
                      x1: x,
                      y1: y,
                      x2: x + width,
                      y2: y + height
                    };

                  var within = isLabelWithinBound(labelBound, barBound);
                  if (!within) {
                    display = false;
                  } else if (cType_Obj.name === BULLET_CHARTNAME) {
                    var b = temp_label.node().getBoundingClientRect(),
                      bx = b.left - rectBoundLeft,
                      by = b.top - rectBoundTop;
                    var obj = {
                      id: "lbl".concat(rendererIndex, "_").concat(i, "_").concat(j, "_").concat(index, "_").concat(yrangePos),
                      translateFunction: updateHandler,
                      isStackedLabels: isStackedLabels,
                      x1: bx - boundBoxPadding + xDiff - adjustX,
                      y1: by - boundBoxPadding + yDiff - adjustY,
                      x2:
                      bx +
                      b.width +
                      boundBoxPadding +
                      xDiff + (
                      !rotation ? 0 : hookHeight + 2 * boundBoxStrokeWidth) +
                      adjustX,
                      y2:
                      by +
                      b.height +
                      boundBoxPadding +
                      yDiff + (
                      rotation ? 0 : hookHeight + 2 * boundBoxStrokeWidth) +
                      adjustY,
                      overlap: isFixedTopPostion && textOverlap !== 'hidden' && textOverlap !== NONE ? 'hidden' : textOverlap
                    };
                    labelArray.push(obj);
                  }
                } else {
                  if (!clip || isStackedLabels) {
                    if (isMultiLine) {
                      translateTspan(temp_label, X);
                    }
                    var b = temp_label.node().getBoundingClientRect();
                    var bx = b.left - rectBoundLeft,
                      by = b.top - rectBoundTop;
                    var obj = {
                      id: "lbl".concat(rendererIndex, "_").concat(i, "_").concat(j, "_").concat(index, "_").concat(yrangePos),
                      translateFunction: updateHandler,
                      isStackedLabels: isStackedLabels,
                      x1: bx - boundBoxPadding + xDiff - adjustX,
                      y1: by - boundBoxPadding + yDiff - adjustY,
                      x2:
                      bx +
                      b.width +
                      boundBoxPadding +
                      xDiff + (
                      !rotation ? 0 : hookHeight + 2 * boundBoxStrokeWidth) +
                      adjustX,
                      y2:
                      by +
                      b.height +
                      boundBoxPadding +
                      yDiff + (
                      rotation ? 0 : hookHeight + 2 * boundBoxStrokeWidth) +
                      adjustY,
                      overlap: isFixedTopPostion && textOverlap !== 'hidden' && textOverlap !== NONE ? 'hidden' : textOverlap
                    };
                    labelArray.push(obj);
                  } else {
                    if (textDirection != HORIZONTAL_ALIGN) {
                      var w = getParamValue(axisrotated ? 'width' : 'height', d, i, j, commonOption) || 0;
                      width =
                      labelPos == TOP_ALIGN ?
                      boundBox.width :
                      w - (labelPos == BOTTOM_ALIGN ? padding + boundBoxPadding : 2 * boundBoxPadding);
                    } else {
                      width = barW - 2 * boundBoxPadding;
                    }

                    boundBox.width = mathMin(width, boundBox.width);
                  }
                }
              }

              var coordinate = {
                X: X,
                Y: Y,
                DY: DY,
                ANCHOR: ANCHOR,
                text: text,
                display: display,
                height: boundBox.height + heightToBeAdded,
                width: boundBox.width + widthToBeAdded,
                hookPosition: HOOKPOSITION,
                adjustVal: textDirection === HORIZONTAL_ALIGN ? axisrotated ? yDiff : xDiff : NULL$1
              };

              if (actualDY !== undefined) {
                coordinate.actualDY = actualDY;
              }

              if (isCanvasMode && contentType === 'html') {
                coordinate.tspanInfo = getTspanBound(temp_label, fontSize);
              }

              commonProperties.push(coordinate);
            });

            // add to drawing queue
            commonProperties.dataUpdate = dataUpdate; //Each subseries may have different dataUpdates
            var q = queue(commonProperties, index, i, yrangePos, isStackedLabels ? STACKLABELS_LABELTYPE : NULL$1, rendererIndex);
            q.properties = {
              type: BAR_CHARTNAME,
              dataLabels: dataLabels,
              rotation: rotation,
              color: rp.color,
              dataUpdate: dataUpdate,
              showlabel: showlabel,
              multiColoring: multiColoring,
              textDirection: textDirection,
              rangeChart: hasRangePos,
              yrangePos: yrangePos,
              rp: rp,
              contentType: contentType,
              isMultiLine: isMultiLine,
              chartType: cType_Obj.value
            };
          });

          function getFixedTopPosition() {
            if (datatypeY === ORDINAL_DATATYPE) {
              var domain = yscale.domain();
              return yscale(domain[domain.length - 1]) + yscale.bandwidth() / 2;
            } else {
              var rangeCorrections_datalabels = chartObj.cache.correction || {},
                maxDatalabelSize = [0],
                operation = axisrotated ? yaxisReversed ? 1 : -1 : yaxisReversed ? -1 : 1;
              for (var yaxis in rangeCorrections_datalabels) {
                if (yaxis.indexOf('label-y') > -1) {
                  maxDatalabelSize.push(d3_max(rangeCorrections_datalabels[yaxis]));
                }
              }

              return yscale(yscale.domain()[1]) + d3_max(maxDatalabelSize) * operation;
            }
          }
        });
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };

      function getUniqueDataByX(data) {
        var xCategories = d3_set();
        return data.filter(function (d) {
          var xVal = d[0];
          if (xCategories.has(xVal)) {
            return false;
          } else {
            xCategories.add(xVal);
            return true;
          }
        });
      }

      function getVisibleData(data, xCategories) {
        return data.filter(function (d) {
          var x = d[0];
          return xCategories.indexOf(x) > -1;
        });
      }

      return labels;
    }

    LabelRegistry.add('bar', barLabel);

    /*
     * Returns the SVG path description for bound box
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     * @param {Number} r
     * @param {Number} padding
     * @param {Number} hookPosition
     * @param {Object} hookOptions
     * @return {String} SVG path
     */

    function getBoundBoxPathDescription(x, y, w, h, r, padding, hookPosition, hookOptions, adjustVal) {
      var hookEnabled = hookOptions.enabled,
        hookWidth = hookOptions.width,
        hookHeight = hookOptions.height;

      var path = roundedRect(x, y, w + 2 * padding, h + 2 * padding, r);
      if (hookEnabled && hookPosition) {
        var positionIndex = hookPosition === BOTTOM_ALIGN ? 7 : hookPosition === TOP_ALIGN ? 3 : hookPosition === RIGHT_ALIGN ? 5 : 1;
        var parsedPath = parseSVGPath(path);
        var coordinates = getHookCoordinate(hookPosition, parsedPath, positionIndex);
        addPointToSVGPathPoints(parsedPath, positionIndex, coordinates);

        path = createSVGPathFromPoints(parsedPath);
      }

      function getHookCoordinate(mode, parsedPath, positionIndex) {
        var horizontalx1 = parsedPath[positionIndex - 1].moves[positionIndex - 1 ? 5 : 0],
          horizontalx2 = parsedPath[positionIndex].moves[0],
          verticaly1 = parsedPath[positionIndex - 1].moves[positionIndex - 1 ? 6 : 1],
          verticaly2 = parsedPath[positionIndex].moves[1];
        var horizontalMid = (horizontalx1 + horizontalx2) / 2,
          verticalMid = (verticaly1 + verticaly2) / 2;
        y = parsedPath[positionIndex].moves[1], x = parsedPath[positionIndex].moves[0];

        if (defined(adjustVal) && adjustVal) {
          var flip = adjustVal > 0 ? 1 : -1,
            dist = mode === BOTTOM_ALIGN ? horizontalx1 - horizontalx2 : horizontalx2 - horizontalx1,
            adj;

          if ((dist - hookWidth) / 2 - adjustVal * flip > 0) {
            adj = adjustVal;
          } else {
            adj = (dist - hookWidth) / 2 * flip;
          }
          horizontalMid -= adj;
        }

        switch (mode) {
          case BOTTOM_ALIGN:
            return [[horizontalMid - hookWidth / 2, y], [horizontalMid, y + hookHeight], [horizontalMid + hookWidth / 2, y]];
          case TOP_ALIGN:
            return [[horizontalMid + hookWidth / 2, y], [horizontalMid, y - hookHeight], [horizontalMid - hookWidth / 2, y]];
          case LEFT_ALIGN:
            return [[x, verticalMid - hookWidth / 2], [x - hookHeight, verticalMid], [x, verticalMid + hookWidth / 2]];
          case RIGHT_ALIGN:
            return [[x, verticalMid + hookWidth / 2], [x + hookHeight, verticalMid], [x, verticalMid - hookWidth / 2]];}

      }

      return path;
    }

    /*
     * Generate and return SVG path from the given array of points
     * @param {Array of points} points
     * Each point should be,
     * {
     *      "function" : OPERATOR, (e.g) : "M" | "L" | "A" etc
     *      "moves" : [point1, point2, ...pointN]
     * }
     * @return {String} SVG path
     */
    function createSVGPathFromPoints(points) {
      return points.reduce(function (prev, cur) {
        return prev + cur["function"].toUpperCase() + (cur.moves && cur.moves.join(' ') || '');
      }, '');
    }

    /*
     * Add all the LineTo coordinates at the given index
     * @param {Array} array
     * @param {Number} index
     * @param {Array} coordinate [[x1, y1], [x2, y2], ...[xN, yN]]
     */
    function addPointToSVGPathPoints(array, index, coordinates) {
      coordinates.forEach(function (d) {
        array.splice(index, 0, {
          "function": 'l',
          moves: d
        });
      });
    }

    //$Id$

    datalabelsBoundBox_handler.canvas = function () {
      var series;

      function shape(selection, legendOrder, labelType, rendererIndex) {
        selection.each(function () {
          var index = legendOrder,
            renderingOrder = pick(rendererIndex, legendOrder);
          if (!series) {
            return;
          }
          var properties = series.properties,
            chartObj = properties.rp.chartObj;
          var context = chartObj.labelHolderContext;
          if (!defined(context)) {
            return false;
          }

          if (!isBoundBoxEnabled(properties.dataLabels, chartObj)) {
            return;
          }

          var boundboxOptions = getMergedBoundBoxOptions(properties.dataLabels, chartObj);
          var hookOptions = getBoundBoxHookConf(boundboxOptions.hook);
          var dataUpdate = properties.dataUpdate,
            rotation = properties.rotation || 0,
            padding = getBoundBoxPadding(properties.dataLabels, chartObj),
            r = getBorderRadius(boundboxOptions.radius),
            strokeWidth = defined(boundboxOptions.strokeWidth) ? +boundboxOptions.strokeWidth : 1,
            strokeDashArray = getDashArray(boundboxOptions.dashStyle, strokeWidth),
            strokeLineCap = getLineCap(boundboxOptions.lineCap, boundboxOptions.dashStyle),
            heightAdjustScale = d3_scaleLinear();

          series.forEach(function (subSeries) {
            subSeries.forEach(function (item, k) {
              if (hasBoundBox(item)) {
                var xy = item.xy || [item.X, item.Y];
                var x = xy[0],
                  y = xy[1],
                  dy = item.actualDY !== undefined ? item.actualDY : parseFloat(item.DY) || 0,
                  h = item.height,
                  w = item.width;

                var strokeColor = getBoundBoxColor(boundboxOptions.strokeColor, properties, chartObj, dataUpdate, index);
                strokeColor = invokeFunction(
                strokeColor,
                dataUpdate && dataUpdate[k],
                getMetaConfigForBoundbox(k, index, properties),
                chartObj);


                var fillColor = getBoundBoxColor(boundboxOptions.fillColor, properties, chartObj, dataUpdate, index);
                fillColor = invokeFunction(
                fillColor,
                dataUpdate && dataUpdate[k],
                getMetaConfigForBoundbox(k, index, properties),
                chartObj);


                context.save();
                if (defined(rotation) && rotation !== 0) {
                  var tx = 0,
                    ty = 0;
                  if (chartObj.axes.rotated) {
                    tx = -1 * dy * h;
                  } else {
                    ty = (item.ANCHOR === 'middle' ? w / 2 : item.ANCHOR === 'end' ? -w : 0) + padding;
                    tx = -heightAdjustScale.domain([-0.3, 0.9]).range([h, 0])(dy) - padding;
                  }

                  context.translate(x + tx, y + ty);
                  context.rotate(canvasUtils.getRadianAngle(rotation));
                } else {
                  x = (item.ANCHOR === 'middle' ? x - w / 2 : item.ANCHOR === 'end' ? x - w : x) - padding;
                  y = y - heightAdjustScale.domain([-0.3, 1]).range([h, 0])(dy) - padding;

                  context.translate(x, y);
                }

                context.fillStyle = rgba_canvas(fillColor, boundboxOptions.fillOpacity);
                context.strokeStyle = rgba_canvas(strokeColor, boundboxOptions.strokeOpacity);
                context.lineWidth = strokeWidth;
                if (strokeDashArray && defined(context.setLineDash)) {
                  context.setLineDash(strokeDashArray);
                  context.lineCap = strokeLineCap;
                }

                context.beginPath();
                context.translate(-x, -y);
                canvasUtils.boundBoxWithHook(
                context,
                getBoundBoxPathDescription(x, y, w, h, r, padding, item.hookPosition, hookOptions, item.adjustVal));

                context.fill();
                context.stroke();
                context.closePath();
                context.restore();
              }
            });
          });
        });
      }

      shape.args = function (_) {
        if (!arguments.length) {
          return series;
        }
        series = _;
        return shape;
      };

      return shape;
    };

    LabelRegistry.add('boundBox-canvas', datalabelsBoundBox_handler.canvas);

    //$Id$

    dataLabel_handler.canvasUtils = function () {};
    dataLabel_handler.canvasUtils.align = function (anchor) {
      switch (anchor.toLocaleLowerCase()) {
        case 'start':
          return LEFT_ALIGN;
        case 'middle':
          return CENTER_ALIGN;
        case 'end':
          return RIGHT_ALIGN;}

    };

    /**
     *
     * @param shadow html css text shadow string
     * @return {[Number,Number,Number,String]}
     */
    dataLabel_handler.canvasUtils.parseTextShadow = function (shadow) {
      // handle empty string.
      shadow = shadow && shadow.trim();

      if (!shadow) {
        return;
      }

      return shadow.split(/\s+/).map(function (property) {
        var temp = pInt(property);
        if (isNaN(temp)) {
          return property;
        }
        return temp;
      });
    };

    dataLabel_handler.canvasUtils.addTextShadow = function (context, shadow) {
      // set the text shadow if defined
      if (defined(shadow)) {
        context.shadowOffsetX = shadow[0];
        context.shadowOffsetY = shadow[1];
        context.shadowBlur = shadow[2];
        context.shadowColor = shadow[3];
      }
    };

    dataLabel_handler.canvasUtils.createText = function (context, fontStyle) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var position = arguments.length > 3 ? arguments[3] : undefined;
      var text = options.text,font = options.font,fill = options.fill,stroke = options.stroke,textShadow = options.textShadow;
      var fillColor = canvasUtils.rgba(fill || fontStyle.color, validateNullVal(fontStyle && fontStyle['fill-opacity'], 1)),
        strokeColor = stroke || fontStyle.stroke;

      text = pick(text, '');
      position = position || [0, 0];
      context.font = font;
      context.fillStyle = fillColor;

      if (fontStyle['stroke-width'] > 0) {
        if (fontStyle.stroke === 'contrast') {
          strokeColor = getContrastColor(fillColor);
        }
        context.strokeStyle = strokeColor;
        context.lineWidth = fontStyle['stroke-width'];
        context.strokeText(text, position[0], position[1]);
      }

      dataLabel_handler.canvasUtils.addTextShadow(context, textShadow);
      context.fillText(text, position[0], position[1]);
    };

    var _canvasDatalabelUtils = dataLabel_handler.canvasUtils;

    //$Id$

    function drawCustomHtmlInCanvasDatalabel(chartObj, context, item, ele, fontStyle, canvasFont, textShadow, color, stroke) {
      var helpers = _canvasDatalabelUtils,
        xy = item.xy || [item.X, item.Y],
        bb = ele.bb,
        node = ele.node;

      switch (ele.nodeName) {
        case 'image':
          var d3Ele = d3_select(node),
            cusX = +d3Ele.attr('x') || 0,
            cusY = +d3Ele.attr('y') || 0,
            cusWIDTH = +d3Ele.attr('width') || 0,
            cusHEIGHT = +d3Ele.attr('height') || 0,
            href = d3Ele.attr('href') || d3Ele.attr('xlink:href');
          var img = new Image();
          img.onload = function () {
            context.drawImage(img, xy[0] + cusX, xy[1] + cusY, cusWIDTH, cusHEIGHT);
          };
          img.src = href;
          break;
        case 'rect':
          var d3Ele = d3_select(node),
            cusX = +d3Ele.attr('x') || 0,
            cusY = +d3Ele.attr('y') || 0,
            cusWIDTH = +d3Ele.attr('width') || 0,
            cusHEIGHT = +d3Ele.attr('height') || 0,
            cusRADIUS = +d3Ele.attr('rx') || 0;

          context.fillStyle = d3Ele.style('fill');
          context.strokeStyle = d3Ele.style('stroke');
          context.lineWidth = d3Ele.style('stroke-width');
          context.beginPath();
          canvasUtils.roundedRect(
          context,
          cusX,
          cusY,
          cusWIDTH,
          cusHEIGHT,
          chartObj.dataObject.getTransRectValue('radius', NULL$1, NULL$1, NULL$1, NULL$1, cusRADIUS));

          context.fill();
          context.stroke();
          context.closePath();
          break;
        case 'text':
        case 'tspan':
          var userStyle = node.style,
            font,
            _fill,
            _stroke;

          if (userStyle) {
            font = getUserFontValue(fontStyle, userStyle);
            _fill = userStyle.fill;
            _stroke = userStyle.stroke;
          }

          var _options = {
            text: node.textContent,
            font: font || canvasFont,
            fill: _fill || color || fontStyle.color,
            stroke: _stroke || stroke,
            textShadow: textShadow
          };

          context.translate(bb.x, bb.y + 0.77 * bb.height);
          context.textAlign = helpers.align('start');
          helpers.createText(context, fontStyle, _options);
          context.translate(-bb.x, -bb.y - 0.77 * bb.height);
          break;}

    }

    //$Id$

    function canvasRenderer(chartObj, series, i, groupName, rendererIdx) {
      if (!series) {
        return;
      }

      groupName = groupName || 'label';
      var isStackedLabels = groupName === 'stacklabel',
        isInnerLabel = groupName === INNERLABEL_LABELTYPE || groupName === PARENTLABELS_LABELTYPE,
        properties = series.properties,
        legendOrderIndex = isFacet(chartObj) ? properties.rp.legendOrderIndex : i,
        rotation = properties.rotation,
        dataLabels = properties.dataLabels,
        renderer = defined(i) ? chartObj.renderer[i] : null,
        hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
        chartType = properties.chartType,
        isPolar = isCategoryOf(chartObj, chartType, 'polarAxis'),
        isHierarchy = isCategoryOf(chartObj, chartType, 'hierarchy'),
        isNonAxisMultiSeriesCategory = isCategoryOf(chartObj, chartType, 'nonAxisMultiSeries'),
        isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
        isTreemap = chartType == charttype.treemap,
        fontStyle = canvasUtils.getFontStyles(chartObj, properties.dataLabels, properties.color, null, i, isStackedLabels),
        fontSize = parseFloat(fontStyle['font-size']),
        helpers = _canvasDatalabelUtils,
        context = chartObj.labelHolderContext,
        canvasFont = getUserFontValue(fontStyle),
        textShadow = helpers.parseTextShadow(fontStyle['text-shadow']);

      series.forEach(function (subSeries, subSeriesIndex) {
        var dataUpdate = renderer && renderer.seriesdataAfterUpdate ? renderer.seriesdataAfterUpdate[subSeriesIndex] : null;
        subSeries.forEach(function (item, k) {
          context.save();
          var xy = item.xy || [item.X, item.Y];
          var x,
            y,
            dy,
            height,
            display = item.display,
            color = NULL$1,
            stroke = NULL$1;

          if (
          hasColorScale ||
          properties.rp.threshold ||
          isHierarchy ||
          !((isAxisCategory || isPolar || isNonAxisMultiSeriesCategory) && !properties.multiColoring))
          {
            var d = isTreemap && isInnerLabel ? properties.dataUpdate[k] : dataUpdate && dataUpdate[k];
            var rawColor = getRawColor(chartObj, properties.multiColoring ? k : i, d && d.data ? d.data : d, legendOrderIndex);
            var _dataUpdate = properties.dataUpdate || dataUpdate,
              dt = _dataUpdate && _dataUpdate[k],
              paneid = ((dt && dt.data ? dt.data : dt) || []).paneid;

            if (isTreemap && isInnerLabel && /(top-outset|bottom-outset)/.test(dataLabels.position) && d3_rgb(rawColor).opacity < 0.1) {
              rawColor = 'white';
            }

            var _color = function _color(styleName) {return (
                getLabelFontColor(
                chartObj.systemConf,
                rawColor,
                dataLabels,
                chartObj,
                undefined,
                undefined,
                undefined,
                styleName,
                paneid));};

            color = _color('fontColor');
            stroke = _color('strokeColor');
          }

          if (display === true) {
            x = xy[0];
            y = xy[1];
            dy = item.customHTML ? 0 : parseFloat(item.DY || 0);
            height = item.height;
            dy = (item.tspanInfo || dy === 1 ? fontSize : height) * dy;

            if (defined(rotation) && rotation !== 0) {
              if (chartObj.axes.rotated) {
                dy = -1 * dy;
              }
              context.translate(x + dy, y);
              context.rotate(canvasUtils.getRadianAngle(rotation));
            } else {
              context.translate(x, y + dy);
            }

            if (defined(item.ANCHOR)) {
              context.textAlign = helpers.align(item.ANCHOR);
            }

            if (item.customHTML) {
              item.customHTML.forEach(function (ele) {
                drawCustomHtmlInCanvasDatalabel(chartObj, context, item, ele, fontStyle, canvasFont, textShadow, color, stroke);
              });
            } else if (item.tspanInfo) {
              item.tspanInfo.forEach(function (a) {
                var userStyle = a.style,
                  font,
                  fSize,
                  _fill,
                  _stroke;

                if (userStyle) {
                  font = getUserFontValue(fontStyle, userStyle);
                  fSize = parseFloat(userStyle['font-size']);
                  _fill = userStyle.fill;
                  _stroke = userStyle.stroke;
                }

                var _position = [a.dx || 0, (fSize || fontSize) * a.dy],
                  _options = {
                    text: a.text,
                    font: font || canvasFont,
                    fill: _fill || color || fontStyle.color,
                    stroke: _stroke || stroke,
                    textShadow: textShadow
                  };
                helpers.createText(context, fontStyle, _options, _position);
              });
            } else {
              var _options = { text: item.text, font: canvasFont, fill: color || fontStyle.color, stroke: stroke, textShadow: textShadow };
              helpers.createText(context, fontStyle, _options);
            }
            context.restore();
          }
        });
      });
    }

    LabelRegistry.add('canvas', canvasRenderer);

    //$Id$

    var treemapUtils = {};

    treemapUtils.getTileBound = function (layoutObj, dataPoint) {
      var xScale = layoutObj.xScale,
        yScale = layoutObj.yScale,
        x0 = dataPoint.x0 || 0,
        x1 = dataPoint.x1 || 0,
        y0 = dataPoint.y0 || 0,
        y1 = dataPoint.y1 || 0;

      return {
        x: xScale(x0),
        y: yScale(y0),
        width: xScale(x1) - xScale(x0),
        height: yScale(y1) - yScale(y0)
      };
    };

    /**
     * @param {Array} d
     * @return {String} level
     */
    treemapUtils.getLevel = function (d) {
      return d.level || d.data && d.data.level;
    };

    /**
     * @param {Array} d
     * @return {Number} seriesIndex
     */
    treemapUtils.getSeriesIndex = function (d) {
      var level = treemapUtils.getLevel(d);
      if (level) {
        return +level.split('_')[0];
      }
    };

    /**
     * @param {Array} d
     * @return {Number} itemIndex
     */
    treemapUtils.getItemIndex = function (d) {
      var level = treemapUtils.getLevel(d);
      if (level) {
        var split = level.split('_');
        return +split[split.length - 1];
      }
    };

    /**
     * Return color for parent nodes
     * @param {Object} commonRendererProp
     * @param {Array} d
     * @return {Color} clr
     */
    treemapUtils.getParentColor = function (commonRendererProp, d, paneid) {
      var rp = commonRendererProp.params,
        chartObj = rp.chartObj,
        parentColor = rp.commonPlotOptions.parent.fillColor,
        clr = TRANSPARENT;

      if (d.depth) {
        var seriesIndex = treemapUtils.getSeriesIndex(d);
        var currentSeriesColor = getRawColor(chartObj, seriesIndex, d, seriesIndex, paneid);
        if (parentColor === '{{clr-tint}}') {
          clr = getColorCopy(currentSeriesColor, 0.5, 'brighter', d3_hsl);
        } else if (parentColor === '{{clr-shade}}') {
          clr = getColorCopy(currentSeriesColor, 0.5, 'darker', d3_hsl);
        } else if (parentColor === '{{clr}}') {
          clr = currentSeriesColor;
        } else if (parentColor) {
          clr = parentColor;
        } else {
          clr = toRGBA(currentSeriesColor, 0.0001);
        }
      }
      return clr;
    };

    /**
     * Return whether the current data point is disabled or not
     * @param {Object} chartObj
     * @param {Array} d
     * @return {Boolean}
     */
    treemapUtils.isDisabled = function (seriesData, d) {
      var seriesIndex = treemapUtils.getSeriesIndex(d);
      return defined(seriesIndex) && seriesData.disabled;
    };

    //$Id$

    /*
     * PENDING:
     * Bound box - minHeight should be considered for height on handling overlapping datalabels (if hook is enabled)
     */
    //multi coloring
    function hierarchyLabel() {
      var renderer, args;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var currentdata = args[0],
            index = args[1],
            size = args[2] || 0,
            yrangePos = args[3],
            total = args[4],
            leafNodes = args[5],
            transform = args[6] || [0, 0],
            isParent = args[7],
            isPreCalculating = args[8],
            plotoptions = currentdata.plotoptions,
            dataLabels,
            paneid = labelHandler.paneid,
            rp = renderer.commonRendererProp().params,
            chartObj = rp.chartObj,
            systemconf = chartObj.systemConf,
            commonPlotOptions = rp.commonPlotOptions,
            dataset = rp.dataset,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            labelArray = getLabelArray(rp, paneid),
            xscale = rp.xscale,
            yscale = rp.yscale,_rp$rendererIndex =
            rp.rendererIndex,rendererIndex = _rp$rendererIndex === void 0 ? index : _rp$rendererIndex;

          dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index);
          var showlabel = isDatalabelEnabled(dataLabels, chartObj),
            cType_obj = getChartTypeByIndex(chartObj, paneid, 0),
            chartType = cType_obj.value,
            chartName = cType_obj.name,
            isSankeyChart = chartName === SANKEY_CHARTNAME,
            sankeyLabelInside = isSankeyChart && dataLabels.labelPos === 'inside',
            maxWidth = perToPx(defined(dataLabels.maxWidth) ? dataLabels.maxWidth : '30%', chartObj.plotarea.width);

          if (isParent) {
            var parentLabelOptions = mergeJSON$1(commonPlotOptions.parent.datalabels, dataLabels);
            showlabel = isTrue(parentLabelOptions.show);
            dataLabels = parentLabelOptions;
          }

          if (currentdata.disabled || !showlabel || isSeriesFiltered(chartObj, paneid, index)) {
            return;
          }

          var currentPlotBound = getPlotBound(chartObj),
            boundBoxPadding = 0,
            boundBoxStrokeWidth = 0,
            hookHeight = 0,
            hookWidth = 0,
            boundBoxRadius = 0;
          if (isBoundBoxEnabled(dataLabels, chartObj)) {
            var boundBoxOptions = getMergedBoundBoxOptions(dataLabels, chartObj);
            var hookOptions = getBoundBoxHookConf(boundBoxOptions.hook);
            boundBoxPadding = getBoundBoxPadding(dataLabels, chartObj);
            boundBoxStrokeWidth = getBoundBoxStrokeWidth(dataLabels, chartObj);
            hookHeight = hookOptions.height;
            hookWidth = hookOptions.width;
            boundBoxRadius = boundBoxOptions.radius;
          }

          var textOverlap = dataLabels.textOverlap, //dataLabels.textOverlap, //hidden | adjust | ellipsis
            hAlign = dataLabels.hAlign || CENTER_ALIGN,
            vAlign = dataLabels.vAlign || CENTER_ALIGN,
            padding = validateNullVal(dataLabels.padding, 0.5),
            handleOverlapping = systemconf.chart.plot.datalabels.handleOverlapping === true && textOverlap !== NONE,
            GLT = dataLabelTextContent(chartObj, rp, dataLabels, DATALABELS_LABELTYPE, total, index, yrangePos, paneid),
            contentType = GLT.contentType || 'text',
            isMultiLine = contentType === 'html' && GLT.multiLine,
            hasShowAsFunction = GLT.hasShowAsFunction,
            multiColoring = isMultiColoring(commonPlotOptions, chartObj),
            fontSize = getFontSizeByHierarchy(dataLabels, chartObj),
            heightAdjustScale = d3_scaleLinear().domain([-0.3, 0.9]),
            isCanvasMode = chartObj.plot.renderer.mode === 'canvas',
            globalDY = getDY(),
            fontStyles = applyDatalabelFonts(null, dataLabels, chartObj, rp.color, false, index);

          textOverlap = hasShowAsFunction && textOverlap === 'ellipsis' ? 'hidden' : textOverlap;

          var temp_label = appendEle(
          chartObj.staticPaneSVG.select('.labelholder'),
          hasShowAsFunction ? 'g' : 'text',
          [1],
          '.',
          'class',
          'temp_label');

          var updateHandler = labelHandler.update,
            queue = labelHandler.add;

          // currentdata.forEach(function(d, i) {
          var dataUpdate = leafNodes;

          var calculated_points = [];
          applyDatalabelFonts(temp_label, dataLabels, chartObj, rp.color, false, index);
          temp_label.style('opacity', 0);

          dataUpdate.forEach(function (d, j) {
            var ANCHOR = getAnchor(d),
              pos = getPosition(d, ANCHOR);
            var x = pos.x,
              y = pos.y,
              text = null,
              tspanInfo = null;
            var display = colorscale_helpers.isQuantileColorScale(chartObj) ?
              !isParent ?
              isWithinColorRange(dataset.getClr(d.data || d), chartObj) :
              true :
              true,
              dy,
              actualDY,
              HOOKPOSITION = null,
              dy,
              actualDY,
              xDiff = 0;

            if (isSankeyChart) {
              if (ANCHOR === START_ALIGN) {
                HOOKPOSITION = LEFT_ALIGN;
              } else if (ANCHOR === END_ALIGN) {
                HOOKPOSITION = RIGHT_ALIGN;
              }
            }

            temp_label[contentType](function () {
              text = GLT(d.data || d, j, pos);
              return text;
            });

            if (isMultiLine) {
              var t = getDy4MultiLine(temp_label, dataLabels, globalDY, text, display);
              dy = "".concat(t[0], "em");
              actualDY = t[1];
              text = t[2];
              display = t[3];
            } else {
              dy = "".concat(globalDY, "em");
            }

            temp_label.attrs({
              dy: dy,
              transform: "translate(".concat([x, y], ")"),
              'text-anchor': ANCHOR,
              display: display
            });

            var textBound;
            if (contentType === 'html') {
              //Test_665.json
              if (isMultiLine) {
                translateTspan(temp_label, 0);
              }

              if (hAlign !== CENTER_ALIGN && !hasShowAsFunction) {
                //ZC1494: If font-weight is bold or font-style is italic, left/right is out of bound
                temp_label.attr('text-anchor', END_ALIGN);
                textBound = bbox(temp_label);
                var dEnd = textBound.width + textBound.x;

                temp_label.attr('text-anchor', START_ALIGN);
                textBound = bbox(temp_label);
                var dStart = textBound.x;

                x += (dStart - dEnd) * (hAlign === RIGHT_ALIGN ? 1 : -1);

                temp_label.attr('transform', "translate(".concat([x, y], ")")).attr('text-anchor', ANCHOR);
              }

              textBound = bbox(temp_label);
            } else {
              textBound = getTextBound(
              text,
              fontSize,
              getFontFamilyByHierarchy(dataLabels, chartObj),
              null,
              null,
              fontStyles['font-style'],
              fontStyles['font-weight']);

              textBound = updateTextBound(textBound, ANCHOR, dy, x, y);
            }

            var widthToBeAdded = 0;
            var bb_width = textBound.width + widthToBeAdded,
              bb_height = textBound.height,
              bb_x = textBound.x + widthToBeAdded / 2;

            if (handleOverlapping) {
              // update the width with new label width
              // Consider padding for label bound
              var labelBound = {
                  x1: textBound.x + x - boundBoxPadding,
                  y1: textBound.y + y - boundBoxPadding,
                  x2: textBound.x + x + textBound.width + boundBoxPadding,
                  y2: textBound.y + y + textBound.height + boundBoxPadding
                },
                rawPosition = getRawPosition(d, textBound);

              var nodeBound = getNodeBound(rawPosition, textBound, labelBound);

              if (isSankeyChart) {
                pos.w = nodeBound.x2 - nodeBound.x1;
                pos.h = nodeBound.y2 - nodeBound.y1;
              }

              var within = isLabelWithinBound(labelBound, nodeBound);

              if (!within) {
                var trimmed;
                if (textOverlap === 'ellipsis') {
                  // add ellipsis
                  var h = pos.h;
                  var w = pos.w;
                  if (bb_height + 2 * boundBoxPadding < h) {
                    var bound = {
                      left: nodeBound.x1 + boundBoxPadding,
                      top: nodeBound.y1 + boundBoxPadding,
                      right: nodeBound.x2 - boundBoxPadding,
                      bottom: nodeBound.y2 - boundBoxPadding
                    };

                    if (contentType === 'html') {
                      tspanInfo = getTspanBound(temp_label, fontSize);
                      trimAllTspan(temp_label, chartObj, transform, 0, bound, tspanInfo, NULL$1, [x, y]);
                    } else {
                      callTrimText(temp_label, chartObj, transform, 0, bound, [x, y]);
                    }

                    var trimmedText = temp_label.text();
                    if (trimmedText && trimmedText !== '..') {
                      //If the textContent is just "..", hide the label
                      text = temp_label[contentType]();
                      trimmed = true;
                      bb_width = w - 2 * boundBoxPadding;
                      if (isMultiLine) {
                        var newBB = bbox(temp_label);
                        bb_height = newBB.height;
                        bb_width = newBB.width + widthToBeAdded;
                        y += (textBound.height - newBB.height) / 2;
                      }
                    }
                  }
                }
                if (!isParent) {
                  if (!trimmed) {
                    display = false;
                  } else if (contentType === 'html') {
                    tspanInfo = getTspanBound(temp_label, fontSize);
                  }
                }
              }

              // for sankey chart we need overlap handler
              // ZC2593
              if (chartName === SANKEY_CHARTNAME && !sankeyLabelInside) {
                labelBound.x1 = mathMax(nodeBound.x1, labelBound.x1);
                labelBound.x2 = mathMin(nodeBound.x2, labelBound.x2);

                var obj = {
                    id: "lbl".concat(index, "_", 0, "_").concat(j),
                    x1: labelBound.x1,
                    y1: labelBound.y1,
                    x2: labelBound.x2,
                    y2: labelBound.y2,
                    translateFunction: updateHandler,
                    overlap: 'hidden',
                    hookHeight: hookHeight,
                    hookPosition: HOOKPOSITION
                  },_getPlotBound2 =

                  getPlotBound(chartObj),_left2 = _getPlotBound2.left,top = _getPlotBound2.top,_right2 = _getPlotBound2.right,bottom = _getPlotBound2.bottom,
                  pointOutOfPlot = labelBound.x1 < _left2 || labelBound.x2 > _right2 || labelBound.y1 < top || labelBound.y2 > bottom;

                if (display && !isPreCalculating) {
                  display = !pointOutOfPlot;
                }
                labelArray.push(obj);
                // Label Testing Area
              }
            }

            var coordinate = {
              X: 0,
              Y: 0,
              DY: dy,
              xy: [x, y],
              actualDY: actualDY,
              ANCHOR: ANCHOR,
              text: text,
              display: display,
              height: bb_height,
              width: bb_width,
              hookPosition: HOOKPOSITION,
              adjustVal: xDiff
            };

            if (isCanvasMode && contentType === 'html') {
              if (hasShowAsFunction) {
                coordinate.customHTML = getCustomHTML(temp_label);
              } else {
                coordinate.tspanInfo = tspanInfo || getTspanBound(temp_label, fontSize);
              }
            }

            calculated_points.push(coordinate);
          });

          calculated_points.dataUpdate = dataUpdate; //Each subseries may have different dataUpdates
          var q = queue(calculated_points, index, 0, yrangePos, isParent ? PARENTLABELS_LABELTYPE : NULL$1, rendererIndex);
          q.properties = {
            type: 'hierarchy',
            dataLabels: dataLabels,
            color: rp.color,
            dataUpdate: dataUpdate,
            showlabel: showlabel,
            multiColoring: multiColoring,
            rp: rp,
            contentType: contentType,
            isMultiLine: isMultiLine,
            GLT: GLT,
            trans: [0, 0],
            chartType: chartType
          };
          // });

          function getPosition(d, ANCHOR) {
            var pos = getRawPosition(d),
              x = pos.x,
              y = pos.y,
              w = pos.width,
              h = pos.height;

            x = updateXposition(x, w, d, ANCHOR) + transform[0];
            y = updateYposition(y, h) + transform[1];

            return {
              x: x,
              y: y,
              w: w,
              h: h
            };
          }

          function getNodeBound(pos, textBound, labelBound) {
            var nodeheight = pos.height - 2 * padding,
              nodewidth = pos.width - 2 * padding,
              nodex = pos.x + transform[0] + padding,
              nodey = pos.y + transform[1] + padding;

            var bb = {
              x1: nodex,
              y1: nodey,
              x2: nodex + nodewidth,
              y2: nodey + nodeheight
            };

            // when the sankey node is smaller than text height, center by text bound
            if (chartName === SANKEY_CHARTNAME) {
              bb.y1 = labelBound.y1 - 2;
              bb.y2 = labelBound.y2 + 2;

              //bbox floating issue in Windows, Ubuntu, Mac - bb.x is not equal to bb.width/2 - CRM team Zoho - CommandCenter
              bb.x2 += 2;
            }

            if (chartName === PACKEDBUBBLE_CHARTNAME) {
              // var radius = pos.w / 2,
              //     chord = mathMin(textBound.height / 2 + boundBoxPadding, radius),
              //     apothem = mathSQRT(mathPow(radius, 2) - mathPow(chord * 2, 2) / 4);
              // excess = radius - apothem;
              var radius = nodewidth / 2, // hypotenuse
                vert = mathMin(textBound.height / 2, radius),
                hori = mathSQRT(mathPow(radius, 2) - mathPow(vert, 2)),
                excess = radius - hori;
              bb.x1 += excess;
              bb.x2 -= excess;
              bb.y1 += excess;
              bb.y2 -= excess;
            }
            return bb;
          }

          function updateXposition(x, w, d, ANCHOR) {
            if (hAlign === CENTER_ALIGN) {
              x += w / 2;
            } else if (hAlign === RIGHT_ALIGN) {
              x += w - padding - boundBoxPadding;
            } else {
              x += padding + boundBoxPadding;
            }
            return x;
          }

          function updateYposition(y, h) {
            if (vAlign === CENTER_ALIGN) {
              y += h / 2;
            } else if (vAlign === BOTTOM_ALIGN) {
              y += h - padding - boundBoxPadding;
            } else {
              y += padding + boundBoxPadding;
            }
            return y;
          }

          function getAnchor(d) {
            if (isSankeyChart) {
              return renderer.getLabelAnchor(d);
            }
            return hAlign === CENTER_ALIGN ? 'middle' : hAlign === RIGHT_ALIGN ? 'end' : null;
          }

          function getDY() {
            var DY;
            if (vAlign === CENTER_ALIGN) {
              DY = 0.3;
            } else if (vAlign === BOTTOM_ALIGN) {
              DY = -0.3;
            } else {
              DY = 1;
            }

            return DY;
          }

          function getRawPosition(d, textBound) {
            switch (chartName) {
              case PACKEDBUBBLE_CHARTNAME:
                return getPackedbubblePosition(d);
              case TREEMAP_CHARTNAME:
                var layout = chartObj.renderer[getRendererIndex(d.data, chartObj)].layout;
                var pos = treemapUtils.getTileBound(layout, d);
                pos = adjustTileBoundForParents(pos);
                return pos;
              case HEATMAP_CHARTNAME:
                return getHeatCellPosition(chartObj, d, xscale, yscale, yaxiscolumnorder);
              case SANKEY_CHARTNAME:{
                  return renderer.getPosition(d, textBound, padding, maxWidth, boundBoxPadding, hookHeight);
                }}

          }

          function updateTextBound(textBound, ANCHOR, dy, x, y) {
            var w = textBound.width,
              h = textBound.height;
            var tx = ANCHOR === 'middle' ? w / 2 : ANCHOR === 'end' ? w : 0,
              ty = heightAdjustScale.range([h, 0])(parseFloat(dy));
            textBound.x = -tx;
            textBound.y = -ty;
            return textBound;
          }

          function adjustTileBoundForParents(pos) {
            if (isParent && (dataLabels.position === 'bottom-outset' || dataLabels.position === 'top-outset')) {
              var tilePadding = parseShortHandValue(commonPlotOptions.padding),
                adjust = tilePadding[dataLabels.position === 'bottom-outset' ? 'bottom' : 'top'];

              if (dataLabels.position === 'bottom-outset') {
                pos.y = pos.y + pos.height - adjust;
              }
              pos.height = adjust;
            }
            return pos;
          }
        });
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };

      return labels;
    }

    LabelRegistry.add('hierarchy', hierarchyLabel);

    //$Id$

    function scatterLabel() {
      var renderer,
        args,
        dataProcessorHelpers = DataProcessor.helpers;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var currentdata = args[0],
            index = args[1],
            size = args[2] || 0,
            yrangePos = args[3],
            rendererIndex = pick(labelHandler.rendererIndex, index),
            paneid = labelHandler.paneid,
            transform = [0, 0],
            plotoptions = currentdata.plotoptions,
            dataLabels,
            rp = renderer.commonRendererProp().params,
            chartObj = rp.chartObj,
            systemconf = chartObj.systemConf,
            commonPlotOptions = rp.commonPlotOptions,
            dataset = rp.dataset,
            stacked = rp.stacked,
            axisrotated = rp.axisrotated,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            xscale = rp.xscale,
            yscale = rp.yscale,
            labelArray = getLabelArray(rp, paneid),
            cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
            cType = cType_Obj.value,
            isRangeChart = cType_Obj.name == AREARANGE_CHARTNAME,
            isCanvasMode = chartObj.plot.renderer.mode === 'canvas';
          var scatterOrBubble = isScatterChartType(cType),
            isBubbleChart = chartcategory.bubble.has(cType),
            isScatterChart = scatterOrBubble && !isBubbleChart,
            isBubblePie = chartcategory.bubblePie.has(cType),
            isPolar = chartObj.dataObject.isPolarAxisCategory,
            isGeoHeatmap = charttype.geoheatmap === cType,
            hasLocationMarker = isScatterChart && LOCATION_MARKERS.has(commonPlotOptions.marker.symbol);

          dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index, paneid);
          var showlabel = isDatalabelEnabled(dataLabels, chartObj),
            labelOrient = pick(dataLabels.orient, 'top');

          if (currentdata.disabled || !showlabel || isSeriesFiltered(chartObj, paneid, index)) {
            return;
          }

          var currentPlotBound = getPlotBound(chartObj),
            boundBoxPadding = 0,
            boundBoxStrokeWidth = 0,
            hookHeight = 0,
            hookWidth = 0,
            boundBoxRadius = 0,
            plotareaBorderCorrection = getPlotareaBorderCorrection(dataLabels, chartObj);

          if (isBoundBoxEnabled(dataLabels, chartObj)) {
            var boundBoxOptions = getMergedBoundBoxOptions(dataLabels, chartObj);
            var hookOptions = getBoundBoxHookConf(boundBoxOptions.hook);
            boundBoxPadding = getBoundBoxPadding(dataLabels, chartObj);
            boundBoxStrokeWidth = getBoundBoxStrokeWidth(dataLabels, chartObj);
            hookHeight = hookOptions.height;
            hookWidth = hookOptions.width;
            boundBoxRadius = boundBoxOptions.radius;
          }

          var padding = isBubbleChart ? 0 : mathMax(0, +(dataLabels.padding || 0)) + boundBoxPadding + hookHeight,
            textOverlap = dataLabels.textOverlap, //hidden | adjust | ellipsis
            handleOverlapping = systemconf.chart.plot.datalabels.handleOverlapping === true,
            multiColoring = scatterOrBubble ? isMultiColoring(commonPlotOptions, chartObj) : false,
            left = currentPlotBound.left,
            top = currentPlotBound.top,
            right = currentPlotBound.right,
            bottom = currentPlotBound.bottom,
            leftWithBorderCorrection = left + plotareaBorderCorrection.left,
            topWithBorderCorrection = top + plotareaBorderCorrection.top,
            rightWithBorderCorrection = right - plotareaBorderCorrection.right,
            GLT = dataLabelTextContent(chartObj, rp, dataLabels, DATALABELS_LABELTYPE, null, index, yrangePos, paneid),
            contentType = GLT.contentType || 'text',
            isMultiLine = contentType === 'html' && GLT.multiLine,
            isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
            isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder),
            fontSize = getFontSizeByHierarchy(dataLabels, chartObj),
            fontStyles = applyDatalabelFonts(null, dataLabels, chartObj, rp.color, false, index);

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), 'text', [1], '.', 'class', 'temp_label');
          var updateHandler = labelHandler.update,
            queue = labelHandler.add,
            bottomOrient = labelOrient === 'bottom' && isScatterChart,
            factor = bottomOrient ? -1 : 1;

          currentdata.data.forEach(function (d, i) {
            var dataUpdate = renderer.seriesdataAfterUpdate ? renderer.seriesdataAfterUpdate[i] : currentdata.data[i];

            var calculated_points = [];
            applyDatalabelFonts(temp_label, dataLabels, chartObj, rp.color, false, index);
            temp_label.style('opacity', 0);

            dataUpdate.forEach(function (d, j) {
              var xVal = chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'x',
                null,
                yrangePos),

                yVal = chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'y',
                null,
                yrangePos),

                zVal =
                isBubbleChart || isBubblePie ?
                chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'z',
                chartObj.zscale) :

                null,
                isWithinClrRange = isDataActive(d, chartObj);
              var _x5 = null,
                _y3 = null,
                text = null,
                tspanInfo = null,
                _display = isWithinClrRange && !d.disabled,
                id = '',
                dy = isMultiLine ? '0.9em' : isBubbleChart || isGeoHeatmap || bottomOrient ? '0.3em' : '-0.3em',
                ANCHOR = 'middle',
                HOOKPOSITION = isBubbleChart ? null : BOTTOM_ALIGN,
                xDiff = 0,
                yDiff = 0,
                midAngle,
                polarXY;

              if (isBubblePie) {
                var key = bubblepieUtils.getKey(d, index, chartObj);
                var pieRenderer = chartObj.subrenderer[i][key];
                var pieData = pieRenderer.data[index];
                midAngle = (pieData.startAngle + pieData.endAngle) / 2;
                var outerRadius = zVal / 2 + padding;
                var polarXY = polarToXY(outerRadius, midAngle);
                dy = isMultiLine ? '0.9em' : midAngle > mathPI / 2 && midAngle < 3 * mathPI / 2 ? "".concat(getDY(midAngle), "em") : '0';
                ANCHOR = midAngle < 0 || midAngle > mathPI ? 'end' : 'start';
                GLT = dataLabelTextContent(chartObj, rp, dataLabels, DATALABELS_LABELTYPE, pieRenderer.total, index, yrangePos);
              }
              temp_label[contentType](function () {
                if (d.isDummy || isCatNullX(dataset.getX(d)) || isCatNullY(dataset.getY(d, yaxiscolumnorder, yrangePos))) {
                  text = null;
                } else {
                  text = GLT(d, j);
                }
                return text;
              }).
              styles({
                display: function display() {
                  if (isPolar) {
                    return null;
                  }
                  //If the data point itself out of plot, need not to show label.
                  var ptX = xVal,
                    ptY = yVal,
                    pointOutOfPlot = ptX < left || ptX > right || ptY < top || ptY > bottom;
                  return pointOutOfPlot ? (_display = false, NONE) : null;
                }
              }).
              attrs({
                transform: null,
                dy: dy,
                x: function x() {
                  _x5 = isBubblePie ? xVal + polarXY[0] : xVal;
                  return _x5 || 0;
                },
                y: function y() {
                  if (hasLocationMarker) {
                    if (bottomOrient) {
                      radius = 2;
                    } else {
                      radius = size;
                    }
                  } else {
                    radius = (isBubbleChart ? 0 : size) / 2;
                  }

                  radius *= factor;

                  _y3 = isBubblePie ?
                  yVal + polarXY[1] :
                  yVal + (radius + padding * factor) * (isRangeChart && !yrangePos ? 1 : -1);
                  return _y3 || 0;
                },
                'text-anchor': ANCHOR
              });

              // ID
              id = "lbl".concat(rendererIndex, "_").concat(i, "_").concat(j, "_").concat(index, "_").concat(yrangePos);

              var textBound;
              if (isMultiLine) {
                var t = getDy4MultiLine(temp_label, dataLabels, parseFloat(dy), text, _display);
                text = t[2];
                _display = t[3];

                translateTspan(temp_label, _x5);
                textBound = bbox(temp_label.node());

                if (isBubblePie) {
                  var yAdjust = d3_scaleLinear().
                  range([-1, 0]).
                  domain(midAngle < mathPI ? [0, mathPI] : [2 * mathPI, mathPI]);
                  _y3 += yAdjust(midAngle) * textBound.height;
                  translateTspan(temp_label, _x5);
                } else {
                  if (!bottomOrient) {
                    // top orient
                    //#ZC1717
                    _y3 -= isBubbleChart || isGeoHeatmap ? textBound.height / 2 : textBound.height;
                  }
                }

                temp_label.attr('y', _y3);
                textBound = bbox(temp_label.node());
              } else if (contentType === 'html') {
                //Test_665.json
                textBound = bbox(temp_label.node());
              } else {
                textBound = getTextBound(
                text,
                fontSize,
                getFontFamilyByHierarchy(dataLabels, chartObj),
                null,
                null,
                fontStyles['font-style'],
                fontStyles['font-weight']);

                textBound.x = _x5 - (ANCHOR === 'middle' ? textBound.width / 2 : ANCHOR === 'end' ? textBound.width : 0);
                textBound.y = _y3 - textBound.height;
                // #ZC1727
                if (bottomOrient) {
                  _y3 += textBound.height / 2;
                }
              }

              // Adjust Text Within Bound
              var widthToBeAdded = 0;
              if (!isPolar) {
                widthToBeAdded = getSizeToBeAdded(textBound.width, boundBoxPadding, boundBoxRadius, hookWidth);
                var adjust = boundBoxPadding + boundBoxStrokeWidth / 2 + widthToBeAdded / 2,
                  scrolledX = 0; //chartObj.chartRendered ? (chartObj.scrolledX || 0) : 0;

                var label = temp_label,
                  leftPos = textBound.x - adjust,
                  rightPos = leftPos + textBound.width + scrolledX + 2 * adjust;
                var newX =
                _x5 + (
                leftPos < leftWithBorderCorrection ?
                leftWithBorderCorrection - leftPos :
                rightPos > rightWithBorderCorrection ?
                -(rightPos - rightWithBorderCorrection) :
                0);

                if (xDiff = newX - _x5) {
                  _x5 = newX;
                  label.attr('x', newX);
                  if (isMultiLine) {
                    translateTspan(temp_label, newX);
                  }
                }

                // var z = +label.attr("y");
                var newY = _y3 + (textBound.y < topWithBorderCorrection ? textBound.height + size + padding : 0);
                if (yDiff = newY - _y3) {
                  // if (chartObj.dataObject.isPercentChart && !axisrotated) {
                  _y3 = newY;
                  label.attr('y', newY);
                  // } else {
                  //     display = false;
                  // }
                }

                if (isMultiLine && (xDiff || yDiff)) {
                  textBound = bbox(temp_label.node());
                } else {
                  if ($Browser.IE) {
                    // #ZC1751
                    // IE does not allow to the SVGRect object
                    textBound = simpleClone(textBound);
                  }
                  textBound.x += xDiff;
                  textBound.y += yDiff;
                }
              }

              widthToBeAdded = isPolar ?
              getSizeToBeAdded(textBound.width, boundBoxPadding, boundBoxRadius, hookWidth) :
              widthToBeAdded;
              var bb_width = textBound.width + widthToBeAdded,
                bb_height = textBound.height,
                bb_x = textBound.x + widthToBeAdded / 2;
              if (handleOverlapping) {
                var radius = (isBubbleChart ? zVal : size) / 2;

                if (isBubbleChart) {
                  // Bubble chart - Don't show datalabels when they are out of the bubble bound
                  var cx = xVal,
                    cy = yVal,
                    leftDist = mathSQRT(mathPow(cx - bb_x, 2) + mathPow(cy - textBound.y, 2)) + boundBoxPadding,
                    rightDist =
                    mathSQRT(
                    mathPow(cx - (bb_x + textBound.width), 2) + mathPow(cy - (textBound.y + textBound.height), 2)) +
                    boundBoxPadding;

                  if (leftDist > radius || rightDist > radius) {
                    var trimmed;
                    if (textOverlap === 'adjust') {
                      dy = isMultiLine ? '0.9em' : '-0.3em';
                      HOOKPOSITION = BOTTOM_ALIGN;
                      var radius = zVal / 2;
                      radius *= factor;
                      var _padding = mathMax(0, +(dataLabels.padding || 0)) + boundBoxPadding + hookHeight;
                      _y3 = yVal + (radius + _padding * factor) * (isRangeChart && !yrangePos ? 1 : -1);
                      _y3 = _y3 || 0;
                      textBound.y = _y3 - textBound.height;

                      // ZC3169
                      if (textBound.y < topWithBorderCorrection) {
                        _y3 = textBound.height;
                        textBound.y = _y3;
                      }
                    } else {
                      if (textOverlap === 'ellipsis') {
                        // add ellipsis
                        var h = mathMin(textBound.height / 2, radius);
                        var w = mathSQRT(mathPow(radius, 2) - mathPow(h, 2));
                        var bubbleBound = {
                          left: cx - w + boundBoxPadding,
                          top: cy - w + boundBoxPadding,
                          right: cx + w - boundBoxPadding,
                          bottom: cy + w - boundBoxPadding
                        };

                        if (contentType === 'html') {
                          tspanInfo = getTspanBound(temp_label, fontSize);
                          trimAllTspan(temp_label, chartObj, transform, 0, bubbleBound, tspanInfo);
                        } else {
                          callTrimText(temp_label, chartObj, transform, 0, bubbleBound);
                        }

                        var trimmedText = temp_label.text();
                        if (trimmedText && trimmedText !== '..') {
                          //If the textContent is just "..", hide the label
                          text = temp_label[contentType]();
                          trimmed = true;
                          bb_width = 2 * w - 2 * boundBoxPadding;
                          if (isMultiLine) {
                            var newBB = bbox(temp_label.node());
                            bb_height = newBB.height;
                            bb_width = newBB.width + widthToBeAdded;
                            _y3 += (textBound.height - newBB.height) / 2;
                          }
                        }
                      }
                      if (!trimmed) {
                        _display = false;
                        temp_label.style('display', NONE);
                      }
                    }
                  }
                }

                // only render if the label is visible
                // and it should be implemented in all charts
                // TODO Remila need to check OLD ZR 282
                if (chartObj.isGeoMap && _display || !chartObj.isGeoMap) {
                  var obj = {
                    id: id,
                    x1: bb_x - boundBoxPadding,
                    y1: textBound.y - boundBoxPadding,
                    x2: bb_x + bb_width + boundBoxPadding,
                    y2: textBound.y + textBound.height + boundBoxPadding + hookHeight,
                    pointRadius: radius + padding - hookHeight,
                    translateFunction: updateHandler,
                    overlap: textOverlap,
                    hookHeight: hookHeight,
                    orient: labelOrient,
                    factor: factor
                  };
                  labelArray.push(obj);
                }
              }

              var coordinate = {
                X: _x5,
                Y: _y3,
                DY: dy,
                ANCHOR: ANCHOR,
                text: text,
                display: _display,
                height: bb_height,
                width: bb_width,
                hookPosition: HOOKPOSITION,
                adjustVal: xDiff
              };

              if (isCanvasMode && contentType === 'html') {
                coordinate.tspanInfo = tspanInfo || getTspanBound(temp_label, fontSize);
              }

              calculated_points.push(coordinate);
            });

            calculated_points.dataUpdate = dataUpdate; //Each subseries may have different dataUpdates
            var q = queue(calculated_points, index, i, yrangePos, NULL$1, rendererIndex);
            q.properties = {
              type: SCATTER_CHARTNAME,
              dataLabels: dataLabels,
              color: rp.color,
              dataUpdate: dataUpdate,
              showlabel: showlabel,
              multiColoring: multiColoring,
              rp: rp,
              rangeChart: isRangeChart,
              yrangePos: yrangePos,
              contentType: contentType,
              isMultiLine: isMultiLine,
              chartType: cType
            };
          });
        });
      }

      function getPlotareaBorderCorrection(dataLabels, chartObj) {
        var plotareaBorderEle = chartObj.staticPaneSVG.selectAll('g.plotareaBorder-property').node(),
          defaultVal = 1,
          correction = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };

        if (isBoundBoxEnabled(dataLabels, chartObj)) {
          for (var side in correction) {
            correction[side] = plotareaBorderEle["border-".concat(side)] ?
            plotareaBorderEle["border-".concat(side)].size / 2 + defaultVal :
            defaultVal;
          }
        }

        return correction;
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };

      return labels;
    }

    LabelRegistry.add('scatter', scatterLabel);

    //$Id$

    var svg_filters = function svg_filters() {};

    svg_filters.chalk = function (properties, filterID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var svg = getRenderToSvg(chartObj, renderToSvg);
      var filter = svg.
      select('defs').
      append('filter').
      attrs({
        id: filterID,
        x: -0.3,
        y: -0.5,
        height: 2,
        width: 1.6,
        'color-interpolation-filters': 'sRGB'
      });
      filter.append('feTurbulence').attrs({
        baseFrequency: 0.32065,
        seed: 115,
        result: 'result1',
        numOctaves: 1,
        type: 'fractalNoise'
      });

      filter.append('feOffset').attrs({
        result: 'result2',
        dx: -2,
        dy: -2
      });

      filter.append('feDisplacementMap').attrs({
        scale: 5,
        yChannelSelector: 'G',
        in2: 'result1',
        xChannelSelector: 'R',
        "in": 'SourceGraphic'
      });

      return filterID;
    };

    svg_filters.dropShadow = function (properties, filterID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var svg = getRenderToSvg(chartObj, renderToSvg);
      var filter = svg.
      select('defs').
      append('filter').
      attrs({
        x: properties.x,
        y: properties.y,
        width: properties.width,
        height: properties.height,
        id: filterID,
        filterUnits: properties.filterUnits
      });

      filter.append('feGaussianBlur').attrs({
        "in": properties.source || 'SourceAlpha',
        stdDeviation: properties.blur
      });

      if (properties.source !== 'SourceGraphic') {
        filter.append('feOffset').attrs({
          dx: properties.dx,
          dy: properties.dy,
          result: 'offsetblur'
        });

        var floodColor = properties.color,
          floodOpacity = null;
        var rgba = floodColor && floodColor.match(RGBA_PATTERN); //#ZC910 SAFARI dont consider alpha in rgba color
        if (rgba && rgba.length === 5) {
          floodColor = rgb2hex(floodColor);
          floodOpacity = rgba[4];
        }

        var feFlood = filter.append('feFlood');
        feFlood.attrs({
          'flood-color': floodColor,
          'flood-opacity': floodOpacity
        });

        filter.append('feComposite').attrs({
          in2: 'offsetblur',
          operator: 'in'
        });

        var feMerge = filter.append('feMerge');

        feMerge.append('feMergeNode');
        feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
      }
      return filterID;
    };

    svg_filters.colorMatrix = function (properties, filterID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var svg = getRenderToSvg(chartObj, renderToSvg);
      var filter = svg.
      select('defs').
      append('filter').
      attr('id', filterID);

      var feGaussianBlur = filter.append('feColorMatrix').attrs({
        "in": 'SourceGraphic',
        type: properties.type,
        values: properties.values
      });
      return filterID;
    };

    svg_filters.freeHand = function (properties, filterID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var svg = getRenderToSvg(chartObj, renderToSvg);
      var scaleObj = properties.scale == null ? 7 : properties.scale;

      var filter = svg.
      select('defs').
      append('filter').
      attr('id', filterID);

      var feTurbulence = filter.append('feTurbulence').attrs({
        type: 'fractalNoise',
        baseFrequency: 0.015,
        numOctaves: 2,
        result: 'turbulence_3',
        'data-filterId': 3
      });

      var feDisplacementMap = filter.append('feDisplacementMap').attrs({
        xChannelSelector: 'R',
        yChannelSelector: 'G',
        "in": 'SourceGraphic',
        in2: 'turbulence_3',
        scale: properties.scale
      });
      return filterID;
    };

    function getRenderToSvg(chartObj, renderToSvg) {
      return $Browser.SAFARI && chartObj && chartObj.svg ? chartObj.svg : renderToSvg; // Filter element order matters in phantomjs FEATURESEVENTS_LEGEND_13_1
    }

    effects.svg_filters = svg_filters;

    //$Id$

    var svg_gradients = function svg_gradients() {};

    svg_gradients.get = function (gradient, color, dimension, offset, chartObj, defaultOpacity) {
      /**
       * @param chartObj (optional)
       * @param defaultOpacity (optional) // for canvas.
       */

      var gradientTypeName = gradient.type;
      if (!gradientTypeName || gradientTypeName === NONE) {
        return;
      }
      var mode = chartObj ? chartObj.plot.renderer.mode : 'svg';

      var properties = gradient.options[gradientTypeName] || gradient.options;
      var propObj = simpleClone(properties);
      propObj.color = color != null ? color : propObj.color;
      propObj.dimension = dimension != null ? dimension : propObj.dimension;
      propObj.defsLocation = chartObj ? chartObj.defsLocation : '';
      propObj.id = chartObj.id;
      switch (mode) {
        case 'canvas':{
            propObj.pointOpacity = defaultOpacity || 1;
            return canvas_gradients.create(chartObj.context, gradientTypeName, propObj, offset); //NEED TO  CHANGE CHECKING CANVAS MODE HERE. CLEANUP
            break;
          }
        default:{
            return effects.get(svg_gradients, gradientTypeName, propObj, { offset: offset, chartObj: chartObj });
            break;
          }}

    };
    svg_gradients.svgGradientFill = function (properties, gradientID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      return properties && properties.type ?
      svg_gradients[properties.type](properties, gradientID, offset, returnSVGimage, base64, chartObj, renderToSvg) :
      null;
    };

    svg_gradients.radial = function (properties, gradientID, type, returnSVGimage, base64, chartObj, renderToSvg) {
      var svg = renderToSvg,
        color = properties.color,
        dimension = properties.dimension,
        spread = properties.spreadMethod,
        r = isArray$1(dimension) ? defined(dimension[2]) ? dimension[2] : dimension[0] : dimension.r,
        x = +properties.x || 0,
        y = +properties.y || 0,
        radius = +properties.radius || 0,
        scaleTemplate = d3_scaleLinear().domain([0, 100]),
        gradient = svg.
        select('defs').
        append('radialGradient').
        attrs({
          id: gradientID,
          gradientUnits: properties.gradientUnits || 'userSpaceOnUse',
          spreadMethod: !supportsSpreadMethod(spread) && !$Browser.PHANTOMJS ? 'pad' : spread,
          gradientTransform: dimension.transform
        });

      if (properties.gradientUnits === 'objectBoundingBox') {
        gradient.attrs({
          cx: "".concat(x, "%"),
          cy: "".concat(y, "%"),
          r: "".concat(radius, "%")
        });
      } else {
        var w = !isArray$1(dimension) ? dimension.x2 - dimension.x1 : r,
          h = !isArray$1(dimension) ? dimension.y2 - dimension.y1 : r,
          xScale = scaleTemplate.copy().range([0, w]),
          yScale = scaleTemplate.copy().range([0, h]),
          rScale = scaleTemplate.copy().range([0, r]);

        gradient.attrs({
          cx: xScale(x),
          cy: yScale(y),
          r: supportsSpreadMethod(spread) ? rScale(radius) : r
        });
      }
      addStop$1(gradient, properties, color, 'radial');
      return gradientID;
    };
    svg_gradients.linear = function (properties, gradientID, type, returnSVGimage, base64, chartObj, renderToSvg) {
      var svg = renderToSvg,
        color = properties.color,
        dimension = properties.dimension,
        spread = properties.spreadMethod,
        x1 = +properties.x1 || 0,
        x2 = +properties.x2 || 0,
        y1 = +properties.y1 || 0,
        y2 = +properties.y2 || 0;

      var dim = supportsSpreadMethod(spread) ? 100 : mathMax(mathAbs(x2 - x1), mathAbs(y2 - y1)),
        boundX1,
        boundX2,
        boundY1,
        boundY2;

      if (isArray$1(dimension)) {
        boundX1 = 0;
        boundX2 = dimension[0];
        boundY1 = 0;
        boundY2 = dimension[1];
      } else {
        boundX1 = dimension.x1 || 0;
        boundX2 = dimension.x2 || 0;
        boundY1 = dimension.y1 || 0;
        boundY2 = dimension.y2 || 0;
      }

      if (/(pie|dial|bubblepie)/.test(type)) {
        boundX1 = -boundX2;
        boundY1 = -boundY2;
      }

      var xscale = d3_scaleLinear().
        domain([0, 100]).
        range([boundX1, boundX2]),
        yscale = d3_scaleLinear().
        domain([0, 100]).
        range([boundY1, boundY2]);
      x1 = x1 * 100 / dim;
      x2 = x2 * 100 / dim;
      y1 = y1 * 100 / dim;
      y2 = y2 * 100 / dim;
      var gradient = svg.
      select('defs').
      append('linearGradient').
      attrs({
        id: gradientID,
        gradientUnits: properties.gradientUnits,
        spreadMethod: !supportsSpreadMethod(spread) && !$Browser.PHANTOMJS ? 'pad' : spread,
        gradientTransform: dimension.transform
      });
      if (properties.gradientUnits == 'userSpaceOnUse') {
        gradient.attrs({
          x1: xscale(x1),
          x2: xscale(x2),
          y1: yscale(y1),
          y2: yscale(y2)
        });
      } else {
        gradient.attrs({
          x1: "".concat(x1, "%"),
          x2: "".concat(x2, "%"),
          y1: "".concat(y1, "%"),
          y2: "".concat(y2, "%")
        });
      }
      addStop$1(gradient, properties, color, 'linear');
      return gradientID;
    };

    svg_gradients.thresholdLinear = function (properties, gradientID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var svg = renderToSvg;
      var gradient = svg.
      select('defs').
      append('linearGradient').
      attrs({
        id: gradientID,
        gradientUnits: 'userSpaceOnUse',
        x1: properties.x1,
        x2: properties.x2,
        y1: properties.y1,
        y2: properties.y2
      });
      var stop = appendEle(gradient, 'stop', offset, '.', 'class', 'stop');

      stop.attr('offset', function (d) {
        return d.offset;
      }).attr('stop-color', function (d) {
        return d.color;
      });

      return gradientID;
    };

    function addStop$1(gradient, properties, color, type) {
      var stops = getStops(gradient, properties, color, type);
      for (var i = 0; i < stops.offset.length; i++) {
        gradient.
        append('stop').
        attr('offset', stops.offset[i]).
        styles({
          'stop-color': stops.color[i],
          'stop-opacity': stops.opacity[i]
        });
      }
    }

    effects.svg_gradients = svg_gradients;

    //$Id$

    var svg_patterns = function svg_patterns() {};

    svg_patterns.imageFill = function (properties, patternID, offset, returnSVGimage, base64, chartObj, renderToSvg) {
      var w = properties.width,
        h = properties.height,
        svg = renderToSvg;
      svg.select('defs').
      append('pattern').
      attrs({
        patternUnits: 'userSpaceOnUse',
        id: patternID,
        width: w,
        height: h,
        x: properties.x || 0,
        y: properties.y || 0
      }).
      append('image').
      attrs({
        'xlink:href': properties.name,
        x: 0,
        y: 0,
        width: w,
        height: h
      });

      return patternID;
    };

    svg_patterns.svgPatternFill = function (properties, patternID, offset, returnSVGimage, base64, chartObj, renderToSvg, patternUnits) {
      var patternEle;
      if (properties.ele != null) {
        patternEle = generateSVGPatternByHTML(properties.ele, properties, patternID, patternUnits, renderToSvg);
      } else {
        patternEle = generateSVGPatternByProp(properties, patternID, patternUnits, renderToSvg);
      }

      if (returnSVGimage) {
        var xml =
        "<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='".concat(patternEle.w, "' height='").concat(
        patternEle.h, "'>").concat(
        new XMLSerializer().serializeToString(patternEle.node.node()), "<path d='").concat(getSVGsymbol('square')(
        mathMin(patternEle.w, patternEle.h)), "' transform='translate(").concat(
        patternEle.w / 2, ",").concat(patternEle.h / 2, ")' style='fill: ") + "url(#".concat(patternEle.id, ")'></path> </svg>");
        return {
          url: $Browser.FIREFOX || base64 ? "data:image/svg+xml;base64,".concat(btoa(xml)) : "data:image/svg+xml;utf8,".concat(xml),
          node: patternEle.node,
          w: patternEle.w,
          h: patternEle.h,
          id: patternEle.id
        };
      }

      return patternEle;
    };

    function generateSVGPatternByHTML(ele, properties, patternID, patternUnits, renderToSvg) {
      var pattern_svg = renderToSvg;
      var bgClr = properties.bgClr || properties.bgClr_base;
      var customele = invokeFunction(ele, bgClr);

      properties.ele = customele.replace(/\{\{clr\}\}/g, bgClr);

      var patternNode = pattern_svg.
      select('defs').
      append('pattern').
      attrs({
        patternUnits: patternUnits || 'userSpaceOnUse',
        id: patternID,
        x: properties.x || 0,
        y: properties.y || 0
      }).
      html(properties.ele);

      var bb;
      if ($Browser.FIREFOX) {
        pattern_svg.
        append('g').
        html(properties.ele).
        each(function () {
          bb = bbox(this);
        }).
        remove();
      } else {
        bb = bbox(patternNode.node().firstChild);
      }

      var w = bb.width,
        h = bb.height;
      patternNode.attrs({
        width: w,
        height: h
      });

      return { node: patternNode, w: w, h: h, id: patternID };
    }
    function generateSVGPatternByProp(properties, patternID, patternUnits, renderToSvg) {
      var pattern_svg = renderToSvg;
      var bgClr_base = properties.bgClr || properties.bgClr_base,
        stroke_base = properties.stroke || properties.stroke_base;
      var regExp = /\{\{([a-z]+)\}\}/;

      var symbolTypes = (properties.type || '').split(','),
        noOfSymbols = symbolTypes.length,
        isSize_function = typeof properties.size == 'function',
        isTranslate_function = properties.translate && typeof properties.translate == 'function',
        size = isSize_function ? properties.size(properties.width) : (properties.size || '').split(','),
        strokeWidth = (properties.strokeWidth || '').split(','),
        fillColor = bgClr_base.split(','),
        stroke = stroke_base.split(','),
        fillOpacity = (properties.fillOpacity || '').split(','),
        strokeOpacity = (properties.strokeOpacity || '').split(','),
        translate = isTranslate_function ?
        properties.translate(properties.width) :
        properties.translate ?
        /\[.*?\]/g.test(properties.translate) ?
        JSON.parse(properties.translate) :
        properties.translate.split(',') :
        null;
      size = properties.width && !isSize_function ? getPatternSize(properties, size) : size;

      var patternNode = pattern_svg.
      select('defs').
      append('pattern').
      attrs({
        id: patternID,
        patternUnits: patternUnits || 'userSpaceOnUse',
        width: size[0],
        height: size[0],
        x: properties.x || 0,
        y: properties.y || 0
      });

      for (var i = 0; i < noOfSymbols; i++) {
        var pattern_path = getSVGsymbol(symbolTypes[i])(size[i] || size[0]),
          stroke_cur = isNull(stroke[i] || stroke[0]) ?
          properties.stroke_base :
          (stroke[i] || stroke[0]) == 'static' ?
          properties.customStaticClr :
          stroke[i] || stroke[0],
          fill_cur = isNull(fillColor[i] || fillColor[0]) ?
          properties.bgClr_base :
          (fillColor[i] || fillColor[0]) == 'static' ?
          properties.customStaticClr :
          fillColor[i] || fillColor[0],
          trans_init = (size[i] || size[0]) / 2,
          trans_final = [trans_init, trans_init];
        stroke_cur = regExp.test(stroke_cur) ?
        getColorCopy(properties.stroke_base, 1, stroke_cur.replace(regExp, '$1'), d3_hsl) :
        stroke_cur;
        fill_cur = regExp.test(fill_cur) ? getColorCopy(properties.bgClr_base, 1, fill_cur.replace(regExp, '$1'), d3_hsl) : fill_cur;

        if (translate) {
          var subTranslate = translate[i] || translate[0];
          if (isArray$1(subTranslate)) {
            trans_final = [trans_init + parseFloat(subTranslate[0]), trans_init + parseFloat(subTranslate[1])];
          } else {
            var trans = trans_init + parseFloat(subTranslate);
            trans_final = [trans, trans];
          }
        }

        patternNode.append('path').attrs({
          transform: "translate(".concat(trans_final[0], ",").concat(trans_final[1], ")"),
          d: pattern_path,
          stroke: stroke_cur,
          fill: fill_cur,
          'stroke-width': strokeWidth[i] || strokeWidth[0],
          'stroke-opacity': strokeOpacity[i] || strokeOpacity[0],
          'fill-opacity': fillOpacity[i] || fillOpacity[0]
        });
      }

      return { node: patternNode, w: size[0], h: size[0], id: patternID };
    }

    effects.svg_patterns = svg_patterns;
    Registry.setComponent('patterns.svg', svg_patterns);

    //bullet-events.js

    /**
     *
     * @param x
     * @param y
     * @param width
     * @param height
     * @param axesRotated
     * @returns {{x: Number, y: Number, width: Number, height: Number}}
     */

    function getDimension(x, y, width, height, axesRotated) {
      return {
        _x: axesRotated ? y : x,
        _y: axesRotated ? x : y,
        _width: axesRotated ? height : width,
        _height: axesRotated ? width : height
      };
    }

    /**
     *
     * @param chart
     * @param barOptions
     * @param scaleX
     * @param scaleY
     * @constructor
     */
    function BulletEvent(chart, barOptions, scaleX, scaleY) {
      this.chart = chart;
      this.barOptions = barOptions;
      this.scale = {
        x: scaleX,
        y: scaleY
      };
      this.barOptions = barOptions;
      this.axesRotated = chart.axes.rotated;

      // cache to store rectangles
      this.cache = d3_map();
    }

    /**
     *
     * @param coordinate
     * @param point
     * @returns {*}
     */

    BulletEvent.prototype.getCurrentPoint = function (coordinate, point) {
      var bulletEvent = this,
        rectangles = bulletEvent.getCurrentRectangles(point),
        count = rectangles.length,
        currentRect;

      while (count--) {
        currentRect = rectangles[count];
        if (pointInRectangle(coordinate.x, coordinate.y, currentRect)) {
          return currentRect;
        }
      }
      return null;
    };

    /**
     *
     * @param point
     * @returns {Array}
     */
    BulletEvent.prototype.getCurrentRectangles = function (point) {
      if (point.isDummy) {
        return [];
      }

      var bulletEvent = this,
        chart = bulletEvent.chart,
        xKey = chart.dataset.getX(point);

      // check cache and if already calculated return that.
      if (bulletEvent.cache.has(xKey)) {
        return bulletEvent.cache.get(xKey);
      }

      // else continue calculate rectangles
      var scaleY = bulletEvent.scale.y,
        scaleX = bulletEvent.scale.x,
        levelMarker = chart.systemConf.chart.plot.plotoptions.bullet.levelMarker,
        targetMarker = chart.systemConf.chart.plot.plotoptions.bullet.targetMarker,
        barOption = bulletEvent.barOptions,
        x = scaleX(xKey) + barOption.levelMarkerPadding,
        y,
        bandWidth = scaleX.bandwidth(),
        width = mathMin(levelMarker.maxBandWidth, bandWidth),
        height,
        type = 'y',
        datatype = chart.dataset.getDataType(type, 0),
        formatConf,
        rectangles = [],
        originalValues = point[levelMarker.dataindex] || [],
        col,
        axisrotated = bulletEvent.axesRotated,
        itemIndex = scaleX.domain().indexOf(xKey),
        tempRect = null;

      if (!isArray$1(originalValues)) {
        originalValues = [originalValues];
      }

      var steps = originalValues.slice(0);

      if (datatype === TIME_DATATYPE) {
        var column = chart.dataset.getColumn(type, 0);
        formatConf = defined(column.time) ? column.time : null;
      }

      steps.push(0); // add for get the base.
      steps = steps.map(function (point) {
        return datatype === TIME_DATATYPE ? generateDateVal(point, null, formatConf).getTime() : point;
      });

      steps = axisrotated ? steps.sort(d3_ascending) : steps.sort(d3_descending);

      var temp = steps.map(function (target) {
          return scaleY(target);
        }),
        len;

      steps.splice(steps.indexOf(0), 1); // remove
      var eventOptions_levelMarker = levelMarker.events || {};
      var levelMarkerEventsEnabled = defined(eventOptions_levelMarker.enabled) ? eventOptions_levelMarker.enabled : true;
      col = temp.length - 1;
      len = col - 1;
      if (levelMarkerEventsEnabled) {
        while (col--) {
          height = temp[col + 1] - temp[col];
          if (height > 0) {
            y = temp[col];
          }

          y = temp[col];

          if (height > 0) {
            tempRect = getDimension(x, y, width, height, axisrotated);
            tempRect.currentStage = steps[col];
            tempRect.type = 'levelMarker';
            tempRect.data = point;
            tempRect.rangeIndex = len - col;
            tempRect.itemIndex = itemIndex;
            tempRect.seriesIndex = point.seriesIndex;
            tempRect.events = levelMarker.events;
            tempRect.chartType = chart.chartTypes[0];
            tempRect._defaultH = defaultH;
            tempRect._visible = true;
            tempRect._key = "levelMarker_".concat(point.seriesIndex, "_").concat(itemIndex, "_").concat(tempRect.rangeIndex);
            rectangles.push(tempRect);
          }
        }
      }

      // get the marker
      var eventOptions = targetMarker.events || {};
      var targetEventsEnabled = defined(eventOptions.enabled) ? eventOptions.enabled : true;
      if (targetMarker.enabled === true && targetEventsEnabled) {
        // get the dimension
        var strokeWidthFactor = 0; //mathMax(targetMarker.outerStrokeWidth, targetMarker.innerStrokeWidth) / 2;

        width = pick(targetMarker.size, barOption.levelMarkerWidth - 2 * pick(targetMarker.padding, barOption.padding / 2));
        if (defined(targetMarker.size)) {
          width = mathMin(width, bandWidth / 10) * 10;
        }

        if (targetMarker.symbol === 'line') {
          height = mathMax(pick(targetMarker.outerStrokeWidth, targetMarker.innerStrokeWidth, 0));
        } else {
          height = width;
        }

        // get the coordinates
        var currentStage = point[targetMarker.dataindex];

        x = scaleX(chart.dataset.getX(point)) - strokeWidthFactor;
        y = scaleY(currentStage) - strokeWidthFactor;

        x += (bandWidth - width) / 2;
        y -= height / 2;
        if (height < 5) {
          height = 5;
          y -= 2.5;
        }

        // The target marker bound might be very small. triggeringOffset extends its boundary for event

        var triggerOffset = eventOptions.triggerOffset || 0;
        x -= triggerOffset / 2;
        y -= triggerOffset / 2;
        width += triggerOffset + strokeWidthFactor * 2;
        height += triggerOffset + strokeWidthFactor * 2;

        tempRect = getDimension(x, y, width, height, axisrotated);
        tempRect.type = 'marker';
        tempRect.data = point;
        tempRect.currentStage = currentStage;
        tempRect.itemIndex = itemIndex;
        tempRect.seriesIndex = point.seriesIndex;
        tempRect.targetIndex = 0; // we support only one marker for one bullet.
        tempRect.events = targetMarker.events;
        tempRect.chartType = chart.chartTypes[0];
        tempRect._defaultH = defaultH;
        tempRect._key = "targetMarker_".concat(point.seriesIndex, "_").concat(itemIndex, "_").concat(currentStage);
        rectangles.push(tempRect);
        tempRect._visible = true;
      }

      // add to cache
      bulletEvent.cache.set(xKey, rectangles);
      return rectangles;
    };

    /**
     *
     * @param currentPoint
     * @param seriesIndex
     * @returns {*}
     */
    BulletEvent.prototype.getTooltipContent = function (currentPoint, seriesIndex) {
      var bulletEvent = this,
        chart = bulletEvent.chart,
        plotOptions = chart.systemConf.chart.plot.plotoptions.bullet,
        levelMarkerColumnInfo = getColumnIdxBasedOnDataindex(chart, plotOptions.levelMarker),
        targetMarkerColumnInfo = getColumnIdxBasedOnDataindex(chart, plotOptions.targetMarker),
        levelMarkerEvents = getPropVal(plotOptions, 'levelMarker.events') || {},
        targetMarkerEvents = getPropVal(plotOptions, 'targetMarker.events') || {},
        columnInfo = (this.type === 'marker' ? targetMarkerColumnInfo : levelMarkerColumnInfo) || chart.dataset.getColumn('y', 0),
        value = currentPoint.currentStage,
        dataType = columnInfo.datatype,
        metaInfo = chart.dataset.getMetaInfoObj(chart, currentPoint.data, seriesIndex),
        formattedValue = getFormattedValue(columnInfo[dataType], value, dataType, chart, 'tooltip'),
        text;

      var userCallback = {
        value: value,
        formattedValue: formattedValue,
        actualData: currentPoint.data,
        data: metaInfo
      };

      if (currentPoint.type === 'marker') {
        text = invokeFunction(targetMarkerEvents.tooltipContent, userCallback, chart, 'tooltip') || "Target: ".concat(formattedValue);
      } else {
        text = invokeFunction(levelMarkerEvents.tooltipContent, userCallback, chart, 'tooltip') || "Range: ".concat(formattedValue);
      }

      return text;
    };

    function defaultH() {
      return [];
    }
    events.BulletEvent = BulletEvent;

    /**
     *
     * @param d
     * @param groupbyDataIndices
     * @param chartType
     * @return {*|Array}
     */

    DataProcessor.prototype.flattenData = function (customdata) {
      var processor = this,
        chart = processor.chartObj,
        isDynamic = defined(customdata),
        chartdata = chart.seriesdata,
        data = getDataToFlatten(customdata, chart),
        flatten = this.flattenPoints = this.flattenPoints || d3_map(),
        root,
        helpers = DataProcessor.helpers,
        globalChartType = processor.globalChartType,
        isCombo = processor.isCombinationalChart,
        tooltipShared = tooltip_helpers.hasSharedSeries(chart),
        xAxisReversed = chart.systemConf.chart.axes.xaxis.reversed,
        pivot = processor.pivot,
        hierarchical = processor.hierarchical;

      var groupby = 'charttype'; //or searchModel;
      //Flatten seriesdata and assign values
      var renderCounter = 0;
      data.forEach(function (grid, gridIdx) {
        var paneid = "".concat(grid.row || 0, "_").concat(grid.column || 0),
          gridId = "pane".concat(grid.row || 0, "_").concat(grid.column || 0),
          paneIdx = "pane".concat(grid.index || 0);
        if (!flatten.has(gridId)) {
          flatten.set(gridId, d3_map());
        }
        root = flatten.get(gridId);

        grid.data.forEach(function (series, i) {
          var seriesIdx = isDynamic ? series.seriesindex : i,
            cType_Obj = getChartTypeByIndex(chart, paneid, seriesIdx),
            chartName = cType_Obj.name,
            rendererIdx_pivot = isDynamic ? series.rendererIndex : renderCounter++,
            rendererIdx = chartName == 'bubblepie' ? chart.bubblePieRendererIndex : pivot ? rendererIdx_pivot : seriesIdx,
            renderer = chart.renderer[rendererIdx],
            rp = renderer.commonRendererProp().params,
            isBarChart = isBarChartType(cType_Obj.value),
            chartName_alt = checkSegmentSelection(chart, renderer, chartName),
            key = getJoinbyKey(chartName_alt, groupby),
            searchModel = root.get(key) || {},
            yaxisOrder = helpers.getParsedYAxisOrder(pivot && !isDynamic ? series.node.yaxiscolumnorder : series.yaxiscolumnorder),
            chartType_num = cType_Obj.value,
            _stacked = processor.isstacked(chartType_num),
            highlighter = renderer.getHighlighter && renderer.getHighlighter(chart, seriesIdx, chartName), // TODO: while non axis chart also using event rect, renderer.getHighlighter conditon has to be removed
            seriesdata = series.data || series;

          if (!arrayIncludes(chartcategory.singleSourceEvent, chartType_num)) {
            // TODO: while non axis chart also using event rect, remove this condition
            return;
          }

          var flatted;
          if (arrayIncludes(chartcategory.hierarchy, cType_Obj.value)) {
            flatted = [];
            flatHierarchyData(seriesdata, flatted);
          }

          each(flatted ? [flatted] : seriesdata, function (subseries, j) {
            var subseriesIdx = isDynamic ? series.subseriesindex : j;

            var id = "".concat(seriesIdx, "_").concat(subseriesIdx);
            var flattenPoints = searchModel[id] || [];
            var lastItemPos = isDynamic ?
            flattenPoints[flattenPoints.length - 1] && flattenPoints[flattenPoints.length - 1].itemIndex + 1 ?
            flattenPoints[flattenPoints.length - 1].itemIndex + 1 :
            0 :
            0;

            // hash each point
            each(subseries, function (point, k) {
              var itemIdx = lastItemPos++,
                sortedItemIdx = itemIdx,
                x_uniqueKeys = d3_set();
              if (xAxisReversed) {
                sortedItemIdx = subseries.length - 1 - sortedItemIdx;
              }
              {
                // set index on point
                point.seriesIndex = seriesIdx;
                point.subSeriesIndex = subseriesIdx;
                point.itemIndex = itemIdx;
                point.sortedItemIndex = itemIdx;
                point.rendererIndex = rendererIdx;
                // point.counter = counter;
                point.yaxisOrder = yaxisOrder;
                point._data = dataHash(chart, renderer, point, yaxisOrder, _stacked);
                // point._key = `${chart.id}_${seriesIndex}_${subSeriesIndex}_${itemIndex}`;
                point.paneid = paneid;
                point._key = DataProcessor.helpers.generatePointKey(chart.id, gridId, seriesIdx, subseriesIdx, itemIdx);
                point._xid = chart.dataset.getActualX(point);

                point.subseriesLength = seriesdata.length;
                flattenPoints.push(point);
                //Flatten levelmarker details
                if (highlighter.levelmarker && !searchModel["lm_".concat(point._xid)]) {
                  var collections = highlighter.levelmarker(point);
                  searchModel["".concat(chart.id, "_") + "lm_".concat(point._xid)] = collections;
                  searchModel["".concat(chart.id, "_") + "lm_".concat(point._xid)].disabled = function () {
                    return chartdata[seriesIdx].disabled || eventDisabled(chartdata[seriesIdx], chartName, chart);
                  };
                }
              }
            });

            searchModel[id] = flattenPoints;
            if (chartName == 'bar' || chartName == 'barrange' || chartName == 'boxplot') {
              if (rp.whiskers && rp.whiskers.enabled && rp.whiskers.showOn == 'overlay' && rp.whiskers.events.enabled) {
                searchModel.superKey = "".concat(chartName, "_segment");
              }
            }
            searchModel[id].disabled = function () {
              var currentdata = customdata ?
              chartdata[seriesIdx] || chartdata[i] :
              grid.data[seriesIdx] && grid.data[seriesIdx].node || grid.data[seriesIdx] || grid.data[i];
              return currentdata.disabled || eventDisabled(currentdata, chartName, chart);
            };
          });

          root.set(key, searchModel);
        });
      });

      //Flatten threshold details
      if (chart.cache.thresholdCustomPoints && !customdata) {
        for (var key in chart.cache.thresholdCustomPoints) {
          var thresholdEventObj = chart.cache.thresholdCustomPoints[key];
          if (chart.cache.thresholdCustomPoints.hasOwnProperty(key)) {
            var type = key,
              root1 = root;
            if (thresholdEventObj.grid) {
              root1 = flatten.get("pane".concat(thresholdEventObj.grid));
            }
            var bubblePoints = root1.get(type);
            if (bubblePoints) {
              root1.set(type, root1.concat(thresholdEventObj));
            } else {
              root1.set(type, thresholdEventObj);
            }
          }
        }
      }

      // for other custom points
      var customPoints = chart.cache.customPoints;
      if (customPoints) {var _loop5 = function _loop5(customPointsName)
        {
          if (customPoints.hasOwnProperty(customPointsName)) {
            each(customPoints[customPointsName], function (points, key) {
              var _key$split$map = key.split('_').map(Number),_key$split$map2 = _slicedToArray(_key$split$map, 2),seriesIndex = _key$split$map2[0],subSeriesIndex = _key$split$map2[1],
                renderer = chart.renderer[seriesIndex];

              if (isFunction(renderer)) {
                // the _data is needed for our search model
                points.forEach(function (point, itemIndex) {
                  point.seriesIndex = seriesIndex;
                  point.subSeriesIndex = subSeriesIndex;
                  point._key = DataProcessor.helpers.generatePointKey(customPointsName, seriesIndex, subSeriesIndex, itemIndex);
                  point._data = dataHash(chart, renderer, point);
                });
              }
            });
            root.set(customPointsName, customPoints[customPointsName]);
          }
        };for (var customPointsName in customPoints) {_loop5(customPointsName);}
      }

      if (this.pushFlattenAnnotation) {
        this.pushFlattenAnnotation();
      }

      /*
      ANNOTATION COMPONENT POINTS
       */
      if (chart.components) {
        chart.components.forEach(function (component) {
          var eventPoints = component.events;
          if (root.get(eventPoints.type)) {
            root.get(eventPoints.type)[eventPoints.id] = eventPoints.config[eventPoints.id];
          } else {
            root.set(eventPoints.type, eventPoints.config);
          }
        });
      }

      function getJoinbyKey(type, mode) {
        if (mode == 'charttype') {
          return type;
        } else {
          return getSearchMode(type, tooltipShared || processor.noofBarEnabledSeries);
        }
      }
    };

    DataProcessor.prototype.getFlattenedSeriesData = function (point) {
      var processor = this,
        chart = processor.chartObj,
        joinbykey = chart.chartTypes[point.seriesIndex].name,
        flatten = chart.dataObject.flattenPoints.get(joinbykey)["".concat(point.seriesIndex, "_").concat(point.subSeriesIndex)];
      return flatten;
    };

    DataProcessor.prototype.removeFlattenData = function (point) {
      var flatten = this.getFlattenedSeriesData(point),
        position = point.itemIndex;

      flatten.splice(position, 1);
      for (var i = position; i < flatten.length - 1; i++) {
        flatten[i].itemIndex = position++;
      }
    };

    DataProcessor.prototype.pushFlattenAnnotation = function () {
      var processor = this,
        chart = processor.chartObj,
        chartdata = chart.seriesdata,
        annotationFlatten = chart.annotation.flatten = [],
        root = this.flattenPoints.get('pane0_0'); // TODO

      annotationFlatten.push(function () {
        var annotation = chart.annotation.events; // TODO: rename
        chart.cache.parser = {}; // TODO: enhance

        // Flushing previous points
        annotation.forEach(function (a) {
          var _ = a.parser.event;
          root.set(_.type, null);
        });

        annotation.forEach(function (a) {
          var _ = a.parser.event;
          if (!root.get(_.type)) {
            root.set(_.type, {});
          }

          root.get(_.type).superKey = _.superKey;
          root.get(_.type).size = _.size;
          var seriesIndex = a.data.seriesIndex;
          var id = _.id; // + (defined(seriesIndex) ? '_' + seriesIndex : '');

          var arr = root.get(_.type)[id] = root.get(_.type)[id] || [];
          arr.disabled = function () {return defined(seriesIndex) ? chartdata[seriesIndex].disabled : false;};
          arr.push(invokeFunction(_.data, a.data, chart, a.xy, a)); // TODO: enhance

          // let id = pick(_.id, 'zc-common');
          var _key = "".concat(_.type, "_").concat(id, "_").concat(a.data._key);
          // chart.cache.parser[a.data._key] = chart.cache.parser[a.data._key] || {};
          chart.cache.parser[a.data._key] = a; // TODO: work
          chart.cache.parser[a.data._key]._highlighter = invokeFunction(
          isObjectPropDefined(chart.cache, "parser.".concat([a.data._key], ".parser.event.highlighter"), true),
          chart);

        });
      });
    };

    function dataHash(chart, renderer, point, y_axisorder, stacked) {
      var highlighter = renderer.highlighter;
      return highlighter.data(point);
    }

    function eventDisabled(series, type, chart) {
      /*
       * returns true if the series is filtered or event is disabled for that series
       */
      var plotOptions = series.plotoptions;
      var commonPlotOptions = chart.systemConf.chart.plot.plotoptions[type];
      return series.disabled || validateNullVal(getEventConf(plotOptions, commonPlotOptions, chart, 'enabled'), true) == false;
    }

    function checkSegmentSelection(chart, renderer, defaultChartType) {
      var rp = renderer.commonRendererProp().params,
        plotOptions = rp.commonPlotOptions,
        markerOptions = rp.markerOptions || {},
        symbol = markerOptions.symbol,
        // check sankey link type
        link = plotOptions.link || {};

      if (symbol == 'line' || symbol == 'vertical-line') {
        return 'segment';
      } else if (link.curve) {
        return "".concat(defaultChartType, "Link").concat(toCapitalize(link.curve));
      } else {
        return defaultChartType;
      }
    }

    function getDataToFlatten(customdata, chart) {
      var gridlist = customdata ? [{ data: customdata }] : [{ data: chart.seriesdata }];
      if (chart.dataObject.pivot) {
        if (customdata) {
          gridlist = [
          {
            row: customdata[0].row,
            column: customdata[0].column,
            data: customdata,
            index: customdata[0].index
          }];

        } else {
          var pivotLayout = chart.dataObject.hierarchical.pivotLayout,
            layers = pivotLayout.getRootNodeList('layer'),
            panes = layers.panes;
          gridlist = objectValues(panes);
        }
      }
      return gridlist;
    }

    function flatHierarchyData(data, arr) {
      if (!data) {
        return;
      }

      if (!isArray$1(data[0])) {
        arr.push(data);
        return;
      }
      data.forEach(function (d) {
        flatHierarchyData(d, arr);
      });
    }

    function defaultHash(d, chart, series, item, type, _key) {
      d.seriesIndex = series || 0;
      d.subSeriesIndex = 0;
      d.itemIndex = item || 0;
      d.sortedItemIndex = item || 0;
      d.rendererIndex = 0;
      // d.componentIndex = 0;
      d.yaxisOrder = 0;
      d.paneid = '0_0';
      d._key = DataProcessor.helpers.generatePointKey(chart.id, type, series, 0, item);
      d.__key = _key;
      d._xid = chart.dataset.getActualX(d);
      d.type = type;
      return d;
    }

    Registry.setComponent('events.dataHash', defaultHash);

    var SELECTED_NEW = 1,
      SELECTED_OLD = 2,
      SELECTED_MERGED = 3,
      SELECTED_NULL = null;var

    SelectionManager = /*#__PURE__*/function () {
      function SelectionManager(chart, eventM) {_classCallCheck(this, SelectionManager);
        this.chart = chart;
        this.eventManager = eventM;
        this.nearest = null;
        this.selectedEvent = null;
        this.selectionSet = [];
        this.newSelectionSet = [];
        this.oldSelectionSet = [];
        this.mergedSelectionSet = [];
        this.rejectionSet = [];
        this.oldSelectionSet = [];
        this.oldRejectionSet = [];
      }_createClass(SelectionManager, [{ key: "add", value:
        function add(selections) {
          if (this.selectionSet.length) {
            this.mergedSelectionSet = this.intersection(selections, this.selectionSet, SELECTED_MERGED);
            this.oldSelectionSet = this.difference(this.selectionSet, this.mergedSelectionSet, SELECTED_OLD);
            this.newSelectionSet = this.difference(selections, this.mergedSelectionSet, SELECTED_NEW);
          } else if (selections.length) {
            this.newSelectionSet = selections;
            this.updateID(this.newSelectionSet, SELECTED_NEW);
          }
          this.selectionSet = selections;
          this.selectedEvent = this.eventManager.eventType;
        } }, { key: "remove", value:
        function remove() {
          this.updateID(this.mergedSelectionSet, SELECTED_NULL);
          this.mergedSelectionSet = [];
          this.oldSelectionSet = _toConsumableArray(this.selectionSet);
          this.selectionSet = [];
        } }, { key: "updateID", value:
        function updateID(set, id) {
          set.forEach(function (d) {
            d.selected = id;
          });
        } }, { key: "difference", value:
        function difference(set1, set2, id) {
          var difference = [];
          if (set2.length) {
            set1.forEach(function (d0) {
              set2.forEach(function (d1) {
                if (d0._key == d1._key && !(d1.selected == SELECTED_MERGED)) {
                  difference.push(d0);
                }
              });
            });
          } else {
            difference = set1;
          }

          this.updateID(difference, id);
          return difference;
        } }, { key: "intersection", value:
        function intersection(set1, set2, id) {
          if (this.eventManager.eventType != this.selectedEvent) {
            return [];
          }
          var intersection = [];
          set1.forEach(function (d0) {
            set2.forEach(function (d1) {
              if (d0._key && d0._key == d1._key && (d1.selected == SELECTED_NEW || d1.selected == SELECTED_MERGED)) {
                intersection.push(d0);
              }
            });
          });
          this.updateID(intersection, id);
          return intersection;
        } }]);return SelectionManager;}();var


    PlotHighlighter = /*#__PURE__*/function () {
      function PlotHighlighter(chart) {_classCallCheck(this, PlotHighlighter);
        this.chart = chart;
      }_createClass(PlotHighlighter, [{ key: "highlight", value:
        function highlight(point) {
          var seriesIndex = point.seriesIndex,
            itemIndex = point.itemIndex,
            subseriesIndex = point.subSeriesIndex,
            subseriesLength = point.subseriesLength,
            type = point.type || 'series',
            highlighter = this.getRenderer(point, type),
            set = highlighter._defaultH(point);

          for (var key in set) {
            if (set.hasOwnProperty(key)) {
              var obj = set[key];
              var context = obj.path.call(highlighter, point, obj),
                styles = obj.styles ? obj.styles.call(highlighter, point) : null;
              this.applyStyles(context, styles);
            }
          }
        } }, { key: "getRenderer", value:
        function getRenderer(point, type) {
          if (type == 'series') {
            var chartName = getChartTypeByIndex(this.chart, point.paneid, point.seriesIndex).name,
              r = this.chart.renderer,
              renderer = r[point.rendererIndex || 0],
              highlighter = renderer.highlighter;
            return highlighter;
          } else if (type == 'threshold-marker' || type == 'levelMarker' || type == 'marker') {
            return point;
          } else {
            // TODO: add default marker highlight
            return isObjectPropDefined(this.chart.cache, "parser.".concat([point.__key], "._highlighter"), true); // TODO: enhance
          }
        } }, { key: "getRenderingContext", value:

        function getRenderingContext() {} }, { key: "applyStyles", value:
        function applyStyles(context, styles) {
          // let plotElements = this._plotElements,
          //     effectsConfig = this._effectsConfig;
          //
          // plotElements.forEach((ele) => {
          //     effectsConfig.forEach((eff) => {
          //         ele.styles(eff);
          //     })
          // })
          if (context) {
            context.styles(styles);
          }
        } }]);return PlotHighlighter;}();


    function getDependantData(point, chart) {
      var columnIdx = point.column,
        tag = 'column',
        nodeList = chart.dataObject.hierarchical.pivotLayout.getRootNodeList(tag),
        clusterIdx = 0,
        cluster = nodeList.clusters[clusterIdx];
      if (cluster.datatype == NUMERIC_DATATYPE) {
        return null;
      }
      var clusterNodes = nodeList.getClusterNodes(clusterIdx),
        currentNode = clusterNodes[point.index],
        dependentPoints = currentNode.data;
      return dependentPoints;
    }

    function highlighter_c(mouse, selectionManager) {
      var nearest = selectionManager.nearest;
      if (nearest && nearest.selected == SELECTED_MERGED) {
        return;
      }
      if (!this.chart.eventHandler.isSingleSource()) {
        nearest.renderer.defaultMouseOverFunc(nearest.data, nearest.seriesIndex, nearest.itemIndex, nearest.paneid);
      } else if (this.chart.isGeoMap) {
        this.chart.eventHandler.mapEvents.handleMouseMove(nearest);
      } else {
        ordinalDatamouseMove(selectionManager, mouse, this.chart);
      }
    }

    function ordinalDatamouseMove(selectionManager, relmousePt, chart) {
      clearHighlightContext(chart);
      //Update tooltip shared series;
      //TODO move to tooltip section;
      var tooltipShared = tooltip_helpers.hasSharedSeries(chart),
        tooltipSharedInfo = d3_map(),
        points;

      var plotHighlighter = chart.eventHandler.plotHighlighter || new PlotHighlighter(chart);
      chart.eventHandler.plotHighlighter = plotHighlighter;
      points = tooltipShared || isDependentPointHighlightType(chart) ? selectionManager.selectionSet : [selectionManager.nearest];

      if (chart.dataObject.pivot && chart.systemConf.chart.axes.events && chart.systemConf.chart.axes.events.highlightAllGrid) {
        points = getDependantData(selectionManager.nearest, chart) || points;
      }

      points.forEach(function (d) {
        if (chart.eventHandler.getPointType(d) == 'series') {
          chart.eventHandler.tooltipSharedInfo = tooltipSharedInfo.set(
          d.seriesIndex,
          defined(d.counter) ? d.counter : pick(d.sortedItemIndex, d.itemIndex));

          tooltip_content.updateSharedInfo(chart, tooltipSharedInfo, d.seriesIndex);
        }
        plotHighlighter.highlight(d);
      });
    }

    var HIGHLIGHT_NEARBY = d3_set(['line', 'scatter', 'threshold']),
      HIGHLIGHT_WITHIN_SHAPE = d3_set([
      'bubble',
      'bubblepie',
      'area',
      'arearange',
      'web',
      'bar',
      'bullet',
      'gantt',
      'heatmap',
      'waterfall',
      'boxplot',
      'levelMarker',
      'marker',
      'sankey',
      'treemap',
      'wordcloud',
      'barrange',
      'geoheatmap']);


    Registry.setComponent('events.controllers.highlighter', highlighter_c);

    function reversehighlight_c(mouse, selectionManager) {
      var point = selectionManager.nearest;
      this.chart.eventHandler.reverseLegendHighlight.highlight(point);
      this.chart.eventHandler.unselectedHighlight.highlight(point);
    }

    Registry.setComponent('events.controllers.reversehighlight', reversehighlight_c);

    function highlightTouch_c(mouse, selectionManager) {
      var tapOldInfo = this.chart.eventHandler.tapOldInfo,
        isTouchEvent = d3_event() && d3_event().touches,
        point = selectionManager.nearest;
      if (isTouchEvent && this.chart.zcEventType !== 'taphold') {
        // if (this.chart.eventHandler.isSingleSource()) {
        //     var currentQualitativeRangePoint = point.currentQualitativeRangePoint || {};
        //     var currentQualitativeRangePoint_old = (tapOldInfo && tapOldInfo.currentQualitativeRangePoint) || {};
        //
        //     condition =
        //         !tapOldInfo || point && point.selected == SELECTED_MERGED
        //         tapOldInfo.itemPos != point.itemIndex ||
        //         tapOldInfo.seriesPos != point.seriesIndex ||
        //         tapOldInfo.subseriesindex != point.subseriesIndex ||
        //         currentQualitativeRangePoint.rangeIndex != currentQualitativeRangePoint_old.rangeIndex ||
        //         currentQualitativeRangePoint.targetIndex != currentQualitativeRangePoint_old.targetIndex ||
        //         ((point.highlightpoint && point.highlightpoint.type) || currentQualitativeRangePoint.type) !=
        //             currentQualitativeRangePoint_old.type;
        // } else {
        //     condition =
        //         !tapOldInfo ||
        //         (point.level
        //             ? point.level != tapOldInfo.level
        //             : tapOldInfo.itemPos != itemPos || tapOldInfo.seriesPos != seriesPos || tapOldInfo.subseriesindex != 0);
        // }
        var defaultZCBehaviour = $ZC.getPlotDefaultBehaviour(),
          eventManager = this.chart.eventHandler.eventManager;
        if (point && point.selected == SELECTED_MERGED) {
          eventManager.selectionManager.remove();
          defaultZCBehaviour.mouseout.map(function (d, i) {
            d.action().call(eventManager, mouse, selectionManager);
          });
        } else {
          eventManager.associateBehaviours.call(eventManager, 'mousemove', selectionManager, mouse);
          // defaultZCBehaviour.mousemove.map(function(d, i) {
          //     d.action().call(eventManager, mouse, selectionManager);
          // });
        }
      }
    }

    Registry.setComponent('events.controllers.highlightTouch', highlightTouch_c);

    //

    function showCursor_C(mouse, selectionManager, cursor) {
      var eventHandler = this.chart.eventHandler,
        isSingleSource = eventHandler.isSingleSource(),
        trackerElement = getEventTrackerElement(this.chart),
        brushEnabled = getPropVal(this.chart.systemConf, 'chart.brush.enabled') === true,
        overlayElement = this.chart.staticPaneSVG.selectAll(".trackerGroup").selectAll('rect.overlay'),
        // #ZC2066
        isBrushSupported = this.chart.isAxisCategory && this.chart.isPolarAxisCategory || this.chart.isGeoMap,
        cursorNew = cursor || (brushEnabled && isBrushSupported ? 'crosshair' : POINTER);

      if (isSingleSource) {
        cursorNew =
        cursor || ZC_ChartEvents.getCustomBehaviour.call(this, selectionManager, 'cursor') || (brushEnabled && this.chart.isAxisCategory ? 'crosshair' : POINTER);
        var condition = showCursorCriteria(mouse, selectionManager.nearest, this.chart);
        if (condition) {
          trackerElement.style('cursor', cursorNew);
          if (brushEnabled) {
            overlayElement.style('cursor', cursorNew);
          }
        } else {
          hideCursor_C.call(this);

          if (brushEnabled) {
            overlayElement.style('cursor', overlayElement.attr('cursor'));
          }
        }
      } else {
        trackerElement.style('cursor', cursorNew);
      }
    }

    function hideCursor_C() {
      var trackerElement = getEventTrackerElement(this.chart),
        brushEnabled = getPropVal(this.chart.systemConf, 'chart.brush.enabled') === true,
        overlayElement = this.chart.staticPaneSVG.selectAll(".trackerGroup").selectAll('rect.overlay');
      trackerElement.style('cursor', 'default');
      if (brushEnabled) {
        overlayElement.style('cursor', null);
      }
    }

    function showCursorCriteria(mouse, nearest, chart) {
      if (!nearest) {
        return false;
      }
      var point = chart.isGeoMap ? nearest.point : nearest;
      var seriesIndex = point.seriesIndex,
        type = point.type || getChartTypeByIndex(chart, point.paneid, seriesIndex).name,
        isWithinType = HIGHLIGHT_WITHIN_SHAPE.has(type);

      if (isWithinType) {
        return true;
      }

      var p = { x: point._x, y: point._y },
        distance = geometryUtils.dist(p, mouse);
      return distance < 10;
    }

    function getEventTrackerElement(chart) {
      return chart.isAxisCategory && (chart.systemConf.chart.width || chart.systemConf.chart.height) ?
      chart.container.selectAll('.zohocharts_scroll') :
      chart.eventHandler.trackerElement;
    }

    Registry.setComponent('events.controllers.showCursor', showCursor_C);

    function hidetooltip_c() {
      var handlers = this.chart.eventHandler.handlers;
      var tooltip = this.chart.eventHandler.tooltipElement;
      tooltip.hide(tooltip.element);
      hideCursor_C.call(this);
    }

    Registry.setComponent('events.controllers.hideTooltip', hidetooltip_c);

    var annotation$1 = Registry.getComponent('annotation');
    function notes_c(mouse, selectionManager) {
      var chart = this.chart;
      var point = selectionManager.nearest,
        notesConfig = this.chart.systemConf.notes,
        canAddOnDoubleclickEvent = notesConfig && notesConfig.enabled && notesConfig.addOnDoubleclickEvent;
      var notes_args;
      if (canAddOnDoubleclickEvent) {
        if (this.chart.eventHandler.isSingleSource()) {
          var seriesdata = this.chart.seriesdata;
          var clonedata = point.slice();
          var data = clonedata.splice(0, clonedata.length),
            chartType = getChartTypeByIndex(chart, point.paneid, 0).value,
            _centric = point._centric && arrayIncludes(chartcategory.nonAxisSingleSourceEvent, chartType),
            coordinates = [point._x - (_centric ? point._width / 2 : 0), point._y - (_centric ? point._height / 2 : 0)];

          if (seriesdata.length > 1) {
            data.push(seriesdata[point.seriesIndex].seriesname);
          }
          notes_args = {
            coordinate: this.chart.dataObject.isPolarAxisCategory ?
            [coordinates[0] + this.chart.plotarea_approx.x, coordinates[1] + this.chart.plotarea_approx.y] :
            coordinates,
            data: data,
            basedOn: 'plot',
            conf: { data: data }
          };
        } else {
          notes_args = _objectSpread(_objectSpread({}, point), {}, { conf: { data: point.data } });
        }

        if (!annotation$1._empty) {
          annotation$1.addNotes(this.chart, notes_args);
        }
      }
    }

    Registry.setComponent('events.controllers.notes', notes_c);

    function reset_c(mouse, selectionManager) {
      var event = d3_event() || this.chart.eventHandler.targetEvent,
        relatedTarget = event != null ? event.relatedTarget : null,
        target = event != null ? event.target : null,
        tooltip = this.chart.eventHandler.tooltipElement,
        tooltipHideDelay = this.chart.systemConf.tooltip.hideDelay,
        eventEle = this.chart.eventHandler.getSourceNode(),
        point = selectionManager.nearest,
        chart = this.chart,
        eventHandler = this.chart.eventHandler;

      chart.eventHandler.unselectedHighlight.reset();

      if (this.chart.isAxisCategory && checkMouseInTooltip(target, relatedTarget, tooltip)) {
        return;
      }

      if (eventHandler.isSingleSource()) {
        clearTimeout(eventHandler.mouseouttimer);
        eventHandler.mouseouttimer = setTimeout(function () {
          {
            clearTimeout(eventHandler.tooltipElement.timeout);
            eventHandler.tooltipElement.timeout = setTimeout(function () {
              clearHighlightContext(chart);
              tooltip.hide();
            }, pick(tooltipHideDelay, 150));
          }
        }, 0);

        hideCursor_C.call(this);
      } else {
        var index = point ? point.seriesIndex : 0,
          renderer = this.chart.renderer[index] || point.renderer;
        // if (eventEle.id == 'zctooltip' || checkMouseInTooltip(target, relatedTarget, tooltip)) {
        //     var actualRenderer = this.chart.eventHandler.oldRenderer;
        //     if (actualRenderer != null) {
        //         actualRenderer.renderer.defaultMouseOutFunc(
        //             actualRenderer.data,
        //             this.chart.isNonAxisMultiSeriesCategory ? actualRenderer.seriesPos : actualRenderer.itemPos,
        //             forceMouseOut
        //         );
        //     }
        // } else {
        //     renderer.defaultMouseOutFunc(point, index, forceMouseOut);
        // }

        hidetooltip_c.call(this);
      }
      eventHandler.reverseLegendHighlight.reset();
    }

    Registry.setComponent('events.controllers.reset', reset_c);

    function resethighlight_c(mouse, selectionManager) {
      var event = d3_event() || this.chart.eventHandler.targetEvent,
        relatedTarget = event != null ? event.relatedTarget : null,
        target = event != null ? event.target : null,
        tooltip = this.chart.eventHandler.tooltipElement,
        tooltipHideDelay = this.chart.systemConf.tooltip.hideDelay,
        forceMouseOut,
        eventEle = this.chart.eventHandler.getSourceNode(),
        point = selectionManager.nearest,
        chart = this.chart,
        eventHandler = this.chart.eventHandler;
      if (eventHandler.isSingleSource()) {
        var nearest = selectionManager.nearest;
        if (nearest && nearest.selected == SELECTED_MERGED) {
          return;
        }
        clearHighlightContext(this.chart);
      } else {
        invokeMouseOut(chart, point, forceMouseOut);
      }
    }

    function forceResetHighlight_c(mouse, selectionManager) {
      var forceMouseOut,
        point = selectionManager.nearest,
        chart = this.chart,
        eventHandler = this.chart.eventHandler;
      if (eventHandler.isSingleSource()) {
        var nearest = selectionManager.nearest;
        if (nearest && nearest.selected == SELECTED_MERGED) {
          return;
        }
        clearHighlightContext(this.chart);
      } else {
        invokeMouseOut(chart, point, forceMouseOut);
      }
    }

    function invokeMouseOut(chart, point, forceMouseOut) {
      var index = point ? point.seriesIndex : 0,
        renderer =
        chart.renderer[
        chart.dataObject.isAxisCategory || chart.dataObject.isPolarAxisCategory ? index : point && point.rendererIndex || 0] ||
        point.renderer;

      var func = renderer.defaultMouseOutFunc || point.renderer.defaultMouseOutFunc; // Hierarchy chart: some renderer may not have defaultMouseOutFunc
      func(point, index, forceMouseOut);
    }

    Registry.setComponent('events.controllers.resethighlight', resethighlight_c);
    Registry.setComponent('events.controllers.forceResetHighlight', forceResetHighlight_c);

    //

    var markerBehaviourMap = {
      mousemove: [
      {
        action: function action() {
          return resethighlight_c;
        },
        allowifcustom: true,
        type: 'resetHighlight'
      },
      {
        action: function action() {
          return highlighter_c;
        },
        type: 'highlight'
      },
      {
        action: function action() {
          return showCursor_C;
        },
        type: 'cursor'
      },
      {
        action: {
          callback: function callback(event, d, chart) {
            var tooltip = chart.eventHandler.tooltipElement;
            tooltip.hide(tooltip.element);
          }
        },
        type: 'custom'
      }],

      click: [
      {
        action: function action() {
          return hidetooltip_c;
        },
        type: 'hidetooltip'
      },
      {
        action: function action() {
          return showCursor_C;
        },
        type: 'cursor',
        allowifcustom: conditionalDefault
      },
      {
        action: function action() {
          return highlightTouch_c;
        },
        type: 'highlightOnTaphold'
      }],

      doubleclick: [
      {
        action: function action() {
          return hidetooltip_c;
        },
        type: 'hidetooltip'
      },
      {
        action: function action() {
          return showCursor_C;
        },
        type: 'cursor',
        allowDefault: conditionalDefault
      }],

      mouseout: [
      {
        action: function action() {
          return resethighlight_c;
        },
        type: 'resetHighlight',
        allowDefault: true
      },
      {
        action: function action() {
          return reset_c;
        },
        type: 'resetTooltip',
        allowDefault: true
      }],

      contextmenu: []
    };

    markerBehaviourMap.touchmove = markerBehaviourMap.mousemove;
    markerBehaviourMap.tap = markerBehaviourMap.click;
    markerBehaviourMap.doubletap = markerBehaviourMap.doubleclick;

    var behaviourMap = {};
    behaviourMap._defaultPlotBehaviour = {
      mousemove: [
      {
        action: function action() {
          return resethighlight_c;
        },
        allowifcustom: true,
        type: 'resetHighlight'
      },
      {
        action: function action() {
          return highlighter_c;
        },
        type: 'highlight'
      },
      {
        action: function action() {
          return showCursor_C;
        },
        type: 'cursor'
      },
      {
        action: function action() {
          return reversehighlight_c;
        },
        type: 'reverseHighlight'
      },
      {
        action: function action() {
          return tooltip_c;
        },
        allowDefault: true,
        type: 'tooltip'
      }],

      click: [
      {
        action: function action() {
          return hidetooltip_c;
        },
        type: 'hidetooltip'
      },
      {
        action: function action() {
          return showCursor_C;
        },
        type: 'cursor',
        allowifcustom: conditionalDefault
      },
      {
        action: function action() {
          return highlightTouch_c;
        },
        type: 'highlightOnTaphold'
      }],

      doubleclick: [
      {
        action: function action() {
          return hidetooltip_c;
        },
        type: 'hidetooltip'
      },
      {
        action: function action() {
          return notes_c;
        },
        type: 'notes'
      },
      {
        action: function action() {
          return showCursor_C;
        },
        type: 'cursor',
        allowDefault: conditionalDefault
      }],

      mouseout: [
      {
        action: function action() {
          return resethighlight_c;
        },
        type: 'resetHighlight',
        allowDefault: true
      },
      {
        action: function action() {
          return reset_c;
        },
        type: 'resetTooltip',
        allowDefault: true
      }],

      contextmenu: []
    };
    behaviourMap._defaultPlotBehaviour.touchmove = behaviourMap._defaultPlotBehaviour.mousemove;
    behaviourMap._defaultPlotBehaviour.tap = behaviourMap._defaultPlotBehaviour.click;
    behaviourMap._defaultPlotBehaviour.doubletap = behaviourMap._defaultPlotBehaviour.doubleclick;

    function setPlotDefaultBehaviour() {
      if (arguments.length === 2) {
        behaviourMap[arguments[0]] = arguments[1];
      } else {
        behaviourMap._defaultPlotBehaviour = arguments[0];
      }
    }

    function getPlotDefaultBehaviour() {
      if (arguments.length) {
        var _arguments4 = Array.prototype.slice.call(arguments),name = _arguments4[0];
        if (name) {
          return behaviourMap[name];
        }
      } else {
        return behaviourMap._defaultPlotBehaviour;
      }
    }

    function conditionalDefault(args) {
      if (this.chart.isAxisCategory || this.chart.isPolarAxisCategory) {
        return true;
      }
      return false;
    }

    setPlotDefaultBehaviour('marker', markerBehaviourMap);var

    EventManager = /*#__PURE__*/function () {
      function EventManager(chart, data) {_classCallCheck(this, EventManager);
        this.chart = chart;
        this.data = data;
        this.selectionManager;
        this.handlers = {};
        this.dataGenerators = {};
        this.defaultBehaviour = {};
        this.customBehaviour = {};
        this.targetEvent = null;
      }_createClass(EventManager, [{ key: "init", value:
        function init() {
          this.selectionManager = new SelectionManager(this.chart, this);
        } }, { key: "bindTo", value:
        function bindTo(element) {
          this.tracker = element;
        } }, { key: "attachListeners", value:
        function attachListeners(tracker, mouseHandlers, touchHandlers, options, namespace) {
          attachevents(tracker, mouseHandlers, touchHandlers, options, namespace);
        } }, { key: "dataFinder", value:
        function dataFinder(actions) {
          if (actions) {
            this.dataGenerators = actions;
          }
          return this.dataGenerators;
        }
        //founddata should be like
        // {
        //     'nearby': point.nearby,
        //     'nearest': point.nearest,
        //     'type': 'series'
        // }
      }, { key: "getData", value: function getData(eventType, mouse) {var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var finder = this.dataFinder()[eventType],
            foundData = finder.call.apply(finder, [this, mouse, eventType].concat(_toConsumableArray(args)));

          this.updateSelectionManager(foundData);
          return this.selectionManager;
        } }, { key: "updateSelectionManager", value:

        function updateSelectionManager(selection) {
          if (selection.dependents) {
            this.selectionManager.add([selection.nearest]);
            this.selectionManager.selectionSet = selection.dependents;

            if (this.selectionManager.nearest !== selection.nearest) {
              this.selectionManager.updateID([selection.nearest], SELECTED_NEW);
            }
          } else if (selection.nearby) {
            this.selectionManager.add(selection.nearby);
          } else if (selection.nearest) {
            this.selectionManager.add([selection.nearest]);
          } else {
            this.selectionManager.remove();
          }
          this.selectionManager.nearest = selection.nearest;
          this.selectionManager.surround = selection.surround;
        } }, { key: "associateBehaviours", value:

        function associateBehaviours(eventType, selectionManager, mouse) {var _this20 = this;
          var behaviour = this.getbehaviour(eventType, selectionManager);
          var iscustom;
          behaviour.forEach(function (d) {
            if (d) {
              var allowifcustom = getValue(d.allowifcustom, _this20);
              if (d.type == 'custom') {
                //custom events
                iscustom = true;
                var action = d.action;
                invokeFunction(action.callback, _this20.targetEvent, action.args, _this20.chart);
              } else if (_this20.targetEvent.allowDefault || d.allowDefault) {
                //add extra default behaviours
                if (iscustom) {
                  if (!allowifcustom) {
                    invokeAction(d, _this20, mouse, selectionManager);
                  }
                } else {
                  invokeAction(d, _this20, mouse, selectionManager);
                }
              } else if (iscustom && allowifcustom) {
                //extra behaviour added only for custom events
                invokeAction(d, _this20, mouse, selectionManager);
              } else if (!iscustom && !allowifcustom) {
                //default behaviours
                invokeAction(d, _this20, mouse, selectionManager);
              }
            }
          });
        } }, { key: "getbehaviour", value:
        function getbehaviour(eventType, selectionManager) {
          var behaviour = [],
            point = selectionManager.nearest;

          var _b = this.getBehaviourName && this.getBehaviourName(point);
          var _defaultB = pick(getPlotDefaultBehaviour(_b), this.defaultBehaviour)[eventType];
          var _customB = this.customBehaviour(selectionManager, eventType);
          if (defined(_customB)) {
            behaviour = behaviour.concat(_customB); //{'callback': '<>', args:{}}
            behaviour = behaviour.concat(_defaultB);
          } else {
            behaviour = behaviour.concat(_defaultB);
          }

          return behaviour;
        }

        /**
         * Checks if a user has allowed the fault function
         *
         * @param userFunction
         * @param event
         * @return {*|boolean}
         */ }, { key: "isDefaultAllowed", value:
        function isDefaultAllowed(userFunction, event) {
          return !defined(userFunction) || userFunction && event.allowDefault === true;
        } }]);return EventManager;}();


    function invokeAction(d, eventManager, mouse, selectionManager) {
      var action = isObject(d) ? d.action() : d;
      return action.call(eventManager, mouse, selectionManager);
    }

    /*
           List of search tool model
        */

    var QUADTREE_TYPES = d3_set([
      'line',
      'scatter',
      'bubble',
      'bubblepie',
      'threshold',
      'threshold-marker',
      'segment',
      'treemap',
      'wordcloud']),

      POLY_TYPES = d3_set(['area', 'arearange', 'web', 'sankeyLinkLinear', 'sankeyNodes']),
      BISECT_TYPES = d3_set([
      'bar',
      'bullet',
      'gantt',
      'heatmap',
      'waterfall',
      'boxplot',
      'barrange',
      'bar_segment',
      'barrange_segment',
      'boxplot_segment',
      'bar_triggeroffset']);


    var NONSERIES_TYPES = d3_set(['threshold']);

    var QUADTREE_NORM_TYPES = d3_set(['line', 'scatter', 'threshold']),
      QUADTREE_SIZE_TYPES = d3_set(['bubble']),
      QUADTREE_PIE_TYPES = d3_set(['bubblepie']),
      QUADTREE_BOUND_TYPES = d3_set(['treemap']),
      QUADTREE_TEXT_TYPES = d3_set(['wordcloud']);

    var BISECT_NORM_TYPES = d3_set(['bar', 'barrange', 'bullet', 'gantt', 'heatmap', 'waterfall']),
      BISECT_LEVEL_TYPES = d3_set(['boxplot']),
      BISECT_SEGMENT_TYPES = d3_set(['bar_segment', 'barrange_segment', 'boxplot_segment']),
      BISECT_QUADTREE_TYPES = d3_set(['bar_triggeroffset']);

    var SEGMENT_TYPES = d3_set(['segment', 'whisker']);

    var PATH_TYPES = d3_set(['sankeyLinkBezier']);
    var FLOW_TYPES = d3_set(['sankey']);

    /**
     *
     * @param type
     * @param sharedCriteria
     * @return {"bisect" | "PATH" | "POLY" | "QUADTREE" | "BISECT"}
     */
    function getSearchMode$1(type, sharedCriteria) {
      if (sharedCriteria && !NONSERIES_TYPES.has(type)) {
        return 'bisect';
      } else if (PATH_TYPES.has(type)) {
        return 'PATH';
      } else if (POLY_TYPES.has(type)) {
        return 'POLY';
      } else if (QUADTREE_TYPES.has(type)) {
        return 'QUADTREE';
      } else if (BISECT_QUADTREE_TYPES.has(type)) {
        return 'BISECT_QUADTREE';
      } else if (BISECT_TYPES.has(type)) {
        return 'BISECT';
      } else if (type === 'zc-marker') {
        return 'QUADTREE';
      }
    }

    function getFineSearchKey(mode) {
      if (mode == 'QUADTREE') {
        return 'bubble';
      } else {
        return 'bar';
      }
    }

    /**
     *
     * @param type
     * @return {string}
     */
    function getChartModel(type) {
      // MODELS ['FLOW', 'COLUMN', 'HIERARCHY', "CONTINUOUS"]

      if (FLOW_TYPES.has(type)) {
        return 'FLOW';
      }
    }

    function PolySearch(nodes) {
      this.data = nodes;
    }

    var proto$3 = PolySearch.prototype;

    proto$3.getPoly = function (d) {
      return d._polydata().points;
    };

    proto$3.find = function (mouse) {
      var points = [];
      this.data.map(function (d, i) {
        if (d._data()._visible) {
          points.push(d);
        }
      });
      return points;
    };

    function Bisectsearch(nodes, type) {
      this.data = nodes;
      this.type = type;
      this.bisector = type == 'continous' ? this.continousBisect() : this.discreteBisect();
    }

    var proto$4 = Bisectsearch.prototype;
    //Finding x value in each series
    //Also need to find series value in every category
    proto$4.find = function (x, mouse) {
      var _this = this,
        points = [];
      var insertionPoint = this.data.map(function (d) {
        return _this.bisector.call(_this, d, x, mouse);
      });
      var bisected = this.bisectValue(insertionPoint, mouse),
        withInBisect = function withInBisect(d) {
          return _this.type == 'discrete' || bisected == d._x;
        };
      this.data.map(function (d, i) {
        if (insertionPoint[i]) {
          return insertionPoint[i].map(function (p) {
            if (d[p] && d[p]._data()._visible && withInBisect(d[p])) {
              points.push(d[p]);
            }
          });
        }
      });
      return points;
    };

    proto$4.continousBisect = function () {
      var bisector = d3_bisector(function (d) {
        return d._data()._uid;
      }).left;

      var discreteBisect = this.discreteBisect;
      return function (d, x, mouse) {
        var index = bisector(d, x, 0, d.length - 1);
        if (index > 0) {
          var _a = [index, index - 1];
          var _b = [x0(mouse, d[_a[0]]), x0(mouse, d[_a[1]])];
          index = _b[0] <= _b[1] ? _a[0] : _a[1];
        }
        // index = [index];
        return discreteBisect()(d, d[index]._uid);
        // return index;
      };
    };

    proto$4.discreteBisect = function () {
      return searchIndex(function (d) {
        return d._data()._uid;
      });
    };

    proto$4.bisectValue = function (insertionPoint, mouse) {
      var v,
        y,
        y0,
        type = this.type;

      this.data.map(function (d, i) {
        if (insertionPoint[i]) {
          return insertionPoint[i].map(function (p) {
            if (d[p] && d[p]._data()._visible) {
              y = x0(mouse, d[p]);
              if (y < y0 || y0 == null) {
                v = d[p]._x;
                y0 = y;
              }
            }
          });
        }
      });
      return v;
    };

    function x0(a, x) {
      return mathAbs(a.x - x._data()._x);
    }

    function barSelection(points, mouse, chart, key) {
      var point;
      var commonPlotOptions = chart ? chart.systemConf.chart.plot.plotoptions[key] : null,
        customTriggerOffset = commonPlotOptions && commonPlotOptions.events && commonPlotOptions.events.triggerOffset,
        sizeOffset = customTriggerOffset || 0,
        _needRect2PtDist = sizeOffset && needRect2PtDistCalc(chart),
        _needExtendBound = sizeOffset && supportedExtendedBound(chart);
      var x = points.map(function (p, i) {
        var _a = p._data(),
          bound_default = getBound(_a),
          rect = _needExtendBound ? getExtendedBound(bound_default, sizeOffset) : bound_default,
          _mouse = getRotatedMouse(mouse, { x: _a._x, y: _a._y, rotation: _a._rotation });

        var _b = pointInRectangle(_mouse.x, _mouse.y, rect),
          distance;
        if (_needRect2PtDist && _b) {
          /*
            distance between bar and mouse point
           */
          p.searchKey = 'bar_triggeroffset';
          distance = distanceBetweenRectFromPoint(bound_default, _mouse);
        }
        return [_b ? 0 : 1, _a, distance];
      });
      var nearbtPts = x.filter(function (d) {
        if (d[0] == 0) {
          return d;
        }
      });

      if (nearbtPts.length > 1) {
        var rank = {
          marker: 0,
          //for normal data, rank is 1
          levelMarker: 2
        };
        var sorted = nearbtPts.sort(function (a, b) {
          if (_needRect2PtDist) {
            /*
            sort by distance calculated above
            For multi clustered bar chart, to avoid overlapping of bounds,
            we need to calculate by minimum distance between bar and mouse
             */
            return d3_ascending(a[2], b[2]);
          } else {
            var rank_p0 = rank[a[1].type] || 1,
              rank_p1 = rank[b[1].type] || 1;
            return rank_p0 == rank_p1 ? -1 : d3_ascending(rank_p0, rank_p1);
          }
        });
        point = sorted[0][1];
        return point;
      } else if (nearbtPts.length) {
        point = nearbtPts[0][1];
        return point;
      }

      return NULL$1;
    }

    function getBound(point) {
      var x = point._x,y = point._y,width = point._width,height = point._height,centric = point._centric;

      if (centric) {
        return { x: x - width / 2, y: y - height / 2, width: width, height: height };
      }
      return { x: x, y: y, width: width, height: height };
    }

    function getExtendedBound(rect, extendedDist) {
      var x = (rect.x || 0) - extendedDist,
        y = (rect.y || 0) - extendedDist,
        width = rect.width + 2 * extendedDist,
        height = rect.height + 2 * extendedDist;

      return { x: x, y: y, width: width, height: height };
    }

    function needRect2PtDistCalc(chart) {
      if (chart) {
        return (
          chart.dataObject.noofBarEnabledSeries &&
          chart.dataObject.noofBarEnabledSeries > 1 &&
          chart.chartTypes[0].name != 'bullet' && chart.chartTypes[0].name != 'heatmap');

      }
      return null;
    }

    function supportedExtendedBound(chart) {
      if (chart) {
        return chart.dataObject.noofBarEnabledSeries && chart.chartTypes[0].name != 'bullet' && chart.chartTypes[0].name != 'heatmap';
      }
      return null;
    }
    function _barPointSelection(point, mouse) {
      var rect = getBound(point),
        _mouse = getRotatedMouse(mouse, { x: point._x, y: point._y, rotation: point._rotation }),
        _b = pointInRectangle(_mouse.x, _mouse.y, rect);
      return _b;
    }

    function getPolygonPoints(data, point) {
      var prevpt,
        curpt,
        nextpt,
        prevBasept,
        curBasept,
        nextBasept,
        points = [];
      var itemIndex = defined(point.counter) ? point.counter : point.itemIndex,
        first = itemIndex == 0,
        last = itemIndex == data.length - 1,
        empty = [0, 0],
        current = point._data(),
        previous = first ? empty : data[itemIndex - 1]._data(),
        next = last ? empty : data[itemIndex + 1]._data();

      /*
      For area chart with null data points, we will break the data and show as different polygons.
      Hence we will check case for previous and next null data points. Construct polygon based on that.
      For normal data, polygon structure will be like, mid(prev, cur) -> cur -> mid(cur, next) and form the base data similarly.
      If previous is null point, then polygon will be like, cur -> mid(cur, next) . hence we will assign prev point to cur point
      If next is null point, then polygon will be like, mid(prev, cur) -> cur,. hence we will assign next point to cur point
        For stacked area with Previous or Next point is DUMMY, we need not find mid value. We will connect with previous point itself (dummy).
       */


      var isNull_current = !current._defined,
        isNull_previous = first ? true : !previous._defined,
        isNull_next = last ? true : !next._defined;

      var isDummy_previous = previous.isDummy,
        isDummy_next = next.isDummy;

      curpt = isNull_current ? empty : getPoint(current);
      prevpt = first ? empty : isNull_previous ? curpt : getPoint(previous);
      nextpt = last ? empty : isNull_next ? curpt : getPoint(next);

      curBasept = isNull_current ? empty : getBasePoint(current);
      prevBasept = first ? empty : isNull_previous ? curBasept : isDummy_previous ? prevpt : getBasePoint(previous);
      nextBasept = last ? empty : isNull_next ? curBasept : isDummy_next ? nextpt : getBasePoint(next);

      var prevCur = first ? empty : isNull_previous || isDummy_previous ? prevpt : getMidPoint(prevpt, curpt);
      var curNext = last ? empty : isNull_next || isDummy_next ? nextpt : getMidPoint(nextpt, curpt);

      var prevbaseCur = first ? empty : isNull_previous || isDummy_previous ? prevBasept : getMidPoint(prevBasept, curBasept);
      var curbaseNext = last ? empty : isNull_next || isDummy_next ? nextBasept : getMidPoint(nextBasept, curBasept);

      var temp =
      isNull_previous && isNull_next ?
      points.push(curpt) :
      first || isNull_previous ?
      points.push(curpt, curNext, curbaseNext, curBasept) :
      last || isNull_next ?
      points.push(prevCur, curpt, curBasept, prevbaseCur) :
      points.push(prevCur, curpt, curNext, curbaseNext, curBasept, prevbaseCur);
      return {
        points: points,
        prevCur: prevCur,
        curNext: curNext,
        curpt: curpt
      };
    }
    function getPoint(point) {
      return [point._x, point._y];
    }
    function getBasePoint(point) {
      return [point._x0, point._y0];
    }
    function getMidPoint(point1, point2) {
      return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];
    }

    function getAbstractPolyPoints(points) {
      var poly = [];
      points.filter(function (d) {
        var data = d._data();
        if (d._defined) {
          poly.push([d._x, d._y]);
        }
      });
      return poly;
    }

    //

    function segmentSelection(points, mouse, chart, key) {
      var doRadiusSearch = chart.cache.search.bisect,
        points_scatter = doRadiusSearch ? points : points,
        mindist,
        point;
      if (!points_scatter) {
        return;
      }
      mouse = [mouse.x, mouse.y];
      points_scatter.map(function (p) {
        mindist = chart.eventHandler.dataAccesor().radius(key);

        var renderer = chart.renderer[p.seriesIndex],
          // bbox = renderer.getSymbolBBox(p),
          // segments = segmentsForSymbol(p, chart, bbox),
          segments =
          p.type === 'zc-marker' ?
          isObjectPropDefined(chart.cache, "parser.".concat([p.__key], "._highlighter"), true).getSegments(p) :
          renderer.getSegments(p);
        if (segments) {
          segments.map(function (s) {
            var dist = s ? distToSegment(mouse, s[0], s[1]) : mathSQRT(dist2(mouse, [p._x, p._y]));
            if (dist < mindist || mindist == null) {
              mindist = dist;
              point = p;
            }
          });
        } else {
          var dist = dist2(mouse, [p._x, p._y]);
          if (dist < mindist || mindist == null) {
            mindist = dist;
            point = p;
          }

        }

      });
      return point;
    }

    function distToSegment(p, v, w) {
      return mathSQRT(distToSegmentSquared(p, v, w));
    }
    function distToSegmentSquared(p, v, w) {
      var l2 = dist2(v, w);
      if (l2 === 0) {
        return dist2(p, v);
      }
      var t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;
      if (t < 0) {
        return dist2(p, v);
      }
      if (t > 1) {
        return dist2(p, w);
      }
      return dist2(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);
    }
    function sqr(x) {
      return x * x;
    }

    function dist2(v, w) {
      return sqr(v[0] - w[0]) + sqr(v[1] - w[1]);
    }

    function areaSelection(points, mouse, chart, key) {
      var renderer = chart.renderer,
        dataObject = chart.dataObject,
        dataset = chart.dataset,
        dataProcessorHelpers = DataProcessor.helpers,
        getParsedYAxisOrder = dataProcessorHelpers.getParsedYAxisOrder,
        mouse = [mouse.x, mouse.y];
      var point;
      var dist, mindist;

      var pointDetails = points.map(function (p) {
        var rendererIndex = p.rendererIndex,
          seriesIndex = p.seriesIndex,
          subseriesIndex = p.subSeriesIndex,
          itemIndex = p.itemIndex,
          chartType = getChartTypeByIndex(chart, p.paneid, seriesIndex),
          renderer = chart.renderer[rendererIndex],
          data = renderer ? renderer.seriesdataAfterUpdate[subseriesIndex] : points,
          polygonPoints = p._polydata(),
          isWithinPoly = d3_polygonContains(polygonPoints.points, mouse);

        if (chartType.name === SANKEY_CHARTNAME) {
          if (isWithinPoly) {
            dist = dataset.getZ(p);
            if (dist < mindist || mindist == null) {
              mindist = dist;
              point = p;
            }
          }
        } else {
          if (isWithinPoly) {
            dist =
            itemIndex == 0 ?
            distToSegment(mouse, polygonPoints.curpt, polygonPoints.curNext) :
            itemIndex == data.length - 1 ?
            distToSegment(mouse, polygonPoints.prevCur, polygonPoints.curpt) :
            d3_min([
            distToSegment(mouse, polygonPoints.prevCur, polygonPoints.curpt),
            distToSegment(mouse, polygonPoints.curpt, polygonPoints.curNext)]);


            if (dist < mindist || mindist == null) {
              mindist = dist;
              point = p;
            }
          } else if ((data.length == 1 || polygonPoints.points.length == 1) && p._defined) {
            dist = dist2(mouse, polygonPoints.curpt);
            if ((dist <= mindist || mindist == null) && dist < getTriggeringOffset(chart, charttype.line)) {
              mindist = dist;
              point = p;
            }
          }
        }
      });

      if (!point) {
        point = ScatterSelection(points, { x: mouse[0], y: mouse[1] }, chart, 'web');
      }
      return point;
    }

    function LineHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
      // extend(LineHighlighter.prototype, ScatterHighlighter.prototype);
    }
    inherit(LineHighlighter, ScatterHighlighter);
    var proto$5 = LineHighlighter.prototype;

    proto$5.options = function (point) {
      var rp = this.renderer.commonRendererProp().params,
        commonOptions = _super(this).commonOptions.call(this, point),
        symbol = commonOptions.symbol,
        size = commonOptions._size || rp.gvp('strokeWidth');

      commonOptions.size = {
        outer: size * 0.9,
        inner: size * 0.4
      };

      return commonOptions;
    };

    function AreaHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
      return this;

      // extend(AreaHighlighter.prototype, LineHighlighter().prototype);
    }
    inherit(AreaHighlighter, ScatterHighlighter);
    var proto$6 = AreaHighlighter.prototype;

    proto$6._defaultH = function () {var _this21 = this;
      var defaultH = [
      {
        shape: 'marker',
        path: _super(this).path,
        data: _super(this).data,
        context: _super(this).renderingContext,
        translate: _super(this).translateContext
      },
      {
        shape: 'poly',
        path: this.path,
        data: this.data,
        context: this.renderingContext,
        translate: _super(this).translateContext,
        styles: function styles(point) {
          return patternFillEffect.call(_this21, point, 'inherit');
        }
      }];

      if (this.renderer.commonRendererProp().params.isRangeChart) {
        defaultH.push({
          shape: 'marker',
          path: _super(this).path,
          data: _super(this).data,
          context: _super(this).renderingContext,
          translate: _super(this).translateContext,
          type: 'end'
        });
      }
      return defaultH;
    };

    proto$6.data = function (point) {
      var rp = this.renderer.commonRendererProp().params;
      var chart = this.chart,
        renderer = this.renderer,
        axisrotated = rp.axisrotated,
        stacked = rp.stacked,
        layout = renderer.layout[point.subSeriesIndex],
        x = axisrotated ? layout.x1() : layout.x(),
        y = axisrotated ? layout.y() : layout.y1(),
        x0 = axisrotated ? layout.x0() : layout.x(),
        y0 = axisrotated ? layout.y() : layout.y0(),
        isDefined = layout.defined();
      point._polydata = this.poly(point);

      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key],
          itemIndex = defined(point.counter) ? point.counter : point.itemIndex;

        cache._x = point._x = cache._x || x(point, itemIndex);
        cache._y = point._y = cache._y || y(point, itemIndex);
        cache._x0 = point._x0 = cache._x0 || x0(point, itemIndex);
        cache._y0 = point._y0 = cache._y0 || y0(point, itemIndex);
        cache._uid = point._uid = chart.dataset.getX(point);
        cache._defined = point._defined = defined(cache._defined) ? cache._defined : isDefined(point);
        cache._visible = point._visible = isPointVisible(chart, point) && (stacked ? !point.isDummy : true);
        cache._point = point;
        return point;
      };
    };

    proto$6.poly = function (point) {
      var chart = this.chart,
        renderer = this.renderer;
      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key],
          flatten = renderer.seriesdataAfterUpdate[point.subSeriesIndex];

        cache._poly = point._poly = cache._poly || getPolygonPoints(flatten, point);
        return point._poly;
      };
    };

    proto$6.options = function (point) {
      var rp = this.renderer.commonRendererProp().params,
        commonOptions = _super(this).commonOptions.call(this, point),
        symbol = commonOptions.symbol,
        size = commonOptions._size || rp.gvp('strokeWidth'),
        interpolation = rp.gvp('mode'),
        fillopacity = rp.hoverOptions.fillOpacity || 0.2;

      commonOptions.size = {
        outer: size * 0.9,
        inner: size * 0.4
      };
      commonOptions.fillopacity = fillopacity;
      commonOptions.interpolation = interpolation;

      return commonOptions;
    };

    proto$6.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('area').call(this, this.chart);
    };

    proto$6.path = function (point, model) {
      point = point._data();
      var options = this.options(point),
        poly = this.poly(point)(),
        axisrotated = this.chart.axes.rotated,
        context = model.context.call(this),
        pathContext,
        rp = this.renderer.commonRendererProp().params,
        area = this.renderer.layout[point.subSeriesIndex];
      area.context(NULL$1);
      context.style('display', '').attr('transform', "translate(".concat(this.chart.plotarea.left, ",").concat(this.chart.plotarea.top, ")"));

      if (options.interpolation == 'linear') {
        var polyPoints = d3_merge(poly.points);
        pathContext = appendEle(context, 'polygon', [poly], '.', 'class', "highlight".concat(point.paneid).concat(point.seriesIndex));
        pathContext.attr('points', polyPoints.toString()).styles({
          'fill-opacity': options.fillopacity || 0.2,
          display: ''
        });
      } else {
        var points = poly.points;
        var x0 = d3_min(points, function (d) {return d[0];}),
          x1 = d3_max(points, function (d) {return d[0];}),
          y0 = d3_min(points, function (d) {return d[1];}),
          y1 = d3_max(points, function (d) {return d[1];});

        var x = x0,
          y = 0,
          w = x1 - x0,
          h = this.chart.plotarea.height;
        if (rp.axisrotated) {
          x = 0, y = y0, w = this.chart.plotarea.width, h = y1 - y0;
        }
        var properties = {
            name: 'rect',
            id: this.chart.id,
            x: x + ((axisrotated ? 0 : this.chart.scrolledX) || 0),
            y: y + ((axisrotated ? 0 : this.chart.scrolledY) || 0),
            width: w,
            height: h
          },
          args = {
            chartObj: this.chart
          };
        var clipID = effects.get(effects.svg_clips, 'rect', properties, args);

        pathContext = appendEle(context, 'path', [1], '.', 'class', "highlight".concat(point.paneid).concat(point.seriesIndex));
        pathContext.
        datum(this.renderer.seriesdataAfterUpdate[point.subSeriesIndex]).
        attr('d', area).
        attr('stroke', '').
        attr('clip-path', "url(".concat(this.chart.defsLocation, "#").concat(clipID, ")")).
        styles({
          'fill-opacity': options.fillopacity,
          display: ''
        });
      }
      return pathContext;
    };

    function BubbleHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
      // extend(BubbleHighlighter.prototype, ScatterHighlighter.prototype);
    }
    inherit(BubbleHighlighter, ScatterHighlighter);
    var proto$7 = BubbleHighlighter.prototype;

    proto$7.options = function (point) {
      var _options = _super(this).options.call(this, point);
      return {
        options: _options.options,
        color: _options.color,
        symbol: _options.symbol,
        size: {
          outer: (point._size + perToPx('2.5%', mathMin(this.chart.plotarea.width, this.chart.plotarea.height))) * 0.1,
          inner: point._size / 2 * 0.1
        }
      };
    };

    function BubblepieHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
      // extend(BubblepieHighlighter.prototype, ScatterHighlighter.prototype);
    }
    inherit(BubblepieHighlighter, BubbleHighlighter);
    var proto$8 = BubblepieHighlighter.prototype;

    proto$8.data = function (point) {
      var rp = this.renderer.commonRendererProp().params;
      var chart = this.chart,
        _d = _super(this).data.call(this, point);

      return function () {
        var cache = _d(),
          xIndex = chart.dataset.getX(point),
          key = bubblepieUtils.getKey(NULL$1, NULL$1, NULL$1, [xIndex, point[1]]),
          pieRenderer = chart.subrenderer[point.subSeriesIndex][key];

        var angles = pieRenderer.data.map(function (piePoint) {
          var pieDataPoint = piePoint.data,
            pieAngle = getBubblePieAngle(chart, pieDataPoint.seriesIndex, pieDataPoint.subSeriesIndex, pieDataPoint);
        });
        cache._angles = point._angles = angles;
        cache._visible = point._visible = isPointVisible(chart, point);
        cache._uid = point._uid = chart.dataset.getX(point);
        return point;
      };
    };

    //$Id$

    /**
     *
     * @returns {chart} bubblePie.
     */
    /*
     PENDING :
     -------
     1) Total datalabel
     2) Annotation at centre / on arc?
     */
    svg_plot_renderer.bubblepie = function () {
      var shiftInfo,
        commonRendererProp,
        subRenderers;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params,
            chartObj = rp.chartObj,
            index = rp.datasetIndex,
            commonPlotOptions = rp.commonPlotOptions,
            axisrotated = rp.axisrotated,
            stacked = rp.stacked,
            xscale = rp.xscale,
            yscale = rp.yscale,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            labelQueue = rp.labelQueue,
            renderingOrder = rp.renderingOrderIndex,
            bound = rp.bound,_rp$rendererIndex2 = rp.rendererIndex,rendererIndex = _rp$rendererIndex2 === void 0 ? index : _rp$rendererIndex2,
            container = d3_select(this),
            currentdata = data[index],
            data_bind = { data: currentdata, index: renderingOrder },
            plotoptions = currentdata.plotoptions;

          renderer_helpers.saveSeriesdataInRenderer(chartObj, index, rendererIndex);
          if (index !== chartObj.bubblePieRendererIndex) {
            chart.chartRendered = true;
            return;
          }

          subRenderers = [];
          chart.subrenderer = chart.subrenderer || [];
          if (!isFacet(chartObj)) {
            chartObj.subrenderer = chart.subrenderer;
          }

          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, BUBBLEPIE_CHARTNAME);
          var transitionDuration = animationOptions.duration;
          commonRendererProp.params.hoverOptions =
          plotoptions && plotoptions.hoverOptions ?
          mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
          commonPlotOptions.hoveroptions;

          var pieRenderer = chart.subrenderer, // TODO: check
            paneid = isFacet(chartObj) ? "".concat(currentdata.row, "_").concat(currentdata.column) : null,
            chartTypeObj = getChartTypeByIndex(chartObj, paneid, index),
            isBubblepie = !arrayIncludes(chartcategory.nonaxis, chartTypeObj.value),
            dataIndex = isBubblepie ? validateNullVal(commonPlotOptions.dataindex, 3) : chartObj.dataset.yidx(yaxiscolumnorder),
            pieData = chartObj.dataObject.processBubblePieData(data, { dataIndex: dataIndex }),
            labelIndex = -1;

          if (chartObj.renderVisiblePointsOnly) {
            // #ZC2073
            var dataUpdate = DataProcessor.helpers.filterPointsInViewport(chartObj, pieData[0], 'bubblepie', 'xy', index);
            pieData = [dataUpdate];
          }

          var series = appendEle(container, 'g', pieData ? [data_bind] : [], '.', 'class', 'scatterseries');
          if (pieData) {
            pieData.forEach(function (piedatum, ssi) {
              pieRenderer[ssi] = pieRenderer[ssi] || {};
              var dataKeyFunc = function dataKeyFunc(d) {
                  var dt = d.reference;
                  return bubblepieUtils.getKey(NULL$1, NULL$1, chartObj, [d.x, d.y]); //#ZC1323
                },
                _data = bubblepieUtils.filterBySum(piedatum, dataIndex);

              //ZC2763
              _data = _data.filter(function (_d) {
                var dt = _d.reference,
                  x = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, dt, 'x'),
                  y = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, dt, 'y');

                return !isNaN(x) && !isNaN(y);
              });

              if (isFacet(chartObj)) {
                _data.forEach(function (_d) {
                  _d.row = currentdata.row;
                  _d.column = currentdata.column;
                });
              }

              var subseries = appendEle(series, 'g', [1], '.', 'class', "subseries_".concat(ssi));
              var _class = hasColorColumnInNonAxis(chartObj) ? 'zc_nonaxis' : 'scatter',
                g = appendEle(subseries, 'g', _data, '.', 'class', _class, NULL$1, dataKeyFunc);

              g.each(function (d, i) {
                var dt = d.reference, //First reference data for the position
                  key = bubblepieUtils.getKey(NULL$1, NULL$1, chartObj, [d.x, d.y]),
                  x = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, dt, 'x') || 0,
                  y = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, dt, 'y') || 0,
                  size = isBubblepie ?
                  chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  dt,
                  'z',
                  chartObj.zscale) :

                  mathMin(bound.width, bound.height, xscale.bandwidth ? xscale.bandwidth() : 1),
                  rendererName = isBubblepie ? 'pie' : chartTypeObj.name,
                  translate = isBubblepie ?
                  [x - size / 2, y - size / 2] :
                  chartObj.axes.rotated ?
                  [bound.width / 2 - size / 2, y - size / 2 - bound.y] :
                  [x - size / 2 - bound.x, bound.height / 2 - size / 2];

                pieRenderer[ssi][key] = (pieRenderer[ssi][key] || svg_plot_renderer[rendererName]()).
                commonRendererProp(commonRendererProp).
                plotarea({
                  width: size,
                  height: size,
                  left: x - size / 2,
                  top: y - size / 2,
                  translate: translate
                });
                pieRenderer[ssi][key].chartRendered = false;
                pieRenderer[ssi][key].subSeriesIndex = ++labelIndex;
                subRenderers.push(pieRenderer[ssi][key]);

                d3_select(this).
                attr('transform', "translate(".concat(translate[0], ",").concat(translate[1], ")")).
                call(pieRenderer[ssi][key]);
              });
            });
          }

          function getSymbolSize(d) {
            return chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'z', chartObj.zscale);
          }
          chart.getSymbolSize = getSymbolSize;

          if (isBubblepie) {
            chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
              chart.chartRendered = true;

              var seriesData = chartObj.seriesdata;
              seriesData.forEach(function (d, i) {
                var chartType = getChartTypeByIndex(chartObj, paneid, i).value;
                if (!chartcategory.bubblePie.has(chartType)) {
                  // For combinational chart
                  return;
                }

                var renderer = chartObj.renderer[i];
                labelQueue.push({
                  renderer: renderer,
                  charttype: SCATTER_CHARTNAME,
                  chartObj: chartObj,
                  args: [d, i]
                });
                labelQueue.push({
                  renderer: renderer,
                  charttype: 'pieInnerLabels',
                  chartObj: chartObj,
                  args: [seriesData, i, pieData]
                });
              });
            }, transitionDuration);
          }
        });
        return chart;
      }
      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          chart.highlighter = new BubbleHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };
      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };

      chart.endFunctions = function () {
        if (subRenderers.every(function (_) {return _.chartRendered;})) {
          chart.chartRendered = true;
        }
      };

      return chart;
    };

    /**
     *
     * @param chartInstance
     * @param seriesIndex
     * @param subSeriesIndex
     * @param point
     * @return {null|{start: *, end: *}}
     */
    function getBubblePieAngle(chartInstance, seriesIndex, subSeriesIndex, point) {
      var key = bubblepieUtils.getKey(point, seriesIndex, chartInstance),
        pieRenderer = chartInstance.subrenderer[subSeriesIndex][key];

      if (!pieRenderer) {
        //ZC1498
        return null;
      }

      return {
        start: pieRenderer.data[seriesIndex].startAngle,
        end: pieRenderer.data[seriesIndex].endAngle
      };
    }

    function bubblePieSelection(points, mouse, chart, key) {
      var point = bubbleSelection(points, mouse, chart, key),
        key,
        pieRenderer,
        bubblePiePoint = null;

      if (point) {
        var type = point.type || chart.chartTypes[point.seriesIndex].name;
        if (type != 'bubblepie' && type != 'geobubblepie') {
          //consider for threshold
          return point;
        }
        key = bubblepieUtils.getKey(point, point.seriesIndex, chart);
        pieRenderer = chart.subrenderer[point.subSeriesIndex][key];

        if (!pieRenderer) {
          return false;
        }

        pieRenderer.data.some(function (piePoint) {
          if (piePoint.data.disabled || piePoint.data.dummy) {
            return false;
          }

          var pieDataPoint = piePoint.data,
            pieAngle = getBubblePieAngle(chart, pieDataPoint.seriesIndex, pieDataPoint.subSeriesIndex, pieDataPoint),
            pointAngle = mathAtan2(mouse.x - pieDataPoint._x, -(mouse.y - pieDataPoint._y)),
            pointFound = pieAngle && isAngleInside(pieAngle.start, pieAngle.end, pointAngle);

          if (pointFound) {
            bubblePiePoint = pieDataPoint;
          }

          return pointFound;
        });

        if (bubblePiePoint && (!chart.hasColorScale || chart.hasColorScale && isDataActive(bubblePiePoint, chart))) {
          return bubblePiePoint;
        }
      }
      return null;
    }

    function boxplotSelection(points, mouse, chart) {
      var points_trans = points.map(function (d, i) {
        var renderer = chart.renderer[d.seriesIndex],
          highlighter = renderer.highlighter,
          box = highlighter.box(d);
        return box;
      });
      var selectedPoint = barSelection(points_trans, mouse, chart);
      if (!selectedPoint) {
        return NULL$1;
      }
      var datapoint = selectedPoint._point, //actual datapoint
        renderer = chart.renderer[datapoint.seriesIndex],
        highlighter = renderer.highlighter,
        levels = highlighter.levels(datapoint);
      if (!levels) {
        return selectedPoint._point;
      }
      var selectedPoint1 = barSelection(levels, mouse, chart);
      selectedPoint1._point.subtype = selectedPoint1.type;
      return selectedPoint1._point;
    }

    function barWithSegmentSelection(points, mouse, chart) {
      var selectedPoint_bar = barSelection(points, mouse, chart);
      var points_trans = points.map(function (d, i) {
        var renderer = chart.renderer[d.seriesIndex],
          highlighter = renderer.highlighter,
          box = highlighter.box(d);
        return box;
      });
      var selectedPoint = barSelection(points_trans, mouse, chart);
      if (!selectedPoint) {
        return NULL$1;
      }

      var datapoint = selectedPoint._point, //actual datapoint
        selectedPoint1 = segmentSelection([datapoint], mouse, chart, 'bar_segment');
      var selected = selectedPoint1 || selectedPoint_bar;
      if (!selected) {
        return null;
      }
      var oldSelectedType = selected && selected._type;
      if (selectedPoint1) {
        selectedPoint1._type = 'segment';
      } else if (selectedPoint_bar) {
        selectedPoint_bar._type = '';
      }
      if (selected._type !== oldSelectedType) {
        selected.selected = null;
      }
      // selectedPoint1._point.subtype = selectedPoint1.type;
      return selectedPoint1 || selectedPoint_bar;
    }

    function TreemapSelection(points, mouse, chart, key) {
      if (!points) {
        return;
      }

      return barSelection(points, mouse);
    }

    //$Id$

    var wordCloudUtils = {};

    /**
     * @param {Array} d
     * @return {Number} seriesIndex
     */
    wordCloudUtils.getSeriesIndex = function (d) {
      return d.seriesIndex;
    };

    /**
     * @param {Array} d
     * @return {Number} itemIndex
     */
    wordCloudUtils.getItemIndex = function (d) {
      return d.itemIndex;
    };

    /**
     * @param {object} obj
     * @return {Number} dy
     */
    wordCloudUtils.getDy = function (obj) {
      return wordCloudUtils.isMultiLine(obj) ? 0.9 : 0.35;
    };

    /**
     * @param {object} obj
     * @return {Boolean} isMultiLine
     */
    wordCloudUtils.isMultiLine = function (obj) {
      return (obj.nodeList ? obj.nodeList.format : obj.format).multiLine;
    };

    /**
     * @param {object} layout
     * @param {object} datalabelOptions
     * @param {object} commonPlotOptions
     * @param {object} chartObj
     * @return {object} {x, y, width, heihgt, r}
     */
    wordCloudUtils.getBoundBoxSize = function (layout, datalabelOptions, commonPlotOptions, chartObj, layoutObj) {
      var boundboxOptions = getMergedBoundBoxOptions(datalabelOptions, chartObj),
        padding = (validateNullVal(commonPlotOptions.padding, 2) + getBoundBoxStrokeWidth(datalabelOptions, chartObj)) / 2,
        scaleFactor = layoutObj.output.scaleFactor,
        fontScaleFactor = layoutObj.isScalable ? 1 : scaleFactor;

      return {
        x: layout.x * fontScaleFactor - layout.width / 2 * fontScaleFactor + padding,
        y:
        layout.y * fontScaleFactor -
        layout.height / 2 * fontScaleFactor +
        padding + (
        wordCloudUtils.isMultiLine(layout) ?
        layout.size * fontScaleFactor * wordCloudUtils.getDy(layout) - layout.height / 2 * fontScaleFactor :
        0),
        width: layout.width * fontScaleFactor - 2 * padding,
        height: layout.height * fontScaleFactor - 2 * padding,
        r: chartObj.dataObject.getTransRectValue('radius', NULL$1, NULL$1, NULL$1, NULL$1, boundboxOptions.radius)
      };
    };

    /**
     * @param {Object} layoutObj
     * @param {Object} dimension
     * @return {Object} {translate, scale}
     */
    wordCloudUtils.getContainerTransformation = function (layoutObj, dimension) {
      var scaleFactor = layoutObj.output.scaleFactor,
        x = dimension.x - dimension.width * (scaleFactor - 1) / 2,
        y = dimension.y - dimension.height * (scaleFactor - 1) / 2;

      return {
        translate: [x, y],
        scale: layoutObj.isScalable ? scaleFactor : 1
      };
    };

    /**
     * @param  {Object} d
     * @return {Boolean}
     */
    wordCloudUtils.hasBoundBox = function (d) {
      var innerSVG = isObjectPropDefined(d, 'layout.nodeList.innerSVG', true);
      return d.layout.size && !(isUndefined(innerSVG) || innerSVG === '');
    };

    //

    function WordCloudSelection(points, mouse, chart, key) {
      if (!points || !points.length) {
        // FEATURES_COMBOPIVOT_4
        // In wordcloud grid - throws error while hovering on the plot not on words
        return;
      }

      var relmousePt = _objectSpread({}, mouse),
        renderer = chart.renderer[getRendererIndex(points[0], chart)],
        layoutObj = renderer.layout,
        bound = renderer.commonRendererProp().bound(),
        scaleFactor = layoutObj.output.scaleFactor,
        dimension = layoutObj.dimension,
        transformation = wordCloudUtils.getContainerTransformation(layoutObj, dimension);

      relmousePt.x -= transformation.translate[0];
      relmousePt.y -= transformation.translate[1];
      relmousePt.x -= bound.x;
      relmousePt.y -= bound.y;

      points = points.filter(function (d) {
        var layout = d.layout,
          x = layout.x * scaleFactor,
          y = layout.y * scaleFactor,
          w = layout.width * scaleFactor,
          h = layout.height * scaleFactor,
          curPt = {
            x: x - w / 2,
            y: y - h / 2,
            width: w,
            height: h
          },
          rotatedPt = geometryUtils.rotatePoint(relmousePt, layout.rotation, { x: x, y: y });

        return geometryUtils.pointInRectangle(layout.rotation % mathPI ? rotatedPt : relmousePt, curPt);
      });

      if (points.length <= 1) {
        return points[0];
      }

      points = points.filter(function (d) {
        var layout = d.layout,
          tightBound = layout.tightBound,
          x = layout.x * scaleFactor,
          y = layout.y * scaleFactor,
          w = tightBound.width * scaleFactor,
          h = tightBound.height * scaleFactor,
          curPt = {
            x: x - (layout.width * scaleFactor / 2 - tightBound.x * scaleFactor),
            y: y - (layout.height * scaleFactor / 2 - tightBound.y * scaleFactor),
            width: w,
            height: h
          },
          originX = layout.x * scaleFactor,
          originY = layout.y * scaleFactor,
          rotatedPt = geometryUtils.rotatePoint(relmousePt, layout.rotation, { x: originX, y: originY });

        return geometryUtils.pointInRectangle(layout.rotation % mathPI ? rotatedPt : relmousePt, curPt);
      });

      if (points.length <= 1) {
        return points[0];
      }

      var onWord = null;
      points.some(function (d) {
        var layout = d.layout,
          x = layout.x * scaleFactor,
          y = layout.y * scaleFactor,
          w = layout.width * scaleFactor,
          h = layout.height * scaleFactor;

        if (!layout.scaledPolygon) {
          layout.scaledPolygon = layout.polygon.map(function (_) {return [x - w / 2 + _[0] * scaleFactor, y - h / 2 + _[1] * scaleFactor];});
        }

        var polygon = layout.scaledPolygon,
          condition = polygon.some(function (_) {return mathAbs(_[0] - parseInt(relmousePt.x)) <= 5 && mathAbs(_[1] - parseInt(relmousePt.y)) <= 5;});

        if (condition) {
          onWord = d;
        }

        return condition;
      });

      if (onWord) {
        return onWord;
      }

      points = points.sort(function (a, b) {return d3_ascending(a.layout.size, b.layout.size);});

      return points[0];
    }

    var SELECTION_TOOL = d3_map();
    var availableModes = [
    POLY_TYPES,
    PATH_TYPES,
    BISECT_NORM_TYPES,
    BISECT_LEVEL_TYPES,
    BISECT_SEGMENT_TYPES,
    QUADTREE_NORM_TYPES,
    QUADTREE_SIZE_TYPES,
    QUADTREE_PIE_TYPES,
    QUADTREE_BOUND_TYPES,
    QUADTREE_TEXT_TYPES,
    SEGMENT_TYPES];

    var matchers = [
    'POLY_TYPES',
    'PATH_TYPES',
    'BISECT_NORM_TYPES',
    'BISECT_LEVEL_TYPES',
    'BISECT_SEGMENT_TYPES',
    'QUADTREE_NORM_TYPES',
    'QUADTREE_SIZE_TYPES',
    'QUADTREE_PIE_TYPES',
    'QUADTREE_BOUND_TYPES',
    'QUADTREE_TEXT_TYPES',
    'SEGMENT_TYPES'];


    SELECTION_TOOL.set('POLY_TYPES', areaSelection);
    SELECTION_TOOL.set('PATH_TYPES', areaSelection);
    SELECTION_TOOL.set('BISECT_NORM_TYPES', barSelection);
    SELECTION_TOOL.set('BISECT_LEVEL_TYPES', boxplotSelection);
    SELECTION_TOOL.set('BISECT_SEGMENT_TYPES', barWithSegmentSelection);
    SELECTION_TOOL.set('QUADTREE_NORM_TYPES', ScatterSelection);
    SELECTION_TOOL.set('QUADTREE_SIZE_TYPES', bubbleSelection);
    SELECTION_TOOL.set('QUADTREE_PIE_TYPES', bubblePieSelection);
    SELECTION_TOOL.set('QUADTREE_BOUND_TYPES', TreemapSelection);
    SELECTION_TOOL.set('QUADTREE_TEXT_TYPES', WordCloudSelection);
    SELECTION_TOOL.set('QUADTREE_TYPES', bubblePieSelection);
    SELECTION_TOOL.set('SEGMENT_TYPES', segmentSelection);

    function getSelectionTool(type) {
      var tool;
      availableModes.some(function (d, i) {
        if (d.has(type)) {
          tool = SELECTION_TOOL.get(matchers[i]);
          return true;
        }
      });
      return tool;
    }

    /**
     *
     * @param nodes
     * @constructor
     */
    function PathSearch(nodes) {
      PolySearch.call(this, nodes);
    }

    inherit(PathSearch, PolySearch);

    /**
     *
     * @param point
     * @return {*}
     */
    PathSearch.prototype.getPoly = function (point) {
      // define the point type as path
      point._setPolygonType('path');

      // then call the super method
      return _super(this).getPoly(point);
    };

    function getNearestPoint(data, mouse, isDefaultBisect, accessor) {
      //data contains array of objects with different keys of different series data
      var keys = data.keys(),
        //Group output points by similar search mode
        selected = {},
        nearby = [],
        dependents;
      keys.map(function (key) {
        //Get object by key. Here key refers different chart types / marks
        var d = data.get(key),
          super_key = d.superKey || key,
          bisect = accessor.isBisectMode(key, isDefaultBisect),
          // Group different series of data under same mark into array
          a = objectToArray(
          d,
          function (d0) {
            return !d0.disabled();
          },
          accessor.spliceIndices()),

          //Find search tool
          mode = getSearchMode$1(super_key, bisect),
          //Nearby points surrounded by radius from mouse
          encloseby = getEnclosedPoints(a, key, mouse, mode, accessor);

        //From enclosed array of points, find single
        //closest point by using respective selection tools
        if (encloseby) {
          nearby = nearby.concat(encloseby);

          var s = getSelectionTool(super_key),
            //get closest single point
            p = s(encloseby, mouse, accessor.chart, key),
            //Find moder irrespective of shared criteria
            m = getSearchMode$1(super_key, false);
          if (p && (isArray$1(p) && p.length || isObject(p))) {
            if (selected[m]) {
              selected[m].push(p);
            } else {
              selected[m] = [p];
            }
          }
        }
      });

      var p0 = getNearestPointBySameMode(selected, mouse, accessor),
        nearest = getNearestPointByPriority(p0, accessor);

      if (nearest) {
        nearest = accessor.pointLiesInsidePlot(nearest) ? nearest : null;
      }
      // if the point is dependant type
      if (nearest && accessor.hasDependantPoints()) {
        dependents = getDependantPoints(nearest, accessor);
      }

      var point = { nearest: nearest, nearby: nearby, dependents: dependents },
        userSelection = accessor.userSelection;

      if (userSelection) {
        point = invokeFunction(userSelection, point, accessor.chart) || point;
      }

      return point;
    }

    /**
     *
     * @param point
     * @param accessor
     * @return {*[]}
     */
    function getDependantPoints(point, accessor) {
      var type = getPointType(point, accessor),
        chartModel = getChartModel(type),
        seriesIndex = point.seriesIndex,
        renderer = accessor.chart.renderer[seriesIndex],
        points;

      if (chartModel === 'FLOW') {
        points = renderer.highlighter.getDependentLayoutPoints(point, true).map(function (d) {return d.point;});
      }

      return points;
    }

    function getEnclosedPoints(data, key, mouse, mode, accessor) {
      var searchCache = accessor.chart.cache.search,
        enclosed,
        tree,
        pane = searchCache.lastPane;

      if (mode == 'QUADTREE') {
        //For Quad tree
        //For quad mode, we need to merge all series of data if its in array form
        var d = data[0] instanceof Array ? d3_merge(data) : data,
          radius = accessor.radius(key),
          sizeOffset = accessor.sizeOffset(key),
          _extent2 = accessor.extent(),
          size = accessor.size(key);
        mouse = accessor.toArray(mouse);
        tree = searchCache["".concat(pane, "_").concat(key, "_").concat(mode)] || new Quadtreesearch(d, size, radius, _extent2, sizeOffset);
        enclosed = tree.find(mouse);
      } else if (mode == 'POLY') {
        //For area charts and polygon highlight
        var _d5 = d3_merge(data);
        tree = searchCache["".concat(pane, "_").concat(key, "_").concat(mode)] || new PolySearch(_d5);
        enclosed = tree.find(mouse);
      } else if (mode === 'PATH') {
        //For area charts and polygon highlight
        var _d6 = d3_merge(data);
        tree = searchCache["".concat(pane, "_").concat(key, "_").concat(mode)] || new PathSearch(_d6);
        enclosed = tree.find(mouse);
      } else {
        //For bisecting data by x scale
        var m = accessor.bisectMode(),
          median = accessor.median();
        tree = searchCache["".concat(pane, "_").concat(key, "_").concat(mode)] || new Bisectsearch(data, m);
        enclosed = tree.find(median, mouse);
      }
      searchCache["".concat(pane, "_").concat(key, "_").concat(mode)] = tree;
      return enclosed;
    }

    function getNearestPointBySameMode(data, mouse, accessor) {
      var p = [];
      for (var mode in data) {
        var d = data[mode];
        if (d.length > 1) {
          var s = SELECTION_TOOL.get("".concat(mode, "_TYPES")),
            key = getFineSearchKey(mode),
            d0 = s(d, mouse, accessor.chart, key, true);
          p.push(d0);
        } else {
          p.push(d[0]);
        }
      }
      return p;
    }

    function getNearestPointByPriority(data, accessor) {
      if (data && data.length == 1) {
        return data[0];
      } else {
        var rank = {
            QUADTREE: function QUADTREE() {return 0;},
            BISECT: function BISECT() {return 1;},
            POLY: function POLY() {return 2;},
            BISECT_QUADTREE: function BISECT_QUADTREE(point) {
              //changed while applying bar trigger offset
              if (accessor.hasSelection(point, 'BISECT_QUADTREE')) {
                return 1;
              } else {
                return 3;
              }
            }
          },
          pointRankType = getPointRankType(data, accessor),
          sorted;

        if (pointRankType === 'SEARCH_MODE') {
          sorted = data.sort(function (p0, p1) {
            if (p0 && (isArray$1(p0) && p0.length || isObject(p0))) {
              var type_p0 = getPointType(p0, accessor),
                mode_p0 = getSearchMode$1(type_p0),
                type_p1 = getPointType(p1, accessor),
                mode_p1 = getSearchMode$1(type_p1);
              return rank[mode_p0](p0) - rank[mode_p1](p1);
            }
          });
        } else if (pointRankType === 'POINT') {
          sorted = data.sort(function (p1, p2) {
            return p1._getRank() - p2._getRank();
          });
        }

        return sorted[0];
      }
    }

    function getPointType(p, accessor) {
      var seriesindex = p.seriesIndex,
        type = p.type || p.searchKey || accessor.chart.chartTypes[seriesindex].name;
      return type;
    }

    /**
     *
     * @param points
     * @param accessor
     * @return {string}
     */
    function getPointRankType(points, accessor) {
      if (isDependentPointHighlightType(accessor.chart)) {
        return 'POINT';
      } else {
        return 'SEARCH_MODE';
      }
    }

    function ZC_PLOT_MOUSEOUT(point) {
      var chart = this.chart,
        eventManager = this.eventManager,
        selectionManager = eventManager.selectionManager;

      if (chart.eventHandler.mouseOnTooltip === true) {
        return;
      }
      if (chart.chartRendered) {
        eventManager.eventType = 'mouseout';
        eventManager.targetEvent = chart.eventHandler.targetEvent = d3_event() || chart.eventHandler.targetEvent;

        var isSingleSrcEvt = this.isSingleSource();

        var pointFound = point && point.constructor === Object || point && point.constructor === Array;

        if (!pointFound) {
          point = selectionManager.oldSelectionSet[0] || selectionManager.selectionSet[0];
        }
        point = this.toNewObject(point);

        eventManager.selectionManager.remove();

        eventManager.associateBehaviours('mouseout', point);
      }
    }

    function ZC_PLOT_HOVER(point) {
      var chart = this.chart,
        eventManager = this.eventManager;

      // // dont proceed hover while zoom and brush
      if (chart.zooming || chart.brushing) {
        return false;
      }

      if (chart.chartRendered) {
        this.clearOldActions();
        // if (d3_event().defaultPrevented) return;

        // let USING Brush Bubble
        var useBubble = $Browser.isTouchDevice && chart.isAxisCategory && chart.systemConf.chart.brush.enabled;
        if (chart.stopPropogate !== false && !useBubble) {
          d3_event().stopPropagation();
        }

        eventManager.eventType = chart.zcEventType || 'mousemove';
        eventManager.targetEvent = chart.eventHandler.targetEvent = d3_event();

        var isSingleSrcEvt = this.isSingleSource();
        var node = this.getSourceNode();
        var mouse = this.getRelativeMousePosition(node, isSingleSrcEvt);
        var pointFound = point.constructor === Object || point.constructor === Array || !isSingleSrcEvt;
        point = !isSingleSrcEvt ? point.constructor === Object ? point : eventManager.selectionManager.nearest : point;
        if (pointFound) {
          point = this.toNewObject(point);
        }

        //find point

        if (!pointFound) {
          point = eventManager.getData('mousemove', mouse);
          if (!point.selectionSet.length) {
            var handlers = chart.eventHandler.handlers;
            handlers.mouseout.call(this);
            // chart.eventHandler.mouseOut();
            // chart.eventHandler.oldInfo = { isNoInfo: true };
            return;
          }
        }

        //associate default behaviors
        eventManager.associateBehaviours(eventManager.eventType, point, mouse);
      }
    }

    //$Id$

    var docEle = d3_select(document.documentElement);

    var docTapFunction = function docTapFunction(chartObj, point) {
      //For pivot pie,funnel, pyramid, sunburst, packedbubble chart reset the old highlighlight on the last pane interacted
      if (chartObj && $Browser.isTouchDevice && chartObj.dataObject.pivot && chartObj.cache.search.lastPane) {
        var nonAxisSingleSeries = !(chartObj.dataObject.isAxisCategory || chartObj.dataObject.isNonAxisMultiSeriesCategory);
        if (nonAxisSingleSeries && point && point.paneid && point.paneid !== chartObj.cache.search.lastPane) {
          $ZCG.clickArguments = []; //TODO
          resetOldHighlight(chartObj);
        }
      }
      if (
      $Browser.isTouchDevice && (
      !chartObj && $ZCG.clickArguments && $ZCG.previousChartObj || $ZCG.previousChartObj && $ZCG.previousChartObj != chartObj) &&
      // ZC2736 & ZC2728
      $ZCG.previousChartObj && !$ZCG.previousChartObj.destroying)
      {
        resetOldHighlight($ZCG.previousChartObj);
      }
    };

    function resetOldHighlight(chartInstance) {
      var container = chartInstance.container.node();
      // if (document.body.contains(container) && (container.style.display != NONE)) {
      if (isElementVisible(container)) {
        $ZCG.clickArguments[4] = true;

        var tooltipConfig = chartInstance.systemConf.tooltip;
        var tooltipHideDelay = tooltipConfig.hideDelay;
        tooltipConfig.hideDelay = 0; //Mouse out should happen without delay
        var nonAxisSingleSeries = !(chartInstance.dataObject.isAxisCategory || chartInstance.dataObject.isNonAxisMultiSeriesCategory);
        if (chartInstance.dataObject.pivot && nonAxisSingleSeries) {
          chartInstance.eventHandler.eventManager.selectionManager.oldSelectionSet = [];
        }

        chartInstance.eventHandler.tapOldInfo = null;
        chartInstance.eventHandler.handlers.mouseout.call(chartInstance.eventHandler);

        tooltipConfig.hideDelay = tooltipHideDelay; //reset the delay
      }
    }
    var documentTapEvent = docTapFunction;

    if ($Browser.isTouchDevice) {
      var callPlotMouseOut = function callPlotMouseOut() {
        var now = new Date().getTime();
        if (!$ZCG.clickedTime || now - $ZCG.clickedTime > 500) {
          docTapFunction(d3_event().target.__chart);
        }
      };

      var docTapHandlers = {
        tap: callPlotMouseOut,
        taphold: callPlotMouseOut,
        dbltap: callPlotMouseOut
      };
      attachevents(docEle, {}, docTapHandlers, { preventDefault: false });

      docEle.on('touchmove', function () {
        docTapFunction(d3_event().target.__chart);
      });
    }

    function ZC_PLOT_CLICK(point) {
      var chart = this.chart,
        eventManager = this.eventManager;

      if (chart.chartRendered) {
        var seriesdata = chart.seriesdata;
        var isTouchEvent = d3_event() && d3_event().touches,
          eventType = chart.zcEventType || 'click';
        if (isTouchEvent && eventType !== 'taphold') {
          assignTouchEventLog(eventType, chart, point);
        }
        eventManager.eventType = eventType;
        eventManager.targetEvent = chart.eventHandler.targetEvent = d3_event();

        var isSingleSrcEvt = this.isSingleSource();
        var node = this.getSourceNode();
        var mouse = this.getRelativeMousePosition(node, isSingleSrcEvt);

        var pointFound = point.constructor === Object || point.constructor === Array || !isSingleSrcEvt;
        if (!isSingleSrcEvt) {
          point = this.toNewObject(point);
        }

        //find point

        if (!pointFound) {
          point = eventManager.getData('click', mouse);
          if (!point.nearest) {
            var handlers = chart.eventHandler.handlers;
            handlers.mouseout.call(this);
            // chart.eventHandler.oldInfo = { isNoInfo: true };
            return;
          }
        }

        //associate default behaviors
        eventManager.associateBehaviours(eventType, point, mouse);
      }
    }

    function assignTouchEventLog(type, chart, point) {
      if (type != 'taphold') {
        documentTapEvent(chart, point);
        $ZCG.clickedTime = new Date().getTime();
        $ZCG.clickedElement = d3_event() && d3_event().target;
        $ZCG.clickArguments = []; //[renderer, data, seriesPos, itemPos];
        $ZCG.previousChartObj = chart;
      }
    }

    function ZC_PLOT_DOUBLECLICK(point) {
      var chart = this.chart,
        eventManager = this.eventManager;

      if (chart.chartRendered) {
        var useBubble = $Browser.isTouchDevice && chart.isAxisCategory && chart.systemConf.chart.brush.enabled;
        if (chart.stopPropogate !== false && !useBubble) {
          d3_event().stopPropagation();
        }
        var isTouchEvent = d3_event() && d3_event().touches;
        if (isTouchEvent) {
          var handlers = chart.eventHandler.handlers;
          handlers.mouseout.call(this);
        }
        eventManager.eventType = chart.zcEventType || 'doubleclick';
        eventManager.targetEvent = chart.eventHandler.targetEvent = d3_event();

        var isSingleSrcEvt = this.isSingleSource();
        var node = this.getSourceNode();
        var mouse = this.getRelativeMousePosition(node, isSingleSrcEvt);

        var pointFound = point.constructor === Object || point.constructor === Array || !isSingleSrcEvt;
        if (!isSingleSrcEvt) {
          point = this.toNewObject(point);
        }

        if (!pointFound) {
          point = eventManager.getData('doubleclick', mouse);
          if (!point.nearest) {
            var handlers = chart.eventHandler.handlers;
            handlers.mouseout.call(this);
            return;
          }
        }

        //associate default behaviors
        eventManager.associateBehaviours(eventManager.eventType, point, mouse);
      }
    }

    function ZC_PLOT_CONTEXTMENU(point) {
      var chart = this.chart,
        eventManager = this.eventManager;

      if (chart.chartRendered) {
        chart.eventHandler.targetEvent = d3_event();

        var isSingleSrcEvt = this.isSingleSource();
        var node = this.getSourceNode();
        var mouse = this.getRelativeMousePosition(node, isSingleSrcEvt);

        point = eventManager.selectionManager;
        //associate default behaviors
        eventManager.associateBehaviours('contextmenu', point, mouse);
        // chart.eventHandler.targetEvent.preventDefault();
      }
    }

    var __defaultPlotHandlers = {

      mousemove: ZC_PLOT_HOVER,
      mouseout: ZC_PLOT_MOUSEOUT,
      click: ZC_PLOT_CLICK,
      doubleclick: ZC_PLOT_DOUBLECLICK,
      contextmenu: ZC_PLOT_CONTEXTMENU,
      tap: ZC_PLOT_CLICK,
      dbltap: ZC_PLOT_DOUBLECLICK,
      singletouchmove: ZC_PLOT_HOVER,
      touchend: ZC_PLOT_MOUSEOUT
    };

    //$Id$

    var UnSelectedHighlight = function UnSelectedHighlight(chartObj) {
      this.chartObj = chartObj;
      this.elements =
      chartObj.plot.renderer.mode === 'svg' ? chartObj.container.selectAll('g.seriesholder, g.qualitativeGroupHolder') : d3_select(chartObj.context.canvas);
      this.backupStyles = NULL$1;
      this.previousPoint = NULL$1;
    };

    UnSelectedHighlight.prototype.highlight = function (point) {
      var chartObj = this.chartObj,
        replacerFunction = chartObj.dataObject.isHierarchy ? replacer : NULL$1,
        applyUnselectedSeriesToPlot = chartObj.systemConf.legend.highlightEffect.applyUnselectedSeriesToPlot,
        previousPoint = this.previousPoint,
        condition =
        applyUnselectedSeriesToPlot &&
        point && (
        !previousPoint ||
        jsonStringify(previousPoint.data, replacerFunction) != jsonStringify(point.data, replacerFunction) ||
        previousPoint.seriesPos != point.seriesPos ||
        previousPoint.itemPos != point.itemPos ||
        jsonStringify(previousPoint.subseriesindex) != jsonStringify(point.subseriesindex));

      if (condition) {
        var elements = this.elements,
          highlightEffect = chartObj.legendHighlight.getLegendHighlightEffect(0, 'unselectedSeries', 'plot', point.paneid),
          styles = chartObj.legendHighlight.getEffect(highlightEffect, NULL$1, NULL$1, NULL$1, 0, 'plot');

        this.getBackup(styles);
        elements.styles(styles);
        this.previousPoint = point;
      }
    };

    UnSelectedHighlight.prototype.reset = function () {
      var backupStyles = this.backupStyles;
      if (backupStyles) {
        this.elements.styles(backupStyles);
        this.backupStyles = NULL$1;
        this.previousPoint = NULL$1;
      }
    };

    UnSelectedHighlight.prototype.getBackup = function (styles) {
      var elements = this.elements,
        backupStyles = this.backupStyles;

      if (!backupStyles) {
        backupStyles = {};
        for (var styleName in styles) {
          if (styles.hasOwnProperty(styleName)) {
            backupStyles[styleName] = elements.style(styleName);
          }
        }
        this.backupStyles = backupStyles;
      }
    };

    function replacer(key, value) {
      // Filtering out properties
      var omitKeysList = ['parent', 'children'];
      if (omitKeysList.indexOf(key) > -1) {
        return UNDEFINED;
      }
      return value;
    }

    function triggerUserCallback(callback, point, event, extraParams, chart) {
      var userArguments;

      // get arguments for threshold marker
      if (!point) {
        return {
          callback: callback
        };
      } else if (point.type === 'threshold-marker') {
        var key = point.thresholdType === 'x' ? 'x' : "y.groups[".concat(point.yColumnIndex, "]");
        userArguments = getPropVal(chart.axes, "".concat(key, ".threshold.line")).getMetaInfo(point);
      } else if (chart.chartTypes[0].name === SANKEY_CHARTNAME && point._type === 'node') {
        userArguments = {
          point: point,
          seriesIndex: point.seriesIndex,
          subSeriesIndex: point.subSeriesIndex,
          data: chart.dataset.getMetaInfoObj(chart, point, point.seriesIndex)
        };
      } else {
        userArguments = getUserArguments(chart, point);
      }

      // set extra params
      if (defined(extraParams) && _typeof(extraParams) === 'object') {
        userArguments = mergeJSON$1(userArguments, extraParams, true, true);
      }

      return {
        args: userArguments,
        callback: callback
      };
    }

    /**
     *
     * @param point
     * @return {*}
     */
    function getUserArguments(chart, point) {
      var params,
        rangePoint = point.currentQualitativeRangePoint,
        dataPoint = pick(point.point, point.data) || {},
        levels = pick(point.level, dataPoint && dataPoint.level);

      // it is a hierarchy chart.
      // indexes need to be parsed
      if (defined(levels)) {
        params = parseHierarchyLevel(levels);
      } else {
        params = {
          seriesIndex: pick(point.seriesIndex, dataPoint.seriesIndex),
          subSeriesIndex: pick(point.subSeriesIndex, point.subSeriesIndex, dataPoint.subSeriesIndex),
          itemIndex: pick(point.itemIndex, dataPoint.itemIndex) //TODO: priority should be corrected
        };
      }

      if (isArray$1(point.subseriesindex)) {
        point.subseriesindex.some(function (value) {
          if (defined(value)) {
            return params.subSeriesIndex = value;
          }
        });
      }

      // handle bullet range points
      if (defined(rangePoint)) {
        params.rangeIndex = rangePoint.rangeIndex;
        params.targetIndex = rangePoint.targetIndex;
      }

      if (defined(params.seriesIndex) && defined(params.itemIndex)) {
        if (defined(dataPoint) && isArray$1(dataPoint.data)) {
          dataPoint = dataPoint.data;
        }

        if (!isArray$1(dataPoint)) {
          params.subSeriesIndex = pick(params.subSeriesIndex, 0);
          dataPoint = point;
          // dataPoint = getCurrentDataPoint(params.seriesIndex, params.subSeriesIndex, params.itemIndex, point.itemPosShared);

          // since all indexes has been set, set the label index alone.
          if (defined(dataPoint.level)) {
            params.levelIndices = parseHierarchyLevel(dataPoint.level).levelIndices;
          }
        }

        // TODO has to be revamp. Since we are passing all required params, It can be access through API.
        params.data = chart.dataset.getMetaInfoObj(chart, dataPoint, params.seriesIndex);
      }
      // pass the actual point
      params.point = dataPoint;

      return params;
    }

    function parseHierarchyLevel(level) {
      level = level.split('_');
      return {
        levelIndices: level.map(Number),
        seriesIndex: +level[0],
        itemIndex: +level[level.length - 1]
      };
    }

    function getNearestPaneID(chart, mouse) {
      var isPolar = chart.dataObject.isPolarAxisCategory;

      //grid data
      if (chart.dataObject.pivot) {
        if (chart.dataObject.isPolarAxisCategory) {
          mouse.x += chart.plotarea_approx.x;
          mouse.y += chart.plotarea_approx.y;
        }
        var pivoLayout = chart.dataObject.hierarchical.pivotLayout,
          rowList = pivoLayout.getRootNodeList('row'),
          columnList = pivoLayout.getRootNodeList('column'),
          row,
          column;

        if (rowList.hasMultiCluster()) {
          var yLeaves = chart.axes.y.leaves,
            rowSize = rowList.leafSize,
            temp = 0,
            rotated = chart.axes.rotated,
            rotated_orient = isPolar ? false : chart.axes.rotated;
          var row_ordinalRange = yLeaves.map(function (d, i) {
            var range = isPolar ? [temp, temp + rowSize] : d.scale.range(),
              reversed = isPolar ? true : d.reversed,
              index = isPolar ? 0 : rotated_orient ? reversed ? 0 : 1 : 1;
            temp = temp + rowSize;

            return range[index];
          });
          var validator = rotated_orient ? '<' : '>';
          row = getBisectedValue(mouse, row_ordinalRange, 'y', rotated, !rotated, validator);
        } else if (rowList.count) {
          var row_ordinalRange = chart.axes.y.branches[0].scale.ordinalRange;
          var validator = chart.axes.rotated ? '>' : '>';
          //TopToBottom leftToRight
          row = getBisectedValue(mouse, row_ordinalRange, 'y', chart.axes.rotated, !chart.axes.rotated, validator);
        }
        if (columnList.count) {
          var column_ordinalRange = chart.axes.x.levels[0].scale.ordinalRange,
            reversed = chart.axes.x.reversed;
          var validator = chart.axes.rotated && !reversed ? '<' : '>';
          //leftToRight, bottomToTop
          column = getBisectedValue(mouse, column_ordinalRange, 'x', chart.axes.rotated, reversed, validator);
        }

        if (chart.dataObject.isPolarAxisCategory) {
          mouse.x -= chart.plotarea_approx.x;
          mouse.y -= chart.plotarea_approx.y;
        }

        return "".concat(row || 0, "_").concat(column || 0);
      }
      return '0_0';
    }var

    ZC_ChartEvents = /*#__PURE__*/function () {
      function ZC_ChartEvents(chart, bindTo) {_classCallCheck(this, ZC_ChartEvents);
        this.chart = chart;
        this.tracker = bindTo;
        this.rotated = chart.axes.rotated;
        this.isAxisCategory = chart.isAxisCategory;
        this.isGeoMap = chart.isGeoMap;
        this.isPolarAxisCategory = chart.dataObject.isPolarAxisCategory;
        this.isFlowChartCategory = chart.dataObject.isFlowChartCategory;
      }_createClass(ZC_ChartEvents, [{ key: "init", value:
        function init() {
          this.eventManager = new EventManager(this.chart);
          this.reverseLegendHighlight = new ReverseLegendHighlight(this.chart);
          this.unselectedHighlight = new UnSelectedHighlight(this.chart);
          this.eventManager.bindTo(this.tracker);
          this.eventManager.init();
          if (this.chart.isGeoMap) {
            return; //TODO Soon
          }
          this.addListeners(this.tracker);
          this.eventManager.dataFinder({
            mousemove: ZC_ChartEvents.findData,
            click: ZC_ChartEvents.findData,
            doubleclick: ZC_ChartEvents.findData
          });
          // this.eventManager.selectionManager = new SelectionManager(this.chart);
          this.eventManager.defaultBehaviour = getPlotDefaultBehaviour();
          this.eventManager.customBehaviour = ZC_ChartEvents.getCustomBehaviour;
          this.eventManager.getBehaviourName = ZC_ChartEvents.getBehaviourName;

          if (events.customPoints) {
            this.CustomPoints = new events.customPoints(this.chart);
            this.CustomPoints.addPoints(this.chart.cache.thresholdCustomPoints, true);
          }
        } }, { key: "update", value:
        function update() {
          this.rotated = this.chart.axes.rotated;
          this.isAxisCategory = this.chart.isAxisCategory;
          this.isGeoMap = this.chart.isGeoMap;
          this.isPolarAxisCategory = this.chart.dataObject.isPolarAxisCategory;
          this.isFlowChartCategory = this.chart.dataObject.isFlowChartCategory;
          this.tooltipElement.initialize();
          this.bulletEvents = null; //#ZC1009

          if (this.CustomPoints) {
            this.CustomPoints.addPoints(this.chart.cache.thresholdCustomPoints, true);
          }
        } }, { key: "isSingleSource", value:
        function isSingleSource() {
          var event = d3_event(),
            chart = this.chart;

          if (event && !this.isGeoMap && chart.dataObject.isCombinationalChart && isFacet(chart)) {
            if (chart.divScroll) {
              var mouse = getMousePosition(chart.eventHandler.trackerElement.node(), event),
                accessor = chart.eventHandler.dataAccesor({ x: mouse[0], y: mouse[1] }),
                paneId = accessor.paneId(),
                chartType = getChartTypeByIndex(chart, paneId, 0);

              return !arrayIncludes(chartcategory.nonAxisSingleSourceEvent, chartType);
            }

            var target = event.target,
              eventRectNode = chart.eventHandler.trackerElement.node(),
              seriesHolderNode = chart.svg.selectAll('g.seriesholder').node();

            if (target !== eventRectNode && !seriesHolderNode.contains(target)) {
              var nearest = chart.eventHandler.eventManager.selectionManager.nearest,
                _isArray = nearest && isArray$1(nearest);
              if (nearest && (_isArray && nearest.length || !_isArray)) {
                return _isArray;
              }
            } else {
              return target === eventRectNode;
            }
          }

          return (
            this.isAxisCategory ||
            this.isPolarAxisCategory ||
            this.isFlowChartCategory ||
            this.isGeoMap ||
            chart.dataObject.singleSourceEvent);

        } }, { key: "clearOldActions", value:
        function clearOldActions() {
          var tooltip = this.chart.eventHandler.tooltipElement;
          if (tooltip != null && tooltip.timeout != null) {
            clearTimeout(tooltip.timeout); // To avoid flickering on  mouse move, clearing the timeout that makes the tooltip's display prop to none
          }
        } }, { key: "getSourceNode", value:
        function getSourceNode() {
          var node;
          if (this.isSingleSource()) {
            node = this.chart.eventHandler.trackerElement.node();
          } else {
            node = this.chart.svg.node();
          }
          return node;
        } }, { key: "getRelativeMousePosition", value:
        function getRelativeMousePosition(node, relativeTo) {
          var mouse = getMousePosition(node, d3_event());
          if (relativeTo) {
            var element = bbox(node);
            mouse[0] -= element.x;
            mouse[1] -= element.y;
            if (this.isPolarAxisCategory) {
              mouse[0] -= this.chart.plotarea_approx.x;
              mouse[1] -= this.chart.plotarea_approx.y;
            }
          }
          this.chart.eventHandler.mousePos = mouse;
          return {
            x: mouse[0],
            y: mouse[1]
          };
        } }, { key: "toNewObject", value:
        function toNewObject(obj) {
          var o = { nearest: obj };
          this.eventManager.updateSelectionManager(o);
          return this.eventManager.selectionManager;
        } }, { key: "addListeners", value:
        function addListeners(tracker, type) {var _this22 = this;
          var _this = this;
          var handlers = this.handlers = this.handlers || __defaultPlotHandlers;

          var clickHandlers = {
              click: function click(args) {
                handlers.click.call(_this, args);
              },
              dblclick: function dblclick(args) {
                handlers.doubleclick.call(_this, args);
              },
              contextmenu: function contextmenu(args) {
                handlers.contextmenu.call(_this, args);
              }
            },
            moveHandlers = {
              mousemove: function mousemove(args) {
                handlers.mousemove.call(_this, args);
              },
              mouseout: function mouseout(args) {
                handlers.mouseout.call(_this, args);
              }
            },
            touchHandlers = {
              tap: function tap(args) {
                handlers.click.call(_this, args);
              },
              dbltap: function dbltap(args) {
                handlers.doubleclick.call(_this, args);
              },
              singletouchmove: function singletouchmove(args) {
                handlers.mousemove.call(_this, args);
              },
              touchend: function touchend(args) {
                handlers.mouseout.call(_this, args);
              }
            },
            options = {
              target: 'plot',
              chartObj: this.chart
            };

          if (type == 'tooltip') {
            this.eventManager.attachListeners(tracker, moveHandlers, null, options);
          } else {
            this.eventManager.attachListeners(tracker, moveHandlers, null, options, 'chart');
            this.eventManager.attachListeners(tracker, clickHandlers, null, options, 'chartmove');
            this.eventManager.attachListeners(tracker, {}, touchHandlers, options);
          }
          if (customGestureList) {
            var gestureKeys = Object.keys(customGestureList),
              _CustomGesture2 = Registry.getComponent('CustomGesture');
            gestureKeys.map(function (d) {
              _CustomGesture2.call(_this22, d, tracker, 'plot');
            });
          }
        } }, { key: "removeTracker", value:
        function removeTracker() {
          var i = this.trackerElement;
          i.attr('transform', null);
          i.attr('width', null);
          i.attr('height', null);
          i.attr('style', null).attr('cursor', null);
        } }, { key: "dataAccesor", value:

        function dataAccesor(mouse) {
          var manager = this,
            chart = this.chart,
            containsBarchart = manager.chart.dataObject.noofBarEnabledSeries > 0,
            tooltipShared = tooltip_helpers.hasSharedSeries(chart),
            sharedCriteria = chart.cache.search.bisect = containsBarchart || tooltipShared;
          var accessor = {
            chart: chart,
            parseKey: function parseKey(key) {
              if (chart.cache.thresholdCustomPoints && key.indexOf('threshold') !== -1) {
                return 'threshold';
              }
            },
            bestChartType: function bestChartType(key) {
              var cTypeBest = key == 'threshold' || key == 'segment' ? 'scatter' : key;
              return cTypeBest;
            },
            radius: function radius(key) {
              if (arrayIncludes(chartcategory.nonAxisSingleSourceEvent, charttype[key])) {
                return mathMax(chart.plotarea.width, chart.plotarea.height);
              }

              if (chart.cache.thresholdCustomPoints && key.indexOf('threshold') !== -1 && chart.cache.thresholdCustomPoints[key]) {
                return chart.cache.thresholdCustomPoints[key].triggerOffset;
              }
              if (key == MARKER_COMPONENT) {
                return chart.dataObject.flattenPoints.get('pane0_0').get(key).size; // TODO: check
              }
              key = key == 'threshold' || key == 'segment' ? 'scatter' : key;
              var mSizeCheckNeededType = key == 'line' || key == 'scatter',
                isSameSize4Series = mSizeCheckNeededType ? chart.dataObject.markerSize[key].size() == 1 : null,
                markerSize = isSameSize4Series ? parseInt(chart.dataObject.markerSize[key].values()[0]) || 0 : 0,
                subtype;

              if (key == 'bar_segment') {
                key = 'scatter';
                subtype = 'segment';
                markerSize = 0.5;
              }

              var triggeringOffset = pick(getTriggeringOffset(chart, charttype[key], null, subtype), 10);

              return triggeringOffset + markerSize / 2;
            },
            sizeOffset: function sizeOffset(key) {
              if (arrayIncludes(chartcategory.nonAxisSingleSourceEvent, charttype[key])) {
                return 0;
              }

              key = key == 'threshold' ? 'scatter' : key;
              var commonPlotOptions = chart.systemConf.chart.plot.plotoptions[key],
                customTriggerOffset = commonPlotOptions && commonPlotOptions.events && commonPlotOptions.events.triggerOffset;
              return customTriggerOffset || 10;
            },
            extent: function extent() {
              return [chart.plotarea.width, chart.plotarea.height];
            },
            size: function size(key) {
              var mSizeCheckNeededType = key == 'line' || key == 'scatter',
                isSizeDiffers4Series = mSizeCheckNeededType ? chart.dataObject.markerSize[key].size() > 1 : null;

              return (
                chart.dataObject.isBubbleEnabled ||
                isSizeDiffers4Series ||
                key == 'segment' ||
                key == MARKER_COMPONENT ||
                arrayIncludes(chartcategory.nonAxisSingleSourceEvent, charttype[key]));
              //NEED TO CHECK
            },
            toArray: function toArray(obj) {
              var xy = XY(this.rotated);
              return [obj[xy[0]], obj[xy[1]]];
            },
            bisectMode: function bisectMode() {
              var datatype = chart.dataset.getDataType('x');
              return chart.dataObject.noofBarEnabledSeries || datatype == ORDINAL_DATATYPE ? 'discrete' : 'continous';
            },
            median: function median() {
              var hasMultiLeaves, column;
              if (chart.dataObject.pivot) {
                var hierarchical = chart.dataObject.hierarchical,
                  columnList = hierarchical.pivotLayout.getRootNodeList('column'),
                  columnLeavesCount = columnList.getLeavesCount();
                hasMultiLeaves = columnLeavesCount > 1;
                column = chart.cache.search.lastPane.split('_')[1];
              }
              var xaxisReversed = chart.systemConf.chart.axes.xaxis.reversed,
                onlyBarCombo_noAreaChart =
                chart.dataObject.noofBarEnabledSeries && !chart.dataObject.noofAreaEnabledSeries && tooltipShared,
                xscale = hasMultiLeaves ? chart.axes.x.leaves[column].scale : chart.axes.x.scale,
                datatype = this.chart.dataset.getDataType('x');
              var median = scale.invert(datatype, mouse, xscale, chart.axes.rotated, null, xaxisReversed, onlyBarCombo_noAreaChart);
              median = datatype == ORDINAL_DATATYPE ? xscale.domain()[median] : median;
              return median;
            },
            spliceIndices: function spliceIndices() {
              return [];
            },
            paneIndex: function paneIndex(row, column) {
              if (chart.dataObject.pivot) {
                var panes = chart.dataObject.hierarchical.pivotLayout.getRootNodeList('layer').panes;
                return panes["".concat(row, "_").concat(column)].index;
              }
              return 0;
            },
            paneId: function paneId() {
              return getNearestPaneID(chart, mouse);
            },

            hasDependantPoints: function hasDependantPoints() {
              return isDependentPointHighlightType(chart);
            },

            pointLiesInsidePlot: function pointLiesInsidePlot(point) {
              var seriesindex = point.seriesIndex,
                cType_Obj = getChartTypeByIndex(chart, point.paneid, seriesindex),
                type = cType_Obj.value;
              if (
              !isBarChartType(type) &&
              !isAreaChartType(type) &&
              !chart.dataObject.isPolarAxisCategory &&
              !chart.dataObject.isFlowChartCategory)
              {
                return isWithinPlotarea(point, chart);
              }
              return true;
            },
            userSelection: tooltipShared && chart.systemConf.tooltip.sharedSeriesInfo.selection,
            isBisectMode: function isBisectMode(key, defaultBisect) {
              if (defaultBisect) {
                return key != MARKER_COMPONENT;
              }
              return false;
            },
            hasSelection: function hasSelection(point, mode) {
              if (mode == 'BISECT_QUADTREE') {
                return _barPointSelection(point, mouse);
              }
            }
          };

          return accessor;
        } }, { key: "getPointType", value:



























































































        function getPointType(p) {
          var seriesindex = p.seriesIndex,
            // type = p.type || this.chart.chartTypes[seriesindex].name;
            type = p.type || 'series';
          return type;
        } }, { key: "eventDisabled", value:
        function eventDisabled(d) {
          /*
           * returns true if the series is filtered or event is disabled for that series
           */
          var plotOptions = d.plotoptions;
          var cName = DataProcessor.helpers.getChartType(d.type || this.chart.userdata.seriesdata.type, 'string');
          var commonPlotOptions = this.chart.systemConf.chart.plot.plotoptions[cName];
          return d.disabled || validateNullVal(getEventConf(plotOptions, commonPlotOptions, this.chart, 'enabled'), true) == false;
        } }], [{ key: "findData", value: function findData(mouse) {var manager = this,chart = manager.chart,containsBarchart = manager.chart.dataObject.noofBarEnabledSeries > 0,tooltipShared = tooltip_helpers.hasSharedSeries(chart),sharedCriteria = chart.cache.search.bisect = containsBarchart || tooltipShared,accessor = chart.eventHandler.dataAccesor(mouse),paneid = "pane".concat(accessor.paneId()),flattendata1 = chart.dataObject.flattenPoints.get(paneid);chart.cache.search.lastPane = paneid;var chartTypes = isFacet(chart) && chart.dataObject.hierarchical && chart.dataObject.hierarchical.gridOptions[paneid.replace('pane', '')].chartTypes;if (chartTypes && arrayIncludes(chartcategory.nonAxisSingleSourceEvent, chartTypes[0].value)) {sharedCriteria = chartTypes.some(function (_) {return isBarChartType(_.value);});}var point = getNearestPoint(flattendata1, mouse, sharedCriteria, accessor);return { nearby: tooltipShared ? point.nearby : null, nearest: point.nearest, dependents: point.dependents, surround: point.nearby };} }, { key: "getCustomBehaviour", value: function getCustomBehaviour(selectionManager, eventType) {var manager = this,chart = manager.chart,event = manager.targetEvent,selectedPoint = selectionManager.nearest || selectionManager.selectionSet[0] || selectionManager.oldSelectionSet[0],behaviour = [],eventConfig,extraparams;if (!selectedPoint && eventType !== 'contextmenu' && eventType != 'mouseout') {return;}if (eventType == 'contextmenu' || !selectedPoint && eventType == 'mouseout') {eventConfig = chart.systemConf.chart.plot.events[eventType];} else {var plotOptions, commonPlotOptions;var seriesindex = selectedPoint.seriesIndex,cType_Obj = getChartTypeByIndex(chart, selectedPoint.paneid, seriesindex),type = selectedPoint.type || cType_Obj.name;if (type === 'zc-marker') {commonPlotOptions = { events: isObjectPropDefined(chart.cache, "parser.".concat([selectedPoint.__key], ".parser.event"), true) || {} };} else if (type == 'threshold-marker' || type == 'levelMarker' || type == 'marker') {commonPlotOptions = selectedPoint;} else if (selectedPoint._type == 'segment') {//for whiskers
              commonPlotOptions = chart.systemConf.chart.plot.plotoptions[cType_Obj.name].whiskers;} else {var seriesdata = DataProcessor.helpers.getSeriesdata(chart, selectedPoint.paneid, selectedPoint.seriesIndex),seriesIndex = selectedPoint.seriesIndex,chartName = cType_Obj.name,plotOptions = seriesdata.plotoptions,commonPlotOptions = chart.systemConf.chart.plot.plotoptions[chartName],evt = chart.zcEventType || chart.eventHandler.targetEvent;}eventConfig = getEventConf(plotOptions, commonPlotOptions, chart, eventType), extraparams = { x: selectedPoint._x, y: selectedPoint._y };}if (eventConfig) {if (eventType == 'cursor') {return eventConfig;}behaviour.push({ action: triggerUserCallback(eventConfig, selectedPoint, getEventObject(event), extraparams, chart), type: 'custom' });return behaviour;}return null;} }, { key: "getBehaviourName", value: function getBehaviourName(point) {var manager = this,chart = manager.chart;return point && isObjectPropDefined(chart.cache, "parser.".concat([point.__key], ".parser.event.behaviour"), true);} }]);return ZC_ChartEvents;}();

    Registry.setComponent('ZC_ChartEvents', ZC_ChartEvents);

    //custom-points.js

    /**
     *
     * @param {Chart} chartInstance
     * @param {Array} points array of points
     * @param {Boolean} toCircle if point to be treated as circle
     * @constructor
     */

    function CustomPoints(chartInstance, points, toCircle) {
      if (!(this instanceof CustomPoints)) {
        return new CustomPoints(points);
      }

      points = pick(points, []);

      if (toCircle) {
        points = CustomPoints.toCircle(points);
      }

      this.chart = chartInstance;
      this.points = CustomPoints.addType(points);
    }

    /**
     *
     * @param points
     * @param toCircle
     */
    CustomPoints.prototype.addPoints = function (points, toCircle) {
      if (!points) {
        return;
      }
      for (var key in points) {
        if (points.hasOwnProperty(key)) {
          if (toCircle) {
            points[key] = CustomPoints.toCircle(points[key]);
          }
          Array.prototype.push.apply(this.points, CustomPoints.addType(splat(points[key]))); // adds new point to the existing list
        }
      }

      return this;
    };

    /**
     *
     * @param fromIndex
     * @param itemCount
     * @return {[]}
     */
    CustomPoints.prototype.removePoints = function (fromIndex, itemCount) {
      return this.points.splice(fromIndex, itemCount || 1);
    };

    CustomPoints.prototype.hoverPoint = function (point, event, mouse, showTooltip, showMarker, forceHover) {
      showTooltip = showTooltip !== false;
      showMarker = showMarker !== false;

      if (showTooltip) {
        var node = this.chart.eventHandler.getSourceNode(),
          mouse = this.chart.eventHandler.getRelativeMousePosition(node, true);
        showTooltipOnPoint(this.chart, event || d3_event(), mouse, point, showMarker, forceHover);
      }
      return;
    };

    /**
     *
     * @param points
     * @return {*}
     */
    CustomPoints.toCircle = function (points) {
      points.forEach(function (point) {
        if (!point._converted && !defined(point.r)) {
          var _data = point._data();
          point.cx = _data._x + point.width / 2; // center x
          point.cy = _data._y + point.height / 2; // center y
          point.r = mathMax(point.width, point.height) / 2; // radius
          point._converted = true; // set converted
        }
      });
      return points;
    };

    /**
     *
     * @param points
     * @return {*}
     */
    CustomPoints.addType = function (points) {
      points.forEach(function (point) {
        var _data = point._data();
        if (defined(point.r)) {
          point._type = 'circle';
        } else if (defined(_data._x) && defined(_data._y) && defined(point.width) && defined(point.height)) {
          point._type = 'rect';
        } else {
          // not supported
          point._type = 'poly';
        }
      });
      return points;
    };

    /**
     * custom point tooltip
     *
     * @param chart
     * @param event
     * @param mouse
     * @param point
     * @param highlight
     */
    function showTooltipOnPoint(chart, event, mouse, point, highlight, forceHover) {
      var oldInfo = chart.eventHandler.oldInfo,
        tooltip = chart.systemConf.tooltip,
        tooltipShared = chart.systemConf.tooltip.sharedSeriesInfo,
        wrap = chart.staticPaneSVG.selectAll('g.eventgroup'),
        tooltipEnabled = tooltip.enabled === true || forceHover === true,
        tooltipEvent = chart.eventHandler.tooltipElement,
        context;

      if (oldInfo && oldInfo.isNoInfo === false) {
        chart.eventHandler.mouseOut();
      }

      // hide all the highlighters
      clearTimeout(tooltipEvent.timeout);
      wrap.selectAll('#zcscatterhighlight,#zcbarhighlight,#zcareahighlight').style('display', NONE);
      var _data = point._data();
      var x = _data._x,
        y = _data._y;

      // fix mouse
      if (!defined(mouse)) {
        // relative;
        mouse = { x: x, y: y };
      }

      // fix event
      if (defined(event)) {
        event = getEventObject(event);
      }

      if (!defined(event)) {
        // mimic clientX and clientY
        var chartSVGPosition = chart.svg.node().getBoundingClientRect();

        event = {
          clientX: x + chart.plotarea.left + chartSVGPosition.x,
          clientY: y + chart.plotarea.top + chartSVGPosition.y
        };
      }

      // highlight the point based on type
      if (highlight) {
        // highlight for points
        if (point._type === 'circle') {
          context = showMarkerOnPoint(point, x, y, wrap, chart.plotarea, chart);
        }
      }

      if (tooltipEnabled) {
        var tooltipPos = getTooltipPosition(event, mouse, x, y, chart, null, chart.axes.rotated, tooltipShared, null, false, false),
          tooltipContent = [point.text, point.formattedValue].join(': '),
          marker = point.marker,
          pointEvents = pick(point.events, {}),
          tooltipFunction = pointEvents.tooltipContent;

        if (defined(tooltipFunction)) {
          var temp = invokeFunction(
          tooltipFunction,
          event,
          {
            data: [point.columnInfo],
            itemIndex: point.itemIndex,
            point: point.point,
            pointFormatted: point.formattedValue
          },
          chart);

          if (defined(temp)) {
            tooltipContent = temp;
          }
        }

        tooltipPos.helpers.backgroundColor = pick(tooltip.backgroundColor, marker.fillColor, point.color);
        tooltipPos.helpers.borderColor = pick(tooltip.borderColor, marker.strokeColor, point.color);

        tooltipEvent.show(chart, tooltipPos, tooltipContent, false, tooltipPos.helpers);
      }
      return context;
    }

    /**
     * custom point marker for point
     *
     * @param point
     * @param x
     * @param y
     * @param wrap
     * @param plotArea
     * @param chartObj Chart
     */
    function showMarkerOnPoint(point, x, y, wrap, plotArea, chartObj) {
      var scatterWrap = wrap.
      selectAll('#zcscatterhighlight').
      style('display', null).
      attr('transform', "translate(".concat(plotArea.left, ",").concat(plotArea.top, ")"));

      var hoverOptions = getPropVal(point.marker, 'hoveroptions') || {};
      var symbolOptions = {
        color: point.color,
        symbolSize: {
          inner: point._mSize / 2,
          outer: point._mSize
        },
        transform: [x, y]
      };
      addSVGmarker(scatterWrap, null, hoverOptions, symbolOptions, chartObj);
      return scatterWrap;
    }

    events.customPoints = CustomPoints;

    function setPivotAttributes(elements, chartObj, chartName) {
      var _rawData = getRawData(chartName);

      if (chartObj.dataObject.pivot) {
        elements
        //
        .attr('levelbycolumn', function (d) {return _rawData(d).levelByColumn;}).
        attr('levelbyrow', function (d) {return _rawData(d).levelByRow;});
      }
    }

    function getRawData(chartName, labelData) {
      if (chartName === SUNBURST_CHARTNAME || chartName === PACKEDBUBBLE_CHARTNAME || chartName === TREEMAP_CHARTNAME) {
        return getLeafData;
      } else if (chartName === PIE_CHARTNAME) {
        return function (d) {return d.data;};
      } else if (chartName === AREA_CHARTNAME || chartName === LINE_CHARTNAME) {
        return function (d) {return d[0] && d[0];};
      } else if (chartName == 'label') {
        return labelData ? function (labelData, i) {return labelData[labelData.length - 1 - i];} : function (d) {return d.data || d;};
      } else {
        return function (d) {return d;};
      }
    }

    function getLeafData(d) {
      // Parent data doesn't have levelByRow, levelByColumn info ZC2734
      if (d.children) {
        return getLeafData(d.children[0]);
      } else {
        return d.data;
      }
    }

    function setOpacityForTickFilterElements(elements, chartObj, chartName, labelData) {
      if (chartObj.dataObject.hierarchical && chartObj.cache.hierarchical) {
        elements.style('opacity', function (d, i) {
          var opacity = getOpacityForTickFilterElements(d, i, chartObj, chartName, labelData);
          d3_select(this).attr('filtered-opacity', opacity);
          return opacity;
        });
      }
    }

    function _setOpacityForTickFilterElements(d, i, chartObj, chartName) {
      if (chartObj.dataObject.hierarchical && chartObj.cache.hierarchical) {
        var opacity = getOpacityForTickFilterElements(d, i, chartObj, chartName);
        return opacity;
      }
    }

    function getOpacityForTickFilterElements(d, i, chartObj, chartName, labelData) {
      var _rawData = getRawData(chartName, labelData);

      var tickFilterCache = chartObj.cache.hierarchical,
        cacheRow = tickFilterCache.row,
        cacheColumn = tickFilterCache.column,
        isRowActive = true,
        isColumnActive = true,
        d1 = _rawData(labelData || d, i);

      if (cacheRow && cacheRow.active) {
        var query = cacheRow.query;
        isRowActive = defined(d1.levelByRow) ? d1.levelByRow.startsWith(query) : true;
      }
      if (cacheColumn && cacheColumn.active) {
        var query = cacheColumn.query;
        isColumnActive = defined(d1.levelByColumn) ? d1.levelByColumn.startsWith(query) : true;
      }
      var styleSelector = STYLE_SELECTOR.get(chartName),
        propertyName = styleSelector && styleSelector[1] || 'opacity',
        propertyValue = chartObj.systemConf.chart.plot.plotoptions[chartName] ?
        chartObj.systemConf.chart.plot.plotoptions[chartName][propertyName] :
        1;
      var opacity = isRowActive && isColumnActive ? propertyValue : 0.1;

      return opacity;
    }

    //$Id$

    datalabelsBoundBox_handler.svg = function () {
      var series, properties, chartObj;

      function shape(selection, legendOrder) {var labelType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DATALABELS_LABELTYPE;var rendererIndex = arguments.length > 3 ? arguments[3] : undefined;var labelQueue = arguments.length > 4 ? arguments[4] : undefined;
        selection.each(function () {
          var index = legendOrder,
            renderingOrder = pick(rendererIndex, legendOrder);
          if (series) {
            properties = series.properties;
            chartObj = properties.rp.chartObj;
          }
          var showBoundBox = series && isBoundBoxEnabled(properties.dataLabels, chartObj);

          var container = d3_select(this);
          var boundboxSeries = appendEle(
          container,
          'g',
          [{ showBoundBox: showBoundBox, labelQueue: labelQueue }],
          '.',
          'class',
          (labelType === PARENTLABELS_LABELTYPE ?
          'parentboundboxseries_' :
          labelType === INNERLABEL_LABELTYPE ?
          'innerboundboxseries_' :
          'boundboxseries_') + renderingOrder);

          if (properties && properties.rangeChart) {
            boundboxSeries = appendEle(boundboxSeries, 'g', [1], '.', 'class', "rangePos_".concat(properties.yrangePos));
          }
          var boundboxSubSeries = appendEle(boundboxSeries, 'g', showBoundBox ? series : []);

          if (!showBoundBox) {
            return;
          }

          var chartType = properties.chartType,
            isPolarAxisCategory = isCategoryOf(chartObj, chartType, 'polarAxis'),
            isAxisCategory = isCategoryOf(chartObj, chartType, 'axis');

          var seriesTranslation = isPolarAxisCategory ? "translate(".concat(
          chartObj.plotarea_approx.x, ",").concat(chartObj.plotarea_approx.y, ")") :
          !isAxisCategory ?
          properties.translation :
          null;
          boundboxSeries.attr('transform', seriesTranslation);

          var _properties = properties,config = _properties.dataLabels,isMultiLine = _properties.isMultiLine,
            boundboxOptions = getMergedBoundBoxOptions(config, chartObj),
            hookOptions = getBoundBoxHookConf(boundboxOptions.hook),
            globalDataUpdate = properties.dataUpdate,
            globalActualData = properties.data,
            rotation = properties.rotation || 0,
            padding = getBoundBoxPadding(config, chartObj),
            r = getBorderRadius(boundboxOptions.radius),
            strokeColor = getBoundBoxColor(boundboxOptions.strokeColor, properties, chartObj, globalDataUpdate, index),
            fillColor = getBoundBoxColor(boundboxOptions.fillColor, properties, chartObj, globalDataUpdate, index),
            strokeWidth = defined(boundboxOptions.strokeWidth) ? +boundboxOptions.strokeWidth : 1,
            strokeDashArray = getDashArray(boundboxOptions.dashStyle, strokeWidth),
            strokeLineCap = getLineCap(boundboxOptions.lineCap, boundboxOptions.dashStyle),
            heightAdjustScale = d3_scaleLinear(),
            plotarea = chartObj.plotarea;

          var trans = properties.trans || [0, 0];
          var edge = {
            left: -trans[0] + plotarea.left,
            right: plotarea.width - trans[0] - plotarea.left
          };

          boundboxSubSeries.
          attr('transform', function (d) {return d.translation;}).
          attr('class', function (d, i) {
            return "subseries_".concat(i);
          });
        });
      }

      shape.args = function (_) {
        if (!arguments.length) {
          return series;
        }
        series = _;
        return shape;
      };

      return shape;
    };

    LabelRegistry.add('boundBox-svg', datalabelsBoundBox_handler.svg);

    //$Id$

    function connector(chartObj, series, i, rendererIdx, wrap) {
      rendererIdx = pick(rendererIdx, i);

      var properties = series && series.properties || {},_properties$dataUpdat =
        properties.dataUpdate,dataUpdate = _properties$dataUpdat === void 0 ? [] : _properties$dataUpdat,isSunburst = properties.isSunburst,connectorPath = properties.connectorPath,showlabel = properties.showlabel,_properties$dataLabel = properties.dataLabels,dataLabels = _properties$dataLabel === void 0 ? {} : _properties$dataLabel,
        lineConf = dataLabels.line,
        data_length = dataUpdate.length;

      var labelHolder = getLabelHolder(chartObj),
        linkseries = appendEle(
        wrap || labelHolder,
        'g',
        !series || !isFacet(chartObj) && showlabel === 'circular' ? [] : [1],
        '.',
        'class', "link_".concat(
        rendererIdx));


      if (!series) {
        return;
      }

      if (!lineConf) {
        return;
      }

      var actualData = properties.data;
      linkseries.attr('transform', properties.translation).styles({
        stroke: lineConf.strokeColor,
        'stroke-width': lineConf.strokeWidth,
        fill: NONE
      });

      series.forEach(function (subSeries, j) {
        var enabled = (subSeries.showlabel || showlabel) !== 'circular';
        var subseries = appendEle(linkseries, 'g', enabled ? [1] : [], '.', 'class', "subseries_".concat(j));
        var labelText = appendEle(subseries, 'path', subSeries.dataUpdate || dataUpdate);

        subseries.attr('transform', subSeries.translation);
        labelText.
        styles({
          display: function display(d, k) {
            return subSeries[k].display === false ? NONE : NULL$1;
          },
          stroke: function stroke(d, k) {
            if (isSunburst || lineConf.strokeColor) {
              return NULL$1;
            }
            return getRawColor(chartObj, properties.reverseColor ? data_length - 1 - k : k, d && d.data ? d.data : d, i);
          }
        }).
        attrs({
          d: subSeries.connectorPath || connectorPath,
          "class": 'zc_label_connector',
          id: function id(d, k) {
            return "link".concat(i, "_").concat(j, "_").concat(k);
          },
          levelbycolumn: function levelbycolumn(_d, i) {
            var d = actualData ? actualData[actualData.length - 1 - i] : _d.data || _d;
            if (d.levelByColumn) {
              return d.levelByColumn;
            }
          },
          levelbyrow: function levelbyrow(_d, i) {
            var d = actualData ? actualData[actualData.length - 1 - i] : _d.data || _d;
            if (d.levelByRow) {
              return d.levelByRow;
            }
          }
        });
        setOpacityForTickFilterElements(labelText, chartObj, 'label', actualData);
      });
    }

    LabelRegistry.add('connector', connector);

    //$Id$

    function targetLabel(targetMarkerOptions, renderer, dataUpdate, options) {
      var targetLabelOptions = targetMarkerOptions.label || {};
      var chartObj = this,
        dataset = this.dataset,
        plotarea = this.plotarea,
        systemconf = this.systemConf,
        commonOption = renderer.commonOption,
        rp = renderer.commonRendererProp().params,
        axisrotated = rp.axisrotated,
        yscale = rp.yscale,
        rangeBand = rp.xscale.bandwidth(),
        yaxisOrient = systemconf.chart.axes.yaxis[0].orient || (this.axes.rotated ? BOTTOM_ALIGN : LEFT_ALIGN),
        labelArray = getLabelArray(rp, options.paneid);

      var targetDataIndex = targetMarkerOptions.dataindex,
        showlabel = targetMarkerOptions.enabled === true && targetLabelOptions.enabled === true && defined(targetDataIndex);

      var wrap = this.staticPaneSVG.selectAll('g.qualitativeGroup'),
        targetLabelGroup = appendEle(wrap, 'g', showlabel ? [1] : [], '.', 'class', 'targetLabel');
      targetLabelGroup.attr('transform', "translate(".concat(plotarea.left, ",").concat(plotarea.top, ")"));

      if (!showlabel) {
        return;
      }

      var hAlign = targetLabelOptions.hAlign,
        vAlign = targetLabelOptions.vAlign,_targetLabelOptions$t =
        targetLabelOptions.textOverlap,textOverlap = _targetLabelOptions$t === void 0 ? 'none' : _targetLabelOptions$t,
        padding = validateNullVal(targetLabelOptions.padding, 2),
        isFixedPosition = targetLabelOptions.position === 'fixed',
        markerSize =
        validateNullVal(
        targetMarkerOptions.size,
        (commonOption.levelMarkerWidth - 2 * validateNullVal(targetMarkerOptions.padding, commonOption.padding / 2)) / 10) *
        10,
        markerSizeAdjust =
        (targetMarkerOptions.symbol === 'line' ? validateNullVal(targetMarkerOptions.outerStrokeWidth, 1) : markerSize) / 2;

      if (axisrotated) {
        hAlign = hAlign || CENTER_ALIGN;
        vAlign = vAlign || (yaxisOrient === BOTTOM_ALIGN ? TOP_ALIGN : BOTTOM_ALIGN);
      } else {
        hAlign = hAlign || (yaxisOrient === LEFT_ALIGN ? RIGHT_ALIGN : LEFT_ALIGN);
        vAlign = vAlign || CENTER_ALIGN;
      }

      var columns = this.userdata.metadata.columns;
      var columnidx = columns.filter(function (d) {
        return d.dataindex === targetMarkerOptions.dataindex;
      });
      var targetColumn = columnidx.length ? columnidx[0] : columns[dataset.getColumnIdx('y', 0)];
      var datatype = targetColumn.datatype;
      var formatConf = targetColumn[datatype];

      var adjust = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      if (axisrotated) {
        adjust.top = adjust.bottom = plotarea.adjust;
      } else {
        adjust.left = adjust.right = plotarea.adjust;
      }
      if (!isFixedPosition && systemconf.chart.axes.yaxis[0].show === true) {
        adjust[yaxisOrient] = 0;
      }

      var rectBound = chartObj.container.node().getBoundingClientRect(),
        rectBoundLeft = rectBound.left + chartObj.plotarea.left,
        rectBoundTop = rectBound.top + chartObj.plotarea.top,
        currentPlotBound = getPlotBound(chartObj),
        left = currentPlotBound.left - adjust.left,
        top = currentPlotBound.top - adjust.top,
        right = currentPlotBound.right + adjust.left + adjust.right,
        bottom = currentPlotBound.bottom + adjust.top + adjust.bottom;

      applyFont(targetLabelGroup, [targetLabelOptions, systemconf.chart, systemconf.canvas, $ZCG]);
      var dataKeyFunc = function dataKeyFunc(d) {
        return dataset.getX(d);
      };
      var targetLabelText = appendEle(targetLabelGroup, 'text', dataUpdate, null, null, null, null, dataKeyFunc);
      targetLabelText.style('display', null);

      targetLabelText.each(function (d, i) {
        var targetValue = d[targetDataIndex];
        if (!defined(targetValue)) {
          return;
        }

        var xValue = dataset.getX(d),
          X,
          Y,
          DY,
          ANCHOR,
          TEXT = defined(targetLabelOptions.text) ?
          dataset.getCustomizedVal(chartObj, targetLabelOptions.text, 0, null, null, d, 'targetLabel') :
          getFormattedValue(formatConf, targetValue, datatype, chartObj, 'targetLabel'),
          isNeg = targetValue < 0,
          flip = isNeg ? -1 : 1;
        var x = commonOption.bandwidth1(xValue) + rangeBand / 2,
          y = yscale(targetValue);

        if (axisrotated) {
          X = y;
          Y = x;
          if (vAlign === BOTTOM_ALIGN) {
            Y += markerSize / 2;
            if (hAlign === CENTER_ALIGN) {
              DY = '1em';
              Y = x + (isFixedPosition ? rangeBand : markerSize) / 2;
            }
          } else if (vAlign === CENTER_ALIGN) {
            DY = '0.3em';
          } else if (vAlign === TOP_ALIGN) {
            Y -= markerSize / 2;
            if (hAlign === CENTER_ALIGN) {
              DY = '-0.3em';
              Y = x - (isFixedPosition ? rangeBand : markerSize) / 2;
            } else {
              DY = '1em';
            }
          }

          if (hAlign === CENTER_ALIGN) {
            ANCHOR = 'middle';
            Y -= vAlign === CENTER_ALIGN ? 0 : vAlign === TOP_ALIGN ? padding * flip : -(padding * flip);
          } else {
            if (hAlign === RIGHT_ALIGN) {
              X += (padding + markerSizeAdjust) * flip;
              ANCHOR = isNeg ? 'end' : null;
            } else {
              X -= (padding + markerSizeAdjust) * flip;
              ANCHOR = isNeg ? null : 'end';
            }
          }
        } else {
          X = x;
          Y = y;
          if (hAlign === RIGHT_ALIGN) {
            X += (isFixedPosition ? rangeBand : markerSize) / 2;
          } else if (hAlign === CENTER_ALIGN) {
            ANCHOR = 'middle';
          } else if (hAlign === LEFT_ALIGN) {
            X -= (isFixedPosition ? rangeBand : markerSize) / 2;
            ANCHOR = 'end';
          }

          if (vAlign === CENTER_ALIGN) {
            X += hAlign === CENTER_ALIGN ? 0 : hAlign === RIGHT_ALIGN ? padding : -padding;
            DY = '0.3em';
          } else if (vAlign === TOP_ALIGN) {
            Y -= (padding + markerSizeAdjust) * flip;
            DY = '-0.3em';
          } else {
            Y += (padding + markerSizeAdjust) * flip;
            DY = '1em';
          }
        }

        d3_select(this).
        attrs({
          transform: "translate(".concat(X, ",").concat(Y, ")"),
          'text-anchor': ANCHOR,
          dy: DY
        }).
        text(TEXT);

        // label should be within container
        var b = this.getBoundingClientRect(),
          leftPos = b.left - rectBoundLeft,
          rightPos = leftPos + b.width,
          topPos = b.top - rectBoundTop,
          bottomPos = topPos + b.height;

        if (textOverlap !== 'none') {
          var ele = d3_select(this),
            obj = {
              id: "lbl".concat(options.rendererIndex, "_0_").concat(options.subIndex, "_").concat(i),
              translateFunction: function translateFunction(id, translateX, translateY, hide) {
                if (hide) {
                  ele.style('display', 'none');
                } else {
                  ele.attr('transform', "translate(".concat(X + translateX, ",").concat(Y + translateY, ")"));
                }
              },
              x1: leftPos,
              y1: topPos,
              x2: rightPos,
              y2: bottomPos,
              overlap: textOverlap,
              priority: 1
            };
          labelArray.push(obj);
          labelArray.accessor = function (a, b) {return d3_ascending(a.priority || 0, b.priority || 0);};
          labelArray.align = 'vertical';
        }

        var newX = X + (leftPos < left ? left - leftPos : rightPos > right ? -(rightPos - right) : 0),
          newY = Y + (topPos < top ? top - topPos : bottomPos > bottom ? -(bottomPos - bottom) : 0);

        if (newX != X) {
          X = newX;
        }

        if (newY != Y) {
          Y = newY;
        }

        d3_select(this).attr('transform', "translate(".concat(X, ",").concat(Y, ")"));
      });
    }

    LabelRegistry.add('bullet', targetLabel);

    function executeMarkOperators(data, mapping, operators, customOperators) {var _this23 = this;
      var _this = this,
        _marks = new Array(0);
      operators.map(function (d) {
        var _thisTrack = mapping[d];
        if (_thisTrack) {
          var condition = _thisTrack.condition ? _thisTrack.condition.call(_this) : true,
            customOperator = customOperators && customOperators[d],
            mark,
            holder = _thisTrack.holder ? _thisTrack.holder.call(_this) : null;
          if (customOperator && customOperator.parser) {
            mark = invokeFunction(customOperator.parser, _this23, data, 'render', condition);
          } else {
            mark = _thisTrack.operator.call(_this23, data, 'render', condition);
          }

          if (customOperator && customOperator.extender) {
            mark = invokeFunction(customOperator.extender, _this23, mark);
          }
          _marks.push({
            mark: mark,
            holder: holder
          });
        } else {
          throw 'Mark operator is not defined';
        }
      });
      return _marks;
    }

    function datalabel_style() {
      var KEY = 'label';
      var _this = this,
        chart = _this.chart,properties = _this.properties,dataLevelFontColor = _this.dataLevelFontColor,dataLevelStrokeColor = _this.dataLevelStrokeColor,
        _sereisInfo = _this.subSeries;

      _this.helpers.styles[KEY] = {
        fill: function fill(d, i) {
          if (this.ctype === charttype.waterfall && dataLabels.fontColor !== undefined && dataLabels.fontColor == NULL$1) {
            var color = colorscale_helpers.getWaterfallColor(d, properties.rp.categoryColorConfig);
            if (color) {
              return color;
            }
          }
          var y = dataLevelFontColor;
          return y && y(d, i);
        },
        display: function display(d, i) {
          return _sereisInfo[i].display === false ? NONE : null;
        },
        opacity: function opacity(d, i) {
          if (chart.dataObject.hierarchical && chart.cache.hierarchical) {
            return getOpacityForTickFilterElements(d, i, chart, 'label', _this.actualData);
          }
        },
        'stroke-width': function strokeWidth(data, i, isOutlineText) {
          if (isOutlineText) {
            return _this.properties.dataLabels.strokeWidth;
          }
        },
        'filtered-opacity': function filteredOpacity(d, i) {
          if (chart.dataObject.hierarchical && chart.cache.hierarchical) {
            return getOpacityForTickFilterElements(d, i, chart, 'label', _this.actualData);
          }
        },
        dy: function dy(d, i) {
          return _sereisInfo[i].DY;
        },
        'text-anchor': function textAnchor(d, i) {
          return _sereisInfo[i].ANCHOR;
        },
        id: function id(d, i) {
          return _sereisInfo[i].ID;
        },
        'clip-path': function clipPath(d, i) {
          var bb = bbox(this);
          var properties = {
              name: 'textClip',
              id: chart.id,
              x: bb.x,
              y: bb.y,
              width: _sereisInfo[i].width,
              height: bb.height
            },
            args = {
              chart: chart
            };
          var clipID = effects.get(effects.svg_clips, 'rect', properties, args);
          return "url(".concat(chart.defsLocation, "#").concat(clipID, ")");
        },
        levelbycolumn: function levelbycolumn(_d, i) {
          var d = _this.actualData ? _this.actualData[_this.actualData.length - 1 - i] : _d.data || _d;
          if (d.levelByColumn) {
            return d.levelByColumn;
          }
        },
        levelbyrow: function levelbyrow(_d, i) {
          var d = _this.actualData ? _this.actualData[_this.actualData.length - 1 - i] : _d.data || _d;
          if (d.levelByRow) {
            return d.levelByRow;
          }
        },
        stroke: function stroke(needStroke) {
          var strokeColor = _this.properties.dataLabels.strokeColor;
          if (needStroke) {
            // apply datalabels contrast color
            if (strokeColor === 'contrast') {
              return function (d, i) {
                var clr = dataLevelFontColor ? dataLevelFontColor(d, i) : _this.datalabelOptions.fill;
                return getContrastColor(clr);
              };
            } else {
              return _this.dataLevelStrokeColor;
            }
          }
        }
      };

      _this.helpers.text[KEY] = function (d, i) {
        var str = _sereisInfo[i].text;
        return str;
      };
    }
    function datalabel_position() {var _this24 = this;
      var KEY = 'label';
      var _this = this,
        _sereisInfo = _this.subSeries,
        chart = _this.chart,
        properties = _this.properties,
        rotation = properties.rotation;

      _this.helpers.position[KEY] = {};

      _this.helpers.position[KEY].start = {};
      _this.helpers.position[KEY].stop_1 = {};
      _this.helpers.position[KEY].end = {};

      var isMultiLineAnimation = _this.properties.isMultiLine && _this.animate || _this.animate; //if renderOnInit is true, it means animation is enabled.
      //if isMultiLineAnimation is true - translate will be set to transform to position the label, and all x,y will be set to 0

      _this.helpers.position[KEY].start.transform = function (d, i) {
        var val = '',
          _s = _sereisInfo[i],
          rotation = properties.rotation,
          pos = _s.xy || [_s.X, _s.Y],
          plotH = chart.plotarea.height;

        if (chart.axes.rotated) {
          pos = _s.xy && [0, _s.xy[1]] || [0, _s.Y];
        } else {
          pos = _s.xy && [_s.xy[0], plotH] || [_s.X, plotH];
        }
        if (_s.xy) {
          val = "translate(".concat(pos, ")");
        }
        if (isMultiLineAnimation) {
          if (defined(rotation)) {
            val = "translate(".concat(pos, ") rotate(").concat(rotation, ")");
          } else {
            val = "translate(".concat(pos, ")");
          }
        } else if (defined(rotation)) {
          val += "rotate(".concat(rotation, " ").concat(pos, ")");
        }
        return val || NULL$1;
      };
      _this.helpers.position[KEY].start.x = function (d, i) {
        var _s = _sereisInfo[i];
        if (isMultiLineAnimation) {
          return 0;
        }
        if (chart.axes.rotated) {
          return 0;
        }
        return _s.xy && _s.xy[0] || _s.X;
      };
      _this.helpers.position[KEY].start.y = function (d, i) {
        var _s = _sereisInfo[i];
        if (isMultiLineAnimation) {
          return 0;
        }
        if (chart.axes.rotated) {
          return _s.xy && _s.xy[1] || _s.Y;
        }
        return chart.plotarea.height;
      };

      _this.helpers.position[KEY].end.transform = function (d, i) {
        var val = '',
          rotation = properties.rotation,
          _s = _sereisInfo[i],
          pos = _s.xy || [_s.X, _s.Y],
          _minDist,
          isRotation_pos;

        if (defined(rotation)) {
          _minDist = 360 - rotation, isRotation_pos = rotation > 0;
          rotation = _minDist < rotation ? isRotation_pos ? -_minDist : _minDist : rotation;
        }

        if (_s.xy) {
          val = "translate(".concat(pos, ")");
        }
        if (isMultiLineAnimation) {
          if (defined(rotation)) {
            val = "translate(".concat(pos, ") rotate(").concat(rotation, ")");
          } else {
            val = "translate(".concat(pos, ")");
          }
        } else if (defined(rotation)) {
          val += "rotate(".concat(rotation, " ").concat(pos, ")");
        }

        return val || NULL$1;
      };
      _this.helpers.position[KEY].end.x = function (d, i) {
        var _s = _sereisInfo[i],
          rotation = properties.rotation;
        if (isMultiLineAnimation) {
          return 0;
        }
        return _s.X;
      };
      _this.helpers.position[KEY].end.y = function (d, i) {
        var _s = _sereisInfo[i],
          rotation = properties.rotation;
        if (isMultiLineAnimation) {
          return 0;
        }
        return _s.Y;
      };

      _this.helpers.position[KEY].stop_1.transform = function (d, i, ele) {
        var _s = _sereisInfo[i],
          val = '',
          eleInfo = $ZC.get('domUtils.getSvgTransform')(ele),
          pos = _s.xy || [_s.X, _s.Y],
          _rot = eleInfo.rotate;

        if (chart.axes.rotated) {
          var _x = Number(ele.getAttribute('x')) || eleInfo.translate[0];
          if (_s.xy) {
            val = "translate(".concat([_x, pos[1]], ")");
          }
          if (isMultiLineAnimation) {
            if (defined(rotation)) {
              val = "translate(".concat([_x, pos[1]], ") rotate(").concat(rotation, ")");
            } else {
              val = "translate(".concat([_x, pos[1]], ")");
            }
          } else if (defined(_rot)) {
            val += "rotate(".concat(_rot, " ").concat([_x, pos[1]], ")");
          }
        } else {
          var _y = Number(ele.getAttribute('y')) || eleInfo.translate[1];
          if (_s.xy) {
            val = "translate(".concat([pos[0], _y], ")");
          }
          if (isMultiLineAnimation) {
            if (defined(rotation)) {
              val = "translate(".concat([pos[0], _y], ") rotate(").concat(rotation, ")");
            } else {
              val = "translate(".concat([pos[0], _y], ")");
            }
          } else if (defined(_rot)) {
            val += "rotate(".concat(_rot, " ").concat([pos[0], _y], ")");
          }
        }
        return val || NULL$1;
      };
      _this.helpers.position[KEY].stop_1.x = function (d, i, ele) {
        var _s = _sereisInfo[i],
          pos = _s.X,
          eleInfo = $ZC.get('domUtils.getSvgTransform')(ele),
          _rot = eleInfo.rotate;

        if (isMultiLineAnimation) {
          return 0;
        }

        if (_this24.chart.axes.rotated) {
          return ele.getAttribute('x');
        } else {
          return pos;
        }
      };
      _this.helpers.position[KEY].stop_1.y = function (d, i, ele) {
        var _s = _sereisInfo[i],
          pos = _s.Y,
          eleInfo = $ZC.get('domUtils.getSvgTransform')(ele),
          _rot = eleInfo.rotate;

        if (isMultiLineAnimation) {
          return 0;
        }
        if (_this24.chart.axes.rotated) {
          return pos;
        } else {
          return ele.getAttribute('y');
        }
      };

      _this.helpers.position[KEY].dy = function (d, i) {
        var _s = _sereisInfo[i];
        return _s.DY;
      };
    }
    function racingLabel_position() {
      var KEY = 'racingLabel';
      var _this = this,
        _sereisInfo = _this.subSeries,
        chart = _this.chart,
        properties = _this.properties;

      _this.helpers.position[KEY] = {};

      _this.helpers.position[KEY].start = {};
      _this.helpers.position[KEY].exit = {};
      _this.helpers.position[KEY].end = {};

      _this.helpers.position[KEY].end.transform = function (d, i) {
        var _s = _sereisInfo[i],
          pos = _s.xy || [_s.X, _s.Y],
          rotation = properties.rotation,
          val = '',
          _minDist,
          isRotation_pos;

        if (defined(rotation)) {
          _minDist = 360 - rotation, isRotation_pos = rotation > 0;
          rotation = _minDist < rotation ? isRotation_pos ? -_minDist : _minDist : rotation;
        }
        val = "translate(".concat(pos, ")");
        if (defined(rotation)) {
          val = "translate(".concat(pos, ") rotate(").concat(rotation, ")");
        }
        return val;
      };

      _this.helpers.position[KEY].start.transform = function (d, i) {
        var _s = _sereisInfo[i],
          pos = _s.xy || [_s.X, _s.Y],
          rotation = properties.rotation,
          val = '',
          plotH = chart.plotarea.height;
        val = "translate(".concat([pos[0], plotH + 20], ")");
        if (defined(rotation)) {
          val = "translate(".concat([pos[0], plotH + 20], ") rotate(").concat(rotation, ")");
        }
        return val;
      };

      _this.helpers.position[KEY].exit.transform = function (d, i, ele) {
        var eleInfo = $ZC.get('domUtils.getSvgTransform')(ele),
          plotH = chart.plotarea.height,
          _rot = eleInfo.rotate,
          transX = eleInfo.translate[0];

        var val = "translate(".concat([transX, plotH + 20], ")");
        if (defined(_rot)) {
          val = "translate(".concat([transX, plotH + 20], ") rotate(").concat(_rot, ")");
        }

        return val;
      };
    }
    function boundBox_position() {
      var KEY = 'boundBox';
      var _this = this,
        _sereisInfo = _this.subSeries,
        chart = _this.chart,
        properties = _this.properties;

      _this.helpers.position[KEY] = {};

      _this.helpers.position[KEY].start = {};
      _this.helpers.position[KEY].stop_1 = {};
      _this.helpers.position[KEY].end = {};

      _this.helpers.position[KEY].start.transform = function (d, i) {
        var _s = _sereisInfo[i],
          pos = _s.xy || [_s.X, _s.Y],
          rotation = properties.rotation,
          plotH = chart.plotarea.height,
          val = '';

        if (chart.axes.rotated) {
          pos = _s.xy && [0, _s.xy[1]] || [0, _s.Y];
        } else {
          pos = _s.xy && [_s.xy[0], plotH] || [_s.X, plotH];
        }
        val = "translate(".concat(pos, ")");
        if (defined(rotation)) {
          val = "translate(".concat(pos, ") rotate(").concat(rotation, ")");
        }
        return val;
      };

      _this.helpers.position[KEY].stop_1.transform = function (d, i, ele) {
        var _s = _sereisInfo[i],
          pos = _s.xy || [_s.X, _s.Y],
          val = '',
          eleInfo = $ZC.get('domUtils.getSvgTransform')(ele),
          _rot = eleInfo.rotate;

        if (chart.axes.rotated) {
          var transX = eleInfo.translate[0];
          val = "translate(".concat([transX, pos[1]], ")");
          if (defined(_rot)) {
            val = "translate(".concat([transX, pos[1]], ") rotate(").concat(_rot, ")");
          }
        } else {
          var transY = eleInfo.translate[1];
          val = "translate(".concat([pos[0], transY], ")");
          if (defined(_rot)) {
            val = "translate(".concat([pos[0], transY], ") rotate(").concat(_rot, ")");
          }
        }

        return val;
      };

      _this.helpers.position[KEY].end.transform = function (d, i) {
        var _s = _sereisInfo[i],
          pos = _s.xy || [_s.X, _s.Y],
          rotation = properties.rotation,
          val = '',
          _minDist,
          isRotation_pos;

        if (defined(rotation)) {
          _minDist = 360 - rotation, isRotation_pos = rotation > 0;
          rotation = _minDist < rotation ? isRotation_pos ? -_minDist : _minDist : rotation;
        }
        val = "translate(".concat(pos, ")");
        if (defined(rotation)) {
          val = "translate(".concat(pos, ") rotate(").concat(rotation, ")");
        }

        return val;
      };
    }
    function boundBox_style() {
      var KEY = 'boundBox';
      var _this = this,
        _sereisInfo = _this.subSeries,chart = _this.chart,properties = _this.properties,labelType = _this.datalabel_type,isPolarAxisCategory = _this.isPolarAxisCategory,isAxisCategory = _this.isAxisCategory,
        config = properties.dataLabels,isMultiLine = properties.isMultiLine,chartType = properties.chartType,
        boundboxOptions = getMergedBoundBoxOptions(config, chart),
        hookOptions = getBoundBoxHookConf(boundboxOptions.hook),
        globalDataUpdate = properties.dataUpdate,
        padding = getBoundBoxPadding(config, chart),
        r = getBorderRadius(boundboxOptions.radius),
        strokeWidth = defined(boundboxOptions.strokeWidth) ? +boundboxOptions.strokeWidth : 1,
        strokeDashArray = getDashArray(boundboxOptions.dashStyle, strokeWidth),
        strokeLineCap = getLineCap(boundboxOptions.lineCap, boundboxOptions.dashStyle),
        heightAdjustScale = d3_scaleLinear(),
        plotarea = chart.plotarea,
        trans = properties.trans || [0, 0],
        edge = {
          left: -trans[0] + plotarea.left,
          right: plotarea.width - trans[0] - plotarea.left
        };
      _this.helpers.styles[KEY] = {
        display: function display(d, i, args) {
          return hasBoundBox(_sereisInfo[i]) ? null : NONE;
        },
        fill: function fill(d, i, args) {
          var fillColor = getBoundBoxColor(boundboxOptions.fillColor, properties, chart, globalDataUpdate, args.legendOrder);
          return invokeFunction(fillColor, d, getMetaConfigForBoundbox(i, args.legendOrder, properties), chart);
        },
        'fill-opacity': boundboxOptions.fillOpacity,
        stroke: function stroke(d, i, args) {
          var strokeColor = getBoundBoxColor(boundboxOptions.strokeColor, properties, chart, globalDataUpdate, args.legendOrder);
          return invokeFunction(strokeColor, d, getMetaConfigForBoundbox(i, args.legendOrder, properties), chart);
        },
        'stroke-opacity': boundboxOptions.strokeOpacity,
        'stroke-dasharray': strokeDashArray,
        'stroke-linecap': strokeLineCap,
        transition: 'opacity ease .2s',
        opacity: function opacity(d, i, args) {
          if (defined(chart.dataObject.hierarchical) && defined(chart.cache.hierarchical)) {
            var cache = chart.cache.hierarchical;
            if (cache.active) {
              if (d.active === true) {
                return 1;
              } else {
                return 0.1;
              }
            }
          }
        },
        strokeWidth: boundboxOptions.strokeWidth,
        d: function d(_d7, i, args) {
          var point = _sereisInfo[i],
            xy = point.xy || [point.X, point.Y];
          // var x = - padding,
          //     y = - padding,
          var x = xy[0] - padding,
            y = xy[1] - padding,
            w = point.width,
            h = point.height,
            dy = point.actualDY !== undefined ? point.actualDY : parseFloat(point.DY) || 0,
            anchor = point.ANCHOR,
            hookPosition = point.hookPosition,
            dyHeight =
            args.labelType === DATALABELS_LABELTYPE &&
            arrayIncludes([charttype.funnel, charttype.pyramid], chartType) &&
            defined(config.y) &&
            isMultiLine ?
            properties.txtHgt :
            h;
          x = anchor === 'middle' ? x - w / 2 : anchor === 'end' ? x - w : x;
          y = y - heightAdjustScale.domain([-0.3, 0.9]).range([dyHeight, 0])(dy);

          if (!isAxisCategory && !isPolarAxisCategory && properties.type !== 'hierarchy') {
            if (x < edge.left) {
              w -= edge.left - x + strokeWidth / 2 + padding;
              x = edge.left + strokeWidth / 2;
            }
            if (x + w + strokeWidth / 2 + padding > edge.right) {
              w -= x + w - edge.right + strokeWidth / 2 + padding * 2;
              // if ((x + w) > edge.right) {
              //     w -= (x + w + padding - edge.right);
            }
            x += (boundboxOptions.strokeWidth || 1) * (hookPosition === RIGHT_ALIGN ? 0.5 : hookPosition === LEFT_ALIGN ? -0.5 : 0);
          }
          x = x - xy[0];
          y = y - xy[1];
          return getBoundBoxPathDescription(x, y, w, h, r, padding, hookPosition, hookOptions, point.adjustVal);
        },
        id: function id(dt, j) {
          return "boundbox".concat(_sereisInfo[j].ID);
        },
        levelbycolumn: function levelbycolumn(_d, i) {
          var d = _this.actualData ? _this.actualData[_this.actualData.length - 1 - i] : _d.data || _d;
          if (d.levelByColumn) {
            return d.levelByColumn;
          }
        },
        levelbyrow: function levelbyrow(_d, i) {
          var d = _this.actualData ? _this.actualData[_this.actualData.length - 1 - i] : _d.data || _d;
          if (d.levelByRow) {
            return d.levelByRow;
          }
        }
      };
    }

    function datalabel_encode_collectors() {
      datalabel_position.call(this);
      datalabel_style.call(this);
      racingLabel_position.call(this);
      boundBox_position.call(this);
      boundBox_style.call(this);
    }

    var ZC_DATALABEL_MARKS_MAPPING = function ZC_DATALABEL_MARKS_MAPPING() {
      var mapping = {
        datalabel: {
          operator: MarksRegistry.get('datalabel.default')
        }
      };
      return mapping;
    };

    function datalabel_parser_helpers() {
      var _this = this,

        chart =









        _this.chart,properties = _this.properties,isPolar = _this.isPolar,isHierarchy = _this.isHierarchy,isNonAxisMultiSeriesCategory = _this.isNonAxisMultiSeriesCategory,isAxisCategory = _this.isAxisCategory,isTreemap = _this.isTreemap,isInnerLabel = _this.isInnerLabel,index = _this.index,hasColorScale = _this.hasColorScale,
        rp = this.builderC,
        dataLabels = properties.dataLabels,reverseColor = properties.reverseColor,globalDataUpdate = properties.dataUpdate,
        legendOrderIndex = isFacet(chart) ? rp.legendOrderIndex : index,
        data_length = isAxisCategory || isPolar ? NULL$1 : globalDataUpdate.length,
        dataLevelColor = NULL$1;

      _this.dataLevelFontColor = NULL$1;
      _this.dataLevelStrokeColor = NULL$1;

      _this.helpers = {
        position: {},
        styles: {},
        text: {}
      };

      if (
      hasColorScale ||
      rp.threshold ||
      isHierarchy ||
      !((isAxisCategory || chart.isGeoMap || isPolar || isNonAxisMultiSeriesCategory) && !properties.multiColoring))
      {
        dataLevelColor = function dataLevelColor(styleName) {
          return function (d, k) {
            var clrIndex = reverseColor ?
              data_length - 1 - k :
              (isAxisCategory || isPolar || isNonAxisMultiSeriesCategory) && !properties.multiColoring ?
              index :
              k,
              clr = getRawColor(chart, clrIndex, d && d.data ? d.data : d, legendOrderIndex),
              options = properties.isSunburst && properties.parentInnerLabel && d.children ? properties.parentInnerLabel : dataLabels,
              paneid = ((d && d.data ? d.data : d) || []).paneid;

            if (isTreemap && isInnerLabel && /(top-outset|bottom-outset)/.test(options.position) && d3_rgb(clr).opacity < 0.1) {
              clr = 'white';
            }

            return getLabelFontColor(chart.systemConf, clr, options, chart, isInnerLabel, index, undefined, styleName, paneid);
          };
        };
        _this.dataLevelFontColor = dataLevelColor('fontColor');
        _this.dataLevelStrokeColor = dataLevelColor('strokeColor');
      }
    }var

    DatalabelRenderer = /*#__PURE__*/function () {
      function DatalabelRenderer(args) {_classCallCheck(this, DatalabelRenderer);
        var
          datalabel_type =














          args.datalabel_type,ctype = args.ctype,chart = args.chart,dataUpdate = args.dataUpdate,actualData = args.actualData,properties = args.properties,builderC = args.builderC,rendererIndex = args.rendererIndex,subSeries = args.subSeries,index = args.index,subseriesIdx = args.subseriesIdx,datalabelOptions = args.datalabelOptions,commonOptions = args.commonOptions,options = args.options,operator = args.operator;
        this.datalabel_type = datalabel_type;
        this.ctype = ctype;
        this.chart = chart;
        this.dataUpdate = dataUpdate;
        this.actualData = actualData;
        this.conf = chart.rendererConf[rendererIndex];
        this.properties = properties;
        this.rendererIndex = rendererIndex;
        this.builderC = builderC;
        this.subSeries = subSeries;
        this.index = index;
        this.subseriesIdx = subseriesIdx;
        this.datalabelOptions = datalabelOptions;
        this.commonOptions = commonOptions.datalabels;
        this.options = options.datalabels;
        this.markOperator = operator;
        this.animate = this.commonOptions.animation && this.commonOptions.animation.enabled || this.options.animation && this.options.animation.enabled;
        this.isStackedLabel = datalabel_type === 'stacklabel';
        this.isInnerLabel = datalabel_type === INNERLABEL_LABELTYPE || datalabel_type === PARENTLABELS_LABELTYPE;
        this.hasColorScale = colorscale_helpers.isQuantileColorScale(chart);
        this.isPolar = isCategoryOf(chart, properties.chartType, 'polarAxis'),
        this.isHierarchy = isCategoryOf(chart, properties.chartType, 'hierarchy'),
        this.isNonAxisMultiSeriesCategory = isCategoryOf(chart, properties.chartType, 'nonAxisMultiSeries'),
        this.isAxisCategory = isCategoryOf(chart, properties.chartType, 'axis'),
        this.isTreemap = properties.chartType == charttype.treemap,
        this.isPolarAxisCategory = isCategoryOf(chart, properties.chartType, 'polarAxis');
        this.isPackedBubble = properties.chartType == charttype.packedbubble,
        this.isRedraw = this.conf.parser && this.conf.parser.phase || chart.redraw;
        this.setMarkMapping();
      }_createClass(DatalabelRenderer, [{ key: "initialize", value:
        function initialize(container) {
          this.container = container;
          datalabel_parser_helpers.call(this);
          this.renderInfo = this.chart.renderer[this.rendererIndex].commonRendererProp().params; //getDatalabelCommonOption(this.conf, this.rendererIndex, this.legendOrder, this.paneid);
          this.scales = {
            x: this.renderInfo.xscale,
            y: this.renderInfo.yscale
          };
          this.collectEncode();
        } }, { key: "collectEncode", value:
        function collectEncode() {
          datalabel_encode_collectors.call(this);
        } }, { key: "getAllowedMarkOperator", value:
        function getAllowedMarkOperator() {
          return ["datalabel"];
        } }, { key: "getDefaultMarkParser", value:
        function getDefaultMarkParser() {
          var operators = this.getAllowedMarkOperator(),
            markMapping = this.markMapping,
            customOperator = this.markOperator;
          this._mark = executeMarkOperators.call(this, this.data, markMapping, operators, customOperator);
        } }, { key: "setMarkMapping", value:
        function setMarkMapping(mapping) {
          this.markMapping = (mapping || ZC_DATALABEL_MARKS_MAPPING).call(this);
        } }, { key: "render", value:
        function render(parent) {
          this._mark.map(function (d) {
            renderDom(d.mark, parent);
          });
        } }]);return DatalabelRenderer;}();


    function pointTravel(chartObj, array) {
      var dataObj = chartObj.dataObject;

      var isContinousChart = dataObj.isContinousChart,
        length = array.length,
        translateOrders = {
          top: ['hidden', 'topPlus', 'right', 'bottom', 'left'],
          bottom: ['hidden', 'right', 'left']
        };

      var currentPlotBound = getPlotBound(chartObj);
      var plotbound = {
        x1: currentPlotBound.left,
        y1: currentPlotBound.top,
        x2: currentPlotBound.right,
        y2: currentPlotBound.bottom
      };

      array = isContinousChart ? array.sort(function (a, b) {return d3_ascending(a.x1, b.x1);}) : array;
      for (var i = 1; i < length; i++) {
        var bool = 0,
          overlap = false,
          testCase = 0,
          factor = pick(array[i].factor, 1),
          radius = (array[i].pointRadius || 0) * factor,
          x1 = array[i].x1,
          y1 = array[i].y1,
          x2 = array[i].x2,
          y2 = array[i].y2,
          w = array[i].x2 - array[i].x1,
          h = array[i].y2 - array[i].y1,
          orient = pick(array[i].orient, 'top'),
          translateOrder = translateOrders[orient],
          previousLabels = array.slice(0, i),
          currentLabel,
          isHidden,
          newHookPosition;
        previousLabels = isContinousChart ? previousLabels.reverse() : previousLabels;

        do {
          //testCase 0 : actual position, testCase 1 : top, testCase 2 : right, testCase 3 : bottom, testCase 4 : left
          var currentStep = translateOrder[testCase];

          switch (currentStep) {
            case 'hidden':
              currentLabel = array[i];
              isHidden = currentLabel.overlap === 'hidden' || dataObj.isBubbleEnabled;
              break;
            case 'topPlus':
              currentLabel.y1 = y1 - h / 2, currentLabel.y2 = y2 - h / 2;
              newHookPosition = BOTTOM_ALIGN;
              break;
            case 'right':
              currentLabel.x1 = (x1 + x2) / 2 + radius;
              currentLabel.x2 = (x1 + x2) / 2 + radius + w;
              currentLabel.y1 = y2 + 1;
              currentLabel.y2 = y2 + h + 1;
              newHookPosition = LEFT_ALIGN;
              break;
            case 'bottom':
              currentLabel.x1 = x1;
              currentLabel.x2 = x2;
              currentLabel.y1 = y2 + 2 * (radius + 1);
              currentLabel.y2 = y2 + 2 * (radius + 1) + h;
              newHookPosition = TOP_ALIGN;
              break;
            case 'left':
              currentLabel.x1 = (x1 + x2) / 2 - radius - w;
              currentLabel.x2 = (x1 + x2) / 2 - radius;
              currentLabel.y1 = y2 + 1;
              currentLabel.y2 = y2 + h + 1;
              newHookPosition = RIGHT_ALIGN;
              break;}

          for (var index = i - 1; index >= 0; index--) {
            overlap = doOverlap(previousLabels[index], currentLabel);
            if (overlap) {
              bool++;
              break;
            }
          }
        } while (++testCase < 5 && overlap);
        if (bool != 0) {
          var isWithInPlot = dataObj.isPolarAxisCategory ? true : isLabelWithinBound(currentLabel, plotbound), //For web chart, within plot boundary check is not necessary
            translateFunc = array[i].translateFunction,
            id = array[i].id,
            isStackedLabels = array[i].isStackedLabels;

          if (!isWithInPlot || bool == 5 || isHidden) {
            translateFunc(id, null, null, true, UNDEFINED, UNDEFINED, isStackedLabels ? STACKLABELS_LABELTYPE : DATALABELS_LABELTYPE);
            array[i].x1 = array[i].y1 = array[i].x2 = array[i].y2 = 0;
          } else {
            var translateX = currentLabel.x1 - x1,
              translateY = currentLabel.y1 - y1;
            translateFunc(
            id,
            translateX,
            translateY,
            null,
            undefined,
            newHookPosition,
            isStackedLabels ? STACKLABELS_LABELTYPE : DATALABELS_LABELTYPE);

          }
        }
      }
    }

    //

    function stepTravel(chartObj, array) {
      var length = array.length;

      var currentPlotBound = getPlotBound(chartObj);
      var plotbound = {
        x1: currentPlotBound.left,
        y1: currentPlotBound.top,
        x2: currentPlotBound.right,
        y2: currentPlotBound.bottom
      };

      var axisrotated = chartObj.axes.rotated,
        prevSortAccessor = function prevSortAccessor(a, b) {return axisrotated ? d3_descending(a.x1, b.x1) : d3_ascending(a.y1, b.y1);},
        sortAccessor = array.accessor || function (a, b) {return axisrotated ? d3_descending(a.y1, b.y1) : d3_ascending(a.x1, b.x1);},
        align = array.align || (axisrotated ? 'horizontal' : 'vertical');

      array.sort(sortAccessor);

      for (var i = 0; i < length; i++) {
        var bool = false,
          overlappingCount = 0,
          translateValue = 0,
          x = array[i].x1,
          y = array[i].y1,
          currentLabel = array[i],
          previousLabels = array.slice(0, i).sort(prevSortAccessor);
        var isHidden = currentLabel.overlap === 'hidden';
        for (var index = i - 1; index >= 0 && overlappingCount < 2; index--) {
          var overlap = doOverlap(previousLabels[index], currentLabel);
          if (overlap) {
            if (align === 'horizontal') {
              translateValue = previousLabels[index].x2 - currentLabel.x1;
              currentLabel.x2 += translateValue;
              currentLabel.x1 += translateValue;
            } else {
              translateValue = previousLabels[index].y1 - currentLabel.y2;
              currentLabel.y2 += translateValue;
              currentLabel.y1 += translateValue;
            }
            overlappingCount++;
          }
          bool = bool || overlap;
        }
        if (bool) {
          var isWithInPlot = isLabelWithinBound(currentLabel, plotbound),
            translateFunc = array[i].translateFunction,
            id = array[i].id,
            isStackedLabels = array[i].isStackedLabels;

          if (!isWithInPlot || overlappingCount > 1 || isHidden) {
            translateFunc(id, null, null, true, UNDEFINED, UNDEFINED, isStackedLabels ? STACKLABELS_LABELTYPE : DATALABELS_LABELTYPE);
            array[i].x1 = array[i].y1 = array[i].x2 = array[i].y2 = 0;
          } else {
            var translateX = currentLabel.x1 - x,
              translateY = currentLabel.y1 - y;
            translateFunc(
            id,
            translateX,
            translateY,
            UNDEFINED,
            UNDEFINED,
            UNDEFINED,
            isStackedLabels ? STACKLABELS_LABELTYPE : DATALABELS_LABELTYPE);

          }
        }
      }
    }

    //$Id$

    function arrange(slot, TOP, slotCount, slottedCount) {
      var leftUnslotted = [],
        unslotted = [],
        remaining = [],
        remainingCount = slotCount - slottedCount,
        sortByDist = function sortByDist(a, b) {
          return a.dist - b.dist;
        },
        sortByY = function sortByY(a, b) {
          return a[0].y1 - b[0].y1;
        };
      var remainingCount_copy = remainingCount;

      //Collect free slot indices
      for (var i = 0; i < slotCount; i++) {
        if (!slot[i]) {
          leftUnslotted.push(i);
        }
      }

      slot.forEach(function (d) {
        d.sort(sortByDist);
      });

      // Add all unslotted labels
      slot.forEach(function (d) {
        d.forEach(function (dt, i) {
          if (i != 0) {
            remaining[i] = remaining[i] || [];
            remaining[i].push(dt);
          }
        });
      });

      remaining.forEach(function (d) {
        d.sort(sortByDist);
      });

      remaining.forEach(function (d) {
        d.forEach(function (dt, i) {
          unslotted.push([dt]);
        });
      });

      unslotted.forEach(function (d, i) {
        if (remainingCount > 0) {
          remainingCount--;
        } else {
          d[0].hide = true;
        }
      });

      unslotted = unslotted.slice(0, remainingCount_copy);
      unslotted.sort(sortByY);

      unslotted.forEach(function (d) {
        var us = d[0];
        var height = us.y2 - us.y1;
        var co = mathMax(mathFloor((us.y1 - TOP) / height), 0);
        if (slot[co]) {
          var dist,
            pos = leftUnslotted[0],
            id = 0;
          for (var o = 0; o < leftUnslotted.length; o++) {
            var dst = mathAbs(TOP + leftUnslotted[o] * height - us.y1);
            if (dist == null) {
              dist = dst;
            }
            if (dst < dist) {
              dist = dst;
              pos = leftUnslotted[o];
              id = o;
            }
          }
          if (pos < co) {
            leftUnslotted.splice(id, 1);

            var prev = pos;
            slot.forEach(function (d, i) {
              var dt = d[0];
              if (i > pos && dt.y1 < us.y1) {
                slot[prev] = d;
                prev = i;
              }
            });

            slot[prev] = [us];
          } else {
            leftUnslotted.splice(id, 1);

            var prev = [us];
            for (var i = co; i <= pos; i++) {
              if (!slot[i]) {
                slot[i] = prev;
              } else if (slot[i][0].y1 > us.y1) {
                var temp = slot[i];
                slot[i] = prev;
                prev = temp;
              }
            }
          }
        } else {
          slot[co] = d;
        }
      });

      slot.forEach(function (d, i) {
        var dt = d[0];
        var height = dt.y2 - dt.y1;
        var dy = TOP + i * height - dt.y1;
        dt.translate = mathAbs(dy) < height && i + 1 < slotCount && !slot[i + 1] && dy < 0 ? 0 : dy;
      });
      // Some other way
      slot.forEach(function (d, i) {
        var dt = d[0];
        var height = dt.y2 - dt.y1;
        var dy = TOP + i * height - dt.y1;
        dt.translate =
        mathAbs(dy) < height && i + 1 < slotCount && (!slot[i + 1] || !slot[i + 1][0].translate) && dy < 0 ? dt.translate : dy;
      });
      // Some other way
    }

    function addToSlot(half, count, slot, TOP) {
      half.forEach(function (obj) {
        var height = obj.y2 - obj.y1;
        var co = mathMax(0, mathFloor((obj.y1 - TOP) / (obj.y2 - obj.y1)));
        obj.dist = obj.y1 < TOP ? TOP - obj.y1 : obj.y1 - (TOP + co * height);
        if (!slot[co]) {
          slot[co] = [];
          count++;
        }
        slot[co].push(obj);
      });
      return count;
    }

    function addToHalf(obj, slotCount, TOP, BOTTOM, prev, half, count, totalSpaceNeeded, reverse) {
      var MARGIN = 5;
      if (!obj.hide) {
        if (slotCount == null) {
          slotCount = mathFloor((BOTTOM - TOP) / (obj.y2 - obj.y1));
        }
        var dist = reverse // If (dist < 0), it is overlapping
        ? prev == null ?
        BOTTOM - obj.y2 :
        half[prev].y1 - obj.y2 :
        prev == null ?
        obj.y1 - TOP :
        obj.y1 - half[prev].y2;
        totalSpaceNeeded += prev != null && doOverlap(obj, half[prev]) && dist < -MARGIN ? mathAbs(dist) : 0;

        prev = count;
        half.push(obj);
        count++;
      }
      return {
        prev: prev,
        count: count,
        totalslot: slotCount,
        need: totalSpaceNeeded
      };
    }

    function slotTravel(chartObj, array, labelQueue) {
      var length = array.length;

      if (!length) {
        return;
      }

      var rightHalf = [],
        leftHalf = [],
        TOP = array.TOP,
        BOTTOM = array.BOTTOM,
        queue = array.queue,
        rightCount = 0,
        leftCount = 0,
        prevLeft,
        prevRight,
        rightSlot = [],
        leftSlot = [],
        rightCo = 0,
        leftCo = 0,
        totalRightSpaceNeeded = 0,
        totalLeftSpaceNeeded = 0,
        slotCount;

      array.forEach(function (d) {
        var isLeft = d.isLeft;
        if (isLeft) {
          // Collect left half labels
          var added = addToHalf(d, slotCount, TOP, BOTTOM, prevLeft, leftHalf, leftCount, totalLeftSpaceNeeded, true);
          slotCount = added.totalslot, prevLeft = added.prev, leftCount = added.count, totalLeftSpaceNeeded = added.need;
        } else {
          // Collect right half labels
          var added = addToHalf(d, slotCount, TOP, BOTTOM, prevRight, rightHalf, rightCount, totalRightSpaceNeeded);
          slotCount = added.totalslot, prevRight = added.prev, rightCount = added.count, totalRightSpaceNeeded = added.need;
        }
      });

      if (totalRightSpaceNeeded || totalLeftSpaceNeeded) {
        if (array.actualType === 'funnel') {
          rightHalf.reverse();
        }
        rightCo = addToSlot(rightHalf, rightCo, rightSlot, TOP);
        leftHalf.reverse();
        leftCo = addToSlot(leftHalf, leftCo, leftSlot, TOP);

        arrange(rightSlot, TOP, slotCount, rightCo);
        arrange(leftSlot, TOP, slotCount, leftCo);

        array.forEach(function (d) {
          chartObj.labelHandler.update(
          d.id,
          d.DX,
          d.translate || 0,
          d.hide,
          undefined,
          d.overlappingHookPosition,
          undefined,
          d.queue || queue);

        });

        if (isObjectPropDefined(queue, 'properties.onOverlap')) {
          var queues = splat(array.queues);
          queues.forEach(function (_) {return _.properties.onOverlap(_[array.subSeriesIndex]);});
          // queue.properties.onOverlap(queue[array.subSeriesIndex]);
        }
      } else {
        if (isObjectPropDefined(queue, 'properties.onNonOverlap')) {
          var _queues = splat(array.queues);
          _queues.forEach(function (_) {return _.properties.onNonOverlap(_[array.subSeriesIndex]);});
        }

        array.forEach(function (d) {
          chartObj.labelHandler.update(d.id, 0, 0, null, d.actualDY, undefined, undefined, d.queue || queue); // TODO: check for pivot
        });
      }
    }

    //

    function MeasureDataLabel(data, _args) {
      var config = _args.config,chartObj = _args.chartObj,renderMode = _args.renderMode,_args$accessor = _args.accessor,accessor = _args$accessor === void 0 ? dataLabelTextContent(chartObj, null, config) : _args$accessor,
        systemConfig = chartObj.systemConf,
        fullConfig = [config, systemConfig.chart.plot.datalabels, systemConfig.chart, systemConfig.canvas, $ZCG];

      return MeasureText(data, { config: fullConfig, accessor: accessor, renderMode: renderMode });
    }

    function MeasureText(data, _args) {
      var config = _args.config,renderMode = _args.renderMode,content = _args.accessor,
        contentType = content.contentType,multiLine = content.multiLine,
        renderDOM = contentType == 'html' || multiLine || renderMode === 'svg',
        element;
      config = splat(config);

      if (renderDOM) {
        element = createElement('text', '.dummy-text', [1], d3_selectAll('svg.svgPattern'));
        element.style('opacity', 0);
        applyFont(element, config);
      }

      var size = data.map(function (d, i) {
        var text = invokeFunction(content, d, i);
        if (renderDOM) {
          return getTextBoundByDOM(element, text, contentType, multiLine);
        } else {
          var font = applyFont(null, config),
            fontSize = defined(font['font-size']) ? parseFloat(font['font-size']) : null;
          return getTextBound(text, fontSize, font['font-family'], null, null, font['font-style'], font['font-weight']);
        }
      });

      if (element) {
        element.remove();
      }

      return size;
    }

    Registry.setComponent('dataLabel.measureText', MeasureDataLabel);

    function getLabeltype(config) {
      var showAs = config.showAs;
      if (LABELTYPES_AVAILABLE.has(showAs)) {
        return showAs;
      } else {
        var result = d3_map();
        showAs.toString().replace(CUSTOM_VALUE_PATTERN, function () {
          var matchedString = arguments[0],
            valIndex = arguments[1], //INDEX value of {{val(INDEX)}}
            colIndex = arguments[2], //INDEX value of {{col(INDEX)}}
            perIndex = arguments[3], //INDEX value of {{per(INDEX)}}
            splitPerIndex = arguments[4], //INDEX value of {{splitper(INDEX)}}
            maxPerIndex = arguments[5];
          var idx = valIndex || colIndex || perIndex || splitPerIndex || maxPerIndex;
          var operation = matchedString.match(/[a-z]+/gi)[0];
          if (result.has(operation)) {
            var arr = result.get(operation);
            arr.push(idx);
            result.set(operation, arr);
          } else {
            result.set(operation, [idx]);
          }
        });
        return result;
      }
    }

    //$Id$

    var DEFAULT_TEXT = 'qtyplkjhgfd';
    function preCalculation(type, serData, chartObj) {var evaluate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;var key = arguments.length > 4 ? arguments[4] : undefined;
      var operator = [];
      if (chartObj.dataObject.hasLevelMarker || !serData) {
        return 0;
      } // serData = undefined -> On legend filter, multi yaxes chart (numeric axis + ordinal axis)

      if (!isLabelsEnabledForChart(chartObj, type)) {
        return evaluate ? 0 : operator;
      }

      var sizeArray = [],
        systemconf = chartObj.systemConf,
        dataObj = chartObj.dataObject,
        axisrotated = chartObj.axes.rotated,
        stacked = dataObj.isstacked(),
        hasBarSeries = dataObj.noofBarEnabledSeries,
        dim = (axisrotated ? chartObj.plotarea.width : chartObj.plotarea.height) * 0.75,
        handleOverlap = systemconf.chart.plot.datalabels.handleOverlapping,
        isYaxis = type === 'y',
        labelRenderer = chartObj.datalabels.renderer ? chartObj.datalabels.renderer : chartObj.datalabels.renderer = [],
        isSankeyChart = chartObj.chartTypes[0].name === SANKEY_CHARTNAME,
        isFixed = function isFixed(i) {return isYaxis && hasBarSeries && !stacked && getValignforBarLabels(chartObj, i) === FIXEDTOP_ALIGN;},
        getFullConfig = function getFullConfig(config) {return [config, systemconf.chart.plot.datalabels, systemconf.chart, systemconf.canvas, $ZCG];},
        getPadding = function getPadding(config, i) {
          var isFixedDatalabels = isFixed(i),
            defaultPadding = isFixedDatalabels && isBarChartType(chartObj.chartTypes[i].value) ? 2 : 0,
            padding = isYaxis ? mathMax(0, mathMin(validateNullVal(config.padding, defaultPadding), dim)) : 0;

          if (isFixedDatalabels && isBoundBoxEnabled(config, chartObj) || isSankeyChart) {
            padding += 2 * getBoundBoxPadding(config, chartObj) + getBoundBoxStrokeWidth(config, chartObj);
          }

          return padding;
        },
        setAttrInRenderer = function setAttrInRenderer(config, i) {
          var show = isDatalabelEnabled(config, chartObj);
          labelRenderer[i] = labelRenderer[i] || {};
          labelRenderer[i].show = show;
          labelRenderer[i].config = config;
          labelRenderer[i].labeltype = getLabeltype(config);
        },
        seriesdata = chartObj.userdata.seriesdata;
      chartObj.seriesdata.forEach(function (series, i) {
        if (!series.disabled) {
          var plotoptions = series.plotoptions,
            commonPlotOptions = systemconf.chart.plot.plotoptions[chartObj.chartTypes[i].name],
            dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions),
            show = isDatalabelEnabled(dataLabels, chartObj),
            isFixedDatalabels = isFixed(i),
            GLT = dataLabelTextContent(chartObj, null, dataLabels, DATALABELS_LABELTYPE, null, i),
            padding = getPadding(dataLabels, i); // Change default padding
          setAttrInRenderer(dataLabels, i);
          //code to avoid scale correction when datalabel position is not on the top - need to check usecases
          // var isAxisCategory = isCategoryOf(chartObj, series.type || seriesdata.type, 'axis');
          // if(!isAxisCategory || (dataLabels.labelPos && !(dataLabels.labelPos === "top"))){
          //     operator.push(0);
          //     return;
          // }

          if (show) {
            if (isFixedDatalabels && (axisrotated || GLT.contentType === 'html')) {
              var yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(series.yaxiscolumnorder),
                datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
                xCategories = dataObj.getDomain(dataObj.getCategories('x'), 'x', true),
                yCategories = datatypeY == ORDINAL_DATATYPE ? dataObj.getCategories('y', yaxiscolumnorder) : null,
                _maxWidth = perToPx(defined(dataLabels.maxWidth) ? dataLabels.maxWidth : '30%', chartObj.plotarea.width);

              series.data.forEach(function (d) {
                operator.push({
                  _type: 'font',
                  renderMode: 'svg',
                  padding: padding,
                  config: getFullConfig(dataLabels),
                  data: dataObj.updateSeriesdatabyCategories(d3_values(d), xCategories, yCategories, yaxiscolumnorder),
                  accessor: GLT,
                  measure: function measure(_) {return axisrotated ? mathMin(_.width, _maxWidth) : _.height;},
                  key: key
                });
              });
            } else if (isSankeyChart) {
              getSankeyOutsideLabelDimension(chartObj, dataLabels, padding, sizeArray, i);
            } else {
              operator.push({
                _type: 'font',
                renderMode: 'svg',
                padding: padding,
                config: getFullConfig(dataLabels),
                data: [DEFAULT_TEXT],
                accessor: function accessor(d) {return d;},
                measure: function measure(_) {return _.height + (handleOverlap && !axisrotated && isYaxis && !isFixedDatalabels ? _.height : 0);},
                key: key
              });
            }
          }
        }
      });

      if (isYaxis && hasBarSeries && stacked && !dataObj.isStackedPercentChart) {
        var stackEncode = dataObj.getEncode('stack'),
          encode = dataObj.getEncode('stack', Object.keys(stackEncode)[0]);

        if (encode) {
          var seriesIndex = getSeriesIndex4StackLabel(encode),
            stackedLabels = systemconf.chart.plot.plotoptions[chartObj.chartTypes[seriesIndex].name].datalabels.stackLabels || {},
            showStackLabels = stackedLabels ? stackedLabels.show : false,
            padding = mathMax(0, mathMin(validateNullVal(stackedLabels.padding, 2), dim)),
            maxWidth = perToPx(defined(stackedLabels.maxWidth) ? stackedLabels.maxWidth : '30%', chartObj.plotarea.width);
          chartObj.datalabels.isStackedLabels = showStackLabels;

          if (showStackLabels) {
            if (
            getValignforBarLabels(chartObj, seriesIndex, STACKLABELS_LABELTYPE) === FIXEDTOP_ALIGN && (
            axisrotated || hasHTMLContentInStackLabels(chartObj, stackedLabels)))
            {
              each(stackEncode, function (d) {
                var seriesIndex = getSeriesIndex4StackLabel(d),
                  GLT = dataLabelTextContent(chartObj, null, stackedLabels, STACKLABELS_LABELTYPE, null, seriesIndex);

                operator.push({
                  _type: 'font',
                  renderMode: 'svg',
                  padding: padding,
                  config: getFullConfig(stackedLabels),
                  data: d.layout.getAllExtents(),
                  accessor: GLT,
                  measure: function measure(_) {return axisrotated ? mathMin(_.width, maxWidth) : _.height;},
                  key: key
                });
              });
            } else {
              operator.push({
                _type: 'font',
                renderMode: 'svg',
                padding: padding,
                config: getFullConfig(stackedLabels),
                data: [DEFAULT_TEXT],
                accessor: function accessor(d) {return d;},
                measure: function measure(_) {return _.height;},
                key: key
              });
            }
          }
        }
      }

      if (!evaluate) {
        return operator;
      }

      if (isSankeyChart) {
        return sizeArray;
      } else {
        var val = d3_max(operator, function (_) {
          var data = _.data,config = _.config,renderMode = _.renderMode,accessor = _.accessor,padding = _.padding,measure = _.measure,
            bbs = MeasureDataLabel(data, { config: config, renderMode: renderMode, accessor: accessor, chartObj: chartObj });
          return d3_max(bbs, function (bb) {return padding + measure(bb);});
        });
        return val;
      }
    }

    function getSankeyOutsideLabelDimension(chartObj, options, padding, sizeArray) {
      // #ZC2593 [**]
      var renderer = chartObj.renderer[0],
        cType = 'hierarchy',
        labelHolder = chartObj.staticPaneSVG.selectAll('g.labelholder'),
        handler,
        lastLength = 0;

      handler = dataLabel_handler.initialize(chartObj);
      handler.chartType = cType;

      var getMaxLabel = function getMaxLabel(position) {
        var labelrenderer = LabelRegistry.get(cType),
          point = renderer.nodeAligns[position].map(function (n) {return n.point;}),
          args = [chartObj.seriesdata[0], 0, NULL$1, NULL$1, null, point, [0, 0], null, true];

        labelrenderer = labelrenderer();
        labelrenderer.args(args).renderer(renderer);
        labelHolder.call(labelrenderer, handler);

        var _handler$getQueue = handler.getQueue(0),_handler$getQueue2 = _slicedToArray(_handler$getQueue, 1),items = _handler$getQueue2[0],
          max = d3_max(items.slice(lastLength), function (item) {
            return item.display ? item.width : 0;
          });

        lastLength = point.length;

        return max;
      };

      var startMax = getMaxLabel('start'),
        endMax = getMaxLabel('end');
      //
      sizeArray.push(startMax);
      sizeArray.push(endMax);
    }

    function hasHTMLContentInStackLabels(chartObj, stackedLabels) {
      var stackEncode = chartObj.dataObject.getEncode('stack');

      return Object.keys(stackEncode).some(function (d) {
        var encode = chartObj.dataObject.getEncode('stack', d),
          stackLabelIndex = getSeriesIndex4StackLabel(encode);

        return dataLabelTextContent(chartObj, null, stackedLabels, STACKLABELS_LABELTYPE, null, stackLabelIndex).contentType === 'html';
      });
    }

    LabelRegistry.add('preCalculation', preCalculation);

    //$Id$

    function evalLabelCorrection(_) {
      var _scale = this,
        data = _.data,config = _.config,renderMode = _.renderMode,accessor = _.accessor,padding = _.padding,measure = _.measure,
        bbs = MeasureText(data, { config: config, renderMode: renderMode, accessor: accessor });

      var bound = d3_max(bbs, function (bb) {return padding + invokeFunction(measure, bb);});
      if (!_modularized.scaleCorrection) {
        return labelCorrection(_scale, bound);
      }
      return bound || 0;
    }

    ScaleRegistry.add('font-correction-evaluator', evalLabelCorrection);
    ScaleRegistry.add('label-correction-evaluator', evalLabelCorrection);

    //$Id$

    dataLabel_handler.initialize = function (chartObj) {
      var mode = chartObj.plot.renderer.mode,
        drawLabel = LabelRegistry.get("".concat(mode)),
        drawConnector = LabelRegistry.get('connector'),
        labelHolder = getLabelHolder(chartObj),
        availableChartTypes = charttype;

      var config = {};
      config[DATALABELS_LABELTYPE] = [];
      config[STACKLABELS_LABELTYPE] = [];
      config[INNERLABEL_LABELTYPE] = [];
      config[PARENTLABELS_LABELTYPE] = [];

      var criteria = {
        rangeChart: [availableChartTypes.arearange, availableChartTypes.boxplot, availableChartTypes.barrange],
        connector: [availableChartTypes.pie, availableChartTypes.sunburst, availableChartTypes.funnel, availableChartTypes.pyramid]
      };
      var isRangeChart;
      criteria[INNERLABEL_LABELTYPE] = chartcategory.innerLabels;
      criteria[PARENTLABELS_LABELTYPE] = chartcategory.parentLabels;

      var handlers = {};
      handlers.add = function (c, seriesIndex, subSeries, yRangePos, type, rendererIndex) {
        type = type || DATALABELS_LABELTYPE;
        rendererIndex = pick(rendererIndex, seriesIndex);
        var queue = config[type];
        queue = queue[rendererIndex] = queue[rendererIndex] || [];
        //For range chart , queue yrangepos
        //For boxplot with median no need to queue yrangepos
        if (
        type === DATALABELS_LABELTYPE &&
        criteria.rangeChart.indexOf(chartObj.chartTypes[seriesIndex].value) > -1 &&
        defined(yRangePos))
        {
          isRangeChart = true; //consider boxplot median line
          yRangePos = yRangePos || 0;
          queue = queue[yRangePos] = queue[yRangePos] || [];
        }

        queue[subSeries] = queue[subSeries] || [];
        queue[subSeries].push.apply(queue[subSeries], c);

        // Each subseries may have different dataUpdates
        // dataUpdate, translation
        Object.keys(c).
        filter(isNaN).
        forEach(function (_) {return queue[subSeries][_] = c[_];});

        return queue;
      };

      handlers.update = function (id, x, y, display, DY, hookPosition, type, _queue) {
        type = type || DATALABELS_LABELTYPE;
        var index = id.match(/\d+/g),
          rendererIndex = index[0],
          subSeriesIndex = index[1],
          itemIndex = index[2],
          yRangePos = index[4],
          legendSeriesOrder = pick(index[3], rendererIndex);

        var queue = _queue || handlers.getQueue(legendSeriesOrder, yRangePos, type, rendererIndex);
        var d = queue[subSeriesIndex][itemIndex];
        if (!d) {
          return;
        }

        d.X += x;
        d.Y += y;
        d.display = d.display && !display;
        if (DY !== undefined) {
          d.DY = DY;
        }
        if (hookPosition) {
          d.hookPosition = hookPosition;
        }
      };

      handlers.getQueue = function (seriesIndex, yRangePos, type, rendererIndex, paneid) {
        type = type || DATALABELS_LABELTYPE;
        rendererIndex = pick(rendererIndex, seriesIndex);
        var queue = config[type];
        queue = queue[rendererIndex];
        var cType_Obj = getChartTypeByIndex(chartObj, paneid, seriesIndex);

        if (
        type === DATALABELS_LABELTYPE &&
        criteria.rangeChart.indexOf(cType_Obj.value) > -1 &&
        defined(yRangePos) && //consider boxplot median
        queue)
        {
          queue = queue[yRangePos || 0];
        }

        return queue;
      };

      handlers.draw = function () {
        if (chartObj.isAxisCategory) {
          var stackEncode = chartObj.dataObject.getEncode('stack'),
            keys = chartObj.dataObject.getStackGroup();

          if (keys) {
            keys = keys.map(function (d, i) {return i;});
          } else {
            keys = Object.keys(stackEncode);
          }

          keys.forEach(function (d, i) {
            var encode = chartObj.dataObject.getEncode('stack', d);
            if (config[STACKLABELS_LABELTYPE].length && encode) {
              var stackLabelIndex = getSeriesIndex4StackLabel(encode);
              drawLabel(chartObj, config[STACKLABELS_LABELTYPE][stackLabelIndex], i, 'stacklabel');
            } else if (mode === 'svg') {
              appendEle(labelHolder, 'g', [], '.', 'class', "stacklabel_".concat(i));
            }
          });

          /*
           * bar19.json - Remove the stack labels if all the bar series are disabled at legend filter
           */
          if (!keys.length && mode === 'svg') {
            appendEle(labelHolder, 'g', [], '#', 'id', STACKLABELS_LABELTYPE);
          }
        }
        var hierarchical = chartObj.dataObject.hierarchical,
          facetRendering = hierarchical && hierarchical.facetRendering,
          layerDomain,
          layerGroups,
          gridlist = [{ data: chartObj.seriesdata }];
        if (facetRendering) {
          var pivotLayout = facetRendering && hierarchical.pivotLayout,
            layers = pivotLayout.getRootNodeList('layer'),
            panes = layers.panes;
          gridlist = objectValues(panes);
          layerDomain = layers.domain;
          layerGroups = hierarchical.pivotLayout.layers.groups;
        }

        var renderCounter = 0;
        if (chartObj.viewFlow && chartObj.viewFlow.marks._default.label.length) {
          var marks_plot = chartObj.viewFlow.marks._default.label;
          gridlist = [{ data: marks_plot }];
        }
        gridlist.forEach(function (grid, gridIdx) {
          grid.data.forEach(function (s, i) {
            var rendererIdx = renderCounter++;
            var layerIdx = facetRendering ? s.layer : 0;
            var data = config[DATALABELS_LABELTYPE][rendererIdx],
              legendIdx = facetRendering ? layerGroups[s.layer].indexOf(s.value) : i,
              paneid = facetRendering ? "".concat(s.row, "_").concat(s.column) : i,
              cType_Obj = getChartTypeByIndex(chartObj, paneid, legendIdx),
              cType = cType_Obj.value,
              renderer = chartObj.renderer[rendererIdx] || chartObj.renderer[0],
              bound = renderer.commonRendererProp().params.bound,
              wrap;

            if (hasColorColumnInNonAxis(chartObj, paneid) && i !== 0) {
              return;
            }

            if (facetRendering) {
              var rowid = s.row || 0,
                columnid = s.column || 0;
              wrap = createElement('g', ".grid".concat(rowid, "_").concat(columnid), [1], labelHolder);

              if (!arrayIncludes(chartcategory.axis, cType)) {
                wrap.attr('transform', "translate(".concat(bound.x, ",").concat(bound.y, ")"));
              }
            }

            // if(!data){
            //     return; //MODIFIED MODULARIZE NEED TO check for pie inner labels if not commented
            // }
            if (criteria.rangeChart.indexOf(cType) > -1 && isRangeChart) {
              drawLabel(chartObj, data && data[0], legendIdx, null, rendererIdx, wrap, s);
              drawLabel(chartObj, data && data[1], legendIdx, null, rendererIdx, wrap, s);
            } else {
              drawLabel(chartObj, data, legendIdx, null, rendererIdx, wrap, s);
            }

            if (criteria[INNERLABEL_LABELTYPE].indexOf(cType) > -1) {
              if (criteria.connector.indexOf(cType) > -1) {
                drawConnector(chartObj, data, legendIdx, rendererIdx, wrap);
              }
              drawLabel(chartObj, config[INNERLABEL_LABELTYPE][rendererIdx], legendIdx, INNERLABEL_LABELTYPE, rendererIdx, wrap, s);
            }

            if (criteria[PARENTLABELS_LABELTYPE].indexOf(cType) > -1) {
              drawLabel(chartObj, config[PARENTLABELS_LABELTYPE][rendererIdx], legendIdx, PARENTLABELS_LABELTYPE, rendererIdx, wrap, s);
            }
          });
        });
      };

      handlers.getLabel = function (d) {
        if (!d) {
          return;
        }

        var rendererIndex = d.rendererIndex,seriesIndex = d.seriesIndex,subSeriesIndex = d.subSeriesIndex,itemIndex = d.itemIndex,paneid = d.paneid,
          cType_Obj = getChartTypeByIndex(chartObj, paneid, seriesIndex),
          isRangePlot = chartcategory.rangePlot.has(cType_Obj.value),
          yrangePos = isRangePlot ? [0] : [undefined, null, 0]; // Bar: yrangePos = null, Scatter: yrangePos = undefined

        if (!defined(itemIndex)) {
          return;
        }

        var labelArray = chartObj.rendererConf[rendererIndex].params.labelArray,
          key = function key(_) {return "lbl".concat(rendererIndex, "_").concat(subSeriesIndex, "_").concat(itemIndex, "_").concat(seriesIndex, "_").concat(_);};
        labelArray = labelArray[paneid] || labelArray.undefined_undefined;
        return labelArray && arrayFind(labelArray, function (_) {return yrangePos.some(function (_rangePos) {return _.id === key(_rangePos);});});
      };

      return handlers;
    };

    //$Id$

    function LabelRenderer(labelQueue, array, chartObj) {
      chartObj.labelHandler = null;
      if (chartObj.plot.renderer.mode !== 'image') {
        var dataObj = chartObj.dataObject;

        if (chartObj.isAxisCategory) {
          drawStackLabel(chartObj);
        }

        labelQueue.forEach(drawLabel);

        //handle overlap - start
        for (var attr in array) {
          getOverlapHandlerType(chartObj, attr)(chartObj, array[attr], labelQueue);
        }

        //handle overlap - end

        // remove the temp node.
        chartObj.staticPaneSVG.select('.temp_label').remove();

        if (chartObj.labelHandler) {
          var labelHolder = chartObj.staticPaneSVG.selectAll('g.labelholder'),
            mode = chartObj.plot.renderer.mode,
            hierarchical = chartObj.dataObject.hierarchical,
            facetRendering = hierarchical && hierarchical.facetRendering;

          labelQueue.forEach(function (d) {
            var legendOrder = d.args[1],
              rendererIndex = d.rendererIndex,
              paneid = d.paneid,
              innerLabels = /(pieInnerLabels|funnelInnerLabels)/.test(d.charttype),
              labelType =
              d.charttype === 'pieInnerLabels' &&
              isSunburstChartType(getChartTypeByIndex(chartObj, paneid, legendOrder).value) &&
              d.args[d.args.length - 1] ?
              PARENTLABELS_LABELTYPE :
              innerLabels ?
              INNERLABEL_LABELTYPE :
              DATALABELS_LABELTYPE;


            var queue = findQueue(d, chartObj);

            var boundBoxComponent = LabelRegistry.get("boundBox-".concat(mode));
            if (boundBoxComponent !== noOperation) {
              var datalabelsBoundBox_renderer = boundBoxComponent().args(queue),
                boundBoxWrap =
                facetRendering && defined(paneid) ? createElement('g', ".grid".concat(paneid), [1], labelHolder) : labelHolder;

              boundBoxWrap.call(datalabelsBoundBox_renderer, legendOrder, labelType, rendererIndex, d);
            }
          });
          chartObj.labelHandler.draw();
        }
      }
    }

    function drawLabel(obj) {
      var chartObj = obj.chartObj,
        renderer = obj.renderer,
        cType = obj.charttype,
        rendererIndex = obj.rendererIndex,
        paneid = obj.paneid,
        args = obj.args;
      var labelHolder = chartObj.staticPaneSVG.selectAll('g.labelholder');
      var handler = chartObj.labelHandler;

      if (!chartObj.labelHandler) {
        handler = chartObj.labelHandler = dataLabel_handler.initialize(chartObj);
        handler.chartType = cType;
      }
      handler.rendererIndex = rendererIndex;
      handler.paneid = paneid;

      var labelrenderer = LabelRegistry.get(cType);

      if (labelrenderer !== noOperation) {
        labelrenderer = labelrenderer();
        labelrenderer.renderer(renderer).args(args);
        labelHolder.call(labelrenderer, handler);
      }
    }

    function drawStackLabel(chartObj) {
      var dataObj = chartObj.dataObject;
      var stackEncode = dataObj.getEncode('stack') || [];

      each(stackEncode, function (stackData, stackIndex) {
        stackIndex = dataObj.pivot ? '0_0' : +stackIndex;
        var seriesIndex = getSeriesIndex4StackLabel(stackData);
        if (!dataObj.noofBarEnabledSeries && !dataObj.isCombinationalChart || seriesIndex == null) {
          return;
        }

        var stackLabelsData = stackEncode[stackIndex].layout.getAllExtents();

        // #ZC2063
        if (chartObj.renderVisiblePointsOnly) {
          var visibleDomain = chartObj.axes.x.scale.domain();
          stackLabelsData = stackLabelsData.filter(function (d0) {return arrayIncludes(visibleDomain, d0[0]);});
        }

        var obj = {
          renderer: chartObj.renderer[seriesIndex],
          chartObj: chartObj,
          args: [
          {
            data: [stackLabelsData]
          },
          seriesIndex,
          STACKLABELS_LABELTYPE,
          stackIndex],

          charttype: BAR_CHARTNAME,
          paneid: '0_0' //hardcoded need to change
        };
        drawLabel(obj);
      });
    }

    function getOverlapHandlerType(chartObj, paneid) {
      paneid = isFacet(chartObj) && paneid === '0' ? '0_0' : paneid;
      paneid = paneid.replace(/\((\d+)\)/, '');

      var dataObj = chartObj.dataObject,
        chartType = getChartTypeByIndex(chartObj, paneid, 0).value,
        isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
        isPolarAxisCategory = isCategoryOf(chartObj, chartType, 'polarAxis');

      return isAxisCategory && dataObj.isCombinationalChart ||
      isAxisCategory && !dataObj.noofBarEnabledSeries ||
      isPolarAxisCategory ||
      chartObj.isGeoMap ||
      dataObj.isFlowChartCategory ?
      pointTravel :
      isAxisCategory && dataObj.noofBarEnabledSeries ?
      stepTravel :
      slotTravel;
    }

    function findQueue(d, chartObj) {
      var legendOrder = d.args[1],
        rendererIndex = d.rendererIndex,
        paneid = d.paneid,
        chartType = getChartTypeByIndex(chartObj, paneid, 0).value,
        isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
        yRangePos = isAxisCategory ? d.args[3] : null,
        innerLabels = /(pieInnerLabels|funnelInnerLabels)/.test(d.charttype),
        labelType =
        d.charttype === 'pieInnerLabels' &&
        isSunburstChartType(getChartTypeByIndex(chartObj, paneid, legendOrder).value) &&
        d.args[d.args.length - 1] ?
        PARENTLABELS_LABELTYPE :
        innerLabels ?
        INNERLABEL_LABELTYPE :
        DATALABELS_LABELTYPE;

      return chartObj.labelHandler.getQueue(legendOrder, yRangePos, labelType, rendererIndex, paneid);
    }

    Registry.setComponent('labelRenderer', LabelRenderer);

    function getBoundBoxParser(data, renderOnInit, anime_config, parent) {
      var _this = this,
        enterMarks,
        updateMarks,
        exitMarks,
        staticSVG = _this.chart.staticPaneSVG,
        isParentLabel = _this.datalabel_type === PARENTLABELS_LABELTYPE,
        isInnerLabel = _this.isInnerLabel,
        label_type = isParentLabel ? 'parent' : isInnerLabel ? 'inner' : '',
        _Bb = staticSVG.selectAll(".".concat(
        label_type, "boundboxseries_").concat(pick(this.conf.rendererIndex() || this.conf.datasetIndex() || _this.index))),
        //0 - for funnel chart nd some chart type cases
        parent,
        showBoundBox,
        labelQueue,
        anim_dur = anime_config && anime_config._duration || 100, //for other cases other than bar
        anim_delay = anime_config && anime_config._delay || 0;if (!_Bb.node()) {
        return;
      }
      _Bb.each(function (d) {
        showBoundBox = d.showBoundBox;
        labelQueue = d.labelQueue;
      });
      var paneid = labelQueue.paneid,
        innerLabels = /(pieInnerLabels|funnelInnerLabels)/.test(labelQueue.charttype),
        legendOrder = labelQueue.args[1],
        labelType =
        labelQueue.charttype === 'pieInnerLabels' &&
        isSunburstChartType(getChartTypeByIndex(_this.chart, paneid, legendOrder).value) &&
        labelQueue.args[labelQueue.args.length - 1] ?
        PARENTLABELS_LABELTYPE :
        innerLabels ?
        INNERLABEL_LABELTYPE :
        DATALABELS_LABELTYPE,
        args = {
          legendOrder: legendOrder,
          rendererIndex: labelQueue.rendererIndex,
          paneid: paneid,
          labelType: labelType
        };

      if (_this.properties && _this.properties.rangeChart) {
        _Bb = _Bb.selectAll(".rangePos_".concat(_this.properties.yrangePos));
      }
      parent = _Bb.selectAll(".subseries_".concat(_this.subseriesIdx));

      var boundBoxMarks = {
        name: 'rect',
        selector: '.zc_label_background',
        mark: 'path',
        order: '.customLabel',
        data: showBoundBox ? data : [],
        parent: parent,
        config: {
          strokeWidth: _this.helpers.styles.boundBox.strokeWidth,
          dashStyle: _this.helpers.styles.boundBox['stroke-dasharray'],
          lineCap: _this.helpers.styles.boundBox['stroke-linecap']
        },
        properties: {
          styles: {
            display: function display(d, i) {return _this.helpers.styles.boundBox.display(d, i, args);},
            fill: function fill(d, i) {return _this.helpers.styles.boundBox.fill(d, i, args);},
            'fill-opacity': _this.helpers.styles.boundBox['fill-opacity'],
            stroke: function stroke(d, i) {return _this.helpers.styles.boundBox.stroke(d, i, args);},
            'stroke-opacity': _this.helpers.styles.boundBox['stroke-opacity'],
            // 'stroke-dasharray': _this.helpers.styles.boundBox['stroke-dasharray'],
            // 'stroke-linecap': _this.helpers.styles.boundBox['stroke-linecap'],
            transition: _this.helpers.styles.boundBox.transition,
            opacity: function opacity(d, i) {return _this.helpers.styles.boundBox.opacity(d, i, args);}
          },
          attrs: {
            d: function d(_d8, i) {return _this.helpers.styles.boundBox.d(_d8, i, args);},
            id: function id(d, i) {return _this.helpers.styles.boundBox.id(d, i, args);},
            levelbycolumn: function levelbycolumn(d, i) {return _this.helpers.styles.boundBox.levelbycolumn(d, i, args);},
            levelbyrow: function levelbyrow(d, i) {return _this.helpers.styles.boundBox.levelbyrow(d, i, args);}
          }
        },
        onEnd: function onEnd(d) {
          setOpacityForTickFilterElements(d, _this.chart, 'label', _this.actualData);
        }
      };

      if (renderOnInit) {
        enterMarks = {
          transform: function transform(d, k) {
            return _this.helpers.position.boundBox.start.transform(d, k);
          }
        };
        updateMarks = [
        {
          duration: this.isRedraw == 'redraw' ? anim_dur : 0,
          delay: anim_delay,
          transform: {
            property: 'attrTween',
            to: function to(d, i) {
              var interpolator = d3.interpolateString(
              this.getAttribute('transform'),
              _this.helpers.position.boundBox.stop_1.transform(d, i, this));

              return function (t) {
                return interpolator(t);
              };
            }
          }
        },
        {
          duration: anim_dur,
          delay: anim_delay,
          transform: {
            property: 'attrTween',
            to: function to(d, i) {
              var interpolator = d3.interpolateString(
              this.getAttribute('transform'),
              _this.helpers.position.boundBox.end.transform(d, i));

              return function (t) {
                return interpolator(t);
              };
            }
          }
        }];

        boundBoxMarks.config.enter = enterMarks;
        boundBoxMarks.anime = {};
        boundBoxMarks.anime.update = updateMarks;
      } else {
        enterMarks = {
          transform: function transform(d, k) {
            return _this.helpers.position.boundBox.end.transform(d, k);
          }
        };
        updateMarks = {
          duration: 0,
          transform: function transform(d, k) {
            return _this.helpers.position.boundBox.end.transform(d, k);
          }
        };
        exitMarks = {
          duration: 0,
          delay: 0
        };
        boundBoxMarks.config.enter = enterMarks;
        boundBoxMarks.config.update = updateMarks;
        boundBoxMarks.config.exit = exitMarks;
      }

      return boundBoxMarks;
    }

    function getDefaultParser(data) {
      var _this = this,
        chart = _this.chart,builderC = _this.builderC,properties = _this.properties,
        enterMarks,
        updateMarks,
        exitMarks,
        data = data ? data : _this.dataUpdate,
        anime_config = builderC.animationOptions,
        GLT = properties.GLT,contentType = properties.contentType,
        children = [],
        racing = this.chart.racing && this.chart.racing.syncTransition,
        contentType = contentType || 'text',
        isShowAs = GLT && GLT.hasShowAsFunction,
        strokeColor = _this.properties.dataLabels.strokeColor,
        applyOutline,
        animate = _this.animate,
        anim_dur = anime_config && anime_config._duration || 100,
        anim_delay = anime_config && anime_config._delay || 0;

      if (strokeColor === UNDEFINED) {
        strokeColor = chart.systemConf.chart.plot.datalabels.strokeColor; // ZC2362
      }
      applyOutline = strokeColor !== UNDEFINED;
      if (applyOutline && !isStylePropertySupported('paintOrder')) {
        if (!_this.dataLevelStrokeColor) {
          _this.dataLevelStrokeColor = _this.datalabelOptions.stroke;
        }
      }

      var labelMark = {
        name: 'label',
        selector: '.label',
        mark: isShowAs ? 'g' : 'text',
        data: data,
        config: {
          stroke: _this.helpers.styles.label.stroke(applyOutline && !isStylePropertySupported('paintOrder') ? false : true),
          strokeWidth: function strokeWidth(d, i) {return _this.helpers.styles.label['stroke-width'](d, i);},
          dy: _this.helpers.position.label.dy
        },
        anime: {},
        properties: labelStyles.call(this),
        onEnd: label_onEnd.call(_this, racing)
      };
      if (racing) {
        var raceLabel_pos = _this.helpers.position.racingLabel;
        enterMarks = {
          transform: function transform(d, k) {
            return raceLabel_pos.start.transform(d, k);
          },
          x: 0,
          y: 0
        };
        updateMarks = [
        {
          transition: racing,
          transform: {
            property: 'attrTween',
            to: function to(d, k) {
              var interpolator = d3.interpolateString(this.getAttribute('transform'), raceLabel_pos.end.transform(d, k));
              return function (t) {
                return interpolator(t);
              };
            }
          },
          x: 0,
          y: 0
        }];

        exitMarks = {
          transition: racing,
          transform: function transform(d, k) {
            return raceLabel_pos.exit.transform(d, k, this);
          }
        };
        labelMark.config.enter = enterMarks;
        labelMark.anime.update = updateMarks;
        labelMark.anime.exit = exitMarks;
      } else if (animate) {
        var label_pos = _this.helpers.position.label;
        enterMarks = {
          transform: function transform(d, i) {
            return label_pos.start.transform(d, i);
          },
          x: function x(d, i) {
            return label_pos.start.x(d, i);
          },
          y: function y(d, i) {
            return label_pos.start.y(d, i);
          }
        };
        updateMarks = [
        {
          duration: _this.isRedraw == 'redraw' ? anim_dur : 0,
          delay: anim_delay,
          transform: {
            property: 'attrTween',
            to: function to(d, i) {
              var interpolator = d3.interpolateString(this.getAttribute('transform'), label_pos.stop_1.transform(d, i, this));
              //if from is rotate(0,10,10) nd to is translate(0,0) - case not handled
              //FEATURESEVENTS_SCROLL_2 - apply renderOnInit with animate enabled true, - chnage from bar to line - from will be rotate(0,10,10) but to will be null
              return function (t) {
                return interpolator(t);
              };
            }
          },
          x: function x(d, i) {
            return label_pos.stop_1.x(d, i, this);
          },
          y: function y(d, i) {
            return label_pos.stop_1.y(d, i, this);
          }
        },
        {
          duration: anim_dur,
          delay: anim_delay,
          transform: {
            property: 'attrTween',
            to: function to(d, i) {
              var interpolator = d3.interpolateString(this.getAttribute('transform'), label_pos.end.transform(d, i));
              return function (t) {
                return interpolator(t);
              };
            }
          },
          x: function x(d, i) {
            return label_pos.end.x(d, i);
          },
          y: function y(d, i) {
            return label_pos.end.y(d, i);
          }
        }];

        exitMarks = {
          duration: 0
        };
        labelMark.config.enter = enterMarks;
        labelMark.anime.update = updateMarks;
        labelMark.anime.exit = exitMarks;
      } else {
        var label_pos = _this.helpers.position.label;
        updateMarks = {
          transform: function transform(d, i) {
            return label_pos.end.transform(d, i);
          },
          x: function x(d, i) {
            return label_pos.end.x(d, i);
          },
          y: function y(d, i) {
            return label_pos.end.y(d, i);
          }
        };
        exitMarks = {
          duration: 0
        };
        labelMark.config.update = updateMarks;
        labelMark.anime.exit = exitMarks;
        //we store it here since, for none animation case, incase of trim we will need exact x and y values to calculate bbox
        //if added in anime - only at the end x and y updated, so bbox calculation was not proper.
      }

      labelMark.config[contentType] = function (d, i) {return _this.helpers.text.label(d, i);};
      var boundBoxMark = getBoundBoxParser.call(_this, data, animate, anime_config);
      boundBoxMark ? children.push(boundBoxMark) : null;

      if (applyOutline && !isStylePropertySupported('paintOrder')) {
        _this.isOutLineGroup = true;
        var outLine = {
          name: 'outline',
          selector: '.outline',
          mark: 'text',
          data: data,
          config: {
            update: updateMarks,
            exit: exitMarks,
            stroke: _this.helpers.styles.label.stroke(true),
            strokeWidth: function strokeWidth(d, i) {return _this.helpers.styles.label['stroke-width'](d, i, true);}
          },
          properties: labelStyles.call(this, true),
          onEnd: label_onEnd.call(_this, racing)
        };
        outLine.config[contentType] = function (d, i) {return _this.helpers.text.label(d, i);};
        children.push({
          name: 'outputGroup',
          selector: '.outputGroup',
          mark: 'g',
          data: [1],
          children: [outLine],
          config: {
            strokeWidth: "inherit"
          }
        });
      }
      children.push(labelMark);

      return {
        mark: 'g',
        data: [1],
        selector: ".subseries_".concat(_this.subseriesIdx),
        properties: {
          attrs: {
            "class": function _class(d, i) {
              return "subseries_".concat(_this.subseriesIdx);
            },
            transform: this.subSeries.translation
          }
        },
        children: children,
        onEnd: function onEnd(ele) {
          ele.style('stroke-width', 'inherit');
        }
      };
    }

    MarksRegistry.add('datalabel.default', getDefaultParser);

    //helper functions
    function labelStyles(isOutLineText) {
      var _this = this,
        dataLabels = _this.properties.dataLabels,
        clip = dataLabels.textOverlap === 'clip';
      return {
        styles: {
          display: function display(d, i) {return _this.helpers.styles.label.display(d, i);},
          fill: function fill(d, i) {return _this.helpers.styles.label.fill(d, i);},
          'pointer-events': NONE,
          opacity: function opacity(d, i) {return _this.helpers.styles.label.opacity(d, i, isOutLineText);}
        },
        attrs: {
          dy: function dy(d, i) {return _this.helpers.styles.label.dy(d, i);},
          'text-anchor': function textAnchor(d, i) {return _this.helpers.styles.label['text-anchor'](d, i);},
          id: function id(d, i) {return _this.helpers.styles.label.id(d, i);},
          'clip-path': !clip ? null : function (d, i) {return _this.helpers.styles.label['clip-path'](d, i);},
          levelbycolumn: function levelbycolumn(d, i) {return _this.helpers.styles.label.levelbycolumn(d, i);},
          levelbyrow: function levelbyrow(d, i) {return _this.helpers.styles.label.levelbyrow(d, i);},
          'filtered-opacity': function filteredOpacity(d, i) {return _this.helpers.styles.label['filtered-opacity'](d, i);}
        }
      };
    }

    function label_onEnd(racing) {
      var _this = this,
        chartType = _this.ctype,isPolar = _this.isPolar,isAxisCategory = _this.isAxisCategory,isPackedBubble = _this.isPackedBubble,isTreemap = _this.isTreemap,isStackedLabels = _this.isStackedLabels,isInnerLabel = _this.isInnerLabel,properties = _this.properties,chart = _this.chart,
        GLT = properties.GLT,contentType = properties.contentType,dataLabels = properties.dataLabels,
        fontSize = getFontSizeByHierarchy(dataLabels, chart),
        boundBoxPadding = isBoundBoxEnabled(dataLabels, chart) ?
        getBoundBoxPadding(dataLabels, chart) + getBoundBoxStrokeWidth(dataLabels, chart) :
        0,
        hasLevelMarker = chartType == charttype.bullet || chartType == charttype.dial,
        animate = _this.animate,
        isMultiLineAnimation = properties.isMultiLine && animate;

      return _end;
      function _end(d) {
        d.nodes().map(function (d, i) {
          if (!isMultiLineAnimation && racing && Number(d.getAttribute('x')) != 0 && Number(d.getAttribute('y')) != 0) {
            /*
             * if isMultiLineAnimation - the values of transform,x,y will already be as below
             * racing - initial transform,x,y will not be applied as per racing since syncTransition is avaialable after onload
             * so inorder to animate we modify the transform,x nd y values
             * we need to do this only once
             */
            var details = $ZC.get('domUtils.getSvgTransform')(d);
            d.setAttribute('transform', "translate(".concat(d.getAttribute('x'), ",").concat(d.getAttribute('y'), ") rotate(").concat(details.rotate, ")"));
            d.setAttribute('x', 0);
            d.setAttribute('y', 0);
          }

          var k = i;
          if (properties.isMultiLine) {
            for (var p = 0; p < d.childNodes.length; p++) {
              if (animate || racing) {
                // for cases in which animation enabled and racing cases
                d.childNodes[p].setAttribute('x', 0);
              } else {
                d.childNodes[p].setAttribute('x', _this.subSeries[k].X);
              }

              // if(!Number(d.childNodes[p].getAttribute('x'))){
              //     d.childNodes[p].setAttribute('x', d.getAttribute('x'));
              // }
            }
          }
          if (
          !isAxisCategory &&
          !isTreemap &&
          !isPolar &&
          !hasLevelMarker &&
          !isPackedBubble &&
          !isStackedLabels &&
          !isInnerLabel &&
          !chart.isGeoMap &&
          !(GLT && GLT.hasShowAsFunction) // ZC-T2092
          ) {
            if (contentType === 'html') {
              if (_this.subSeries[k].display !== false) {
                var useBBox = dataLabels.preCalculation && dataLabels.preCalculation.useBBox,
                  newX = null;
                var ele = d3_select(d);

                if ( /*_this.properties.isMultiLine && */animate) {
                  var rotation = _this.properties.rotation,
                    _sereisInfo = _this.subSeries,
                    _s = _sereisInfo[k],
                    pos = _s.xy || [_s.X, _s.Y];
                  ele.attr('x', _s.X).
                  attr('y', _s.Y).
                  attr('transform', rotation ? "rotate(".concat(rotation, " ").concat(pos, ")") : NULL$1);
                  ele.selectAll('.zcTspan').attr('x', _s.X);
                }
                var tspanInfo = getTspanBound(ele, fontSize, useBBox);
                trimAllTspan(
                ele,
                chart,
                properties.trans,
                properties.txtHgt,
                null,
                tspanInfo,
                _this.subSeries[k].isLeft ? boundBoxPadding : 0,
                undefined,
                dataLabels.preCalculation);


                if ( /*_this.properties.isMultiLine && */animate) {
                  var rotation = _this.properties.rotation,
                    _sereisInfo = _this.subSeries,
                    _s = _sereisInfo[k],
                    pos = _s.xy || [_s.X, _s.Y];
                  ele.attr('x', 0).
                  attr('y', 0).
                  attr('transform', rotation ? "translate(".concat(pos, ") rotate(").concat(rotation, ")") : "translate(".concat(pos, ")"));
                  ele.selectAll('.zcTspan').attr('x', 0);
                }
                if (_this.subSeries[k].ANCHOR === 'middle') {
                  var TX = (_this.subSeries[k].width - bbox(d).width) / 2;
                  var flip = _this.subSeries[k].isLeft ? 1 : -1;
                  newX = _this.subSeries[k].X + TX * flip;
                }

                if (defined(newX)) {
                  ele.attr('x', newX);
                  translateTspan(ele, newX);
                }
              }
            } else {
              callTrimText(d3_select(d), chart, properties.trans, properties.txtHgt);
            }
          }
        });

        //when extended is added for mark
        if (Registry.getComponent('defaultDatalabelParser')()) {
          Registry.setComponent('datalabel.default', Registry.getComponent('defaultDatalabelParser')());
        }
      }
    }

    //$Id$

    function svgRenderer(chartObj, series, i, type, rendererIdx, wrap, markData) {
      type = type || 'label';
      rendererIdx = pick(rendererIdx, i);
      var isStackedLabels = type === 'stacklabel',
        isInnerLabel = type === INNERLABEL_LABELTYPE || type === PARENTLABELS_LABELTYPE,
        labelHolder = getLabelHolder(chartObj),
        labelseries = appendEle(wrap || labelHolder, 'g', series ? [1] : [], '.', 'class', "".concat(type, "_").concat(rendererIdx));

      if (!series) {
        return;
      }

      var properties = series.properties,
        globalDataUpdate = properties.dataUpdate,
        dataLabels = properties.dataLabels,
        globalActualData = properties.data,
        rp = properties.rp,
        legendOrderIndex = isFacet(chartObj) ? rp.legendOrderIndex : i,
        rotation = properties.rotation,
        isRangeChart = properties.rangeChart,
        yrangePos = properties.yrangePos,
        reverseColor = properties.reverseColor,
        contentType = properties.contentType || 'text',
        isMultiLine = properties.isMultiLine,
        chartType = properties.chartType,
        isPolar = isCategoryOf(chartObj, chartType, 'polarAxis'),
        isHierarchy = isCategoryOf(chartObj, chartType, 'hierarchy'),
        isNonAxisMultiSeriesCategory = isCategoryOf(chartObj, chartType, 'nonAxisMultiSeries'),
        isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
        isTreemap = chartType == charttype.treemap,
        clip = dataLabels.textOverlap === 'clip',
        fontSize = getFontSizeByHierarchy(dataLabels, chartObj),
        data_length = isAxisCategory || isPolar ? NULL$1 : globalDataUpdate.length,
        isScatterType = properties.type === 'scatter',
        hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
        strokeColor = dataLabels.strokeColor,
        dataLevelColor = NULL$1,
        dataLevelFontColor = NULL$1,
        dataLevelStrokeColor = NULL$1,
        clipseries;

      if (strokeColor === UNDEFINED) {
        strokeColor = chartObj.systemConf.chart.plot.datalabels.strokeColor; // ZC2362
      }

      if (
      hasColorScale ||
      rp.threshold ||
      isHierarchy ||
      !((isAxisCategory || chartObj.isGeoMap || isPolar || isNonAxisMultiSeriesCategory) && !properties.multiColoring))
      {
        dataLevelColor = function dataLevelColor(styleName) {
          return function (d, k) {
            var clrIndex = reverseColor ?
              data_length - 1 - k :
              (isAxisCategory || isPolar || isNonAxisMultiSeriesCategory) && !properties.multiColoring ?
              i :
              k,
              clr = getRawColor(chartObj, clrIndex, d && d.data ? d.data : d, legendOrderIndex),
              options = properties.isSunburst && properties.parentInnerLabel && d.children ? properties.parentInnerLabel : dataLabels,
              paneid = ((d && d.data ? d.data : d) || []).paneid;

            if (isTreemap && isInnerLabel && /(top-outset|bottom-outset)/.test(options.position) && d3_rgb(clr).opacity < 0.1) {
              clr = 'white';
            }

            return getLabelFontColor(chartObj.systemConf, clr, options, chartObj, isInnerLabel, i, undefined, styleName, paneid);
          };
        };
        dataLevelFontColor = dataLevelColor('fontColor');
        dataLevelStrokeColor = dataLevelColor('strokeColor');
      }

      if (clip) {
        var defs = ($Browser.SAFARI ? chartObj.svg : chartObj.getPatternSvg()).selectAll('defs');
        clipseries = appendEle(defs, 'g', [1], '.', 'class', 'textClipPaths');
      }

      if (isRangeChart) {
        labelseries = appendEle(labelseries, 'g', [1], '.', 'class', "rangePos_".concat(yrangePos));
      }

      if (isStackedLabels) {
        labelseries.attr('id', STACKLABELS_LABELTYPE);
      }

      labelseries.attrs({
        'text-anchor': isScatterType ? 'middle' : null,
        transform: properties.translation
      });

      var datalabelOptions = applyDatalabelFonts(labelseries, dataLabels, chartObj, rp.color, isInnerLabel, i, isStackedLabels), //change rp.color
        computedLabelFontColor = datalabelOptions.fill;

      if (strokeColor !== UNDEFINED && !isStylePropertySupported('paintOrder')) {
        labelseries.style('stroke', null);
        if (!dataLevelStrokeColor) {
          dataLevelStrokeColor = datalabelOptions.stroke;
        }
      }

      if (isPolar) {
        labelseries.attr('transform', "translate(".concat(chartObj.plotarea_approx.x, ",").concat(chartObj.plotarea_approx.y, ")"));
      }
      var parser_data;
      if (chartObj.viewFlow && chartObj.viewFlow.marks._default.chart.length) {
        parser_data = markData;
      }
      series.forEach(function (subSeries, j) {
        var args = {
          datalabel_type: type,
          ctype: chartType,
          chart: chartObj,
          dataUpdate: subSeries.dataUpdate || globalDataUpdate,
          actualData: subSeries.data || globalActualData,
          subSeries: subSeries,
          properties: properties,
          builderC: rp,
          rendererIndex: rendererIdx,
          index: i,
          subseriesIdx: j,
          datalabelOptions: datalabelOptions,
          commonOptions: chartObj.systemConf.chart.plot,
          options: rp.commonPlotOptions,
          operator: parser_data ? parser_data.operator : null
        };
        var datalabelRenderer = new DatalabelRenderer(args);
        rp.labelParser = datalabelRenderer;
        datalabelRenderer.initialize(labelseries);
        datalabelRenderer.getDefaultMarkParser();
        datalabelRenderer.render(labelseries);
      });
    }

    LabelRegistry.add('svg', svgRenderer);

    //$Id$

    function dialLabel() {
      var renderer, args;

      function labels(selection) {var labelHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var container = arguments.length > 2 ? arguments[2] : undefined;
        selection.each(function () {
          var currentdata = args[0],
            index = args[1],
            rp = renderer.commonRendererProp().params,
            chartObj = rp.chartObj,
            commonPlotOptions = rp.commonPlotOptions,
            color = rp.color,_rp$rendererIndex3 =
            rp.rendererIndex,rendererIndex = _rp$rendererIndex3 === void 0 ? index : _rp$rendererIndex3,
            paneid = labelHandler.paneid,
            plotoptions = currentdata.plotoptions;
          var plotarea_approx = chartObj.plotarea_approx,
            yscaleDomain = chartObj.axes.y.groups[0].scale.domain();

          var dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index);
          var showlabel = isDatalabelEnabled(dataLabels, chartObj),
            GLT = dataLabelTextContent(
            chartObj,
            rp,
            dataLabels,
            DATALABELS_LABELTYPE,
            yscaleDomain[1] - yscaleDomain[0],
            0,
            undefined,
            paneid),

            contentType = GLT.contentType || 'text',
            isMultiLine = contentType === 'html' && GLT.multiLine;

          if (!showlabel) {
            return;
          }

          var boundBoxPadding = isBoundBoxEnabled(dataLabels, chartObj) ?
          getBoundBoxPadding(dataLabels, chartObj) + getBoundBoxStrokeWidth(dataLabels, chartObj) :
          0;

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), 'text', [1], '.', 'class', 'temp_label');
          applyDatalabelFonts(temp_label, dataLabels, chartObj, color[0]);
          temp_label.style('opacity', 0);

          var dataUpdate = [currentdata[0].data[0][0]],
            commonProperties = [],
            i = 0; //subseries index

          dataUpdate.forEach(function (d, j) {
            var ANCHOR = 'middle',
              DY = isMultiLine ? '0.9em' : '-.3em',
              text = GLT(d, j),
              display = true;

            temp_label[contentType](text).attrs({
              x: X,
              dy: DY,
              'text-anchor': ANCHOR
            });

            var bb = bbox(temp_label.node());
            var X = defined(dataLabels.x) ? invokeFunction(dataLabels.x, d, chartObj, bb) : plotarea_approx.x,
              Y = defined(dataLabels.y) ?
              invokeFunction(dataLabels.y, d, chartObj, bb) :
              plotarea_approx.y + (
              commonPlotOptions.needle.show ?
              bb.height + (+dataLabels.padding || 0) + (+commonPlotOptions.needle.width / 2 || 7) + boundBoxPadding :
              bb.height / 2);

            if (isMultiLine) {
              if (!defined(dataLabels.y)) {
                Y -= bb.height;
              }
              translateTspan(temp_label, X);
              bb = bbox(temp_label.node());
            }

            var coordinate = {
              X: X,
              Y: Y,
              DY: DY,
              ANCHOR: ANCHOR,
              text: text,
              display: display,
              ID: "lbl".concat(index, "_").concat(i, "_").concat(j),
              width: bb.width,
              height: bb.height
            };
            commonProperties.push(coordinate);
          });

          if (container) {
            var conf = commonProperties[0];
            var labelText = appendEle(container, 'text', showlabel ? dataUpdate : []);
            applyDatalabelFonts(labelText, dataLabels, chartObj, color[0]);
            labelText[contentType](conf.text).attrs({
              'text-anchor': conf.ANCHOR,
              dy: conf.DY,
              transform: "translate(".concat(conf.X, ",").concat(conf.Y, ")")
            });

            if (isMultiLine) {
              translateTspan(temp_label, conf.X);
            }
          } else {
            var queue = labelHandler.add;
            // add to drawing queue
            var q = queue(commonProperties, index, i, null, null, rendererIndex, paneid);
            q.properties = {
              type: DIAL_CHARTNAME,
              dataLabels: dataLabels,
              dataUpdate: dataUpdate,
              showlabel: showlabel,
              rp: rp,
              contentType: contentType,
              isMultiLine: isMultiLine,
              chartType: charttype.dial
            };
          }
        });
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };
      return labels;
    }

    LabelRegistry.add('dial', dialLabel);

    //$Id$

    function funnelLabel() {
      var MARGIN = 5,
        d3Line = d3_line(),
        renderer,
        args;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var currentdata = args[0],
            index = args[1],
            data = args[2],
            noofNotNullData = args[3],
            arcHeight = args[4],
            totalEngagement = args[5],
            cfg = args[6],
            labelPosition = args[7];
          var paneid = labelHandler.paneid,
            chartWidth = cfg.width,
            chartHeight = cfg.height,
            rp = renderer.commonRendererProp().params,
            chartObj = rp.chartObj,
            systemconf = chartObj.systemConf,
            commonPlotOptions = rp.commonPlotOptions,
            dataset = rp.dataset,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            labelArray = getLabelArray(rp, paneid, args[8]),_rp$rendererIndex4 =
            rp.rendererIndex,rendererIndex = _rp$rendererIndex4 === void 0 ? index : _rp$rendererIndex4,_getChartTypeByIndex =
            getChartTypeByIndex(chartObj, paneid, index),chartName = _getChartTypeByIndex.name,cType = _getChartTypeByIndex.value,
            chartTop = renderer.plotarea && renderer.plotarea() && renderer.plotarea().top || 0,
            dataLabels;
          var translation = "translate(".concat(args[9], ")"),
            isPyramid = chartName === PYRAMID_CHARTNAME;

          currentdata = currentdata[index];
          var plotoptions = currentdata.plotoptions,
            boundBoxPaddingAlone = 0,
            boundBoxPadding = 0,
            hookWidth = 0,
            boundBoxRadius = 0;
          dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index);

          if (isBoundBoxEnabled(dataLabels, chartObj)) {
            var boundBoxOptions = getMergedBoundBoxOptions(dataLabels, chartObj);
            var hookOptions = getBoundBoxHookConf(boundBoxOptions.hook);
            boundBoxPaddingAlone = getBoundBoxPadding(dataLabels, chartObj);
            boundBoxPadding = boundBoxPaddingAlone + getBoundBoxStrokeWidth(dataLabels, chartObj) + hookOptions.height;
            hookWidth = hookOptions.width;
            boundBoxRadius = boundBoxOptions.radius;
          }

          var padding = cfg.datalabelPadding || +dataLabels.padding || 0,
            type = dataLabels.type,
            handleOverlapping = systemconf.chart.plot.datalabels.handleOverlapping === true,
            txtHgt = getFontSizeByHierarchy(dataLabels, chartObj),
            GLT = dataLabelTextContent(chartObj, rp, dataLabels, DATALABELS_LABELTYPE, totalEngagement, index, undefined, paneid),
            contentType = GLT.contentType || 'text',
            isHTMLContent = contentType === 'html',
            isMultiLine = isHTMLContent && GLT.multiLine,
            showlabel = isDatalabelEnabled(dataLabels, chartObj),
            relativeX = dataLabels.relativeX === true,
            useBBox = isObjectPropDefined(dataLabels, 'preCalculation.useBBox', true);

          if (!showlabel) {
            return;
          }

          showlabel = showlabel ? type : 'hidden';
          var data_length = data.length,
            PathGroupPosition = getSvgTransform(chartObj.svg.selectAll("g.".concat(chartName, "group"))).translate,
            idx = 0;

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), 'text', [1], '.', 'class', 'temp_label'),
            node = temp_label.node();
          applyDatalabelFonts(temp_label, dataLabels, chartObj, rp.color);
          temp_label.attr('transform', translation).style('opacity', 0);
          var queue = labelHandler.add;

          (hasColorColumnInNonAxis(chartObj) ? [currentdata] : currentdata.data).forEach(function (d, i) {
            var dataUpdate = labelPosition,
              commonProperties = [],
              subSeriesIndex = pick(args[8], i),
              overlap = {},
              objs = [];

            dataUpdate.forEach(function (d, j) {
              var display = !isdisabled(j),
                isLeft = isLeftHalf(idx),
                ANCHOR = isLeft ? 'end' : null,
                DY = isMultiLine && isUndefined(dataLabels.y) ? '0.9em' : '0.3em',
                dt = d.data = data[data_length - 1 - j],
                text = GLT(dt, data_length - 1 - j),
                //
                xF = pick(dataLabels.x, function (d, chartObj, bb) {
                  var _ = getEndX(d, idx, overlap) + (isLeft ? -boundBoxPadding : boundBoxPadding);
                  if (display && isMultiLine && !useBBox) {
                    _ += bb.width / 2 * (isLeft ? -1 : 1);
                  }
                  return _;
                }),
                yF = pick(dataLabels.y, function (d, chartObj, bb) {
                  var _ = isPyramid && isLeft ? d.leftY : mathMax(d.y, txtHgt - arcHeight - d.y);
                  if (display && isMultiLine) {
                    _ -= bb.height / 2;
                  }
                  return _;
                }),
                heightToBeAdded = 0,
                bb;

              temp_label[contentType](text).attrs({
                'text-anchor': ANCHOR,
                dy: DY
              });

              if (display && isMultiLine) {
                translateTspan(temp_label, 0);
              }

              bb = bbox(node);
              var X = invokeFunction(xF, d, chartObj, bb),
                Y = invokeFunction(yF, d, chartObj, bb);

              if (display && isMultiLine) {
                translateTspan(temp_label, X);
              }

              temp_label.attrs({
                x: X,
                y: Y
              });

              if (handleOverlapping) {
                if (display) {
                  bb = bbox(node);
                  heightToBeAdded = getSizeToBeAdded(bb.height, boundBoxPaddingAlone, boundBoxRadius, hookWidth);
                  var DX = isLeft ? -(0 + padding + boundBoxPadding) : chartWidth + padding + boundBoxPadding;
                  if (isMultiLine && !useBBox) {
                    DX += bb.width / 2 * (isLeft ? -1 : 1);
                  }

                  objs.push({
                    id: "lbl".concat(index, "_").concat(subSeriesIndex, "_").concat(j),
                    x1: bb.x - boundBoxPadding,
                    x2: bb.x + bb.width + boundBoxPadding,
                    y1: bb.y - MARGIN - boundBoxPadding - heightToBeAdded / 2,
                    isLeft: isLeft,
                    y2: bb.y + bb.height + MARGIN + boundBoxPadding + heightToBeAdded / 2,
                    DX: DX - X
                  });
                }
              } else {
                bb = bbox(node);
                heightToBeAdded = getSizeToBeAdded(bb.height, boundBoxPaddingAlone, boundBoxRadius, hookWidth);
              }

              var coordinate = {
                X: X,
                Y: Y,
                ANCHOR: ANCHOR,
                DY: DY,
                text: text,
                display: display,
                ID: "lbl".concat(index, "_").concat(subSeriesIndex, "_").concat(j),
                width: display ? bb.width : 0,
                height: display ? bb.height + heightToBeAdded : 0,
                hookPosition: isLeft ? RIGHT_ALIGN : LEFT_ALIGN,
                XY: [X, Y]
              };

              if (isHTMLContent) {
                coordinate.isLeft = isLeft;
              }

              commonProperties.push(coordinate);

              idx += display ? 1 : 0;
            });

            idx = -1;
            commonProperties.id = "".concat(paneid, "(").concat(index, "_").concat(subSeriesIndex, ")");
            commonProperties.translation = translation;
            commonProperties.dataUpdate = dataUpdate;
            commonProperties.overlap = overlap;
            commonProperties.connectorPath = function (d, i) {
              idx += isdisabled(i) ? 0 : 1;
              var coordinate = commonProperties[i],
                y = coordinate.Y + (isMultiLine && isUndefined(dataLabels.y) ? coordinate.height / 2 : 0),
                y0 = defined(dataLabels.y) ? coordinate.XY[1] : isPyramid && isLeftHalf(idx) ? d.leftY : d.y,
                polygon = [
                [getStartX(d, idx, coordinate), y0],
                [getEndX(d, idx, overlap, 0, coordinate), y0],
                [getEndX(d, idx, overlap, undefined, coordinate), y]];


              return d3Line(polygon);
            };

            // add to drawing queue
            var q = queue(commonProperties, index, subSeriesIndex, null, null, rendererIndex);
            objs.forEach(function (_) {return _.queue = q;});
            labelArray.push.apply(labelArray, objs);
            labelArray.queue = q;
            labelArray.queues = labelArray.queues || [];
            labelArray.queues.push(q);
            labelArray.subSeriesIndex = subSeriesIndex;

            q.properties = {
              type: PIE_CHARTNAME,
              dataLabels: dataLabels,
              dataUpdate: dataUpdate,
              showlabel: showlabel,
              rp: rp,
              trans: args[9],
              txtHgt: txtHgt,
              reverseColor: true,
              onOverlap: function onOverlap(_) {
                _.overlap.stage = 'overlap';
              },
              contentType: contentType,
              isMultiLine: isMultiLine,
              chartType: cType
            };

            labelArray.TOP = chartTop - args[9][1], labelArray.BOTTOM = chartHeight + args[9][1];
            labelArray.actualType = FUNNEL_CHARTNAME;
          });

          function isdisabled(i) {
            var dt = data[data_length - 1 - i];
            var isWithinClrRange =
            isWithinColorRange(dataset.getClr(dt), chartObj) && !isSeriesFiltered(chartObj, paneid, data_length - 1 - i);
            return dt.disabled || !dataset.getY(dt, yaxiscolumnorder) || !isWithinClrRange;
          }

          function isLeftHalf(idx) {
            switch (showlabel) {
              case 'singleside':
                return false;
              case 'doubleside':
                return idx % 2 == 0;
              case 'strokeddoubleside':
                return idx >= noofNotNullData / 2;}

          }

          function getStartX(d, i, coordinate) {
            if (defined(dataLabels.y)) {
              var y = coordinate.XY[1];
              return d._x(y, isLeftHalf(i));
            }

            return isLeftHalf(i) ? d.leftx + padding : d.rightx - padding;
          }

          function getEndX(d, i, options, pad, coordinate) {
            var isLeft = isLeftHalf(i);

            if (defined(dataLabels.x) && coordinate) {
              return coordinate.XY[0];
            }

            if (!relativeX || options.stage == 'overlap') {
              pad = defined(pad) ? pad : padding;
              return isLeft ? 0 - pad : chartWidth + pad;
            } else {
              return isLeft ? d.leftx - boundBoxPadding : d.rightx + boundBoxPadding;
            }
          }
        });
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };
      return labels;
    }

    LabelRegistry.add('funnel', funnelLabel);

    //$Id$

    function funnelInnerLabel() {
      var renderer, args;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var currentdata = args[0],
            index = args[1],
            data = args[2],
            arcHeight = args[4],
            totalEngagement = args[5],
            cfg = args[6],
            labelPosition = args[7];
          var chartWidth = cfg.width,
            rp = renderer.commonRendererProp().params,_rp$rendererIndex5 =
            rp.rendererIndex,rendererIndex = _rp$rendererIndex5 === void 0 ? index : _rp$rendererIndex5,
            chartObj = rp.chartObj,
            commonPlotOptions = rp.commonPlotOptions,
            dataset = rp.dataset,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            paneid = labelHandler.paneid,_getChartTypeByIndex2 =
            getChartTypeByIndex(chartObj, paneid, index),chartName = _getChartTypeByIndex2.name,cType = _getChartTypeByIndex2.value;
          var translation = "translate(".concat(args[9], ")"),
            isPyramid = chartName === PYRAMID_CHARTNAME;

          currentdata = currentdata[index];
          var plotoptions = currentdata.plotoptions;
          var dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index);
          var innerLabels = dataLabels.innerLabel,
            padding = cfg.datalabelPadding || +dataLabels.padding || 0,
            data_length = data.length;

          var showInnerLabel = innerLabels.show === true,
            txtHgt = getFontSizeByHierarchy(innerLabels, chartObj),
            GLT = dataLabelTextContent(chartObj, rp, innerLabels, INNERLABEL_LABELTYPE, totalEngagement, index, undefined, paneid),
            contentType = GLT.contentType || 'text',
            isMultiLine = contentType === 'html' && GLT.multiLine,
            boundBoxPadding = isBoundBoxEnabled(dataLabels, chartObj) ?
            getBoundBoxPadding(dataLabels, chartObj) + getBoundBoxStrokeWidth(dataLabels, chartObj) :
            0;
          showInnerLabel = showInnerLabel && datacount_based_intelligence(chartObj, DATALABELS_LABELTYPE);
          txtHgt = txtHgt + 2 * boundBoxPadding;

          if (currentdata.disabled || !showInnerLabel) {
            return;
          }

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), 'text', [1], '.', 'class', 'temp_label');
          applyDatalabelFonts(temp_label, innerLabels, chartObj, rp.color);
          temp_label.attr('transform', translation).style('opacity', 0);
          var queue = labelHandler.add;

          currentdata.data.forEach(function (d, i) {
            var dataUpdate = labelPosition,
              commonProperties = [],
              subSeriesIndex = pick(args[8], i);

            dataUpdate.forEach(function (d, j) {
              var display = !isdisabled(j),
                X = isPyramid ? d.midX : chartWidth / 2,
                Y = isPyramid ? d.leftY : d.y,
                ANCHOR = 'middle',
                DY = isMultiLine ? '0.9em' : '0.5em',
                text = GLT(data[data_length - 1 - j], data_length - 1 - j),
                bb = null;

              temp_label[contentType](text).attrs({
                x: X,
                y: Y,
                dy: DY,
                'text-anchor': ANCHOR
              });

              if (display && isMultiLine) {
                translateTspan(temp_label, X);
                bb = bbox(temp_label.node());
                Y -= bb.height / 2;
                txtHgt = bb.height;
              }

              if (display) {
                bb = bb || bbox(temp_label.node());
                if (isPyramid) {
                  display = !(txtHgt > (d.y0 - d.leftY) * 2);
                } else {
                  var ellipseArcHeight = cfg.canOverlap ?
                  (d.rightx - d.leftx - 2 * padding) / chartWidth * arcHeight :
                  arcHeight;
                  display = !(
                  txtHgt < d.y - (d.y0 - d.y) + ellipseArcHeight &&
                  txtHgt > d.y0 + ellipseArcHeight - (d.y - (d.y0 - d.y) + ellipseArcHeight));

                }
              }

              var coordinate = {
                X: X,
                Y: Y,
                DY: DY,
                ANCHOR: ANCHOR,
                text: text,
                display: display,
                ID: "innerlbl".concat(index, "_").concat(subSeriesIndex, "_").concat(j),
                width: display ? bb.width : 0,
                height: display ? bb.height : 0
              };
              commonProperties.push(coordinate);
            });

            commonProperties.dataUpdate = dataUpdate;
            commonProperties.data = data;
            commonProperties.translation = "translate(".concat(args[9], ")");

            // add to drawing queue
            var q = queue(commonProperties, index, subSeriesIndex, NULL$1, INNERLABEL_LABELTYPE, rendererIndex, paneid);
            q.properties = {
              type: PIE_CHARTNAME,
              dataLabels: innerLabels,
              dataUpdate: dataUpdate,
              showlabel: showInnerLabel,
              rp: rp,
              trans: args[9],
              reverseColor: true,
              contentType: contentType,
              isMultiLine: isMultiLine,
              chartType: cType,
              data: data
            };
          });

          function isdisabled(i) {
            var dt = data[data_length - 1 - i];
            var isWithinClrRange =
            isWithinColorRange(dataset.getClr(dt), chartObj) && !isSeriesFiltered(chartObj, paneid, data_length - 1 - i);
            return dt.disabled || !dataset.getY(dt, yaxiscolumnorder) || !isWithinClrRange;
          }
        });
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };
      return labels;
    }

    LabelRegistry.add('funnelInnerLabels', funnelInnerLabel);

    //$Id$

    function pieLabel() {
      var renderer, args, outline, isSunburst, chartObj, dataset, paneid;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var currentdata = args[0],
            pieData = args[2],
            outerRadius = args[3],
            totalEngagement = args[4],
            outlineWithPad = args[5],
            translation = "translate(".concat(args[8][0], ",").concat(args[8][1], ")"),
            extraOptions = args[9] || {},
            rp = renderer.commonRendererProp().params;

          chartObj = rp.chartObj;
          dataset = chartObj.dataset;
          paneid = labelHandler.paneid;
          var systemconf = chartObj.systemConf,
            commonPlotOptions = rp.commonPlotOptions,
            labelArray = getLabelArray(rp, paneid, args[10]),
            index = rp.datasetIndex || args[1] || 0, //For pie & dial chart, rp.datasetIndex is undefined
            rendererIndex = pick(labelHandler.rendererIndex, index),
            dataLabels,
            chartheight = (renderer.plotarea && renderer.plotarea() || chartObj.plotarea).height,
            chartTop = renderer.plotarea && renderer.plotarea() && renderer.plotarea().top || 0,
            cType = getChartTypeByIndex(chartObj, paneid, index).value;
          isSunburst = isSunburstChartType(cType);
          currentdata = currentdata[index];
          outline = args[6];

          var handleOverlapping = systemconf.chart.plot.datalabels.handleOverlapping === true,
            datalabelPadding,
            padding,
            txtHgt,
            showlabel;

          var plotoptions = currentdata.plotoptions;
          var dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index);
          showlabel = isDatalabelEnabled(dataLabels, chartObj);

          if (currentdata.disabled || !showlabel || isSunburst && isSeriesFiltered(chartObj, paneid, index)) {
            return;
          }

          var type = dataLabels.type,
            lineConf = dataLabels.line,
            GLT = dataLabelTextContent(chartObj, rp, dataLabels, DATALABELS_LABELTYPE, totalEngagement, index, undefined, paneid),
            contentType = GLT.contentType || 'text',
            isHTMLContent = contentType === 'html',
            isMultiLine = isHTMLContent && GLT.multiLine,
            useBBox = isObjectPropDefined(dataLabels, 'preCalculation.useBBox', true),
            boundBoxPaddingAlone = 0,
            boundBoxPadding = 0,
            hookWidth = 0,
            boundBoxRadius = 0;

          if (isBoundBoxEnabled(dataLabels, chartObj)) {
            var boundBoxOptions = getMergedBoundBoxOptions(dataLabels, chartObj);
            var hookOptions = getBoundBoxHookConf(boundBoxOptions.hook);
            boundBoxPaddingAlone = getBoundBoxPadding(dataLabels, chartObj);
            boundBoxPadding = boundBoxPaddingAlone + getBoundBoxStrokeWidth(dataLabels, chartObj) + hookOptions.height;
            hookWidth = hookOptions.width;
            boundBoxRadius = boundBoxOptions.radius;
          }

          showlabel = showlabel ? type : 'hidden';
          datalabelPadding = (extraOptions.padding || +(dataLabels.padding || 0)) + boundBoxPadding;
          txtHgt = getFontSizeByHierarchy(dataLabels, chartObj);
          padding = +(utils.getValueOfPlotOptions(plotoptions, commonPlotOptions)('outerPadding') || 0);
          renderer.autoLabelDone = false,
          renderer.showlabel = showlabel,
          renderer.lineStrokeWidth = validateNullVal(lineConf.strokeWidth, 1);

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), 'text', [1], '.', 'class', 'temp_label');
          temp_label.attr('transform', translation);
          var queue = labelHandler.add;

          (isSunburst ? currentdata : hasColorColumnInNonAxis(chartObj) ? [currentdata] : currentdata.data).forEach(function (d, i) {
            var dataUpdate = renderer.seriesdataAfterUpdate ? renderer.seriesdataAfterUpdate[i] : isSunburst ? d : pieData,
              subSeriesIndex = pick(args[10], i),
              objs = [];

            var commonProperties = [];
            applyDatalabelFonts(temp_label, dataLabels, chartObj, rp.color);
            temp_label.style('opacity', 0);

            dataUpdate.forEach(function (d, j) {
              var text,
                bb = null,
                display = !isdisabled(d),
                heightToBeAdded = 0;

              var angle = midAngle(d);
              var isLeft = angle < 0 || angle > mathPI;
              var X =
                showlabel == 'doubleside' ?
                angle < 0 || angle > mathPI ?
                -(outerRadius + datalabelPadding) :
                outerRadius + datalabelPadding :
                outlineWithPad.centroid(d)[0],
                Y =
                outlineWithPad.centroid(d)[1] +
                mathMax(0, txtHgt - padding - 10 - (outerRadius + outlineWithPad.centroid(d)[1])),
                ANCHOR = isLeft ? 'end' : 'start',
                DY = isMultiLine ?
                '0.9em' :
                showlabel == 'circular' && angle > mathPI / 2 && angle < 3 * mathPI / 2 ? "".concat(
                getDY(angle), "em") :
                '0.3em';
              var actualDY = DY;

              var dt = d.data;
              var toNull = isSunburst ? d.depth == 0 : isdisabled(d);
              text = toNull ? null : GLT(dt, j);

              temp_label[contentType](text).attrs({
                x: X,
                y: Y,
                dy: DY,
                'text-anchor': ANCHOR
              });

              if (display && isMultiLine) {
                translateTspan(temp_label, X);
                var bb = bbox(temp_label.node());
                if (showlabel == 'circular') {
                  var yscale = d3_scaleLinear().
                  range([-1, 0]).
                  domain(angle < mathPI ? [0, mathPI] : [2 * mathPI, mathPI]);
                  Y += yscale(angle) * bb.height;
                  X += (angle > 0 && angle < mathPI ? 0.5 : angle > mathPI && angle < 2 * mathPI ? -0.5 : 0) * bb.width;
                } else {
                  Y -= 0.5 * bb.height;
                  if (!useBBox) {
                    X -= bb.width / 2 * (isLeft ? 1 : -1);
                  }
                }

                temp_label.attr('y', Y);
                translateTspan(temp_label, X);
              }

              if (handleOverlapping) {
                renderer.showlabel = 'auto';
                var MARGIN = 5,
                  extra = 10;

                if (!isMultiLine) {
                  DY = '0.3em';
                  temp_label.attr('dy', DY); // Test_495.json
                }

                if (display) {
                  bb = bbox(temp_label.node());
                  heightToBeAdded = getSizeToBeAdded(bb.height, boundBoxPaddingAlone, boundBoxRadius, hookWidth);
                  var DX = isLeft ? -(outerRadius + datalabelPadding + extra) : outerRadius + datalabelPadding + extra;
                  if (isMultiLine && !useBBox) {
                    DX += bb.width / 2 * (isLeft ? -1 : 1);
                  }

                  objs.push({
                    id: "lbl".concat(index, "_").concat(i, "_").concat(j),
                    x1: bb.x - boundBoxPadding,
                    x2: bb.x + bb.width + boundBoxPadding,
                    y1: bb.y - MARGIN - boundBoxPadding - heightToBeAdded / 2,
                    y2: bb.y + bb.height + MARGIN + boundBoxPadding + heightToBeAdded / 2,
                    isLeft: isLeft,
                    actualDY: actualDY,
                    DX: DX - X,
                    overlappingHookPosition: isLeft ? RIGHT_ALIGN : LEFT_ALIGN
                  });
                }
              } else {
                bb = bbox(temp_label.node());
                heightToBeAdded = getSizeToBeAdded(bb.height, boundBoxPaddingAlone, boundBoxRadius, hookWidth);
              }

              var coordinate = {
                X: X,
                Y: Y,
                DY: DY,
                ANCHOR: ANCHOR,
                text: text,
                display: display,
                ID: "lbl".concat(index, "_").concat(subSeriesIndex, "_").concat(j),
                width: display ? bb.width : 0,
                height: display ? bb.height + heightToBeAdded : 0,
                hookPosition: showlabel === 'circular' ? null : isLeft ? RIGHT_ALIGN : LEFT_ALIGN
              };

              if (isHTMLContent) {
                coordinate.isLeft = isLeft;
              }

              commonProperties.push(coordinate);
            });

            // add to drawing queue
            commonProperties.id = "".concat(paneid, "(").concat(index, "_").concat(subSeriesIndex, ")");
            commonProperties.translation = translation;
            commonProperties.dataUpdate = dataUpdate;
            commonProperties.renderer = renderer;

            var q = queue(commonProperties, index, subSeriesIndex, null, null, rendererIndex);
            objs.forEach(function (_) {return _.queue = q;});
            labelArray.push.apply(labelArray, objs);
            labelArray.queue = q;
            labelArray.queues = labelArray.queues || [];
            labelArray.queues.push(q);
            labelArray.subSeriesIndex = subSeriesIndex;

            q.properties = {
              type: PIE_CHARTNAME,
              dataLabels: dataLabels,
              dataUpdate: dataUpdate,
              showlabel: renderer.showlabel,
              rp: rp,
              trans: args[8],
              txtHgt: txtHgt,
              isSunburst: isSunburst,
              connectorPath: function connectorPath(d, i) {
                var angle = midAngle(d);
                var str = "M ".concat(outline.centroid(d)[0], " ").concat(outline.centroid(d)[1], " L").concat(outlineWithPad.centroid(d)[0], " ").concat(
                outlineWithPad.centroid(d)[1]);

                return "".concat(str, " L").concat(outlineWithPad.centroid(d)[0], " ").concat(outlineWithPad.centroid(d)[1], " L").concat(
                angle < 0 || angle > mathPI ?
                -(outerRadius + datalabelPadding - boundBoxPadding) :
                outerRadius + datalabelPadding - boundBoxPadding, " ").concat(
                outlineWithPad.centroid(d)[1]);
              },
              onNonOverlap: function onNonOverlap(_queue) {
                _queue.showlabel = _queue.renderer.showlabel = showlabel;
                _queue.renderer.autoLabelDone = true;
              },
              onOverlap: function onOverlap(_queue) {
                _queue.connectorPath = function (d, i) {
                  // console.log(_queue, q[0]);
                  var extra = 10;
                  var angle = midAngle(d);
                  var pad = mathMax(0, txtHgt - padding - 10 - (outerRadius + outlineWithPad.centroid(d)[1]));
                  var y = outlineWithPad.centroid(d)[1] + pad;
                  var flip = angle < 0 || angle > mathPI ? -1 : 1;
                  var newY = _queue[i].Y + (isMultiLine ? _queue[i].height / 2 : 0);
                  // var path = "M " + outline.centroid(d)[0] + " " + outline.centroid(d)[1] +
                  //     " L" + outlineWithPad.centroid(d)[0] + " " + outlineWithPad.centroid(d)[1] +
                  //     " L" + ( (outerRadius + datalabelPadding) * flip ) + " " + outlineWithPad.centroid(d)[1] +
                  //     " L" + ( (outerRadius + datalabelPadding + extra) * flip ) + " " + newY;
                  // ele
                  // .attr("d", path);

                  var xControl =
                    newY - y ?
                    (outerRadius + datalabelPadding - boundBoxPadding + extra) * flip :
                    outlineWithPad.centroid(d)[0],
                    yControl = outlineWithPad.centroid(d)[1],
                    x2 = (outerRadius + datalabelPadding - boundBoxPadding + extra) * flip,
                    y2 = newY;
                  var path = "M ".concat(outline.centroid(d)[0], " ").concat(outline.centroid(d)[1], " Q ").concat(xControl, " ").concat(yControl, " ").concat(x2, " ").concat(y2);
                  return path;
                };
              },
              contentType: contentType,
              isMultiLine: isMultiLine,
              chartType: cType
            };

            labelArray.TOP = chartTop - args[8][1], labelArray.BOTTOM = chartTop + chartheight - args[8][1];
          });
        });
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };

      function isdisabled(d) {
        var isWithinClrRange = isWithinColorRange(dataset.getClr(isSunburst ? d : d.data), chartObj);
        var active = isWithinClrRange && (isSunburst ? true : !isSeriesFiltered(chartObj, paneid, d.index));
        return !active || (isSunburst ? d.parent == null || d.value == 0 : d.value == 0);
      }

      function midAngle(d) {
        var start = isSunburst ? outline.startAngle()(d) : d.startAngle,
          end = isSunburst ? outline.endAngle()(d) : d.endAngle;
        return (start + end) / 2;
      }

      return labels;
    }

    LabelRegistry.add('pie', pieLabel);

    //$Id$

    function pieInnerLabel() {
      var renderer, args, chartObj, dataset;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var currentdata = args[0],
            pieData = args[2],
            totalEngagement = args[4],
            translation = args[8] ? "translate(".concat(args[8][0], ",").concat(args[8][1], ")") : null,
            arc = args[7],
            isParent = args[9],
            rp = renderer.commonRendererProp().params,_rp$rendererIndex6 =
            rp.rendererIndex,rendererIndex = _rp$rendererIndex6 === void 0 ? index : _rp$rendererIndex6;

          dataset = rp.dataset;
          chartObj = rp.chartObj;
          var commonPlotOptions = rp.commonPlotOptions,
            index = args[1] || 0,
            paneid = labelHandler.paneid,
            chartType = getChartTypeByIndex(chartObj, paneid, index).value,
            isSunburst = isSunburstChartType(chartType),
            outline = args[6],
            yaxiscolumnorder = rp.yaxiscolumnorder;

          isParent = isSunburst ? isParent : NULL$1;
          currentdata = currentdata[index];
          var isBubblePie = chartcategory.bubblePie.has(chartType);

          var plotoptions = currentdata.plotoptions,
            dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index),
            innerLabels = dataLabels.innerLabel,
            showInnerLabel = innerLabels.show === true && datacount_based_intelligence(chartObj, DATALABELS_LABELTYPE);

          if (isParent) {
            var parentLabelOptions = mergeJSON$1(innerLabels.parentLabel, innerLabels);
            showInnerLabel = (defined(parentLabelOptions.show) ? parentLabelOptions.show : innerLabels.show) !== false;
            innerLabels = parentLabelOptions;
          }

          var GLT = dataLabelTextContent(chartObj, rp, innerLabels, INNERLABEL_LABELTYPE, totalEngagement, index, undefined, paneid),
            contentType = GLT.contentType || 'text',
            isMultiLine = contentType === 'html' && GLT.multiLine,
            textOverlap = innerLabels.textOverlap || 'adjust',
            boundBoxPadding = isBoundBoxEnabled(innerLabels, chartObj) ?
            getBoundBoxPadding(innerLabels, chartObj) + getBoundBoxStrokeWidth(innerLabels, chartObj) :
            0;

          if (currentdata.disabled || !showInnerLabel || (isBubblePie || isSunburst) && isSeriesFiltered(chartObj, paneid, index)) {
            return;
          }

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), 'text', [1], '.', 'class', 'temp_label');
          applyDatalabelFonts(temp_label, innerLabels, chartObj, rp.color);
          temp_label.attr('transform', translation).style('opacity', 0);
          var queue = labelHandler.add;

          (isSunburst ? currentdata : hasColorColumnInNonAxis(chartObj) ? [currentdata] : currentdata.data).forEach(function (d, i) {
            var dataUpdate = isBubblePie ? renderer.seriesdataAfterUpdate ? renderer.seriesdataAfterUpdate[i] : d : pieData,
              commonProperties = [],
              subSeriesIndex = pick(args[10], i);

            dataUpdate.forEach(function (d, j) {
              var bb = null;
              var display = !isdisabled(d),
                ANCHOR = 'middle',
                DY = isMultiLine ? '0.9em' : '0.35em',
                X,
                Y,
                xVal = 0,
                yVal = 0;
              if (isBubblePie) {
                var stacked = rp.stacked,
                  axisrotated = rp.axisrotated,
                  xscale = rp.xscale,
                  yscale = rp.yscale;
                var key = bubblepieUtils.getKey(d, index, chartObj);
                var pieRenderer = chartObj.subrenderer[i][key];
                d = pieRenderer.data[index];
                arc = pieRenderer.arc;

                xVal = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d.data, 'x', null);
                yVal = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d.data, 'y', null);
                var zVal = chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d.data,
                'z',
                chartObj.zscale);


                var outerRadius = zVal / 4;
                var polarXY = polarToXY(outerRadius, midAngle(d));
                GLT = dataLabelTextContent(
                chartObj,
                rp,
                innerLabels,
                INNERLABEL_LABELTYPE,
                pieRenderer.total,
                index,
                undefined,
                paneid);


                X = xVal + polarXY[0];
                Y = yVal + polarXY[1];
              } else {
                X = arc.centroid(d)[0];
                Y = arc.centroid(d)[1];
              }

              var dt = d.data;
              var toNull = isSunburst ? d.depth == 0 : isdisabled(d);
              var text = toNull ? null : GLT(dt, j);

              temp_label[contentType](text).attrs({
                x: X,
                y: Y,
                dy: DY,
                'text-anchor': ANCHOR
              });

              if (display && isMultiLine) {
                translateTspan(temp_label, X);
                bb = bbox(temp_label.node());
                Y -= bb.height / 2;
              }

              if (textOverlap != NONE) {
                /*
                 * Default position for the inner label is arc.centroid(d)
                 * innerLabelWithinArc() finds the best position for the inner label
                 * If the inner label overflows in its centroid position but it could be placed inside the arc, it will be translated to its best position
                 * Else it will not be displayed
                 */
                bb = bb || bbox(temp_label.node());
                var centre = arc.centroid(d);
                var wid = bb.width / 2 + boundBoxPadding,
                  hei = bb.height / 2 + boundBoxPadding;
                var TL = {
                    x: centre[0] - wid,
                    y: centre[1] - hei
                  },
                  TR = {
                    x: centre[0] + wid,
                    y: centre[1] - hei
                  },
                  BL = {
                    x: centre[0] - wid,
                    y: centre[1] + hei
                  },
                  BR = {
                    x: centre[0] + wid,
                    y: centre[1] + hei
                  };
                var isPointInArc = pointIsInArc(TL, d) && pointIsInArc(TR, d) && pointIsInArc(BL, d) && pointIsInArc(BR, d);
                if (!isPointInArc) {
                  if (textOverlap === 'adjust') {
                    var SA = isSunburst ? outline.startAngle()(d) : d.startAngle,
                      EA = isSunburst ? outline.endAngle()(d) : d.endAngle,
                      MA = midAngle(d),
                      extra = bb.height + 2 * boundBoxPadding, // / Math.cos(MA), //Need to check again
                      s,
                      e;

                    var a1 = xyToAngle(TL),
                      a2 = xyToAngle(TR),
                      a3 = xyToAngle(BL),
                      a4 = xyToAngle(BR);
                    var angleArray = [a1, a2, a3, a4],
                      posArray = [TL, TR, BL, BR];
                    var minmax = d3_extent(angleArray);

                    var s = posArray[angleArray.indexOf(minmax[0])],
                      e = posArray[angleArray.indexOf(minmax[1])];

                    var dist = mathSQRT((s.x - e.x) * (s.x - e.x) + (s.y - e.y) * (s.y - e.y));
                    var r = mathAbs(dist / 2 / mathTan((EA - SA) / 2)) + extra;
                    var newCentre = [mathSin(MA) * r, -(mathCos(MA) * r)];

                    var TL = {
                        x: newCentre[0] - wid,
                        y: newCentre[1] - hei
                      },
                      TR = {
                        x: newCentre[0] + wid,
                        y: newCentre[1] - hei
                      },
                      BL = {
                        x: newCentre[0] - wid,
                        y: newCentre[1] + hei
                      },
                      BR = {
                        x: newCentre[0] + wid,
                        y: newCentre[1] + hei
                      };
                    isPointInArc = pointIsInArc(TL, d) && pointIsInArc(TR, d) && pointIsInArc(BL, d) && pointIsInArc(BR, d);
                  }

                  if (isPointInArc) {
                    X = newCentre[0] + xVal;
                    Y = newCentre[1] + yVal;
                  } else {
                    display = false;
                  }
                }
              } else {
                bb = bbox(temp_label.node());
              }

              var coordinate = {
                X: X,
                Y: Y,
                DY: DY,
                ANCHOR: ANCHOR,
                text: text,
                display: display,
                ID: "innerlbl".concat(index, "_").concat(subSeriesIndex, "_").concat(j),
                width: bb.width,
                height: bb.height
              };
              commonProperties.push(coordinate);
            });

            // add to drawing queue
            commonProperties.dataUpdate = dataUpdate;
            commonProperties.translation = translation;
            var q = queue(
            commonProperties,
            index,
            subSeriesIndex,
            NULL$1,
            isParent ? PARENTLABELS_LABELTYPE : INNERLABEL_LABELTYPE,
            rendererIndex,
            paneid);

            q.properties = {
              type: PIE_CHARTNAME,
              dataLabels: innerLabels,
              dataUpdate: dataUpdate,
              showlabel: showInnerLabel,
              rp: rp,
              trans: args[8],
              isSunburst: isSunburst,
              contentType: contentType,
              isMultiLine: isMultiLine,
              chartType: chartType
            };
          });

          function pointIsInArc(pt, ptData) {
            var r1 = arc.innerRadius()(ptData),
              r2 = arc.outerRadius()(ptData),
              theta1 = arc.startAngle()(ptData),
              theta2 = arc.endAngle()(ptData),
              dist = pt.x * pt.x + pt.y * pt.y,
              angle = xyToAngle(pt);
            return r1 * r1 <= dist && dist <= r2 * r2 && isAngleInside(theta1, theta2, angle);
          }

          function xyToAngle(obj) {
            return mathAtan2(obj.x, -obj.y);
          }

          function isdisabled(d) {
            var dataActive =
            isDataActive(isSunburst ? d : d.data || d, chartObj) && (
            isBubblePie || isSunburst ? true : !isSeriesFiltered(chartObj, paneid, d.index));
            return !dataActive || (isSunburst ? d.parent == null || d.value == 0 : d.value == 0);
          }

          function midAngle(d) {
            var start = isSunburst ? outline.startAngle()(d) : d.startAngle,
              end = isSunburst ? outline.endAngle()(d) : d.endAngle;
            return (start + end) / 2;
          }
        });
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };
      return labels;
    }

    LabelRegistry.add('pieInnerLabels', pieInnerLabel);

    //

    var DY_MAP = {
      top: '0.91em', // TODO: check '1em'
      center: '0.3em',
      bottom: '-0.3em'
    };

    function TitleParserSvg(spec) {
      var config = spec.config,data = spec.data,bound = spec.bound,
        text = config.text,_config$hAlign = config.hAlign,hAlign = _config$hAlign === void 0 ? 'left' : _config$hAlign,_config$vAlign = config.vAlign,vAlign = _config$vAlign === void 0 ? 'top' : _config$vAlign,
        margin = parseShortHandValue(pick(config.margin, 3)),
        _margin = parseShortHandValue(pick(spec.margin, config.margin, 3)),
        _edge = edge(bound, margin),

        preparedConfig = { text: decodeHTML(text), x: margin.left, y: margin.top, dy: DY_MAP[vAlign], anchor: TEXT_ANCHOR_MAP[hAlign] };

      var titleMark = Mark('text', null, data);
      titleMark.onEnd = _edge && _margin && function (ele) {return trimTitle(ele, _edge, _margin);};
      titleMark.config = _objectSpread(_objectSpread({}, config), preparedConfig);

      return titleMark;
    }

    function trimTitle(ele, edge, margin) {
      var node = ele.node(),
        bb = bbox(node),
        pattern = '..',
        textBound = {
          left: 0,
          top: 0,
          width: bb.width,
          height: bb.height
        };

      trimText(node, node.textContent, textBound, edge, BOTTOM_ALIGN, pattern, margin);

      if (node.textContent === pattern) {
        ele.text('');
      }
    }

    function edge(bound, margin) {
      var _bound$x = bound.x,x = _bound$x === void 0 ? 0 : _bound$x,_bound$y = bound.y,y = _bound$y === void 0 ? 0 : _bound$y;

      return {
        left: x + margin.left,
        top: y + margin.top,
        right: x + bound.maxWidth + margin.left - margin.right,
        bottom: y + bound.maxHeight + margin.top - margin.bottom
      };
    }

    //

    function LegendTitleSvgParser(spec) {
      var config = spec.config,_spec$data = spec.data,data = _spec$data === void 0 ? [1] : _spec$data,
        show = config.show,
        margin = parseShortHandValue(pick(config.margin, 3));

      // Wrap
      var groupMark = Mark('group', '.zc-legend-title', data);

      if (show) {
        var titleMark = TitleParserSvg(spec);
        titleMark.as = { x: 'bb_x', y: 'bb_y', width: 'bb_width', height: 'bb_height' };

        var backgroundMark = Mark('_rect', null, data);
        backgroundMark.config = {
          x: asParser('bb_x', -margin.left),
          y: asParser('bb_y', -margin.top),
          width: asParser('bb_width', margin.left + margin.right),
          height: asParser('bb_height', margin.top + margin.bottom)
        };
        setPropVal(backgroundMark, 'properties.styles', {
          opacity: 0,
          display: function display() {
            var width = titleMark._as[titleMark.as.width][0],
              height = titleMark._as[titleMark.as.height][0];
            return !(width || height) ? 'none' : null;
          }
        });
        groupMark.children = [titleMark, backgroundMark];
      }

      return groupMark;
    }

    function asParser(as, margin) {
      return { _type: 'as', as: as, onEnd: function onEnd(_) {return _ + margin;} };
    }

    //$Id$

    function _LegendBackgroundSvgParser(spec) {
      var config = spec.config,
        backgroundSpec = parseBackground(config.background),
        borderSpec = parseBorder(config.border),
        margin = parseShortHandValue(spec.margin || config.padding);

      var backgroundMark = Mark('_rect', '.zc-legend-background');
      backgroundMark.dependency = 'legend-content';
      backgroundMark.onStart = spec.onStart;
      backgroundMark.onEnd = spec.onEnd;
      backgroundMark.config = _objectSpread(_objectSpread(_objectSpread({},
      backgroundSpec),
      borderSpec), {}, {
        // TODO: Shadow properties
        x: asParser$1('legend-content', 'background_x', -margin.left),
        y: asParser$1('legend-content', 'background_y', -margin.top),
        width: asParser$1('legend-content', 'background_width', margin.left + margin.right),
        height: asParser$1('legend-content', 'background_height', margin.top + margin.bottom) });


      return backgroundMark;
    }

    function asParser$1(name, as, margin) {
      return { _type: 'as', name: name, as: as, onEnd: function onEnd(_) {return _ + margin;} };
    }

    function parseBackground(config) {
      var _config$color = config.color,color = _config$color === void 0 ? TRANSPARENT : _config$color,alpha = config.alpha;

      return {
        fillColor: color,
        fillOpacity: alpha
      };
    }

    function parseBorder(config) {
      var show = config.show,color = config.color,size = config.size,alpha = config.alpha,style = config.style,lineCap = config.lineCap,radius = config.radius;

      if (show) {
        return {
          strokeColor: color,
          strokeWidth: size,
          strokeOpacity: alpha,
          dashStyle: style,
          lineCap: lineCap,
          radius: radius
        };
      }

      return { strokeWidth: 0, radius: 0 };
    }
    Registry.setComponent('legendBackgroundSvg.parser', _LegendBackgroundSvgParser);

    //

    function LegendContentWrapParser(spec) {
      var contentMark = Mark('group', '.zc-legend-content');
      contentMark.name = 'legend-content';
      contentMark.as = {
        x: 'background_x',
        y: 'background_y',
        width: 'background_width',
        height: 'background_height'
      };

      return contentMark;
    }

    //

    function BandParser(spec) {
      var config = spec.config,dimension = spec.dimension,patternSVG = spec.patternSVG,defsPath = spec.defsPath;

      var bandMark = Mark('_rect', '.zc-band');
      setPropVal(bandMark, 'properties.styles.pointer-events', 'visible');
      bandMark.config = _objectSpread(_objectSpread({},
      config), {}, {
        width: dimension[0],
        height: dimension[1],
        fillColor: _objectSpread(_objectSpread({
          _type: 'gradient',
          gradient: 'linear',
          context: patternSVG,
          dimension: [0, dimension[0]] },
        helper(spec)), {}, {
          defsPath: defsPath }) });



      return bandMark;
    }

    function helper(spec) {
      var reversed = spec.reversed,isHorizontal = spec.isHorizontal,scale = spec.scale,config = spec.config,
        userRanges_length = config.ranges && config.ranges.length,
        scale_domain,
        scale_range,
        offsetScale,
        bound;

      if (reversed) {
        bound = { x1: isHorizontal ? 100 : 0, x2: null, y1: null, y2: isHorizontal ? 0 : 100 };
      } else {
        bound = { x1: null, x2: isHorizontal ? 100 : 0, y1: isHorizontal ? 0 : 100, y2: null };
      }

      if (userRanges_length) {
        scale_range = scale.range().filter(function (d) {return d !== null;});
        var temp_domain = [],
          temp_range = [];
        for (var i = 0; i < userRanges_length; i++) {
          temp_domain.push(i, i + 1);
          temp_range.push(scale_range[i], scale_range[i]);
        }
        scale_domain = temp_domain;
        scale_range = temp_range;

        offsetScale = d3_scalePoint().
        domain(scale_domain).
        range([0, 100]);
      } else {
        scale_domain = scale.domain();
        scale_range = scale.range();

        if (scale_domain[0] === scale_domain[1]) {
          //Test_696.json
          scale_range = [scale_range[0], scale_range[0]];
        }

        offsetScale = d3_scaleLinear().
        domain([scale_domain[0], scale_domain[scale_domain.length - 1]]).
        range([0, 100]);
      }

      return _objectSpread(_objectSpread({}, bound), {}, { stopColor: scale_range, stopOffset: scale_domain.map(function (d) {return "".concat(offsetScale(d), "%");}) });
    }

    //

    function handleTicklabels(ele, tickMarkEle, availableBound, bound, labelParser) {
      if (ele.empty()) {
        return;
      }

      var labelBounds,
        e = ele.nodes(),
        lineElements = tickMarkEle.nodes(),
        edge = _edge(availableBound, bound, labelParser.anchor),
        translateFunction = labelParser.translateFunction,
        _margin = labelParser._margin,
        handler = function handler(ele, i) {
          d3_select(ele).style('display', 'none');
          d3_select(lineElements[i]).style('display', 'none');
          labelBounds[i] = { x1: 0, y1: 0, x2: 0, y2: 0 };
        };

      // TODO remove: minmaxPriority - DOCEVENTS_LEGEND_18 no priority for color band axis
      if (labelParser.minmaxPriority !== false) {
        e.splice(1, 0, e.splice(e.length - 1, 1)[0]);
        lineElements.splice(1, 0, lineElements.splice(lineElements.length - 1, 1)[0]);
      }

      labelBounds = getLabelBounds(e, translateFunction);

      handleOverflow(e, edge, handler, translateFunction, _margin);
      handleOverlap$1(e, labelBounds, handler);
    }

    // TODO: reuse
    function handleOverlap$1(ele, eleBounds, handler) {
      ele.forEach(function (e, i) {
        for (var index = i - 1, overlap = false; index >= 0 && !overlap; index--) {
          overlap = doOverlap(eleBounds[index], eleBounds[i]);
          if (overlap) {
            handler(e, i);
          }
        }
      });
    }

    // TODO: reuse
    function handleOverflow(ele, edge, handler, translateFunction) {var margin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : { left: 0, right: 0, bottom: 0, top: 0 };
      var pattern = '..';

      ele.forEach(function (node, i) {
        var bb = bbox(node),
          translate = getTranslate(node, translateFunction),
          textBound = {
            left: bb.x + translate[0],
            top: bb.y + translate[1],
            width: bb.width,
            height: bb.height
          };

        //TODO: ticklabel.maxWidth
        trimText(node, node.textContent, textBound, edge, BOTTOM_ALIGN, pattern, margin);

        if (node.textContent === pattern) {
          d3_select(node).text('');
        }

        if (!node.textContent) {
          handler(node, i);
        }
      });
    }

    function getLabelBounds(elements, translateFunction) {
      return elements.map(function (_) {return getLabelBound(_, translateFunction);});
    }

    function getLabelBound(ele, translateFunction) {
      var bb = bbox(ele),
        translate = getTranslate(ele, translateFunction);

      var bound = {
        x1: bb.x + translate[0],
        y1: bb.y + translate[1],
        width: bb.width,
        height: bb.height
      };

      bound.x2 = bound.x1 + bound.width;
      bound.y2 = bound.y1 + bound.height;

      return bound;
    }

    function _edge(availableBound, bound, textAnchor) {var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { left: 0, right: 0, bottom: 0, top: 0 };
      var _availableBound$x = availableBound.x,x = _availableBound$x === void 0 ? 0 : _availableBound$x,_availableBound$y = availableBound.y,y = _availableBound$y === void 0 ? 0 : _availableBound$y,maxWidth = availableBound.maxWidth,maxHeight = availableBound.maxHeight,

        top = y + margin.top,
        bottom = top + maxHeight - margin.bottom,
        left = x + margin.left,
        right = left + maxWidth - margin.right;

      switch (textAnchor) {
        case 'end':{
            var r = maxWidth - bound.width;
            left -= r;
            right -= r;
            break;
          }
        case 'middle':{
            var _r2 = (maxWidth - bound.width) / 2;
            left -= _r2;
            right -= _r2;
            break;
          }}


      return { top: top, right: right, bottom: bottom, left: left };
    }

    function getTranslate(ele, translateFunction) {
      return translateFunction ? translateFunction(ele) : getSvgTransform(ele).translate;
    }

    //$Id$

    function handleOverlapNOverlap(axisGroup, axisGroupPosition, position, chartObj, spec, colorAxisOptions, container, _m) {
      var minmaxlabels = _m || axisGroup.selectAll("g.".concat(MINMAXLABEL_LEGEND_CLASSNAME)).selectAll('text'),
        ticklabels = axisGroup.selectAll('g.tick').selectAll('text'),
        minmaxlabelsBoundArray = handleOverflowNGetBoundForMinmaxlabels(minmaxlabels, axisGroupPosition, position, chartObj, spec);

      handleOverflowNOverlapForTicklabels(ticklabels, axisGroupPosition, position, minmaxlabelsBoundArray, chartObj, spec, container);

      if (colorAxisOptions.ticklabel.tooltip === true) {
        //#ZC1327 // Have to enhance to show formatted value and user specified labels
        ticklabels.each(function (d) {
          addSVGtitleEle(d3_select(this), this.__formattedValue);
        });
      }
    }

    function handleOverflowNGetBoundForMinmaxlabels(minmaxlabels, axisGroupPosition, position, chartObj, spec) {
      var config = spec.config,bound = spec.bound,
        legendOptions = config,
        legendAlign = getLegendAlignment(legendOptions),
        minmaxlabelsBoundArray = [],
        bound = getAvailableLegendBound(config, bound, chartObj.chartarea, chartObj.canvasarea),
        edge = {
          left: bound.x1,
          top: bound.y1,
          right: bound.x2,
          bottom: bound.y2
        },
        margin = {
          left: 5,
          right: 5,
          top: 5,
          bottom: 5
        },
        pattern = '..';

      minmaxlabels.each(function (d, i) {
        var pos = getMinmaxLabelBound(this, axisGroupPosition, position);

        var textBound = {
          left: pos.x1,
          top: pos.y1,
          width: pos.width,
          height: pos.height
        };
        trimText(this, this.textContent, textBound, edge, BOTTOM_ALIGN, pattern, margin);
        if (this.textContent === pattern) {
          d3_select(this).text('');
        }
        minmaxlabelsBoundArray[i] = getMinmaxLabelBound(this, axisGroupPosition, position);
      });

      if (legendAlign.layout === 'horizontal') {
        if (minmaxlabelsBoundArray.length && doOverlap(minmaxlabelsBoundArray[0], minmaxlabelsBoundArray[1])) {
          var bandWidth = minmaxlabelsBoundArray[1].x2 - minmaxlabelsBoundArray[0].x1;
          minmaxlabels.each(function (d, i) {
            var pos = getMinmaxLabelBound(this, axisGroupPosition, position);
            var textBound = {
              left: pos.x1,
              top: pos.y1,
              width: pos.width,
              height: pos.height
            };
            var e = simpleClone(edge);
            if (i === 0) {
              e.right = pos.x1 + bandWidth / 2; //need to change
            } else {
              e.left = pos.x2 - bandWidth / 2; //need to change
            }

            trimText(this, this.textContent, textBound, e, BOTTOM_ALIGN, pattern, margin);
            if (this.textContent === pattern) {
              d3_select(this).text('');
            }
            minmaxlabelsBoundArray[i] = getMinmaxLabelBound(this, axisGroupPosition, position);
          });
        }
      }

      return minmaxlabelsBoundArray;
    }

    function getMinmaxLabelBound(element, axisGroupPosition, position, parentPos) {
      parentPos = parentPos || [0, 0];
      var bb = bbox(element);
      var pos = {
        x1: bb.x + axisGroupPosition[0] + position[0] + parentPos[0],
        y1: bb.y + axisGroupPosition[1] + position[1] + parentPos[1],
        width: bb.width,
        height: bb.height
      };
      pos.x2 = pos.x1 + bb.width;
      pos.y2 = pos.y1 + bb.height;
      return pos;
    }

    function handleOverflowNOverlapForTicklabels(ticklabels, axisGroupPosition, position, minmaxlabelsBoundArray, chartObj, spec, container) {
      var legBBox = bbox(container.node()),
        ticklabelsBoundArray = [],
        maxTicklabelWidth = [],
        count = 0;

      ticklabels.each(function () {
        maxTicklabelWidth.push(bbox(this).width);
      });
      maxTicklabelWidth = d3_max(maxTicklabelWidth);

      ticklabels.each(function () {
        var parentPos = getSvgTransform(this.parentNode).translate;
        ticklabelsBoundArray.push(getMinmaxLabelBound(this, axisGroupPosition, position, parentPos));

        if (handleOverflow$1(this, chartObj, parentPos, ticklabelsBoundArray[count], maxTicklabelWidth, legBBox, spec, container)) {
          ticklabelsBoundArray[count] = getMinmaxLabelBound(this, axisGroupPosition, position, parentPos);
        }

        if (handleOverlap$2(this, minmaxlabelsBoundArray, ticklabelsBoundArray, count)) {
          ticklabelsBoundArray[count] = {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0
          };
        }

        count++;
      });
    }

    function handleOverlap$2(element, minmaxlabelsBoundArray, ticklabelsBoundArray, i) {
      var overlap;

      for (var index = i - 1; index >= 0 && !overlap; index--) {
        overlap = doOverlap(ticklabelsBoundArray[index], ticklabelsBoundArray[i]);
      }

      if (
      (minmaxlabelsBoundArray.length ?
      doOverlap(ticklabelsBoundArray[i], minmaxlabelsBoundArray[0]) || doOverlap(ticklabelsBoundArray[i], minmaxlabelsBoundArray[1]) :
      false) ||
      overlap)
      {
        d3_select(element.parentNode).style('display', NONE);
        return true;
      }
    }

    function handleOverflow$1(element, chartObj, parentPos, bb, maxTicklabelWidth, legBBox, spec, container) {
      var config = spec.config,bound = spec.bound,
        orient = legend_helpers.getOrient(config),
        percent = orient === RIGHT_ALIGN || orient === LEFT_ALIGN ? 1 : 0.5,
        bound = getAvailableLegendBound(config, bound, chartObj.chartarea, chartObj.canvasarea),
        legendtitleWidth = config.title.show ? bbox(container.selectAll('.zc-legend-title > text').node()).width : 0,
        w = (bound.x2 - bound.x1 - (legBBox.width - mathMax(maxTicklabelWidth, legendtitleWidth))) * percent,
        h = bound.y2 - bound.y1,
        edge = {
          left: parentPos[0],
          top: parentPos[1],
          right: parentPos[0] + w,
          bottom: parentPos[1] + h
        },
        margin = {
          left: 5,
          right: 5,
          top: 5,
          bottom: 5
        },
        pattern = '..';

      if (bb.x2 - bb.x1 > w) {
        var textBound = {
          left: parentPos[0],
          top: parentPos[1],
          width: bb.width,
          height: bb.height
        };
        trimText(element, element.textContent, textBound, edge, BOTTOM_ALIGN, pattern, margin);
        if (element.textContent === pattern) {
          d3_select(element).text('');
          d3_select(element.parentNode).style('opacity', 0);
        }

        return true;
      }
    }

    function getAvailableLegendBound(config, bound, chartarea, canvasarea) {
      var legendOptions = config,
        orient = legend_helpers.getOrient(legendOptions),
        legendAlign = getLegendAlignment(legendOptions),
        hAlign = legendAlign.hAlign,
        floating = legendAlign.floating,
        chartAreaWidth = chartarea.width,chartAreaHeight = chartarea.height,chartAreaLeft = chartarea.left,chartAreaTop = chartarea.top,
        w = chartAreaWidth - legendOptions.marginLeft - legendOptions.marginRight,
        h = chartAreaHeight - legendOptions.marginTop - legendOptions.marginBottom,
        l = chartAreaLeft + legendOptions.marginLeft,
        t = chartAreaTop + legendOptions.marginTop,_bound =
        bound,maxWidth = _bound.maxWidth,maxHeight = _bound.maxHeight,
        bound = {};

      if (floating) {
        bound.x1 = mathMin(legendOptions.x, chartAreaWidth - maxWidth); // If x or y out of chartarea, move position within chartarea
        bound.y1 = mathMin(legendOptions.y, chartAreaHeight - maxHeight);
        bound.x2 = mathMin(bound.x1 + maxWidth, chartAreaWidth);
        bound.y2 = mathMin(bound.y1 + maxHeight, chartAreaHeight);

        return bound;
      }
      if (orient === BOTTOM_ALIGN) {
        bound.y1 = t + h - maxHeight;
        if (hAlign === LEFT_ALIGN) {
          bound.x1 = l;
        } else if (hAlign === RIGHT_ALIGN) {
          bound.x1 = l + w - maxWidth;
        } else {
          bound.x1 = l + (w - maxWidth) / 2;
        }
      } else if (orient === TOP_ALIGN) {
        bound.y1 = t;
        if (hAlign === LEFT_ALIGN) {
          bound.x1 = l;
        } else if (hAlign === RIGHT_ALIGN) {
          bound.x1 = l + w - maxWidth;
        } else {
          bound.x1 = l + (w - maxWidth) / 2;
        }
      } else if (orient === RIGHT_ALIGN) {
        bound.y1 = t;
        bound.x1 = l + w - maxWidth;
      } else {
        bound.y1 = t;
        bound.x1 = l;
      }

      bound.x2 = bound.x1 + maxWidth;
      bound.y2 = bound.y1 + maxHeight;
      return bound;
    }

    function applyAxislineProperties(element, axislineOptions, orient, isHorizontal, dimension) {
      if (!axislineOptions.show) {
        element.remove();
      } else {
        var strokeWidth = validateNullVal(axislineOptions.strokeWidth, 1),
          tx = 0,
          ty = 0;

        if (orient === LEFT_ALIGN) {
          tx = strokeWidth / 2;
        } else if (orient === RIGHT_ALIGN) {
          tx = -strokeWidth / 2;
        } else if (orient === BOTTOM_ALIGN) {
          ty = -strokeWidth / 2;
        } else {
          ty = strokeWidth / 2;
        }
        element.
        attr('transform', "translate(".concat(tx, ",").concat(ty, ")")).
        attr('d', isHorizontal ? "M0,0 L".concat(dimension[0], ",0") : "M0,0 L0,".concat(dimension[1])).
        styles({
          'stroke-dasharray': getDashArray(axislineOptions.style, strokeWidth),
          'stroke-linecap': getLineCap(axislineOptions.lineCap, axislineOptions.style)
        });
      }
    }

    //

    function BandAxisParser(spec) {
      var _helper$ = helper$1(spec),axisSpec = _helper$.axisSpec,updateAxisLine = _helper$.updateAxisLine,trimText = _helper$.trimText,
        config = spec.config,meta = spec.meta,_spec$callbackArgs = spec.callbackArgs,callbackArgs = _spec$callbackArgs === void 0 ? [] : _spec$callbackArgs;

      var groupMark = Mark('group', '.zc-band-axis');

      if (config.show === false) {
        return groupMark;
      }

      var drawAxis = function drawAxis(ele) {
        ele.call(d3axis, axisSpec, config);
        updateAxisLine(ele.selectAll('path.domain'));
        trimText(ele);
        bindEventHandlerForTicks(callbackArgs[0], null, getLabelEle(ele), null, config.ticklabel, { data: [meta] }, 'clr');

        var labelEle = getLabelEle(ele);
        labelEle.style('pointer-events', 'visible');
      };
      var axisGroupMark = Mark('group');
      axisGroupMark.onEnd = drawAxis;

      groupMark.children = [axisGroupMark];
      return groupMark;
    }

    function helper$1(spec) {
      var scale = spec.scale,config = spec.config,_spec$format = spec.format,format = _spec$format === void 0 ? function (d) {return d;} : _spec$format,orient = spec.orient,dimension = spec.dimension,dataType = spec.dataType,reversed = spec.reversed,isHorizontal = spec.isHorizontal,_spec$bandConfig = spec.bandConfig,bandConfig = _spec$bandConfig === void 0 ? {} : _spec$bandConfig,
        viewBound = spec.viewBound,availableBound = spec.availableBound,_spec$globalFont = spec.globalFont,globalFont = _spec$globalFont === void 0 ? {} : _spec$globalFont,

        tickMarkconfig =




        config.tickmark,tickLabelConfig = config.ticklabel,axisLineConfig = config.axisline,gridConfig = config.grid,minmaxLabelConfig = config.minmaxlabels,
        axisLineSize = axisLineConfig.show ? pick(axisLineConfig.strokeWidth, 1) : 0,
        labels = bandConfig.labels,
        tickFormat = function tickFormat(d, i) {
          if (labels && labels.length) {
            var labelIndex = legend_helpers.getLabelIndex(d, bandConfig, dataType);
            if (defined(labelIndex)) {
              var _text2 = labels[labelIndex];
              this.__formattedValue = _text2;
              return d3_select(this).text(_text2);
            }
          }

          var _text = format(d);
          this.__formattedValue = _text;
          d3_select(this).text(_text);
        },

        dummyChartObj = {
          dataObject: {},
          systemConf: { canvas: _objectSpread({}, globalFont), chart: { plot: { border: {} } } }
        },
        dummyAxisObj = { ticks: { isHierarchialLevelType: function isHierarchialLevelType() {} } },
        scale_domain = scale.domain(),
        range = isHorizontal ? [0, dimension[0]] : [dimension[1], 0],
        axisData = minmaxLabelConfig.show && minmaxLabelConfig.excludeIntervals ? [] : scale_domain,
        posScale;

      if (reversed) {
        range.reverse();
      }

      if (bandConfig.ranges && bandConfig.ranges.length) {
        scale_domain = getLegendRanges(bandConfig, dataType);
        if (bandConfig.type === 'continuous' && dataType !== ORDINAL_DATATYPE) {
          scale_domain = d3_merge(scale_domain);
          if (bandConfig.minRange !== scale_domain[0]) {
            scale_domain.splice(0, 0, bandConfig.minRange);
          }

          posScale = d3_scalePoint().
          domain(scale_domain).
          range(range);
        } else {
          posScale = d3_scaleOrdinal().
          domain(scale_domain).
          range(range).
          padding(0);
        }
      } else {
        if (axisData[0] === axisData[1]) {
          //Test_694.json
          var rangeDiff = mathAbs(range[0] - range[1]);
          range = [rangeDiff / 2, rangeDiff / 2];
        }

        posScale = d3_scaleLinear().
        domain([scale_domain[0], scale_domain[scale_domain.length - 1]]).
        range(range);
      }
      posScale.origRange = range;
      axisData = minmaxLabelConfig.show && minmaxLabelConfig.excludeIntervals ? [] : scale_domain;

      var axisSpec = {
          orient: orient,
          scale: posScale,
          tickFormat: tickFormat,
          tickValues: axisData,
          tickSizeInner: pick(tickMarkconfig.size, 6),
          tickSizeOuter: 0,
          gridSize: getMajorTicks(orient, dimension[0], dimension[1], axisLineSize),
          tickPadding: pick(tickLabelConfig.margin, 3),
          rotation: 0,
          renderTicklabel: true,
          renderGrid: true,
          isGridShow: gridConfig.show,
          chart: dummyChartObj, // d3axis requires chartObj
          axis: dummyAxisObj // d3axis requires axisObj
        },
        updateAxisLine = function updateAxisLine(ele) {return applyAxislineProperties(ele, axisLineConfig, orient, isHorizontal, dimension);},
        trimText = function trimText(ele) {
          return;
          // let labelEle = getLabelEle(ele),
          //     lineEle = getLineEle(ele),
          //     _anchor = {
          //         anchor: getAnchor(orient),
          //         minmaxPriority: false, // TODO: remove
          //         _margin: { left: 5, right: 5, bottom: 5, top: 5 },
          //         translateFunction: ele => {
          //             let textTranslate = getSvgTransform(ele).translate,
          //                 gTranslate = getSvgTransform(ele.parentNode).translate;
          //
          //             return [textTranslate[0] + gTranslate[0], textTranslate[1] + gTranslate[1]];
          //         }
          //     };
          //
          // handleTicklabels(labelEle, lineEle, availableBound, viewBound, _anchor);
          //
          // //  ZC2424 after handle overflow, tooltip will not be shown
          // if (tooltip === true) {
          //     labelEle.each(addTooltip);
          // }
        };

      return { axisSpec: axisSpec, updateAxisLine: updateAxisLine, trimText: trimText };
    }

    function getMajorTicks(orient, w, h, axislineSize) {
      var x1, y1, x2, y2;
      x1 = y1 = x2 = y2 = 0;

      if (orient == BOTTOM_ALIGN) {
        y1 = -axislineSize;
        y2 = -h - axislineSize;
      } else if (orient == TOP_ALIGN) {
        y1 = axislineSize;
        y2 = h + axislineSize;
      } else if (orient == LEFT_ALIGN) {
        x1 = w + axislineSize;
        x2 = axislineSize;
      } else if (orient == RIGHT_ALIGN) {
        x1 = -w - axislineSize;
        x2 = -axislineSize;
      }

      return { x1: x1, y1: y1, x2: x2, y2: y2 };
    }

    function getLabelEle(ele) {
      return ele.selectAll('text.ticklabel');
    }

    //

    function MinmaxLabelParser(spec) {
      var _helper = helper$2(spec),
        data = spec.data,
        show = _helper.show,text = _helper.text,x = _helper.x,y = _helper.y,dy = _helper.dy,anchor = _helper.anchor,styles = _helper.styles,trimText = _helper.trimText;

      var groupMark = Mark('group', ".".concat(MINMAXLABEL_LEGEND_CLASSNAME));
      var labelMark = Mark(TEXT_ELEMENT, undefined, show ? data : []);
      labelMark.config = _objectSpread(_objectSpread({}, styles), {}, { text: text, x: x, y: y, dy: dy, anchor: anchor });
      labelMark.onEnd = trimText;

      groupMark.children = [labelMark];
      return groupMark;
    }

    function helper$2(spec) {
      var
        config =










        spec.config,format = spec.format,data = spec.data,trimText = spec.trimText,_spec$index = spec.index,index = _spec$index === void 0 ? function (i) {return i;} : _spec$index,_spec$orient = spec.orient,orient = _spec$orient === void 0 ? RIGHT_ALIGN : _spec$orient,dimension = spec.dimension,_spec$sliderSize = spec.sliderSize,sliderSize = _spec$sliderSize === void 0 ? [[0, 0], [0, 0]] : _spec$sliderSize,
        show = config.show,align = config.align,_config$padding2 = config.padding,padding = _config$padding2 === void 0 ? 2 : _config$padding2,labels = config.text,
        position = data.map(function (d, i) {return getPositionInfo(orient, dimension, align, padding, sliderSize, index(i));});

      return {
        show: show,
        trimText: trimText,
        text: function text(d, i) {return labels ? labels[index(i)] : format(d, index(i));},
        x: function x(d, i) {return position[index(i)].x;},
        y: function y(d, i) {return position[index(i)].y;},
        anchor: function anchor(d, i) {return position[index(i)].anchor;},
        dy: function dy(d, i) {return position[index(i)].dy;},
        styles: config // TODO: pick font properties alone
      };
    }

    function getPositionInfo(orient, dimension, align, padding, sliderSizes, i) {
      var sliderSize = isArray$1(sliderSizes[i]) ? sliderSizes[i] : sliderSizes;
      var x, y, dy, ANCHOR;
      if (orient === BOTTOM_ALIGN) {
        if (align === TOP_ALIGN) {
          dy = '-0.3em';
          ANCHOR = i === 0 ? null : 'end';
          y = -dimension[1] - padding - mathMax(0, (sliderSize[1] - dimension[1]) / 2);
          if (i === 0) {
            x = 0;
          } else {
            x = dimension[0];
          }
        } else if (align === BOTTOM_ALIGN) {
          dy = '1em';
          ANCHOR = i === 0 ? null : 'end';
          y = padding + mathMax(0, (sliderSize[1] - dimension[1]) / 2);
          if (i === 0) {
            x = 0;
          } else {
            x = dimension[0];
          }
        } else {
          dy = '0.3em';
          ANCHOR = i === 0 ? 'end' : null;
          y = -dimension[1] / 2;
          if (i === 0) {
            x = -padding - sliderSize[0] / 2;
          } else {
            x = dimension[0] + padding + sliderSize[0] / 2;
          }
        }
      } else if (orient === TOP_ALIGN) {
        if (align === TOP_ALIGN) {
          dy = '-0.3em';
          ANCHOR = i === 0 ? null : 'end';
          y = -padding - mathMax(0, (sliderSize[1] - dimension[1]) / 2);
          if (i === 0) {
            x = 0;
          } else {
            x = dimension[0];
          }
        } else if (align === BOTTOM_ALIGN) {
          dy = '1em';
          ANCHOR = i === 0 ? null : 'end';
          y = dimension[1] + padding + mathMax(0, (sliderSize[1] - dimension[1]) / 2);
          if (i === 0) {
            x = 0;
          } else {
            x = dimension[0];
          }
        } else {
          dy = '0.3em';
          ANCHOR = i === 0 ? 'end' : null;
          y = dimension[1] / 2;
          if (i === 0) {
            x = -padding - sliderSize[0] / 2;
          } else {
            x = dimension[0] + padding + sliderSize[0] / 2;
          }
        }
      } else if (orient === RIGHT_ALIGN) {
        if (align === LEFT_ALIGN) {
          dy = i !== 0 ? '0.71em' : '0em';
          ANCHOR = 'end';
          x = -dimension[0] - padding - mathMax(0, (sliderSize[1] - dimension[0]) / 2);
          if (i !== 0) {
            y = 0;
          } else {
            y = dimension[1];
          }
        } else if (align === RIGHT_ALIGN) {
          dy = i !== 0 ? '0.71em' : '0em';
          ANCHOR = null;
          x = padding + mathMax(0, (sliderSize[1] - dimension[0]) / 2);
          if (i !== 0) {
            y = 0;
          } else {
            y = dimension[1];
          }
        } else {
          dy = i !== 0 ? '-0.3em' : '1em';
          ANCHOR = 'middle';
          x = -dimension[0] / 2;
          if (i !== 0) {
            y = -padding - sliderSize[0] / 2;
          } else {
            y = dimension[1] + padding + sliderSize[0] / 2;
          }
        }
      } else {
        if (align === LEFT_ALIGN) {
          dy = i !== 0 ? '0.71em' : '0em';
          ANCHOR = 'end';
          x = -padding - mathMax(0, (sliderSize[1] - dimension[0]) / 2);
          if (i !== 0) {
            y = 0;
          } else {
            y = dimension[1];
          }
        } else if (align === RIGHT_ALIGN) {
          dy = i !== 0 ? '0.71em' : '0em';
          ANCHOR = null;
          x = dimension[0] + padding + mathMax(0, (sliderSize[1] - dimension[0]) / 2);
          if (i !== 0) {
            y = 0;
          } else {
            y = dimension[1];
          }
        } else {
          dy = i !== 0 ? '-0.3em' : '1em';
          ANCHOR = 'middle';
          x = dimension[0] / 2;
          if (i !== 0) {
            y = -padding - sliderSize[0] / 2;
          } else {
            y = dimension[1] + padding + sliderSize[0] / 2;
          }
        }
      }
      return {
        x: x,
        y: y,
        dy: dy,
        anchor: ANCHOR
      };
    }
    Registry.setComponent('minmaxLabel.parser', MinmaxLabelParser);

    function handleShadow(filterConfig, handles, ele, chart) {
      var handleType = filterConfig.type;

      if (handleType) {
        var shadow = pick(filterConfig[handleType].shadow, filterConfig.shadow);
        if (shadow) {
          // apply to the first path
          // #ZC2229
          var effectElementIndex = pick(handles[0]._effectElementIndex, 0) + 1;
          ele.select("path:nth-child(".concat(effectElementIndex, ")")).attr('filter', svgBoxShadow(shadow, chart));
        }
      }
    }

    //

    var BrushD3$1 = Registry.getComponent('BrushD3');
    function HighlightItem(mouse, data) {
      var manager = this,
        options = manager.options,chart = manager.chart,
        config = options.config,dimension = options.dimension,highlightElement = options.highlightElement,type = options.type,markerBound = options.markerBound,handleOptions = options.handles,
        markerConfig = config.slider.marker,
        hoverOptions = getHoverOptions(config),
        filterConfig = getDisabledOptions(config),
        hoverType = hoverOptions.type,

        dt = getHighlightData(data.point, options),
        handles;

      // Show highlight element
      cancelAnimation(highlightElement);
      highlightElement.style('opacity', null);

      if (hoverType === 'inherit') {
        if (filterConfig.type) {
          handles = handlerByType(filterConfig, options, dt);
        } else {
          // TODO: implement hoverOptions.marker
          var symbolPath = handleOptions.shape,position = handleOptions.position;
          handles = getSliderShape("marker-".concat(markerConfig.shape), markerConfig, type, dimension);
          handles.shape = [[symbolPath(markerBound.width(dt), markerBound.height(dt))]];
          handles.style.transform = getTranslate$1(dt, position(dt), options);
        }
      } else if (hoverType) {
        handles = handlerByType(hoverOptions, options, dt);
      }

      if (handles) {
        BrushD3$1.ADD_HANDLE(handles, highlightElement);

        var handleElement = highlightElement.selectAll('g.handle--custom');
        if (hoverType === 'inherit') {
          if (filterConfig.type) {
            handleShadow(filterConfig, [handles], handleElement, chart);
          }
        } else if (hoverType) {
          handleShadow(hoverOptions, [handles], handleElement, chart);
        }
      }
    }

    function handlerByType(handleConfig, options, data) {
      var dimension = options.dimension,type = options.type,
        handlerType = handleConfig.type,
        op = handleConfig[handlerType],

        position = getSliderPosition(type, handlerType, dimension, op.size),
        handles = getSliderShape(handlerType, op, type, dimension),
        updateTransform = function updateTransform(style) {
          var transform = style.transform,
            rotateIndex = transform.indexOf('rotate'),
            rotate = rotateIndex > -1 ? " ".concat(transform.substr(rotateIndex)) : '',
            xy = options.encode === 'clr' ? getExistingPosition(transform) : position;

          style.transform = getTranslate$1(data, xy, options) + rotate;
        };

      if (isArray$1(handles.style)) {
        handles.style.forEach(updateTransform);
      } else {
        updateTransform(handles.style);
      }

      return handles;
    }

    function getHighlightData(point, options) {
      var dataType = options.dataType,userRanges = options.ranges;

      if (dataType === ORDINAL_DATATYPE) {
        return userRanges[point][0];
      } else if (userRanges && userRanges.length) {
        return userRanges[point];
      } else {
        return point.data;
      }
    }

    function getTranslate$1(data, markerPosition, options) {
      var isHorizontal = options.isHorizontal,brushScale = options.brushScale,
        bandWidth = brushScale.bandwidth ? brushScale.bandwidth() : 0,
        selection = brushScale(data) + bandWidth / 2,
        pos = [];

      if (isHorizontal) {
        pos[0] = selection;
        pos[1] = markerPosition[1];
      } else {
        pos[0] = markerPosition[0];
        pos[1] = selection;
      }

      return translateString(pos);
    }

    function getExistingPosition(transform) {
      return transform.
      trim().
      replace('translate(', '').
      replace(')', '').
      split(/[, ]/).
      map(function (_) {return +_;});
    }

    function SizeSliderDataFinder(mouse, eventType) {
      var manager = this,
        options = manager.options;

      return getHighlightedItemFromMousePoint(mouse, options);
    }

    function getHighlightedItemFromMousePoint(mouse, options) {
      var config = options.config,brushScale = options.brushScale,reversed = options.reversed,scale = options.scale,singleDomainContinuous = options.singleDomainContinuous,isHorizontal = options.isHorizontal,range = options.range,userRanges = options.ranges,encode = options.encode,
        hoverOptions = getHoverOptions(config, encode),
        mousePt = mouse[isHorizontal ? 0 : 1];

      if (userRanges && userRanges.length) {
        var bandWidth = brushScale.bandwidth(),
          outerPadding = config.filter.enabled ? 0 : bandWidth / 2,
          index = pInt((mousePt + outerPadding) / bandWidth);

        index = mathMax(mathMin(index, userRanges.length - 1), 0);

        if (encode === 'clr' && !isHorizontal) {
          index = userRanges.length - 1 - index;
        }

        index = reversed ? userRanges.length - 1 - index : index;
        return index;
      } else {
        if (singleDomainContinuous) {
          return scale.domain();
        }

        if (encode === 'z') {
          if (reversed) {
            mousePt = mathMin(mathMax(mousePt, range[1]), range[0]);
          } else {
            mousePt = mathMin(mathMax(mousePt, range[0]), range[1]);
          }
        }

        var triggerOffset = mathMax(validateNullVal(hoverOptions.triggerOffset, 10), 0.1); // ZC2499: If triggerOffset is 0, magnitude is 0
        return invertMousePoint(mousePt, brushScale, { triggerOffset: triggerOffset, round: encode === 'z' });
      }
    }

    function invertMousePoint(mousePt, scale, options) {
      var _options$triggerOffse = options.triggerOffset,triggerOffset = _options$triggerOffse === void 0 ? 0 : _options$triggerOffse,_options$round = options.round,round = _options$round === void 0 ? false : _options$round,
        _baseFunc = round ? mathRound : mathFloor,
        min = scale.invert(mousePt - triggerOffset / 2),
        max = scale.invert(mousePt + triggerOffset / 2),
        diff = mathAbs(max - min),
        power = diff ? mathFloor(+(mathLog(diff) / mathLN10).toFixed(2)) : 0,
        magnitude = mathPow(10, power),
        base = _baseFunc(scale.invert(mousePt) / magnitude) * magnitude;
      base = +base.toFixed(12);

      var point = [base, base + magnitude - 0.000000000001];
      point.data = scale.invert(mousePt);
      return point;
    }

    var MIN_VALUE = 0.000000000001;

    /*
     *
     * @param handles
     * @param range
     */
    function styleHandles(options, handles, range) {
      handles.style('fill', function (d, i) {
        return getColor(range, i, options.isHorizontal, options.reversed, options.colorScale || options.scaleObj);
      });
    }

    /**
     *
     * @param options
     * @param selection
     * @return {*}
     */
    function getRange$1(options, selection) {
      var range = options.range, // [0, width] || [height: 0]
        ranges = options.ranges,
        userRanges_length = ranges && ranges.length;

      selection = getExtentWithinRange(selection, range);
      var newRange;
      if (userRanges_length) {
        newRange = getDomainForOrdinalScale(selection, options);
      } else {
        newRange = selection.map(function (d) {return options.scale.invert(d);}).sort(d3_ascending);
      }
      return newRange;
    }

    /**
     *
     * @param options
     * @param selection
     * @return {*[]}
     */
    function snapHandlePosition(options, selection) {
      var snapSelection,
        ranges = options.ranges,
        userRanges_length = ranges && ranges.length,
        brushScale = options.scale;

      if (userRanges_length) {
        snapSelection = getExtentForOrdinalScale(getRange$1(options, selection), options);
      } else if (options.singleDomainContinuous) {
        snapSelection = options.singleDomainContinuous.map(function (d) {return brushScale(d);});
      }
      return snapSelection;
    }

    /**
     *
     * @param extent
     * @param i
     * @param isHorizontal
     * @param reversed
     * @param scaleObj
     * @return {*}
     */
    function getColor(extent, i, isHorizontal, reversed, scaleObj) {
      var colorIndex = isHorizontal ? [0, extent.length - 1] : [extent.length - 1, 0];

      if (reversed) {
        colorIndex.reverse();
      }

      var clrValue = extent[colorIndex[i]];
      return scaleObj(clrValue);
    }

    /**
     *
     * @param extent
     * @param brushScale
     * @param scale_domain
     * @param userRanges
     * @param datatype
     * @param isHorizontal
     * @param reversed
     * @return {*[]}
     */
    function getDomainForOrdinalScale(extent, options) {
      var scale_domain = options.scale_domain,datatype = options.datatype,isHorizontal = options.isHorizontal,reversed = options.reversed,brushScale = options.scale,userRanges = options.ranges,
        discrete_ranges = brushScale.domain().map(brushScale),
        brushScale_range = d3_values(discrete_ranges).sort(d3_ascending),
        brushScale_domain = brushScale.domain(),
        rangeBand = brushScale.bandwidth(),
        startIndex,
        endIndex;

      // Find start and end index
      brushScale_range.some(function (d, i) {
        if (extent[0] >= d && extent[0] <= d + rangeBand) {
          var diff = extent[0] - d;
          if (diff <= 0.5 && diff >= 0) {
            // antialiasing artifacts
            startIndex = mathMax(i - 1, 0);
          } else {
            startIndex = i;
          }
        }
        if (extent[1] >= d && extent[1] <= d + rangeBand) {
          var diff = d + rangeBand - extent[1];
          if (diff <= 0.5 && diff >= 0) {
            // antialiasing artifacts
            endIndex = mathMin(i + 1, brushScale_range.length - 1);
          } else {
            endIndex = i;
          }
        }
        return defined(startIndex) && defined(endIndex);
      });

      startIndex = mathMax(0, validateNullVal(startIndex, 0));
      endIndex = mathMax(0, validateNullVal(endIndex, brushScale_domain.length - 1)); //#ZC1319

      var domain = brushScale_domain;
      if (datatype !== ORDINAL_DATATYPE && userRanges[0].length === 1) {
        // If ranges are single element like [50, 60, 70] (e.g: http://localhost/#/demoCharts/heatmap5), need to make it as range --> [[min, 50], [50, 60], [60, 70]]
        domain = getPairs(scale_domain, domain);
      }

      if (options.encode !== 'z' ? !isHorizontal && !reversed || isHorizontal && reversed : reversed) {
        var temp = startIndex;
        startIndex = brushScale_range.length - 1 - endIndex;
        endIndex = brushScale_range.length - 1 - temp;
      }

      domain = domain.slice(startIndex, endIndex + 1, 0);
      if (datatype === ORDINAL_DATATYPE) {
        extent = domain;
      } else {
        extent = d3_extent(d3_merge(domain));
        extent = updateFilterRange(extent, scale_domain);
      }
      return extent;
    }

    /**
     *
     * @param filterRange
     * @param brushScale
     * @param scale_domain
     * @param userRanges
     * @param datatype
     * @return {*[]}
     */
    function getExtentForOrdinalScale(filterRange, options) {
      var brushScale = options.scale,userRanges = options.ranges,scale_domain = options.scale_domain,datatype = options.datatype,
        rangeBandBy2 = brushScale.bandwidth() / 2,
        extent;

      if (datatype === ORDINAL_DATATYPE) {
        extent = [brushScale(filterRange[0]) + rangeBandBy2, brushScale(filterRange[filterRange.length - 1]) + rangeBandBy2];
      } else {
        var brushScale_domain = brushScale.domain(),
          //start and end index of userRange
          startIndex,
          endIndex; //start and end index of userRange
        filterRange = updateFilterRange(filterRange, scale_domain);

        brushScale_domain.forEach(function (d, i) {
          if (filterRange[0] >= d[0]) {
            startIndex = userRanges[0].length === 1 ? i + 1 : i;
          }
          if (!defined(endIndex) && filterRange[1] <= d[0]) {
            endIndex = userRanges[0].length === 1 ? i : i - 1;
          }
        });

        startIndex = mathMax(0, validateNullVal(startIndex, 0));
        endIndex = mathMax(0, validateNullVal(endIndex, brushScale_domain.length - 1));

        extent = [brushScale(brushScale_domain[startIndex]) + rangeBandBy2, brushScale(brushScale_domain[endIndex]) + rangeBandBy2];
      }

      if (extent[0] === extent[1]) {
        extent[0] -= MIN_VALUE;
        extent[1] += MIN_VALUE;
      }
      return extent;
    }

    /**
     *
     * @param extent
     * @param range
     * @return {*}
     */
    function getExtentWithinRange(extent, range) {
      //Refer: legend filter issue
      if (range[1] > range[0]) {
        extent[1] = mathMin(extent[1], range[1]);
        extent[0] = mathMax(extent[0], range[0]);
      } else {
        extent[1] = mathMax(extent[1], range[1]);
        extent[0] = mathMin(extent[0], range[0]);
      }
      return extent;
    }

    function updateFilterRange(filterRange, scale_domain) {
      // If [[10, 20], [20, 30]] is the user ranges (20 is present twice), the filterRange is should be modified
      // Refer legend-brush-1

      if (!isDistinct(scale_domain, filterRange[1])) {
        filterRange[1] -= MIN_VALUE;
      }
      return filterRange;
    }

    function isDistinct(array, value) {
      return array.indexOf(value) === array.lastIndexOf(value);
    }

    function getPairs(scale_domain, domain) {
      var min = scale_domain[2],
        max = scale_domain[scale_domain.length - 1 - 2],
        pairs = [];
      for (var i = 0; i < domain.length; i++) {
        pairs.push([min, domain[i][0]]);
        min = domain[i][0];
      }
      pairs.push(min, max);
      return pairs;
    }

    //

    function BrushHandleParser(spec) {
      var _helper = helper$3(spec),
        isHorizontal = spec.isHorizontal,
        show = _helper.show,handles = _helper.handles,rectHandle = _helper.rectHandle;

      var groupMark = Mark('group', '.zc-band-brush-handle');
      setPropVal(groupMark, 'properties.styles', { visibility: 'hidden', 'pointer-events': 'none' });

      if (!show) {
        return groupMark;
      }

      groupMark.onEnd = function (ele) {
        handles.forEach(function (_) {
          _.shape = splat(_.shape); // 'triangleUp' shape is not array
          _.style = splat(_.style);
          var transform = _.style[0].transform.
          replace('translate(', '').
          replace(')', '').
          split(' ').
          map(function (_) {return +_ || 0;}) || [0, 0];

          if (isArray$1(_.shape[0])) {
            _.shape.forEach(function (s) {return s.push(rectHandle);}); // 'vernier' shape FEATURESEVENTS_HEATMAP_9_1
            _.style.push({
              transform: 'translate(' + (isHorizontal ? transform[0] : 0) + ' ' + (isHorizontal ? 0 : transform[1]) + ')'
            });
          } else {
            _.shape.push(rectHandle);
            _.style.push({
              transform: 'translate(' + (isHorizontal ? transform[0] : 0) + ' ' + (isHorizontal ? 0 : transform[1]) + ')'
            });
          }
        }); // d3 brush adds rect
        BrushD3.ADD_HANDLE(handles, ele);
      };

      return groupMark;
    }

    function helper$3(spec) {
      var initialExtent = spec.initialExtent,config = spec.config,isHorizontal = spec.isHorizontal,dimension = spec.dimension,brushScale = spec.brushScale,ranges = spec.ranges,singleDomainContinuous = spec.singleDomainContinuous,_config$filter =
        config.filter,enabled = _config$filter.enabled,sliderConfig = _config$filter.slider,
        bandWidth = brushScale.bandwidth ? brushScale.bandwidth() : 0,
        handleSize = 6,
        selection = singleDomainContinuous ?
        initialExtent :
        ranges && ranges.length ?
        initialExtent.map(function (_) {return getHighlightData$1(getHighlightedItemFromMousePoint([_, _], spec), spec);}) :
        getRange$1(spec, initialExtent);

      return {
        show: enabled,
        handles: selection.map(function (_) {return handlerByType(sliderConfig, spec, _);}),
        rectHandle: roundedRect(
        -handleSize / 2,
        -handleSize / 2,
        (isHorizontal ? 0 : dimension[0]) + handleSize,
        (isHorizontal ? dimension[1] : 0) + handleSize,
        getBorderRadius(0))

      };
    }

    function getHighlightData$1(point, options) {
      var dataType = options.dataType,userRanges = options.ranges;

      if (dataType === ORDINAL_DATATYPE) {
        return userRanges[point][0];
      } else if (userRanges && userRanges.length) {
        return userRanges[point];
      } else {
        return point[0];
      }
    }

    //$Id$

    function getColorAxisOptions(legendOptions) {
      var defaultColorAxisOptions = {
        label: {},
        grid: {
          color: TRANSPARENT
        },
        ticklabel: {
          fontColor: legendOptions.fontColor,
          fontFamily: legendOptions.fontFamily,
          fontSize: legendOptions.fontSize,
          fontStyle: legendOptions.fontStyle,
          fontWeight: legendOptions.fontWeight,
          // marginBottom: 5,
          // marginLeft: 5,
          // marginRight: 5,
          // marginTop: 5,
          // maxHeight : "",
          // maxWidth : "",
          // rotation: 0,
          // textOverflow: "ellipsis",
          tooltip: legendOptions.tooltip
        },
        minmaxlabels: {
          //excludeIntervals, show, padding, align, text, fontProperties
          padding: 2,
          align: 'center',
          fontSize: legendOptions.fontSize
        },
        tickmark: {
          color: '#B0B0B0',
          size: 3
        },
        axisline: {
          show: false
        }
      };
      var colorAxisOptions = legendOptions.colorAxis || {};
      colorAxisOptions = mergeJSON$1(defaultColorAxisOptions, colorAxisOptions, true);
      return colorAxisOptions;
    }

    //

    function getSliderSize(sliderOptions, dimension, orient, legendAlign) {
      var type = sliderOptions.type,
        options = sliderOptions[type],
        isHorizontal = legendAlign.layout === 'horizontal';
      if (type === 'triangleUp' || type === 'triangleDown') {
        return [0, 0];
      } else if (type === 'lever' || type === 'vernier') {
        return [options.width, options.height];
      } else if (type === 'pentagon') {
        return [options.size + 2 * options.bandWidth, dimension[isHorizontal ? 1 : 0] + 1.5 * options.bandWidth + 2];
      } else {
        return [options.size, options.size];
      }
    }

    /**
     *
     * @param chartObj
     * @return {*[]}
     */
    function getLegendDefaultSliderOptionsArguments(config, bound, area) {
      var legendAlignment = getLegendAlignment(config);

      return [
      legend_helpers.getColorBandDimension(config, bound, area),
      legendAlignment.layout === 'horizontal',
      config.colorBand.ranges && config.colorBand.ranges.length];

    }

    //$Id$

    function colorBandBrushOptions(config, bound, dataType, area) {
      var trackOptions = {
          fillColor: TRANSPARENT
        },
        sliderOptions = {
          type: 'lever',
          shadow: '0 0 2px rgba(0,0,0,0.2)',
          tooltip: _objectSpread(_objectSpread({},
          brushTooltipOptions()), {}, {
            enabled: getLegendType(config, dataType) === 'continuous' })

        };

      return {
        track: trackOptions,
        slider: mergeJSON$1(
        getDefaultSliderOptions.apply(null, getLegendDefaultSliderOptionsArguments(config, bound, area || dataType)), // TODO: change area, dataType
        sliderOptions,
        true)

      };
    }

    function brushTooltipOptions() {
      return {
        enabled: true,
        padding: 5,
        margin: 5,
        backgroundColor: 'white',
        borderColor: 'rgb(51, 51, 51)',
        fontColor: 'rgb(51, 51, 51)'
      };
    }

    function getBrushTooltipContent(data, i, options) {
      var dataType = options.datatype,format = options.format,ranges = options.ranges,scale = options.scale,reversed = options.reversed,isHorizontal = options.isHorizontal;
      var labels = data,
        decimalCount,
        domainExtent;

      if (dataType === NUMERIC_DATATYPE) {
        if (!(ranges && ranges.length)) {
          var scale_domain = scale.domain();
          domainExtent = [scale_domain[0], scale_domain[scale_domain.length - 1]];
          var diff = mathAbs(domainExtent[1] - domainExtent[0]);

          if (diff) {
            //Test_779.json
            var hunds = Math.floor(Math.log(diff) / Math.LN10) - 2;
            decimalCount = Math.abs(Math.min(hunds, 0));
          }
        }
      }

      var index = i;
      if (options.encode !== 'z') {
        index = isHorizontal ? i : +!i;
      }

      if (reversed) {
        index = !index;
      }

      var val = labels[index ? labels.length - 1 : 0];
      // this.count = !this.count;
      if (defined(decimalCount) && domainExtent.indexOf(val) === -1) {
        //#ZC1283
        if (isArray$1(val)) {
          val = val.map(function (d) {
            return +d.toFixed(decimalCount);
          });
        } else {
          val = +val.toFixed(decimalCount);
        }
      }
      return format(val);
    }

    function getActiveDiscreteDomain(filterRange, userRanges) {
      var filterRange_copy = [filterRange[0], filterRange[1] + 0.000000000001],
        singleValueDomain = userRanges[0].length === 1,
        start,
        end;

      userRanges.forEach(function (d, i) {
        if (d[0] <= filterRange_copy[0]) {
          start = i;
        }
        if (d[d.length === 1 ? 0 : 1] <= filterRange_copy[1]) {
          end = i;
        }
      });

      isUndefined(start) ? start = 0 : singleValueDomain ? start++ : null;
      isUndefined(end) ? end = userRanges.length - 1 : null;
      return [userRanges[start], userRanges[end]];
    }

    function getSliderMarkerPosition(scale, brushScale, config, bound, align) {
      var hAlign = config.hAlign,vAlign = config.vAlign,

        sizeBandWidth = scale.bandwidth ? scale.bandwidth() : 0,
        posBandWidth = brushScale.bandwidth ? brushScale.bandwidth() : 0,

        w = bound.width,
        h = bound.height,

        r = function r(d) {return scale(d) + sizeBandWidth / 2;},
        x,
        y;

      if (align.layout === HORIZONTAL_ALIGN) {
        x = function x(d) {return brushScale(d) + posBandWidth / 2;};
        if (vAlign === TOP_ALIGN) {
          y = function y(d) {return r(d) / 2;};
        } else if (vAlign === BOTTOM_ALIGN) {
          y = function y(d) {return h - r(d) / 2;};
        } else {
          y = function y(d) {return h / 2;};
        }
      } else {
        y = function y(d) {return brushScale(d) + posBandWidth / 2;};
        if (hAlign === LEFT_ALIGN) {
          x = function x(d) {return r(d) / 2;};
        } else if (hAlign === RIGHT_ALIGN) {
          x = function x(d) {return w - r(d) / 2;};
        } else {
          x = function x(d) {return w / 2;};
        }
      }

      return { x: x, y: y, r: r };
    }

    function getHandleData(options, point, strictReverse) {
      var ranges = options.ranges,reversed = options.reversed,config = options.config,scale = options.sizeScale,dataType = options.datatype,singleDomainContinuous = options.singleDomainContinuous,
        filterRange = config.filter.range,
        data;

      if (filterRange) {
        point = point || (reversed ? d3_values(filterRange).reverse() : filterRange);
      }

      if (singleDomainContinuous) {
        return scale.domain();
      }

      if (point) {
        if (dataType === ORDINAL_DATATYPE) {
          var extentData = [point[0], point[point.length - 1]];
          data = reversed ? d3_values(extentData).reverse() : extentData;
        } else if (ranges && ranges.length) {
          data = getActiveDiscreteDomain(d3_values(point).sort(d3_ascending), ranges);
        } else {
          data = strictReverse ? d3_values(point).reverse() : point;
        }

        if (ranges && ranges.length && reversed) {
          data = d3_values(data).reverse();
        }

        return data;
      } else {
        var scale_domain = scale.domain(),
          _extentData = [scale_domain[0], scale_domain[scale_domain.length - 1]],
          _data2 = reversed ? d3_values(_extentData).reverse() : _extentData;

        return _data2;
      }
    }

    //

    function TrackerParser(spec) {
      var _helper = helper$4(spec);

      var groupMark = Mark('group', ".".concat(_helper.className));
      groupMark.config = {
        visibility: _helper.show ? null : 'hidden',
        'shape-rendering': 'crispedges' // ZC2552
      };

      var symbolMark = SymbolParser(_helper);
      var flashMark = FlashParser(_helper);

      groupMark.children = [symbolMark, flashMark];
      return groupMark;
    }

    function FlashParser(spec) {
      var flashSpec = spec.flashSpec,styles = spec.styles;

      return {
        mark: 'polygon',
        selector: ".".concat(TRACK_FLASH_CLASSNAME),
        config: _objectSpread({
          points: flashSpec.points,
          curve: 'linearClosed' },
        styles),

        onStart: flashSpec.onStart
      };
    }

    function SymbolParser(spec) {
      var symbolSpec = spec.symbolSpec,styles = spec.styles;

      var symbolMark = Mark('point', ".".concat(TRACK_SYMBOL_CLASSNAME), symbolSpec.data);
      symbolMark.config = _objectSpread(_objectSpread({}, symbolSpec), styles);
      return symbolMark;
    }

    function helper$4(spec) {
      var bound = spec.bound,data = spec.data,scale = spec.scale,brushScale = spec.brushScale,config = spec.config,filterConfig = spec.filterConfig,align = spec.align,markerBound = spec.markerBound,trackConfig = spec.trackConfig,className = spec.className,
        markerConfig = config.marker,
        handleType = filterConfig.type,
        position = getSliderMarkerPosition(scale, brushScale, markerConfig, bound, align),
        _x6 = position.x,_y4 = position.y,
        symbolEle;

      var flashSpec = {
          points: function points() {return getPolygon(spec, position, symbolEle);},
          onStart: function onStart(ele) {return symbolEle = d3_select(ele.node().parentNode).selectAll("path.".concat(TRACK_SYMBOL_CLASSNAME));} // TODO: pass symbol elements here
        },
        symbolSpec = {
          data: handleType ? [] : data,
          x: function x(d) {return _x6(d);},
          y: function y(d) {return _y4(d);},
          shape: markerConfig.shape,
          size: function size(d) {return [markerBound.width(d), markerBound.height(d)];} // TODO: size should handle array, number, function
        };

      return {
        show: trackConfig.show,
        flashSpec: flashSpec,
        symbolSpec: symbolSpec,
        styles: trackConfig,
        className: className || TRACK_LEGEND_CLASSNAME
      };
    }

    function getPolygon(spec, position, symbolEle) {
      var data = spec.data,config = spec.config,filterConfig = spec.filterConfig,align = spec.align,markerBound = spec.markerBound,
        width = config.width,height = config.height,
        shape = config.marker.shape,
        handleType = filterConfig.type,
        isHorizontal = align.layout === HORIZONTAL_ALIGN,
        x = position.x,y = position.y,r = position.r,
        measure = data.map(function (d) {
          return { x: x(d), y: y(d), r: r(d) / 2, w: markerBound.width(d), h: markerBound.height(d) };
        }),
        tangent;

      if (handleType) {
        var d1 = measure[0],
          d2 = measure[1],
          size = (isHorizontal ? height : width) || 0,
          d1_r = size / 2 || d1.r,
          d2_r = size / 2 || d2.r;

        tangent = isHorizontal ?
        [
        [d1.x, d1.y + d1_r],
        [d2.x, d2.y + d2_r],
        [d1.x, d1.y - d1_r],
        [d2.x, d2.y - d2_r]] :

        [
        [d1.x + d1_r, d1.y],
        [d2.x + d2_r, d2.y],
        [d1.x - d1_r, d1.y],
        [d2.x - d2_r, d2.y]];

      } else if (shape === 'circle') {
        tangent = geometryUtils.outerTangentPoints$Circle(measure[0], measure[1]);
      } else if (shape === 'square' || shape === 'rect') {
        var _d9 = measure[0],
          _d10 = measure[1];
        tangent = isHorizontal ?
        [
        [_d9.x + _d9.w / 2, _d9.y - _d9.h / 2],
        [_d10.x - _d10.w / 2, _d10.y - _d10.h / 2],
        [_d9.x + _d9.w / 2, _d9.y + _d9.h / 2],
        [_d10.x - _d10.w / 2, _d10.y + _d10.h / 2]] :

        [
        [_d9.x + _d9.w / 2, _d9.y + _d9.h / 2],
        [_d10.x + _d10.w / 2, _d10.y - _d10.h / 2],
        [_d9.x - _d9.w / 2, _d9.y + _d9.h / 2],
        [_d10.x - _d10.w / 2, _d10.y - _d10.h / 2]];

      } else if (shape === 'horizontal-whisker' || shape === 'whisker') {
        var _d11 = measure[0],
          _d12 = measure[1];
        tangent = isHorizontal ?
        [
        [_d11.x, _d11.y - _d11.r],
        [_d12.x, _d12.y - _d12.r],
        [_d11.x, _d11.y + _d11.r],
        [_d12.x, _d12.y + _d12.r]] :

        [
        [_d11.x + _d11.r, _d11.y],
        [_d12.x + _d12.r, _d12.y],
        [_d11.x - _d11.r, _d11.y],
        [_d12.x - _d12.r, _d12.y]];

      } else {
        var polygonPoints = [];
        symbolEle.each(function () {
          polygonPoints.push(elementToPolygonPoints(this));
        });

        tangent = geometryUtils.tangentPoints$Polygon(polygonPoints, isHorizontal, measure);
      }

      return tangent && tangent.length ? [tangent[0], tangent[1], tangent[3], tangent[2]] : [];
    }

    //

    function ConnectorParser(spec) {
      var _helper = helper$5(spec);

      var groupMark = Mark('group', ".".concat(CONNECTOR_LEGEND_CLASSNAME));

      var connectorMark = Mark('polygon', ".".concat(CONNECTOR_LINE_CLASSNAME), _helper.data);
      connectorMark.config = _helper.config;

      groupMark.children = [connectorMark];
      return groupMark;
    }

    function helper$5(spec) {
      var data = spec.data,config = spec.config,
        connectorConfig = config.connector,
        show = connectorConfig.show;

      return {
        data: show ? [data] : [],
        config: _objectSpread({
          points: getPoints(spec) },
        connectorConfig)

      };
    }

    function getPoints(spec) {
      var bound = spec.bound,scale = spec.scale,brushScale = spec.brushScale,align = spec.align,config = spec.config,filterConfig = spec.filterConfig,markerBound = spec.markerBound,actData = spec.data,
        width = markerBound.width,height = markerBound.height,
        markerConfig = config.marker,
        shape = markerConfig.shape,
        handleType = filterConfig.type,
        isHorizontal = align.layout === HORIZONTAL_ALIGN,
        bandWidth = brushScale.bandwidth ? brushScale.bandwidth() : 0,
        position = getSliderMarkerPosition(scale, brushScale, markerConfig, bound, align),
        maxSize = mathMax(scale(actData[0]) / 2, scale(actData[actData.length - 1]) / 2);

      return function (data) {var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var measure = data.map(function (d, i) {
            var pos = pick(selection[i], brushScale(d) + bandWidth / 2),
              r = scale(d) / 2;

            if (isHorizontal) {
              return { x: pos, y: position.y(d), r: r, w: width(d), h: height(d) };
            } else {
              return { x: position.x(d), y: pos, r: r, w: width(d), h: height(d) };
            }
          }),_measure = _slicedToArray(
          measure, 2),m0 = _measure[0],m1 = _measure[1],
          points;

        if (handleType || shape === 'whisker' || shape === 'horizontal-whisker') {
          points = [[m0.x, m0.y], [m1.x, m1.y]];
        } else if (shape === 'circle') {
          if (isHorizontal) {
            points = [[m0.x + m0.r, m0.y], [m1.x - m1.r, m1.y]];
          } else {
            points = [[m0.x, m0.y + m0.r], [m1.x, m1.y - m1.r]];
          }
        } else if (shape === 'square' || shape === 'rect') {
          if (isHorizontal) {
            points = [[m0.x + m0.w / 2, m0.y], [m1.x - m1.w / 2, m1.y]];
          } else {
            points = [[m0.x, m0.y + m0.h / 2], [m1.x, m1.y - m1.h / 2]];
          }
        } else {
          var _node = d3_selectAll('svg.svgPattern');
          if (!_node.__cache__) {
            _node.__cache__ = _node.__cache__ || {};
            // TODO: work on this
            var tempEle = createElement(PATH_ELEMENT, '.temp_slider_marker', [1], _node);
            tempEle.attr('d', getSVGsymbol(shape)(maxSize * 2));

            _node.__cache__.edges = getEdges(tempEle);
            tempEle.remove();
          }

          var _node$__cache__$edges2 = _node.__cache__.edges,_right3 = _node$__cache__$edges2.right,_left3 = _node$__cache__$edges2.left,top = _node$__cache__$edges2.top,bottom = _node$__cache__$edges2.bottom;

          if (isHorizontal) {
            var _right = [_right3[0] / maxSize * m0.r, _right3[1] / maxSize * m0.r],
              _left = [_left3[0] / maxSize * m1.r, _left3[1] / maxSize * m1.r];

            points = [[m0.x + _right[0], m0.y + _right[1]], [m1.x + _left[0], m1.y + _left[1]]];
          } else {
            var _bottom = [bottom[0] / maxSize * m0.r, bottom[1] / maxSize * m0.r],
              _top = [top[0] / maxSize * m1.r, top[1] / maxSize * m1.r];

            points = [[m0.x + _bottom[0], m0.y + _bottom[1]], [m1.x + _top[0], m1.y + _top[1]]];
          }
        }

        var isOverlap = isHorizontal ?
        points[0][0] > points[1][0] || points[1][0] < points[0][0] :
        points[0][1] > points[1][1] || points[1][1] < points[0][1];

        if (isOverlap) {
          // Is symbol overlap
          points = [];
        }

        return points;
      };
    }

    function getEdges(ele) {
      var polygonPoints = elementToPolygonPoints(ele),
        edge = {};

      polygonPoints.forEach(function (item) {
        var foundLeft = item[1] < 1 && item[1] > -1 && item[0] <= 0,
          foundRight = item[1] < 1 && item[1] > -1 && item[0] >= 0,
          foundTop = item[0] < 1 && item[0] > -1 && item[1] <= 0,
          foundBottom = item[0] < 1 && item[0] > -1 && item[1] >= 0;

        if (foundLeft) {
          if (!edge.left || edge.left[0] > item[0]) {
            edge.left = item;
          }
        }
        if (foundRight) {
          if (!edge.right || edge.right[0] < item[0]) {
            edge.right = item;
          }
        }
        if (foundTop) {
          if (!edge.top || edge.top[1] > item[1]) {
            edge.top = item;
          }
        }
        if (foundBottom) {
          if (!edge.bottom || edge.bottom[1] < item[1]) {
            edge.bottom = item;
          }
        }
      });

      return edge;
    }

    //

    function SliderAxisParser(spec) {
      var _helper = helper$6(spec),
        show = _helper.show,axisSpec = _helper.axisSpec,trimText = _helper.trimText,updateAxisLine = _helper.updateAxisLine,
        tickValues = axisSpec.tickValues,
        config = spec.config;

      var groupMark = Mark('group', ".".concat(SLIDER_AXIS_CLASSNAME));
      if (!show) {
        return groupMark;
      }

      var drawAxis = function drawAxis(ele) {
        ele.call(d3axis, axisSpec, config);
        updateAxisLine(ele.selectAll('path.domain'));
        ele.selectAll('g.tick').sort(function (a, b) {return a === tickValues[0] || a === tickValues[tickValues.length - 1] ? -1 : 1;});
        trimText(ele);

        var labelEle = getLabelEle$1(ele);
        labelEle.style('pointer-events', 'visible');
      };
      var axisGroupMark = Mark('group');
      axisGroupMark.onEnd = drawAxis;

      groupMark.children = [axisGroupMark];
      return groupMark;
    }

    function helper$6(spec) {
      var scale = spec.scale,config = spec.config,format = spec.format,orient = spec.orient,viewBound = spec.viewBound,availableBound = spec.availableBound,align = spec.align,data = spec.data,
        show = config.show,tickMarkconfig = config.tickmark,tickLabelConfig = config.ticklabel,
        tooltip = tickLabelConfig.tooltip,labels = tickLabelConfig.labels,
        isHorizontal = align.layout === HORIZONTAL_ALIGN,
        tickFormat = function tickFormat(d, i) {
          var _text = labels && labels.length ? labels[i] : format(d);
          this.__formattedValue = _text;
          d3_select(this).text(_text);
        },

        dummyChartObj = {
          dataObject: {},
          systemConf: { canvas: {}, chart: { plot: { border: {} } } }
        },
        dummyAxisObj = { ticks: { isHierarchialLevelType: function isHierarchialLevelType() {} } },

        addTooltip = function addTooltip() {
          addSVGtitleEle(d3_select(this), this.__formattedValue);
        },
        trimText = function trimText(ele) {
          var labelEle = getLabelEle$1(ele),
            lineEle = getLineEle(ele),
            _anchor = {
              anchor: getAnchor(orient),
              translateFunction: function translateFunction(ele) {
                var textTranslate = getSvgTransform(ele).translate,
                  gTranslate = getSvgTransform(ele.parentNode).translate;

                return [textTranslate[0] + gTranslate[0], textTranslate[1] + gTranslate[1]];
              }
            };

          handleTicklabels(labelEle, lineEle, availableBound, viewBound, _anchor);

          //  ZC2424 after handle overflow, tooltip will not be shown
          if (tooltip === true) {
            labelEle.each(addTooltip);
          }
        };

      var axisSpec = {
        orient: orient,
        scale: scale,
        tickFormat: tickFormat,
        tickValues: data,
        tickSizeInner: pick(tickMarkconfig.size, 6),
        tickSizeOuter: 0,
        gridSize: null,
        tickPadding: pick(tickLabelConfig.margin, 3),
        rotation: 0,
        renderTicklabel: true,
        chart: dummyChartObj, // d3axis requires chartObj
        axis: dummyAxisObj // d3axis requires axisObj
      };

      return {
        show: show,
        axisSpec: axisSpec,
        trimText: trimText,
        updateAxisLine: function updateAxisLine(ele) {
          if (scale.bandwidth) {
            var range = scale.range(),
              bandWidth = scale.bandwidth(),
              tickMarkStrokeWidth = pick(tickMarkconfig.strokeWidth, 1),
              excess = bandWidth / 2 - tickMarkStrokeWidth / 2,
              newRange = range[1] > range[0] ? [range[0] + excess, range[1] - excess] : [range[0] - excess, range[1] + excess],
              path = isHorizontal ? "M".concat(newRange[0], ",0 L").concat(newRange[1], ",0") : "M0,".concat(newRange[0], " L0,").concat(newRange[1]);

            ele.attr('d', path);
          }
        }
      };
    }

    function getAnchor(orient) {
      return orient === RIGHT_ALIGN ? START_ALIGN : orient === LEFT_ALIGN ? END_ALIGN : MIDDLE_ALIGN;
    }

    function getLabelEle$1(ele) {
      return ele.selectAll('text.ticklabel');
    }

    function getLineEle(ele) {
      return ele.selectAll('line.minorTicks');
    }

    //

    function SizeSliderParser(obj) {
      var _helper = helper$7(obj);
      var titleSpec = _helper.titleSpec,backgroundSpec = _helper.backgroundSpec,trackSpec = _helper.trackSpec,axisSpec = _helper.axisSpec,minmaxLabelSpec = _helper.minmaxLabelSpec,connectorSpec = _helper.connectorSpec,selectionTrackSpec = _helper.selectionTrackSpec;

      // Wrap
      var groupMark = Mark('group', '.legendgroup'),
        contentMark = LegendContentWrapParser(),
        //
        // Title
        titleMark = LegendTitleSvgParser(titleSpec),
        // Tracker
        trackerMark = TrackerParser(trackSpec),
        // Selection tracker
        selectionTrackerMark = TrackerParser(selectionTrackSpec),
        // Axis
        sliderAxisMark = SliderAxisParser(axisSpec),
        // Connector
        connectorMark = ConnectorParser(connectorSpec),
        // Slider
        sliderViewMark = Mark('group', ".".concat(SLIDER_VIEW_CLASSNAME)),
        // Minmax labels
        minmaxLabelMark = MinmaxLabelParser(minmaxLabelSpec),
        // Background
        backgroundMark = _LegendBackgroundSvgParser(backgroundSpec);

      contentMark.onEnd = obj.align;
      contentMark.children = [titleMark, trackerMark, selectionTrackerMark, sliderAxisMark, connectorMark, sliderViewMark, minmaxLabelMark];
      groupMark.children = [backgroundMark, contentMark];
      groupMark._helper = _helper;

      return groupMark;
    }

    function helper$7(obj) {
      var spec = obj.spec,viewScaleComponent = obj.viewScaleComponent,brushOptions = obj.brushOptions;
      var config = spec.config,bound = spec.bound,format = spec.format,globalFont = spec.globalFont,

        viewScale = viewScaleComponent.scale,viewBound = viewScaleComponent.bound,ticks = viewScaleComponent.ticks,labels = viewScaleComponent.labels,
        data = labels || ticks,

        sliderConfig = config.slider,stops = config.stops,ranges = config.ranges,
        axisConfig = sliderConfig.axis,markerConfig = sliderConfig.marker,trackConfig = sliderConfig.track,
        filterConfig = getDisabledOptions(config),
        padding = pick(sliderConfig.padding, 3),
        axisPadding = axisConfig.show ? pick(axisConfig.padding, 3) : 0,
        parsedPadding = parseShortHandValue(padding),

        align = getLegendAlignment(config),
        isHorizontal = align.layout === HORIZONTAL_ALIGN,
        axisOrient = axisConfig.orient || (isHorizontal ? BOTTOM_ALIGN : RIGHT_ALIGN),
        shape = markerConfig.shape;

      var reversed = brushOptions.reversed,brushScale = brushOptions.brushScale,dimension = brushOptions.dimension,markerBound = brushOptions.markerBound,singleDomainContinuous = brushOptions.singleDomainContinuous,sizeScale = brushOptions.sizeScale,
        dim = { width: dimension[0], height: dimension[1] },
        _extentData = [data[0], data[data.length - 1]],
        extentData = reversed ? d3_values(_extentData).reverse() : _extentData,
        minmaxLabelData = isHorizontal ? extentData : d3_values(extentData).reverse(),
        axisData = singleDomainContinuous ?
        sizeScale.domain() :
        stops && !ranges ?
        getDistinct(d3_merge([stops, brushScale.domain()])) :
        brushScale.domain(),
        sliderSize = minmaxLabelData.map(function (d) {return [viewScale(d), viewScale(d)];}),
        markerSize,
        minmaxLabelDim = dimension,
        availableBound = {
          maxWidth: bound.maxWidth - parsedPadding.left - parsedPadding.right,
          maxHeight: bound.maxHeight - parsedPadding.top - parsedPadding.bottom
        };

      if (filterConfig.type) {
        var temp = getSliderSize(filterConfig, dimension, null, align),
          _pos = isHorizontal ? 1 : 0;
        sliderSize = sliderSize.map(function (_) {return [temp[0], _[_pos]];});
      } else if (brushOptions.handles && shape !== 'circle' && shape !== 'square') {
        // Minmax labels need exact slider size
        var tempEle = createElement('path', '.temp_slider_marker', [1], d3_selectAll('svg.svgPattern'));
        var symbolPath = getSVGsymbol(shape),
          _b = [];
        sliderSize = minmaxLabelData.map(function (d) {
          tempEle.attr('d', symbolPath(markerBound.width(d), markerBound.height(d)));
          var b = bbox(tempEle);
          _b.push(b);
          return isHorizontal ? [b.width, b.width] : [b.height, b.height];
        });
        tempEle.remove();
        minmaxLabelDim = isHorizontal ? [dimension[0], d3_max(_b, function (_) {return _.height;})] : [d3_max(_b, function (_) {return _.width;}), dimension[1]];
      }

      markerSize = isHorizontal ? simpleClone(sliderSize) : simpleClone(sliderSize).reverse();
      var availableAxisBound = getAxisBound(availableBound, minmaxLabelDim, isHorizontal, axisOrient, axisPadding);

      var bandWidth = brushScale.bandwidth ? brushScale.bandwidth() : 0;
      if (bandWidth) {
        // ZC2496
        sliderSize.forEach(function (_) {
          _[0] -= bandWidth;
          _[1] -= bandWidth;
        });
      }

      var titleSpec = { data: [1], config: config.title, bound: bound },
        backgroundSpec = { data: [1], config: config, margin: padding },
        alignSpec = { isHorizontal: isHorizontal, padding: padding, axisPadding: axisPadding, axisOrient: axisOrient, markerSize: markerSize },
        trackSpec = {
          data: extentData,
          scale: viewScale,
          brushScale: brushScale,
          config: sliderConfig,
          filterConfig: filterConfig,
          trackConfig: _objectSpread(_objectSpread({ fillColor: TRANSPARENT }, filterConfig.track), {}, { show: trackConfig.show }),
          margin: padding,
          bound: dim,
          markerBound: markerBound,
          align: align
        },
        selectionTrackSpec = _objectSpread(_objectSpread({},
        trackSpec), {}, {
          trackConfig: trackConfig,
          className: "".concat(TRACK_LEGEND_CLASSNAME, "-selection") }),

        axisSpec = {
          data: axisData,
          format: format,
          scale: brushScale,
          config: axisConfig,
          bound: dim,
          viewBound: isHorizontal ?
          { width: viewBound[0], height: minmaxLabelDim[1] } :
          { width: minmaxLabelDim[0], height: viewBound[1] },
          align: align,
          orient: axisOrient,
          availableBound: availableAxisBound
        },
        minmaxLabelSpec = {
          format: format, //TODO
          data: minmaxLabelData,
          index: isHorizontal ? undefined : function (i) {return i ? 0 : 1;},
          globalFont: globalFont,
          config: axisConfig.minmaxlabels,
          orient: axisOrient,
          dimension: minmaxLabelDim,
          sliderSize: config.filter.enabled ? sliderSize : [0, 0],
          trimText: function trimText(ele) {
            var labelEle = ele.selectAll('text'),
              minmaxLabelAlign = axisConfig.minmaxlabels.align,
              _b = getMinmaxLabelBound$1(
              availableBound,
              minmaxLabelDim,
              minmaxLabelAlign,
              isHorizontal,
              axisOrient,
              dimension,
              bound,
              sliderSize),

              textAnchor = minmaxLabelAlign === RIGHT_ALIGN ? 'start' : minmaxLabelAlign === LEFT_ALIGN ? 'end' : 'middle',
              _labelParser = { anchor: textAnchor };

            handleTicklabels(ele, ele.selectAll('.nothing'), _b, { width: 0, height: 0 }, _labelParser);
          }
        },
        connectorSpec = {
          config: sliderConfig,
          data: extentData,
          align: align,
          bound: dim,
          scale: viewScale,
          brushScale: brushScale,
          filterConfig: filterConfig,
          markerBound: markerBound
        };

      return {
        titleSpec: titleSpec,
        backgroundSpec: backgroundSpec,
        trackSpec: trackSpec,
        axisSpec: axisSpec,
        minmaxLabelSpec: minmaxLabelSpec,
        connectorSpec: connectorSpec,
        alignSpec: alignSpec,
        selectionTrackSpec: selectionTrackSpec
      };
    }

    function getMinmaxLabelBound$1(available, minmaxLabelDim, align, isHorizontal, orient, dimension, bound, sliderSize) {
      var maxWidth = available.maxWidth,maxHeight = available.maxHeight,
        x;

      if (isHorizontal) {
        return { maxWidth: maxWidth, maxHeight: maxHeight, x: (bound.maxWidth - dimension[0] - sliderSize[0][0] / 2 - sliderSize[1][0] / 2) / 2 };
      }

      if (orient === LEFT_ALIGN && align === RIGHT_ALIGN) {
        maxWidth -= minmaxLabelDim[0];
        x = minmaxLabelDim[0];
      } else if (align === LEFT_ALIGN) {
        maxWidth -= minmaxLabelDim[0];
        x = -minmaxLabelDim[0];
      } else if (align === RIGHT_ALIGN) {
        maxWidth -= minmaxLabelDim[0];
      }

      return { maxWidth: maxWidth, maxHeight: maxHeight, x: x };
    }

    function getAxisBound(available, minmaxLabelDim, isHorizontal, orient, axisPadding) {
      var maxWidth = available.maxWidth,maxHeight = available.maxHeight;

      if (isHorizontal) {
        return available;
      }

      if (orient === RIGHT_ALIGN) {
        maxWidth -= minmaxLabelDim[0] + axisPadding;
      } else {
        maxWidth -= axisPadding;
      }

      return { maxWidth: maxWidth, maxHeight: maxHeight };
    }

    //

    function ColorBandParser(obj) {
      var _helper$2 = helper$8(obj.spec, obj.brushOptions),titleSpec = _helper$2.titleSpec,viewSpec = _helper$2.viewSpec,axisSpec = _helper$2.axisSpec,backgroundSpec = _helper$2.backgroundSpec,minmaxLabelSpec = _helper$2.minmaxLabelSpec,brushHandleSpec = _helper$2.brushHandleSpec; // TODO: implement axisEnd

      var groupMark = Mark('group', '.legendgroup'),
        // Background
        backgroundMark = _LegendBackgroundSvgParser(backgroundSpec),
        // Content wrap
        contentMark = LegendContentWrapParser(),
        // Title
        titleMark = LegendTitleSvgParser(titleSpec),
        // Band view
        bandMark = BandParser(viewSpec),
        //Brush handle
        brushHandleMark = BrushHandleParser(brushHandleSpec),
        // Axis
        axisMark = BandAxisParser(axisSpec),
        // Minmax labels
        minmaxLabelMark = MinmaxLabelParser(minmaxLabelSpec),
        // Brush
        brushMark = Mark('group', '.zc-band-brush');

      contentMark.children = [titleMark, bandMark, axisMark, minmaxLabelMark, brushMark, brushHandleMark];
      contentMark.onEnd = obj.align;
      contentMark.onStart = function () {return hideHighlight(groupMark);};
      groupMark.children = [backgroundMark, contentMark];

      return groupMark;
    }

    function helper$8(spec, brushOptions) {
      var config = spec.config,bound = spec.bound,area = spec.area,scaleComponent = spec.scaleComponent,globalFont = spec.globalFont,callbackArgs = spec.callbackArgs;

      //Set default brush properties
      setDefaultOptions('filter', config, null, colorBandBrushOptions(config, bound, scaleComponent.dataType, area), true);

      var bandConfig = config.band || config.colorBand,
        axisConfig = getColorAxisOptions(config),
        minmaxLabelConfig = axisConfig.minmaxlabels,
        filterConfig = config.filter,
        padding = bandConfig.padding,
        parsedPadding = parseShortHandValue(padding),

        legendAlign = getLegendAlignment(config),
        isHorizontal = legendAlign.layout === 'horizontal',
        reversed = legend_helpers.isReversedColorAxis(config),
        dimension = legend_helpers.getColorBandDimension(config, bound, area),
        orient = legend_helpers.getOrient(config),
        sliderSize = filterConfig.enabled ? getSliderSize(filterConfig.slider, dimension, orient, legendAlign) : [0, 0],
        minmaxData = [];

      if (minmaxLabelConfig.show) {
        if (bandConfig.ranges && bandConfig.ranges.length) {
          var ranges = getLegendRanges(bandConfig, scaleComponent.dataType);
          minmaxData = [ranges[0][0], ranges[ranges.length - 1][ranges[ranges.length - 1].length - 1]];
        } else {
          var scale_domain = scaleComponent.scale.domain();
          minmaxData = [scale_domain[0], scale_domain[scale_domain.length - 1]];
        }
      }

      var availableBound = {
          maxWidth: bound.maxWidth - parsedPadding.left - parsedPadding.right,
          maxHeight: bound.maxHeight - parsedPadding.top - parsedPadding.bottom
        },
        axisOrient = axisConfig.orient || (isHorizontal ? BOTTOM_ALIGN : RIGHT_ALIGN);

      if (reversed) {
        minmaxData.reverse();
      }

      var titleSpec = {
          config: config.title,
          bound: bound,
          margin: 5 // Remove (FEATURESEVENTS_HEATMAP_9)
        },
        viewSpec = {
          bound: bound,
          config: bandConfig,
          dimension: dimension,
          patternSVG: spec.chartObj.getPatternSvg(), // TODO: remove
          defsPath: spec.chartObj.defsLocation, // TODO: remove
          reversed: reversed,
          isHorizontal: isHorizontal,
          scale: scaleComponent.scale
        },
        axisSpec = {
          bound: bound,
          scale: scaleComponent.scale,
          config: axisConfig,
          orient: orient,
          dimension: dimension,
          format: spec.format,
          dataType: scaleComponent.dataType,
          meta: isObjectPropDefined(scaleComponent, 'schema.data.meta', true),
          bandConfig: bandConfig,
          isHorizontal: isHorizontal,
          reversed: reversed,
          globalFont: globalFont,
          callbackArgs: callbackArgs,
          viewBound: { width: 0, height: 0 },
          availableBound: {
            maxWidth: bound.maxWidth - parsedPadding.left - parsedPadding.right - (!isHorizontal ? dimension[0] : 0), // TODO
            maxHeight: bound.maxHeight - parsedPadding.top - parsedPadding.bottom
          }
        },
        backgroundSpec = {
          config: config,
          margin: padding
        },
        minmaxLabelSpec = {
          format: spec.format, //d => getFormattedValue(formatConf, d, datatype, chartObj, 'minmaxlabels'), // TODO
          data: minmaxData,
          orient: orient,
          dimension: dimension,
          sliderSize: sliderSize,
          config: minmaxLabelConfig,
          trimText: function trimText(ele) {
            return;
            // let labelEle = ele.selectAll('text'),
            //     minmaxLabelAlign = axisConfig.minmaxlabels.align,
            //     _b = _getMinmaxLabelBound(
            //         availableBound,
            //         minmaxLabelDim,
            //         minmaxLabelAlign,
            //         isHorizontal,
            //         axisOrient,
            //         dimension,
            //         bound,
            //         sliderSize.map(_ => [_, _])
            //     ),
            //     textAnchor = minmaxLabelAlign === RIGHT_ALIGN ? 'start' : minmaxLabelAlign === LEFT_ALIGN ? 'end' : 'start',
            //     _labelParser = { anchor: textAnchor, margin: { left: 5, right: 5, bottom: 5, top: 5 } };
            //
            // handleTicklabels(ele, ele.selectAll('.nothing'), _b, { width: 0, height: 0 }, _labelParser);
            handleOverlapTickLabel(ele); // overlapping axis and minmax label
          }
        },
        brushHandleSpec = brushOptions;

      return { titleSpec: titleSpec, backgroundSpec: backgroundSpec, viewSpec: viewSpec, axisSpec: axisSpec, minmaxLabelSpec: minmaxLabelSpec, brushHandleSpec: brushHandleSpec };
    }

    // function _getMinmaxLabelBound(available, minmaxLabelDim, align, isHorizontal, orient, dimension, bound, sliderSize, i) {
    //     let { maxWidth, maxHeight } = available;
    //
    //     if (isHorizontal && align === CENTER_ALIGN) {
    //         if (i === 0) {
    //             return { maxWidth, maxHeight, x: -(bound.maxWidth - dimension[0] - sliderSize[0][0] / 2 - sliderSize[1][0] / 2) / 2 };
    //         }
    //         return { maxWidth, maxHeight, x: (bound.maxWidth - dimension[0] - sliderSize[0][0] / 2 - sliderSize[1][0] / 2) / 2 };
    //     }
    //
    //     return getMinmaxLabelBound(available, minmaxLabelDim, align, isHorizontal, orient, dimension, bound, sliderSize);
    // }

    function hideHighlight(mark) {
      d3_select(mark.element.node().parentNode).
      selectAll('g.highlight').
      style('display', 'none');
    }

    // TODO: enhance
    function handleOverlapTickLabel(minmaxLabel) {
      if (minmaxLabel.empty()) {
        return;
      }

      var mB = [];
      minmaxLabel.each(function () {
        mB.push(getRect(this));
      });

      var tickLabels = d3_select(minmaxLabel.node().parentNode.parentNode).selectAll('text.ticklabel');
      tickLabels.each(function () {
        var lB = getRect(this);

        if (doOverlap(lB, mB[0]) || doOverlap(lB, mB[1])) {
          d3_select(this).style('display', 'none');
        }
      });
    }

    function getRect(node) {
      var bb = getBoundingRect(node);
      return { x1: bb.left, y1: bb.top, x2: bb.right, y2: bb.bottom };
    }

    //$Id$

    var MIN_VALUE$1 = 0.000000000001;

    function getInitialExtent(userRanges, userFilter, scale, brushScale, dataType) {
      var userRanges_length = userRanges && userRanges.length,
        scale_domain = scale.domain(),
        brushScale_domain = brushScale.domain(),
        rangeBandBy2 = brushScale.bandwidth ? brushScale.bandwidth() / 2 : 0,
        singleDomainContinuous = brushScale.singleDomainContinuous,
        initialExtent;

      if (userRanges_length) {
        if (userFilter) {
          var tempOptions = { scale_domain: scale_domain, datatype: dataType, ranges: userRanges, scale: brushScale };
          initialExtent = getExtentForOrdinalScale(userFilter, tempOptions);
        } else {
          var start = brushScale(brushScale_domain[brushScale_domain.length - 1]),
            end = brushScale(brushScale_domain[0]);
          initialExtent = [start + rangeBandBy2 - MIN_VALUE$1, end + rangeBandBy2 + MIN_VALUE$1];
        }

        initialExtent.sort(d3_ascending);
      } else {
        initialExtent = userFilter || singleDomainContinuous || brushScale.domain();
        initialExtent = initialExtent.map(function (d) {return brushScale(d);}).sort(d3_ascending);
      }

      return initialExtent;
    }

    function getBrushScale(config, dataType, scale, range) {
      var scale_domain = scale.domain();

      if (dataType === ORDINAL_DATATYPE) {
        if (!config.ranges) {
          config.ranges = scale_domain;
        }
      }

      var userRanges = config.ranges,
        userRanges_length = userRanges && userRanges.length,
        brushScale;

      if (userRanges_length) {
        brushScale = d3_scaleOrdinal().
        domain(dataType === ORDINAL_DATATYPE ? scale_domain : getLegendRanges(config, dataType)).
        range(range).
        padding(0);
      } else {
        var domain = [scale_domain[0], scale_domain[scale_domain.length - 1]],
          singleDomainContinuous;

        if (domain[0] === domain[1]) {
          // If the domain is [10, 10], need to change the domain //Test_694.json
          singleDomainContinuous = [-1, 1];
          domain = [-MAX_SAFE_INTEGER, MAX_SAFE_INTEGER];
        }

        brushScale = d3_scaleLinear().
        domain(domain).
        range(range).
        clamp(true); //#ZC1283 var brushScale = d3_scaleLinear().domain([1.5286745234511325, 5]).range([312.2, 0]); brushScale.invert(312.2) returns 1.5286745234511327 insteadof 1.5286745234511325

        brushScale.singleDomainContinuous = singleDomainContinuous;
      }

      return brushScale;
    }

    //
    var
    ColorLegendBand = /*#__PURE__*/function (_ColorLegend) {_inherits(ColorLegendBand, _ColorLegend);var _super5 = _createSuper(ColorLegendBand);function ColorLegendBand() {_classCallCheck(this, ColorLegendBand);return _super5.apply(this, arguments);}_createClass(ColorLegendBand, [{ key: "create", value:
        function create() {var _this25 = this;
          this.brushOptions = this.getBrushOptions();
          this.encode = ColorBandParser({
            spec: this.spec,
            align: function align(ele) {
              _this25.align(ele, _this25);
              // TODO: remove the following
              var spec = _this25.spec,
                config = spec.config,chartObj = spec.chartObj,area = spec.area,
                axisConfig = getColorAxisOptions(config),
                position = getLegendPosition(area, chartObj, null, ele, config),
                axisGroup = ele.selectAll('g.zc-band-axis'),
                _m = ele.selectAll('g.zc-legend-minmaxlabels').selectAll('text'),
                axisXY = getSvgTransform(axisGroup).translate;
              handleOverlapNOverlap(axisGroup, axisXY, position, chartObj, spec, axisConfig, ele, _m);
              _this25.align(ele, _this25);
            },
            brushOptions: this.brushOptions
          });
        } }, { key: "align", value:

        function align(ele, self) {
          var titleEle = getEle(self, 'LegendTitleSvg'),
            bandEle = getEle(self, 'Band'),
            axisEle = getEle(self, 'Axis'),
            minmaxLabelEle = getEle(self, 'MinmaxLabel'),
            brushEle = getEle(self, 'Brush'),
            brushHandleEle = getEle(self, 'BrushHandle'),

            titleBox = bbox(titleEle),
            bandBox = bbox(bandEle),
            minmaxLabelBox = bbox(minmaxLabelEle),
            axisBox = bbox(axisEle),
            brushBox = bbox(brushEle),_this$brushOptions =

            this.brushOptions,isHorizontal = _this$brushOptions.isHorizontal,orient = _this$brushOptions.orient,dimension = _this$brushOptions.dimension,
            config = this.spec.config,
            bandConfig = config.band || config.colorBand,
            axisConfig = getColorAxisOptions(config),
            padding = 0,
            axisPadding = axisConfig.show ? pick(axisConfig.padding, 3) : 0,
            bandStrokeWidth = pick(bandConfig.strokeWidth, 1) / 2,
            axisLineConfig = axisConfig.axisline,
            axisLinsStrokeWidth = (axisLineConfig.show ? pick(axisLineConfig.strokeWidth, 1) : 0) - 0.5,
            x = 0,
            y = 0;

          translate([0, 0], titleEle);
          if (isHorizontal) {
            if (orient === TOP_ALIGN) {
              x = mathMin(0, axisBox.x);
              y = titleBox.height + axisBox.height + padding + bandStrokeWidth;

              translate([x, y + bandStrokeWidth + axisLinsStrokeWidth], bandEle, brushEle, brushHandleEle);
              translate([x, y], axisEle, minmaxLabelEle);
            } else {
              x = -mathMin(0, minmaxLabelBox.x);
              y = titleBox.height + padding;

              translate([x, y - brushBox.y], bandEle, brushEle, brushHandleEle);
              translate([x, y + bandBox.height + axisPadding + bandStrokeWidth + axisLinsStrokeWidth], axisEle, minmaxLabelEle); // TODO: consider brushBox
            }
            var titleX = mathMin(0, mathMin(getBoundingRect(minmaxLabelEle).left) - getBoundingRect(titleEle).left);
            translate([titleX, 0], titleEle);
          } else {
            if (orient === LEFT_ALIGN) {
              x = axisBox.width;
              y = titleBox.height + padding + -mathMin(0, minmaxLabelBox.y);

              translate([x + axisPadding + bandStrokeWidth, y], bandEle, brushEle, brushHandleEle);
              translate([x + bandBox.x - axisLinsStrokeWidth, y], axisEle, minmaxLabelEle);
            } else {
              y = titleBox.height + padding - mathMin(0, minmaxLabelBox.y); // TODO: check

              translate([x, y], bandEle, brushEle, brushHandleEle);
              translate([bandBox.width + bandBox.x + axisPadding + bandStrokeWidth + axisLinsStrokeWidth, y], axisEle);
              translate([bandBox.width + bandBox.x + bandStrokeWidth + axisLinsStrokeWidth, y], minmaxLabelEle);
            }
          }
        } }, { key: "getBrushOptions", value:
        function getBrushOptions() {
          var _this$spec = this.spec,config = _this$spec.config,bound = _this$spec.bound,area = _this$spec.area,format = _this$spec.format,
            ranges = config.ranges,_this$spec$scaleCompo =
            this.spec.scaleComponent,dataType = _this$spec$scaleCompo.dataType,scale = _this$spec$scaleCompo.scale,

            align = getLegendAlignment(config),
            isHorizontal = align.layout === HORIZONTAL_ALIGN,
            dimension = legend_helpers.getColorBandDimension(config, bound, area),
            orient = legend_helpers.getOrient(config),
            reversed = legend_helpers.isReversedColorAxis(config),

            _range = isHorizontal ? [0, dimension[0]] : [dimension[1], 0],
            range = reversed ? _range.reverse() : _range,

            brushScale = getBrushScale(config, dataType, scale, range),
            initialExtent = getInitialExtent(ranges, config.filter.range, scale, brushScale, dataType),

            brushOptions = {
              config: config,
              reversed: reversed,
              ranges: ranges,
              range: range,
              isHorizontal: isHorizontal,
              initialExtent: initialExtent,
              align: align,
              format: format,
              brushScale: brushScale,
              scale: brushScale,
              colorScale: scale,
              sizeScale: scale, // TODO: remove CXZA_SINGLEDATA_1 event
              datatype: dataType,
              dataType: dataType,
              type: isHorizontal ? 'x' : 'y',
              orient: orient,
              dimension: dimension,
              scale_domain: scale.domain(),
              singleDomainContinuous: brushScale.singleDomainContinuous,
              encode: 'clr'
            };

          getHandleOptions(brushOptions);

          return brushOptions;
        } }]);return ColorLegendBand;}(ColorLegend);


    function translate(xy) {
      var _translate = "translate(".concat(xy.join(' '), ")");for (var _len2 = arguments.length, elements = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {elements[_key3 - 1] = arguments[_key3];}
      each(elements, function (ele) {return ele.attr('transform', _translate);});
    }

    function getEle(self, view) {
      var order = {
        LegendTitleSvg: 0,
        Band: 1,
        Axis: 2,
        MinmaxLabel: 3,
        Brush: 4,
        BrushHandle: 5
      };

      if (view === 'LegendBackgroundSvg') {
        return self.encode.children[0].element;
      }
      return self.encode.children[1].children[order[view]].element;
    }

    function getHandleOptions(options) {
      var config = options.config,dimension = options.dimension,isHorizontal = options.isHorizontal,ranges = options.ranges,
        hoverOptions = config.itemHoverStyle || {}; //getHoverOptions(config, 'clr');

      if (hoverOptions.type) {
        var op = getDefaultSliderOptions(dimension, isHorizontal, ranges && ranges.length);
        config._itemHoverStyle = mergeJSON$1(op, hoverOptions, true);
      }
    }

    ColorLegendBand.encode = 'clr';
    ColorLegendBand.view = 'band';
    ColorLegendBand.domMode = 'svg';
    Registry.setComponent('colorLegendBand', ColorLegendBand);
    LegendRegistry.add(ColorLegendBand);

    //

    /**
     *
     * @param chart
     * @return {BrushD3Options}
     */
    function _getLegendColorBandBrushArguments(chart) {
      var legendInstance = chart.legends.get('clr-0'),
        component = legendInstance.component,element = legendInstance.element,
        config = component.spec.config,_component$brushOptio =
        component.brushOptions,type = _component$brushOptio.type,dimension = _component$brushOptio.dimension,

        extent = [[0, 0], dimension],
        BrushD3Options = Registry.getComponent('BrushD3Options');

      return new BrushD3Options({
        type: type,
        extent: extent,
        component: component,
        behaviour: 'resizeToMouse',
        element: getTrackerElement(element),
        styles: {
          selection: {
            fillColor: TRANSPARENT,
            strokeColor: TRANSPARENT,
            fillOpacity: 1
          },
          track: config.filter.track
        }
      });
    }

    /**
     * Returns tracker element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getTrackerElement(container) {
      return container.selectAll('g.zc-band-brush');
    }

    Registry.setComponent('_getLegendColorBandBrushArguments', _getLegendColorBandBrushArguments);

    /**
     *
     * @param instanceMap
     * @param event
     * @constructor
     */
    function LegendColorBandBrushListener(instanceMap, event) {
      var eventManager = this,
        type = event.type,selection = event.selection,
        data = eventManager.getData(instanceMap, type, selection);

      eventManager.associateBehaviours(instanceMap, type, data, selection, event);
    }

    function LegendBrushDataFinder(instanceMap, type, selection, forced) {
      var brushOptions = instanceMap.instance.options.component.brushOptions,
        reversed = brushOptions.reversed,
        data = getRange$1(brushOptions, selection);

      return reversed ? d3_values(data).reverse() : data;
    }

    //

    function getHandles(behaviour) {
      var behaviourInstance = behaviour.instance,_behaviourInstance$op =
        behaviourInstance.options,component = _behaviourInstance$op.component,extent = _behaviourInstance$op.extent,
        brushOptions = component.brushOptions,
        type = brushOptions.type,config = brushOptions.config,handleOptions = brushOptions.handles,
        sliderConfig = config.filter.slider;
      return getBrushHandle(type, sliderConfig.type, extent, null, sliderConfig[sliderConfig.type] || {});
    }

    //$Id$

    var SVGTooltip = function SVGTooltip(options) {
      this.chartObj = options.chartObj;
      this.config = options.config;
      this.globalFont = splat(options.globalFont || []);

      var container = this.container = appendEle(options.container, 'g', this.config.enabled ? [1] : [], '.', 'class', 'zc-svg-tooltip');
      container.style('pointer-events', NONE).style('display', NONE);

      this.boundBoxEle = appendEle(container, PATH_ELEMENT, [1]);
      this.textEle = appendEle(container, TEXT_ELEMENT, [1]);

      this.styleText();
      this.styleBoundBox();
    };

    SVGTooltip.prototype.show = function (textContent, position) {
      cancelAnimation(this.container);
      this.container.styles({
        opacity: NULL$1,
        display: NULL$1
      });
      this.updateTextContent(textContent);
      this.positionTooltip(position);
      this.drawBoundBox();
    };

    SVGTooltip.prototype.hide = function (forced) {
      var container = this.container;

      if (forced) {
        container.style('opacity', 0).style('display', NONE);
      } else {
        container.
        transition().
        duration(forced ? 0 : 250).
        style('opacity', 0).
        on('end', function () {
          d3_select(this).style('display', NONE);
        });
      }
    };

    SVGTooltip.prototype.styleText = function () {
      // Trim text
      var textEle = this.textEle,
        orient = this.config.orient,
        globalFont = this.globalFont,
        isHorizontal = orient === TOP_ALIGN || orient === BOTTOM_ALIGN;

      applyFont(textEle, [this.config].concat(_toConsumableArray(globalFont), [$ZCG]));
      textEle.attrs({
        'text-anchor': isHorizontal ? 'middle' : orient === LEFT_ALIGN ? 'start' : 'end',
        dy: !isHorizontal ? '0.3em' : orient === TOP_ALIGN ? '0.9em' : '-0.3em'
      });
    };

    SVGTooltip.prototype.styleBoundBox = function () {
      var config = this.config;
      this.boundBoxEle.styles({
        fill: config.backgroundColor,
        stroke: config.borderColor,
        'stroke-width': config.borderWidth
      });
    };

    SVGTooltip.prototype.updateTextContent = function (textContent) {
      this.textEle.text(textContent);
    };

    SVGTooltip.prototype.positionTooltip = function (position) {
      if (!position) {
        return;
      }

      this.container.attr('transform', "translate(".concat(position[0], ",").concat(position[1], ")"));
    };

    SVGTooltip.prototype.drawBoundBox = function () {
      var textBounds = this.textEle.nodes(),
        config = this.config,
        padding = config.padding,
        radius = getBorderRadius(config.borderRadius || 0),
        count = 0;

      this.boundBoxEle.attr('d', function () {
        var bb = bbox(textBounds[count++]);
        return getBoundBoxPathDescription(bb.x - padding, bb.y - padding, bb.width, bb.height, radius, padding, TOP_ALIGN, {}, 0);
      });
    };

    function HighlightTooltip(options) {
      var config = options.config,orient = options.orient,chart = options.chart,element = options.element,
        systemConf = chart.systemConf,
        defaultOptions = _objectSpread(_objectSpread({},
        brushTooltipOptions()), {}, {
          fontSize: chart.globalProp.fontL1Size.l5,
          orient: orient }),

        tooltipOptions = {
          config: mergeJSON$1(defaultOptions, config, true),
          container: element,
          globalFont: [systemConf.chart, systemConf.canvas]
        };

      return new SVGTooltip(tooltipOptions);
    }

    function getSVGTooltipPosition(ele, config) {var isHorizontal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var translate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0];
      var padding = config.padding,margin = config.margin,orient = config.orient,
        bb = bbox(ele.node()),
        bb_x,
        bb_y,
        bb_width,
        bb_height,
        outerSpace = padding + margin,
        x,
        y;

      if (isHorizontal) {
        bb_x = bb.x;
        bb_y = bb.y;
        bb_width = bb.width;
        bb_height = bb.height;
      } else {
        bb_x = bb.y;
        bb_y = bb.x;
        bb_width = bb.height;
        bb_height = bb.width;
      }

      switch (orient) {
        case BOTTOM_ALIGN:
          x = 0;
          y = bb_y - outerSpace;
          break;
        case RIGHT_ALIGN:
          x = bb_x - outerSpace;
          y = 0;
          break;
        case LEFT_ALIGN:
          x = bb_x + bb_width + outerSpace;
          y = 0;
          break;
        case TOP_ALIGN:
          x = 0;
          y = bb_y + bb_height + outerSpace;}


      return [x + translate[0], y + translate[1]];
    }

    //$Id$

    var defaultOptions$1 = {
      padding: 5,
      margin: 5
    };

    /**
     *
     * @param tooltipOptions
     * @param brushInstance
     * @param orient
     * @param dataFinder
     * @param customActions
     * @param chart
     * @constructor
     */
    function BrushComponentTooltip(tooltipOptions, brushInstance, orient, dataFinder, chart, customActions, globalFont) {var options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
      var handles = brushInstance.customHandles,_ref15 =
        chart || {},systemConf = _ref15.systemConf,
        _options = {
          config: _objectSpread(_objectSpread(_objectSpread({}, defaultOptions$1), tooltipOptions), {}, { orient: orient }),
          container: handles,
          globalFont: globalFont || [systemConf.chart, systemConf.canvas]
        },
        spec = isObjectPropDefined(brushInstance.options, 'component.spec', true);

      this.dataFinder = dataFinder;
      this.chart = chart;
      var tooltipObj = this["super"] = new SVGTooltip(_options);
      this.container = tooltipObj.container;
      this.boundBoxEle = tooltipObj.boundBoxEle;
      // this.textEle = tooltipObj.textEle;
      this.tooltipOptions = tooltipObj.config;
      this.customActions = customActions || {};
      this.options = options;
      this.positionTooltip();
      if (!spec || !(spec.encode === 'clr' && isObjectPropDefined(spec.config, 'events.enabled', true) === false)) {
        this.addHoverEvents(brushInstance.parent_group);
      }
    }

    BrushComponentTooltip.prototype.show = function () {
      var self = this,
        count = 0;
      self["super"].show(function () {return self.dataFinder(count++);});
      if (self.customActions.show) {
        self.customActions.show();
      }
    };

    BrushComponentTooltip.prototype.hide = function (forced) {
      var self = this;
      self["super"].hide(forced);
      if (self.customActions.hide) {
        self.customActions.hide();
      }
    };

    BrushComponentTooltip.prototype.positionTooltip = function () {
      var tooltipOptions = this.tooltipOptions,
        orient = this["super"].config.orient,_this$options =
        this.options,translate = _this$options.translate,_this$options$boxElem = _this$options.boxElement,boxElement = _this$options$boxElem === void 0 ? function (ele) {return ele;} : _this$options$boxElem,isHorizontal = _this$options.isHorizontal;

      this.container.attr('transform', function () {
        var handleElement = boxElement(d3_select(this.parentNode)),
          position = getSVGTooltipPosition(
          handleElement,
          tooltipOptions,
          invokeFunction(isHorizontal, orient),
          invokeFunction(translate, handleElement));


        return translateString(position);
      });
    };

    BrushComponentTooltip.prototype.addHoverEvents = function (element) {
      var self = this,
        onSelection = true,
        mouseHandlers = {
          mousemove: function mousemove() {
            var className = d3_select(d3_event().srcElement || d3_event().target).attr('class');
            if (className !== 'overlay') {
              self.show();
              onSelection = true;
            } else if (onSelection) {
              self.hide();
              onSelection = false;
            }
          },
          mouseleave: function mouseleave() {
            self.hide();
            onSelection = false;
          }
        };
      attachevents(element, mouseHandlers);
    };

    function brushTooltip(behaviourEventInstance) {
      var brushInstance = behaviourEventInstance.instance,
        component = brushInstance.options.component,_component$spec =
        component.spec,globalFont = _component$spec.globalFont,encode = _component$spec.encode,
        brushOptions = component.brushOptions,
        config = brushOptions.config,reversed = brushOptions.reversed,customActions = brushOptions.customActions,handleOptions = brushOptions.handles,
        disabledOptions = getDisabledOptions(config),
        tooltipOptions = encode === 'clr' ? disabledOptions.slider.tooltip : disabledOptions.tooltip,
        dataFinder = behaviourEventInstance.dataFinder.brush,
        text = function text(d) {
          var point = dataFinder(behaviourEventInstance, null, brushInstance.getSelection()),
            data = getTooltipData(brushOptions, point, reversed);
          return getBrushTooltipContent(data, d, brushOptions);
        },
        orient = legend_helpers.getOrient(config),
        options =
        encode === 'clr' ?
        {} :
        {
          translate: function translate(ele) {return getSvgTransform(ele).translate;},
          boxElement: function boxElement(ele) {return ele.selectAll('path');},
          isHorizontal: handleOptions ? undefined : function (orient) {return orient === TOP_ALIGN || orient === BOTTOM_ALIGN;}
        };

      return new BrushComponentTooltip(tooltipOptions, brushInstance, orient, text, null, customActions, globalFont, options);
    }

    function getTooltipData(options, point, strictReverse) {
      var ranges = options.ranges,reversed = options.reversed,config = options.config,scale = options.sizeScale,dataType = options.datatype,singleDomainContinuous = options.singleDomainContinuous;
      point = point || config.filter.range;
      var data;

      if (singleDomainContinuous) {
        return scale.domain();
      }

      if (point) {
        if (dataType === ORDINAL_DATATYPE) {
          var extentData = [point[0], point[point.length - 1]];
          data = reversed ? d3_values(extentData).reverse() : extentData;
        } else if (ranges && ranges.length) {
          data = getActiveDiscreteDomain(d3_values(point).sort(d3_ascending), ranges);
        } else {
          data = strictReverse ? d3_values(point).reverse() : point;
        }

        return data;
      }
    }

    //

    function StyleHandles(behaviourEventInstance, selectionManager) {
      var _instance = behaviourEventInstance.instance,
        customHandles = _instance.customHandles,
        brushOptions = _instance.options.component.brushOptions,
        _selection = _instance.getSelection(),
        range = getRange$1(brushOptions, _selection);

      styleHandles(brushOptions, customHandles, range);
    }

    function ApplyBrushSelectionOnPlot$1(behaviourEventInstance, selectionManager, selection) {
      var eventManager = this,
        chart = eventManager.chart,
        legendComponent = behaviourEventInstance.instance.options.component,
        brushOptions = legendComponent.brushOptions,
        config = brushOptions.config,singleDomainContinuous = brushOptions.singleDomainContinuous,
        encode = legendComponent.spec.encode;

      if (!selection) {
        return;
      }

      if (!behaviourEventInstance.initialized || singleDomainContinuous) {
        return; // If event is not initialized
      }

      var range = getRange$1(brushOptions, selection);
      config.filter.range = range;

      if (jsonStringify(range) !== jsonStringify(behaviourEventInstance.previousRange)) {
        // #ZC1369 addRemoveSeries only if previousExtent and extent are diff
        if (encode === 'clr') {
          chart.addRemoveSeries();
        } else {
          chart.plot.renderer.draw(true);
        }
      }
      behaviourEventInstance.previousRange = range;
    }

    function showTooltip(behaviourEventInstance, selectionManager, selection) {
      var brushInstance = behaviourEventInstance.instance,
        tooltip = brushInstance.tooltip;

      if (tooltip) {
        tooltip.positionTooltip();
        tooltip.show();
      }
    }

    function hideTooltip(behaviourEventInstance, selectionManager, selection, _, forced) {
      var brushInstance = behaviourEventInstance.instance,
        tooltip = brushInstance.tooltip;

      if (tooltip) {
        tooltip.hide(forced);
      }
    }

    function ResetHighlightItem(mouse, data, forced) {
      var manager = this,
        options = manager.options,
        highlightElement = options.highlightElement;

      // Hide highlight element
      if (forced) {
        highlightElement.style('opacity', 0);
      } else {
        highlightElement.transition().style('opacity', 0);
      }
    }

    function hideCursor() {
      var manager = this,
        options = manager.options,
        trackerElement = options.trackerElement;

      trackerElement.style('cursor', null);
    }

    function hideTooltip$1(mouse, data, forced) {
      var manager = this,
        options = manager.options,
        tooltip = options.tooltip;

      tooltip.hide(forced);
    }

    function HideHighlight(behaviourEventInstance, selectionManager) {
      var chart = this.chart,
        legendEvents = chart.legendEvents,
        legendEventManager = legendEvents && legendEvents.eventManager,
        id = behaviourEventInstance.instance.options.component.spec.id,
        manager = legendEventManager && legendEventManager[getManagerID(chart, id)],
        options = manager && manager.options;

      if (isEmptyObject(manager) || !options.enabled) {
        return;
      }

      ResetHighlightItem.call(manager, null, null, true);
      hideCursor.call(manager);
      hideTooltip$1.call(manager);
    }

    function PreventDefault(behaviourEventInstance, selectionManager, selection, event) {
      var sourceEvent = event.sourceEvent;
      if (sourceEvent && sourceEvent.preventDefault) {
        sourceEvent.preventDefault();
      }
    }

    function SnapRange(behaviourEventInstance, selectionManager, selection) {
      var brushInstance = behaviourEventInstance.instance,
        brushOptions = brushInstance.options.component.brushOptions;

      if (!behaviourEventInstance.initialized) {
        return; // If event is not initialized
      }

      var _selection = brushInstance.getSelection(),
        snapSelection = snapHandlePosition(brushOptions, _selection),
        previousSnapSelection = behaviourEventInstance.snapSelection,
        convertToInt = function convertToInt(d) {return parseInt(d);}, // ZC2438
        isSameSelection =
        previousSnapSelection && jsonStringify(_selection.map(convertToInt)) === jsonStringify(previousSnapSelection.map(convertToInt));

      if (isArray$1(snapSelection) && !isSameSelection) {
        snapSelection.sort(d3_ascending);
        behaviourEventInstance.snapSelection = snapSelection;
        brushInstance.setSelection(snapSelection, 250);
      }
    }

    function ForceHideTooltip() {
      hideTooltip.call.apply(hideTooltip, [this].concat(Array.prototype.slice.call(arguments), [true]));
    }

    //
    function ClearCache(mouse, data) {
      var manager = this,
        chart = manager.chart;

      chart.cache.search = {}; // ZC2516
      chart.cache.data = {}; // ZC3094
    }

    /**
     *
     * @type {{GET_DOMAIN(*=, *=, *, *=, *=): *[], CALCULATE_DOMAIN(*, *=, *=, *=, *=): *[], GET_DOMAIN_INFO(*=, *=, *=, *=): {}}}
     */
    var CHART_BRUSH_HELPERS = {
      CLIP_TRACK: function CLIP_TRACK(brushInstance, selection, chart, name) {var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        var clipSrc = getClip(brushInstance, selection, chart, name, options);
        brushInstance._track.attr('clip-path', clipSrc);

        return clipSrc;
      },
      GET_CLIP: getClip
    };

    function getClip(brushInstance, selection, chart, name) {var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var desc = pick(options.desc, RectClip(brushInstance, selection));

      var properties = { d: desc, name: 'brush', id: chart.id },
        // #ZC2212 $name
        scroll_clip_id = "brush_tracker_clip_".concat(name, "_").concat(chart.id);

      if ($Browser.PHANTOMJS) {
        scroll_clip_id = effects.get(effects.svg_clips, 'polygon', properties, { chartObj: chart });
      } else {
        svg_clips.polygon(properties, scroll_clip_id, null, null, null, chart);
      }

      return "url(".concat(chart.defsLocation, "#").concat(scroll_clip_id, ")");
    }

    function RectClip(brushInstance, selection) {
      var start = [0, 0],
        desc,
        dimension = brushInstance.d3_brush.extent()()[1];

      selection = selection || brushInstance.getSelection();

      if (brushInstance.options.type === 'x') {
        desc =
        "M".concat(start[0], " ").concat(start[1], "L").concat(selection[0], " ").concat(start[1], "L").concat(selection[0], " ").concat(dimension[1], "L").concat(start[0], " ").concat(dimension[1], "Z") + "M".concat(
        selection[1], " ").concat(start[1], "L").concat(dimension[0], " ").concat(start[1], "L").concat(dimension[0], " ").concat(dimension[1], "L").concat(selection[1], " ").concat(dimension[1], "Z");
      } else {
        desc =
        "M".concat(start[0], " ").concat(start[1], "L").concat(dimension[0], " ").concat(start[1], "L").concat(dimension[0], " ").concat(selection[0], "L").concat(start[0], " ").concat(selection[0], "Z") + "M".concat(
        start[0], " ").concat(selection[1], "L").concat(dimension[0], " ").concat(selection[1], "L").concat(dimension[0], " ").concat(dimension[1], "L").concat(start[0], " ").concat(dimension[1], "Z");
      }

      return desc;
    }

    //$Id$

    /**
     *
     * @param options
     * @param container
     * @param brushInstance
     * @param chart
     */
    function updateTrackerClip(options, container, brushInstance, chart) {
      var start = [0, 0],
        selection = brushInstance.getSelection(),
        mid = selection.slice(0),
        isHorizontal = options.type === 'x';

      if (options.scale.bandwidth) {
        var bandWidth = options.scale.bandwidth();
        mid[0] -= mid[0] % bandWidth;
        mid[1] += bandWidth - mid[1] % bandWidth;
      } else if (options.singleDomainContinuous) {
        //Test_779.json
        var index = isHorizontal ? 0 : 1;
        mid[0] = start[index];
        mid[1] = options.dimension[index];
      }

      // clip the track
      // TODO do only if needed
      // brushInstance.clipTrack(mid);
      CHART_BRUSH_HELPERS.CLIP_TRACK(brushInstance, mid, chart, 'colorband');

      // TODO do only if needed
      fixHighlightTracker(container, start, mid, options.dimension, isHorizontal);
    }

    /**
     *
     * @param container
     * @param start
     * @param selection
     * @param dimension
     * @param isHorizontal
     */
    function fixHighlightTracker(container, start, selection, dimension, isHorizontal) {
      var clip = createElement('path', '.zcbrushhighlighttracker', [1], container, ':nth-child(2)');
      // 1px padding is necessary in discrete color band(heatmap-02.json).
      // Filter [0-10] and [10-20]. Hover at the left edge of [20-30].
      // [10-20] is getting hovered. For that 1px is subtracted
      var midStart = selection[0] + 1,
        midEnd = selection[1] - 1,
        d = isHorizontal ? "M".concat(
        midStart, " ").concat(start[1], "L").concat(midEnd, " ").concat(start[1], "L").concat(midEnd, " ").concat(dimension[1], "L").concat(midStart, " ").concat(dimension[1], "Z") : "M".concat(
        start[0], " ").concat(midStart, "L").concat(start[0], " ").concat(midEnd, "L").concat(dimension[0], " ").concat(midEnd, "L").concat(dimension[0], " ").concat(midStart, "Z");

      clip.attr('d', d).styles({
        opacity: 0,
        'stroke-width': 0
      });
    }

    //$Id$

    function StyleTrack(behaviourEventInstance, selectionManager, selection) {
      var eventManager = this,
        chart = eventManager.chart,
        _instance = behaviourEventInstance.instance,
        options = _instance.options,
        component = options.component,
        brushOptions = component.brushOptions;

      updateTrackerClip(brushOptions, _instance.parent_group, _instance, chart);
    }

    //

    var _legendColorBandBrushHandlers = {
      LISTENER: {
        start: LegendColorBandBrushListener,
        brush: LegendColorBandBrushListener,
        end: LegendColorBandBrushListener
      },
      DATA_FINDER: {
        start: LegendBrushDataFinder,
        brush: LegendBrushDataFinder,
        end: LegendBrushDataFinder
      },
      BEHAVIOUR: {
        start: [PreventDefault],
        brush: [ForceHideTooltip, StyleHandles, ApplyBrushSelectionOnPlot$1, showTooltip, HideHighlight, StyleTrack],
        end: [ClearCache, hideTooltip, SnapRange]
      },
      LISTENER_TYPES: d3_set(['start', 'brush', 'end']),
      SUPPORTED: isSupported(BAND_LEGEND_TYPE),
      // UPDATE: function() {},
      INIT: function INIT(behaviour) {
        var behaviouralEvents = this,
          chart = behaviouralEvents.chart,
          behaviourInstance = behaviour.instance,
          legendComponent = behaviourInstance.options.component,
          config = legendComponent.spec.config,
          initialExtent = legendComponent.brushOptions.initialExtent,
          handles = getHandles(behaviour),
          eventEnabled = isEventEnabled(config);

        behaviour.initialized = false;
        var handleElement = behaviourInstance.addCustomHandle(handles);
        behaviourInstance.setSelection(initialExtent);
        behaviourInstance.tooltip = brushTooltip(behaviour);

        // Shadow
        var filterConfig = config.filter.slider;
        handleShadow(filterConfig, handles, handleElement, chart);

        // Visibility for custom handles
        behaviourInstance.customHandles.style('visibility', eventEnabled ? null : 'hidden');

        if (!eventEnabled) {
          behaviourInstance.customHandles.attr('pointer-events', 'none');
          behaviourInstance.destroy();
        }

        behaviour.initialized = true;
      }
    };

    function isEventEnabled(config) {
      var eventsConfig = config.events,filter = config.filter,
        eventDisabled = eventsConfig && validateNullVal(eventsConfig.enabled, true) == false;

      return !eventDisabled && filter.enabled;
    }

    Registry.setComponent('_legendColorBandBrushHandlers', _legendColorBandBrushHandlers);

    //

    function ColorBandListener(_, i, ele, eventType) {
      var manager = this,
        event = d3_event(),
        mouse = getMousePosition(manager.tracker.node(), event);

      var data = manager.getData(eventType, mouse);

      manager.associateBehaviours(eventType, data, mouse, event);
    }

    //

    function ColorBandDataFinder(mouse, eventType) {
      var manager = this,
        options = manager.options;

      return getHighlightedItemFromMousePoint(mouse, options);
    }

    //

    function ReverseDataFinder(data, eventType) {
      var manager = this,
        chart = manager.chart,options = manager.options,
        config = options.config,legendInstance = options.legendInstance,_legendInstance$meta =
        legendInstance.meta,encode = _legendInstance$meta.encode,scaleComponent = _legendInstance$meta.scaleComponent,
        scale = encode === 'clr' ? scaleComponent.scale : scaleComponent.getScale(),
        val = chart.dataset[encode === 'clr' ? 'getClr' : 'getZ'](data),
        indexScale = encode === 'clr' && chart.axes.clr.indexScale;

      var nullAsOptions = { config: config, scale: scale, columnKey: chart.dataset.getColumnIdx(encode) };
      val = convertNull(val, nullAsOptions);
      return getData(val, options, { indexScale: indexScale });
    }

    function getData(val, options, _) {
      var config = options.config,dataType = options.dataType,
        ranges = config.ranges,
        indexScale = _.indexScale;

      if (dataType === ORDINAL_DATATYPE) {
        var scale_domain = isArray$1(ranges[0]) ? ranges.map(function (_) {return _[0];}) : ranges;
        return scale_domain.indexOf(val);
      } else if (ranges && ranges.length) {
        if (ranges[0].length === 1 && indexScale) {
          return indexScale(val);
        }
        return indexOfRange(val, ranges);
      } else {
        var point = [val, val];
        point.data = val;
        return point;
      }
    }

    //

    function ColorReverseDataFinder(data, eventType) {
      return ReverseDataFinder.apply(this, arguments);
    }

    //

    var BrushD3$2 = Registry.getComponent('BrushD3');
    function HighlightItem$1(mouse, data) {
      var manager = this,
        options = manager.options,chart = manager.chart,
        config = options.config,highlightElement = options.highlightElement,
        hoverOptions = getHoverOptions(config, 'clr'),
        hoverType = hoverOptions.type,

        dt = getHighlightData(data.point, options),
        handles;

      // Show highlight element
      cancelAnimation(highlightElement);
      highlightElement.style('opacity', null);

      if (hoverType) {
        handles = handlerByType(hoverOptions, options, dt);
        BrushD3$2.ADD_HANDLE(handles, highlightElement);

        var handleElement = highlightElement.selectAll('g.handle--custom');
        handleShadow(hoverOptions, [handles], handleElement, chart);
      }
    }

    function HighlightSeries(mouse, data, forced) {
      var manager = this,
        chart = manager.chart,options = manager.options,previousHighlightedItem = manager.previousHighlightedItem,
        config = options.config,highlightManager = options.highlightManager,
        ranges = config.ranges,
        highlightedItem = data.point,
        seriesData = chart.seriesdata;

      if (!forced && jsonStringify(previousHighlightedItem) === jsonStringify(highlightedItem)) {
        return; // TODO: check this
      }

      // ZC2429
      if (ranges && ranges[highlightedItem].disabled) {
        return;
      }

      chart.highlightContext = null;

      if (defined(previousHighlightedItem) && jsonStringify(previousHighlightedItem) !== jsonStringify(highlightedItem)) {
        var temp = previousHighlightedItem;
        manager.previousHighlightedItem = null;
        seriesData.forEach(function (d, j) {
          highlightManager.reset(config, j, temp, seriesData.length - 1 === j);
        });
      }

      seriesData.forEach(function (d, j) {
        highlightManager.highlightSelectedSeries(config, j, highlightedItem);
        highlightManager.highlightUnselectedSeries(config, j, highlightedItem);
      });

      manager.previousHighlightedItem = highlightedItem;
    }

    function ResetHighlightSeries(mouse, data) {
      var manager = this,
        chart = manager.chart,options = manager.options,previousHighlightedItem = manager.previousHighlightedItem,
        config = options.config,highlightManager = options.highlightManager,
        seriesData = chart.seriesdata;

      seriesData.forEach(function (d, j) {
        highlightManager.reset(config, j, previousHighlightedItem, seriesData.length - 1 === j);
      });

      manager.previousHighlightedItem = null;
    }

    function ForceResetHighlightItem() {
      ResetHighlightItem.call.apply(ResetHighlightItem, [this].concat(Array.prototype.slice.call(arguments), [true]));
    }

    function ForceHideTooltip$1() {
      hideTooltip$1.call.apply(hideTooltip$1, [this].concat(Array.prototype.slice.call(arguments), [true]));
    }

    //

    function StyleHandle(mouse, data) {
      var manager = this,
        chart = manager.chart,options = manager.options,
        highlightElement = options.highlightElement,legendInstance = options.legendInstance,_legendInstance$compo =
        legendInstance.component.brushOptions,ranges = _legendInstance$compo.ranges,colorScale = _legendInstance$compo.colorScale,
        point = data.point,
        color;

      if (ranges && ranges.length) {
        var colors = chart.seriesColor;
        color = colors[point % colors.length];
      } else {
        color = colorScale(point.data);
      }

      highlightElement.style('fill', color);
    }

    function showCursor(mouse, data) {
      var manager = this,
        options = manager.options,targetEvent = manager.targetEvent,
        trackerElement = options.trackerElement,config = options.config,_config$events =
        config.events,eventsConfig = _config$events === void 0 ? {} : _config$events,
        targetNode = targetEvent.srcElement || targetEvent.target,
        targetElement = d3_select(targetNode),
        cursor = targetElement.classed(SLIDER_HANDLE_TRACK_CLASSNAME) ?
        d3_select(targetNode.parentNode).attr('cursor') // While moving on the handle, resize cursor should be visible
        : eventsConfig.cursor || POINTER;

      trackerElement.style('cursor', cursor);
    }

    function showTooltip$1(mouse, data) {
      var manager = this,
        options = manager.options,
        tooltip = options.tooltip,highlightElement = options.highlightElement,format = options.format,userRanges = options.ranges,isHorizontal = options.isHorizontal,handleOptions = options.handles,dataType = options.dataType,
        point = data.point;

      // Content
      var d = dataType === ORDINAL_DATATYPE ? userRanges[point][0] : userRanges && userRanges.length ? userRanges[point] : point[0];
      tooltip.show(format(d));

      // Position
      var handleElement = highlightElement.selectAll('g.handle--custom'),
        position;

      var pathEle = handleElement.selectAll(PATH_ELEMENT),
        pathNode = pathEle.node(),
        translate = pathNode ? getSvgTransform(pathNode).translate : [0, 0]; // TODO: check pathNode condition

      position = getSVGTooltipPosition(pathEle, tooltip.config, handleOptions ? undefined : isHorizontal, translate);
      tooltip.positionTooltip(position);
    }

    //

    function addLegendApi(legends, chartObj) {
      var // Get
        get = function get(id) {return arrayFind(legends, function (_) {return _.id === id;});},
        // Behaviour
        behaviour = function behaviour(id, name, data) {
          var legend = legends.get(id);

          if (!legend) {
            return;
          }

          var _legend$meta = legend.meta,view = _legend$meta.view,encode = _legend$meta.encode,
            instanceName = "".concat(fullEncode$1(encode).toUpperCase(), "_").concat(view.toUpperCase(), "(").concat(id, ")"),
            manager = chartObj.legendEvents.eventManager[instanceName],
            bahaviour = getBehaviour(manager, name),
            _data = data.point ? data : { point: data };

          if (!bahaviour) {
            return;
          }for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key4 = 3; _key4 < _len3; _key4++) {args[_key4 - 3] = arguments[_key4];}

          bahaviour.call.apply(bahaviour, [manager, null, _data].concat(args));
        };

      // Set
      legends.get = get;
      legends.behaviour = behaviour;
    }

    function getBehaviour(manager, name) {
      var _behaviours = objectValues(manager.defaultBehaviour),
        found;

      _behaviours.some(function (b) {
        found = arrayFind(b, function (_) {return smallizeFirstLetter(_.name).replace(/\$(\d+)/, '') === name;});
        return found;
      });

      return found;
    }

    function smallizeFirstLetter(str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    }

    function fullEncode$1(encode) {
      return encode === 'z' ? 'size' : encode === 'clr' ? 'color' : null;
    }

    //

    function hideBrushTooltip() {
      d3_event().stopImmediatePropagation();

      var manager = this,
        chart = manager.chart,_manager$options$lege =
        manager.options.legendInstance.meta,encode = _manager$options$lege.encode,view = _manager$options$lege.view,
        behaviourName = "LEGEND_".concat(fullEncode$1(encode).toUpperCase(), "_").concat(view.toUpperCase(), "_BRUSH"),
        brushBehaviour = chart.behaviouralEvents.eventManager.behaviours[behaviourName];

      if (brushBehaviour) {
        hideTooltip(brushBehaviour, null, null, null, true);
      }
    }

    //

    var _legendColorBandHandlers = {
      LISTENER: {
        mousemove: ColorBandListener,
        mouseout: ColorBandListener
      },
      DATA_FINDER: {
        mousemove: ColorBandDataFinder,
        mouseout: ColorBandDataFinder
      },
      BEHAVIOUR: {
        mousemove: [hideBrushTooltip, showCursor, HighlightItem$1, HighlightSeries, StyleHandle, showTooltip$1],
        mouseout: [hideCursor, _resetHighlightItem, ResetHighlightSeries, _hideTooltip]
      },
      REVERSE_DATA_FINDER: {
        mousemove: ColorReverseDataFinder
      },
      REVERSE_BEHAVIOUR: {
        mousemove: [HighlightItem$1, StyleHandle, showTooltip$1],
        mouseout: [ForceResetHighlightItem, ForceHideTooltip$1]
      },
      SUPPORTED: isSupported(BAND_LEGEND_TYPE)
    };

    function _resetHighlightItem() {
      var manager = this;

      if (isForced(manager)) {
        ForceResetHighlightItem.call.apply(ForceResetHighlightItem, [manager].concat(Array.prototype.slice.call(arguments), [true]));
      } else {
        ResetHighlightItem.call.apply(ResetHighlightItem, [manager].concat(Array.prototype.slice.call(arguments)));
      }
    }

    function _hideTooltip() {
      var manager = this;

      if (isForced(manager)) {
        ForceHideTooltip$1.call.apply(ForceHideTooltip$1, [manager].concat(Array.prototype.slice.call(arguments), [true]));
      } else {
        hideTooltip$1.call.apply(hideTooltip$1, [manager].concat(Array.prototype.slice.call(arguments)));
      }
    }

    function isForced(manager) {
      // If mouse moves to custom-handle-path, force reset should be done
      var targetEvent = manager.targetEvent,
        relatedTarget = targetEvent.relatedTarget;

      if (relatedTarget) {
        return d3_select(relatedTarget).classed(CUSTOM_HANDLE_PATH_CLASSNAME);
      }
    }

    Registry.setComponent('_legendColorBandHandlers', _legendColorBandHandlers);

    //

    /**
     *
     * @param chart
     * @return {Legend Event options}
     */
    function _legendColorBandEventArguments(chart, id) {
      var legendInstance = chart.legends.get(id),
        component = legendInstance.component,meta = legendInstance.meta,element = legendInstance.element,highlightManager = legendInstance.highlightManager,

        config = meta.config,
        eventsConfig = config.events,
        brushOptions = component.brushOptions,

        eventDisabled = eventsConfig && pick(eventsConfig.enabled, true) == false,
        hoverOptions = getHoverOptions(config, 'clr'),
        enabled = legendInstance.enabled && !eventDisabled && hoverOptions.type && hoverOptions.type !== 'none',
        container = element.selectAll("g.zc-band-brush"),
        trackerElement = getTrackerElement$1(container, config),
        highlightElement = getHighlightElement(container),
        tooltip = getTooltip(chart, highlightElement, meta.config);

      return _objectSpread({ enabled: enabled, config: config, trackerElement: trackerElement, highlightElement: highlightElement, highlightManager: highlightManager, tooltip: tooltip, legendInstance: legendInstance }, brushOptions);
    }

    /**
     * Returns tracker element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getTrackerElement$1(container, config) {
      var selector = config.filter.enabled ? '.selection,.zcbrushhighlighttracker' : '.zcbrushhighlighttracker';

      return container.selectAll(selector).style('pointer-events', 'all');
    }

    /**
     * Returns highlight element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getHighlightElement(container) {
      return createElement('g', ".".concat(HIGHLIGHT_LEGEND_CLASSNAME), [1], container).
      style('pointer-events', 'none').
      style('display', null).
      style('opacity', 1);
    }

    function getTooltip(chart, element, config) {
      var hoverOptions = getHoverOptions(config, 'clr'),
        tooltipOptions = {
          config: hoverOptions.tooltip,
          orient: legend_helpers.getOrient(config),
          element: element,
          chart: chart
        };

      return HighlightTooltip(tooltipOptions);
    }

    Registry.setComponent('_legendColorBandEventArguments', _legendColorBandEventArguments);

    //$Id$

    var hexToRGB$1 = legend_helpers.hexToRGB;
    function getChartTypeSymbol(chartName) {
      return function (size) {
        switch (chartName) {
          case BAR_CHARTNAME:
          case GANTT_CHARTNAME:
          case BULLET_CHARTNAME:
          case WATERFALL_CHARTNAME:
            return (
              "M".concat(-size * 0.5, " ").concat(size * 0.5, " L").concat(-size * 0.5, " ").concat(-size * 0.2, " L").concat(-size * 0.25, " ").concat(-size * 0.2, " L").concat(-size * 0.25, " ").concat(size *
              0.5, "Z ") + " M".concat(
              -size * 0.125, " ").concat(size * 0.5, " L").concat(-size * 0.125, " ").concat(-size * 0.5, " L").concat(size * 0.125, " ").concat(-size * 0.5, " L").concat(size *
              0.125, " ").concat(size * 0.5, "Z ") + " M".concat(
              size * 0.25, " ").concat(size * 0.5, " L").concat(size * 0.25, " ").concat(size * 0.1, " L").concat(size * 0.5, " ").concat(size * 0.1, " L").concat(size * 0.5, " ").concat(size *
              0.5, "Z"));

          case AREA_CHARTNAME:
          case AREARANGE_CHARTNAME:
            return "M".concat(-size * 0.5, " ").concat(size * 0.5, " L").concat(-size * 0.5, " ").concat(size * 0.28, " L").concat(-size * 0.24, " ").concat(size * 0.08, " L").concat(-size *
            0.13, " ").concat(size * 0.19, " L").concat(size * 0.07, " ").concat(-size * 0.14, " L").concat(size * 0.23, " ").concat(size * 0.012, " L").concat(size * 0.5, " ").concat(-size *
            0.5, " L").concat(size * 0.5, " ").concat(size * 0.5, "Z");
          case 'areaLine':
            return "M".concat(-size * 0.5, " ").concat(size * 0.28, " L").concat(-size * 0.24, " ").concat(size * 0.08, " L").concat(-size * 0.13, " ").concat(size * 0.19, " L").concat(size *
            0.07, " ").concat(-size * 0.14, " L").concat(size * 0.23, " ").concat(size * 0.012, " L").concat(size * 0.5, " ").concat(-size * 0.5);
          case PIE_CHARTNAME:
          case BUBBLEPIE_CHARTNAME:
          case SUNBURST_CHARTNAME:
          case GEOBUBBLEPIE_CHARTNAME:
            return (
              "M".concat(size * 0.045, " ").concat(-size * 0.045, " L").concat(size * 0.5, " ").concat(-size * 0.045, " A ").concat(size * 0.455, " ").concat(size * 0.455, " 0 0 0 ").concat(size *
              0.045, " ").concat(-size * 0.5, "Z") + " M".concat(
              -size * 0.045, " ").concat(size * 0.045, " L").concat(-size * 0.045, " ").concat(-size * 0.41, " A ").concat(size * 0.455, " ").concat(size * 0.455, " 1 1 0 ").concat(size *
              0.41, " ").concat(size * 0.045, "Z"));

          case FUNNEL_CHARTNAME:
            return "M".concat(-size * 0.5, " ").concat(-size * 0.5, " L ").concat(size * 0.5, " ").concat(-size * 0.5, " L ").concat(size * 0.15, " ").concat(size * 0.2, " L ").concat(size *
            0.15, " ").concat(size * 0.5, " L ").concat(-size * 0.15, " ").concat(size * 0.5, " L ").concat(-size * 0.15, " ").concat(size * 0.2, "Z");
          case PYRAMID_CHARTNAME:
            return (
              "M0 ".concat(-size * 0.5, " L").concat(size * 0.23, " ").concat(-size * 0.06, " L").concat(-size * 0.23, " ").concat(-size * 0.06, "Z") + " M".concat(
              -size * 0.5, " ").concat(size * 0.5, " L").concat(size * 0.5, " ").concat(size * 0.5, " L").concat(size * 0.27, " 0") + " L".concat(
              -size * 0.27, " 0Z"));

          case WEB_CHARTNAME:
            return getSVGsymbol('line')(size);
          case TREEMAP_CHARTNAME:
            return getSVGsymbol('square')(size);
          case SCATTER_CHARTNAME:
          case GEOSCATTER_CHARTNAME:
          case BUBBLE_CHARTNAME:
          case GEOBUBBLE_CHARTNAME:
          case PACKEDBUBBLE_CHARTNAME:
          case LINE_CHARTNAME:
          default:
            return getSVGsymbol(chartName)(size);}

      };
    }

    legend.getHTML4ChartTypeSymbol = function (width, height, fillColor, chartObj, index, disabled) {
      var isQuantileColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
        seriesIndex =
        (chartObj.isAxisCategory || chartObj.dataObject.isPolarAxisCategory || chartObj.dataObject.isHierarchy || chartObj.isGeoMap) &&
        !isQuantileColorScale ?
        index :
        0,
        chartName = chartObj.chartTypes[seriesIndex].name,
        commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[chartName],
        plotOptions = isQuantileColorScale ? NULL$1 : chartObj.seriesdata[seriesIndex].plotoptions,
        symbolpath = getChartTypeSymbol(chartName)(width),
        gvp = utils.getValueOfPlotOptions(plotOptions, commonPlotOptions);

      switch (chartName) {
        case AREA_CHARTNAME:
        case AREARANGE_CHARTNAME:{
            var _strokeWidth2 = mathMin(pick(gvp('strokeWidth'), 2), height * 0.15),
              _gradientProperties = getGradientProperties(plotOptions, commonPlotOptions, width, height, fillColor, chartObj, chartName),
              _dashProperties = getDashProperties(plotOptions, commonPlotOptions, _strokeWidth2),
              _markerOptions =
              plotOptions && plotOptions.marker ?
              mergeJSON$1(commonPlotOptions.marker, plotOptions.marker, true) :
              commonPlotOptions.marker,
              //
              fill = disabled ? fillColor : _gradientProperties.fill || gvp('fillColor') || fillColor,
              _stroke2 = disabled ? fillColor : gvp('strokeColor') || fillColor,
              fillOpacity = pick(gvp('fillOpacity'), 1),
              strokeOpacity = gvp('strokeOpacity'),
              //
              _markerProperties = '',
              areaStyles = "fill:".concat(hexToRGB$1(fill), ";fill-opacity:").concat(fillOpacity, ";"),
              lineStyles = "stroke:".concat(hexToRGB$1(_stroke2), ";stroke-width:").concat(_strokeWidth2, ";stroke-opacity:").concat(strokeOpacity, ";fill:none;").concat(
              _dashProperties ? _dashProperties : '');


            if (_markerOptions.enabled != false) {
              var _outerRatio = 0.5,
                _innerRatio = 0.35;

              _markerProperties = getMarkerProperties(
              _markerOptions,
              width,
              height,
              fillColor,
              'outer',
              mathMin(width, height) * _outerRatio);

              _markerProperties += getMarkerProperties(
              _markerOptions,
              width,
              height,
              fillColor,
              'inner',
              mathMin(width, height) * _innerRatio);

            }
            var areaProperties = "<path d='".concat(symbolpath, "' transform='translate(").concat(width / 2, ",").concat(height / 2, ")' style='").concat(areaStyles, "'></path>"),
              lineProperties = "<path d='".concat(getChartTypeSymbol('areaLine')(width), "' transform='translate(").concat(width / 2, ",").concat(height /
              2, ")' style='").concat(lineStyles, "'></path>");
            return "".concat(_gradientProperties.defs) + areaProperties + lineProperties + _markerProperties;
          }
        case LINE_CHARTNAME:
        case WEB_CHARTNAME:
          var strokeWidth = mathMin(pick(gvp('strokeWidth'), 2), height * 0.15),
            markerOptions =
            plotOptions && plotOptions.marker ?
            mergeJSON$1(commonPlotOptions.marker, plotOptions.marker, true) :
            commonPlotOptions.marker,
            stroke = disabled ? fillColor : gvp('strokeColor') || fillColor,
            dashProperties = getDashProperties(plotOptions, commonPlotOptions, strokeWidth),
            markerProperties = '';
          var styles = "stroke:".concat(hexToRGB$1(stroke), ";") + "stroke-width:".concat(strokeWidth, ";");

          if (dashProperties) {
            styles += dashProperties;
          } else if (markerOptions.enabled != false) {
            var outerRatio = chartName === WEB_CHARTNAME ? 0.5 : 0.65,
              innerRatio = chartName === WEB_CHARTNAME ? 0.25 : 0.45;

            markerProperties = getMarkerProperties(
            markerOptions,
            width,
            height,
            fillColor,
            'outer',
            mathMin(width, height) * outerRatio);

            markerProperties += getMarkerProperties(
            markerOptions,
            width,
            height,
            fillColor,
            'inner',
            mathMin(width, height) * innerRatio);

          }

          return "<path d='".concat(symbolpath, "' transform='translate(").concat(width / 2, ",").concat(height / 2, ")' style='").concat(styles, "'></path>").concat(markerProperties);

        case SCATTER_CHARTNAME:
        case BUBBLE_CHARTNAME:
        case GEOBUBBLE_CHARTNAME:
        case GEOSCATTER_CHARTNAME:
          var markerOptions =
          plotOptions && plotOptions.marker ?
          mergeJSON$1(commonPlotOptions.marker, plotOptions.marker, true) :
          commonPlotOptions.marker;

          if (markerOptions.imageUrl) {
            return markerOptions.imageUrl;
          }

          var outerSize = mathMin(width, height) - validateNullVal(markerOptions.outerStrokeWidth, 1),
            innerSize = mathMin(width, height) * 0.5 - validateNullVal(markerOptions.innerStrokeWidth, 1),
            outerGradientProperties = getGradientProperties(
            plotOptions,
            commonPlotOptions,
            outerSize,
            outerSize,
            markerOptions.outerFillColor || fillColor,
            chartObj,
            chartName),

            innerGradientProperties = getGradientProperties(
            plotOptions,
            commonPlotOptions,
            innerSize,
            innerSize,
            markerOptions.innerFillColor || fillColor,
            chartObj,
            chartName);


          return (
            outerGradientProperties.defs +
            getMarkerProperties(markerOptions, width, height, fillColor, 'outer', outerSize, outerGradientProperties.fill) +
            innerGradientProperties.defs +
            getMarkerProperties(markerOptions, width, height, fillColor, 'inner', innerSize, innerGradientProperties.fill));

        case PACKEDBUBBLE_CHARTNAME:
          var size = mathMin(width, height) - validateNullVal(commonPlotOptions.strokeWidth, 1),
            gradientProperties = getGradientProperties(plotOptions, commonPlotOptions, size, size, fillColor, chartObj, chartName);
          return (
            gradientProperties.defs +
            getMarkerProperties(commonPlotOptions, width, height, fillColor, null, size, gradientProperties.fill));

        case HEATMAP_CHARTNAME:
          if (commonPlotOptions.symbol && getSVGsymbol(commonPlotOptions.symbol)) {
            var size = mathMin(width, height) - validateNullVal(commonPlotOptions.strokeWidth, 1),
              gradientProperties = getGradientProperties(plotOptions, commonPlotOptions, size, size, fillColor, chartObj, chartName);
            return (
              gradientProperties.defs +
              getMarkerProperties(commonPlotOptions, width, height, fillColor, null, size, gradientProperties.fill));

          } else {
            var strokeWidth = validateNullVal(commonPlotOptions.strokeWidth, 1),
              w = width - strokeWidth,
              h = height - strokeWidth,
              gradientProperties = getGradientProperties(plotOptions, commonPlotOptions, w, h, fillColor, chartObj, chartName);
            return (
              gradientProperties.defs +
              getRoundedRectProperties(commonPlotOptions, w, h, fillColor, chartObj, gradientProperties.fill));

          }
        default:{
            var _gradientProperties2 = getGradientProperties(plotOptions, commonPlotOptions, width, height, fillColor, chartObj, chartName),
              _fillOpacity = pick(plotOptions && plotOptions.fillOpacity, commonPlotOptions.fillOpacity, 1),
              _styles3 = "fill:".concat(_gradientProperties2.fill || fillColor, ";") + "fill-opacity:".concat(_fillOpacity, ";"); //Need to support stroke properties????
            return "".concat(_gradientProperties2.defs, "<path d='").concat(symbolpath, "' transform='translate(").concat(width / 2, ",").concat(height /
            2, ")' style='").concat(_styles3, "'></path>");
          }}

    };

    function getDashProperties(plotOptions, commonPlotOptions, strokeWidth) {
      var dashStyle = getValByPriority([plotOptions, commonPlotOptions], 'dashStyle'),
        dashArray = getDashArray(dashStyle, strokeWidth * 0.75),
        styles;

      if (dashArray && dashArray.length) {
        var strokeLineCap = getLineCap(getValByPriority([plotOptions, commonPlotOptions], 'lineCap'), dashStyle);
        styles = "stroke-dasharray:".concat(dashArray, ";") + "stroke-linecap:".concat(strokeLineCap, ";");
      }

      return styles;
    }

    function getMarkerProperties(markerOptions, width, height, color, markerType, size, gradientFill) {
      var symbolpath = getChartTypeSymbol(markerOptions.symbol)(size);

      var styles =
      "stroke:".concat(hexToRGB$1(markerOptions[markerType ? "".concat(markerType, "StrokeColor") : 'strokeColor'] || color), ";") + "stroke-width:".concat(
      validateNullVal(markerOptions[markerType ? "".concat(markerType, "StrokeWidth") : 'strokeWidth'], 1), ";") + "stroke-opacity:".concat(
      validateNullVal(markerOptions[markerType ? "".concat(markerType, "StrokeOpacity") : 'strokeOpacity'], 1), ";") + "fill:".concat(
      gradientFill || hexToRGB$1(markerOptions[markerType ? "".concat(markerType, "FillColor") : 'fillColor'] || color), ";") + "fill-opacity:".concat(
      validateNullVal(markerOptions[markerType ? "".concat(markerType, "FillOpacity") : 'fillOpacity'], 1), ";");

      return "<path d='".concat(symbolpath, "' transform='translate(").concat(width / 2, ",").concat(height / 2, ")' style='").concat(styles, "'></path>");
    }

    function getGradientProperties(plotOptions, commonPlotOptions, width, height, color, chartObj, chartName) {
      var gradientOptions =
        plotOptions && plotOptions.gradients ?
        mergeJSON$1(commonPlotOptions.gradients || {}, plotOptions.gradients, true) :
        commonPlotOptions.gradients || {},
        defs = '',
        fill,
        patternSvg = chartObj.getPatternSvg();

      if (gradientOptions.type === 'linear' || gradientOptions.type === 'radial') {
        var prop = getGradientProp(gradientOptions, [width, height], color, 1),
          args = {
            offset: chartName,
            chartObj: chartObj
          },
          gradientID = effects.get(effects.svg_gradients, 'svgGradientFill', prop, args),
          XMLS = new XMLSerializer(),
          // #ZC1530
          h = XMLS.serializeToString(patternSvg.select("#".concat(gradientID)).node()); // Converting DOM node into a string

        h = h.replace(/"/g, "'");
        defs = "<defs>".concat(h, "</defs>");
        fill = "url(".concat($Browser.IE ? '#' : '%23').concat(gradientID, ")"); //https://www.chromestatus.com/features/5656049583390720  (Using unescaped '#' characters in a data URI body is deprecated and will be removed in M71, around December 2018)
      }

      return {
        defs: defs,
        fill: fill
      };
    }

    function getRoundedRectProperties(commonPlotOptions, width, height, color, chartObj, gradientFill) {
      var borderRadius = commonPlotOptions.borderRadius;
      if (borderRadius) {
        borderRadius = mathMin(mathMin(width, height) / 4, borderRadius);
      }

      var path = roundedRect(
      -width / 2,
      -height / 2,
      width,
      height,
      chartObj.dataObject.getTransRectValue('radius', null, null, null, null, borderRadius));


      var styles =
      "stroke:".concat(hexToRGB$1(commonPlotOptions.strokeColor || color), ";") + "stroke-width:".concat(
      validateNullVal(commonPlotOptions.strokeWidth, 1), ";") + "stroke-opacity:".concat(
      validateNullVal(commonPlotOptions.strokeOpacity, 1), ";") + "fill:".concat(
      gradientFill || hexToRGB$1(commonPlotOptions.fillColor || color), ";") + "fill-opacity:".concat(
      validateNullVal(commonPlotOptions.fillOpacity, 1), ";");

      return "<path d='".concat(path, "' transform='translate(").concat(width / 2, ",").concat(height / 2, ")' style='").concat(styles, "'></path>");
    }

    var WIDTH_MEASURE = 'width',
      HEIGHT_MEASURE = 'height';var

    Layout = /*#__PURE__*/function () {
      function Layout(units, options) {_classCallCheck(this, Layout);
        var area = options.area,order = options.order,getPosition = options.getPosition,_options$callbackArgs = options.callbackArgs,callbackArgs = _options$callbackArgs === void 0 ? [] : _options$callbackArgs;
        callbackArgs = splat(callbackArgs);

        this.units = units.slice(0);
        this.area = area;
        this.getPosition = getPosition;
        this.order = order;
        this.callbackArgs = callbackArgs;
        this.areaToBeUpdated = [area];
      }_createClass(Layout, [{ key: "create", value:

        function create() {var _this26 = this;
          var self = this,
            units = this.units;

          this.elementBound = {};
          this.HEIGHT = function (id) {return _this26.elementBound[id].height;};
          this.WIDTH = function (id) {return _this26.elementBound[id].width;};

          if (!units.length) {
            return;
          }

          this.findBound(units);
          this.prepare();
          var items = this.items;
          units = this.units;

          items.forEach(function (_, i) {
            var unit = _.unit;
            if (unit.enabled && !getLegendAlignment(getConfig(unit)).floating && !self.canFit(_)) {
              self.redraw(_, i);
              self.findBound(units[i]);
            }
          });

          this.position(units);
        } }, { key: "findBound", value:

        function findBound(units) {
          var bb = this.elementBound;
          units = splat(units);

          units.forEach(function (_) {
            var element = _.element.node(),_getConfig =
              getConfig(_),marginLeft = _getConfig.marginLeft,marginTop = _getConfig.marginTop,marginRight = _getConfig.marginRight,marginBottom = _getConfig.marginBottom,
              b = isSvgElement(element) ? bbox(element) : element.getBoundingClientRect();

            bb[_.id] = {
              width: b.width + marginLeft + marginRight,
              height: b.height + marginTop + marginBottom
            };
          });
        } }, { key: "prepare", value:

        function prepare() {
          var _HEIGHT = this.HEIGHT,
            _WIDTH = this.WIDTH;

          var orderedUnits = this.units = this.getUnitOrder();
          this.items = orderedUnits.map(function (_) {
            return { id: _.id, unit: _ };
          });

          getFormula(orderedUnits, this.items, _WIDTH, _HEIGHT, this.area);
        } }, { key: "canFit", value:

        function canFit(_) {
          var callbackArgs = this.callbackArgs,
            _HEIGHT = this.HEIGHT,
            _WIDTH = this.WIDTH,
            id = _.id,
            w = _.width.apply(_, [id].concat(_toConsumableArray(callbackArgs))),
            h = _.height.apply(_, [id].concat(_toConsumableArray(callbackArgs))),
            newSize = [];

          if (_WIDTH(id) > w) {
            newSize[0] = w;
          }

          if (_HEIGHT(id) > h) {
            newSize[1] = h;
          }

          _.update = newSize;
          return !newSize.length;
        } }, { key: "redraw", value:

        function redraw(_, i) {
          var units = this.units,_getConfig2 =
            getConfig(units[i]),marginLeft = _getConfig2.marginLeft,marginTop = _getConfig2.marginTop,marginRight = _getConfig2.marginRight,marginBottom = _getConfig2.marginBottom,
            newSize = _.update,
            w,
            h;

          if (newSize[0]) {
            w = newSize[0] - marginLeft - marginRight;
          }

          if (newSize[1]) {
            h = newSize[1] - marginTop - marginBottom;
          }

          units[i].component.resize(w, h);
        } }, { key: "position", value:

        function position(units) {
          var self = this,
            items = self.items,elementBound = self.elementBound,getPosition = self.getPosition,chartArea = self.area,
            layoutArea = simpleClone(chartArea),
            bag = [],
            bagBound = [],
            prevSide,

            updateUnits = function updateUnits(side) {
              var newLayoutArea = simpleClone(layoutArea),
                measureName = side === LEFT_ALIGN || side === RIGHT_ALIGN ? HEIGHT_MEASURE : WIDTH_MEASURE,
                changeInAlign,
                changeInCenterAlign,
                //
                blocks = getBlocks(bag, bagBound, chartArea, measureName, items),
                set1 = [],
                set2 = [];

              blocks.forEach(function (_set) {
                changeInAlign = getChangeInAlign(side, bagBound.filter(function (b, i) {return _set.indexOf(i) > -1;}), newLayoutArea);
                var _newLayoutArea = simpleClone(newLayoutArea);

                _set.forEach(function (i) {
                  var unit = bag[i],
                    config = getConfig(unit),
                    element = unit.element,_getLegendAlignment2 =
                    getLegendAlignment(config),hAlign = _getLegendAlignment2.hAlign,vAlign = _getLegendAlignment2.vAlign,
                    newConfig = _objectSpread(_objectSpread({}, config), changeInAlign);

                  if (hAlign === CENTER_ALIGN || vAlign === CENTER_ALIGN) {
                    if (!changeInCenterAlign) {
                      changeInCenterAlign = getChangeInCenterAlign(side, bagBound.slice(i, bagBound.length), _newLayoutArea);
                    }

                    if (side === LEFT_ALIGN || side === RIGHT_ALIGN) {
                      vAlign = newConfig.vAlign = changeInCenterAlign.vAlign;
                    } else {
                      hAlign = newConfig.hAlign = changeInCenterAlign.hAlign;
                    }
                  }

                  var xy = getPosition(element, newConfig, _newLayoutArea),
                    //inner block
                    alignName = side === LEFT_ALIGN || side === RIGHT_ALIGN ? vAlign : hAlign,
                    mName = side === LEFT_ALIGN || side === RIGHT_ALIGN ? HEIGHT_MEASURE : WIDTH_MEASURE;
                  _updateArea(alignName, bagBound[i][mName], _newLayoutArea);

                  Layout.positionElement(element, xy[0], xy[1]);
                  set1.push(bagBound[i]);
                });

                var val = getMaxOccupied(side, set1);
                _updateArea(side, val, newLayoutArea);

                set2.push(val);
                set1 = [];
              });

              var val = d3_sum(set2);
              _updateArea(side, val, layoutArea);
              self.updateArea(side, val);

              bag = [];
              bagBound = [];
            };

          units.forEach(function (unit) {
            var enabled = unit.enabled,id = unit.id,element = unit.element,
              config = getConfig(unit);

            if (enabled) {
              var side = getSide(config);

              if (side) {
                if (prevSide && prevSide !== side) {
                  updateUnits(prevSide);
                }

                var bb = elementBound[id];
                bag.push(unit);
                bagBound.push(bb);

                prevSide = side;
              } else {
                var xy = getPosition(element, config, chartArea);
                Layout.positionElement(element, xy[0], xy[1]);
              }
            }
          });

          if (prevSide) {
            updateUnits(prevSide);
          }
        } }, { key: "updateArea", value:

        function updateArea(side, val) {
          _updateArea(side, val, this.areaToBeUpdated);
        } }, { key: "getUnitOrder", value:

        function getUnitOrder() {
          var units = this.units,
            elementBound = this.elementBound,
            customOrder = this.order,
            callbackArgs = this.callbackArgs,
            orderedIds;

          if (customOrder) {
            orderedIds = isArray$1(customOrder) ? customOrder : invokeFunction.apply(void 0, [customOrder, units, elementBound].concat(_toConsumableArray(callbackArgs)));
          } else {
            orderedIds = getDefaultOrder(units, elementBound);
          }

          return orderedIds.map(function (id) {return arrayFind(units, function (_) {return _.id === id;});});
        } }]);return Layout;}();


    Layout.positionElement = function (ele, x, y) {
      if (isSvgElement(ele)) {
        ele.attr('transform', "translate(".concat(x, ",").concat(y, ")"));
      } else {
        ele.styles({
          left: "".concat(x, "px"),
          top: "".concat(y, "px")
        });
      }
    };

    function _updateArea(side, val, areas) {
      var measureName = _measureName(side);
      areas = splat(areas);
      areas.forEach(function (_) {
        _[side] += val;
        _[measureName] -= val;
      });
    }

    function getFormula(units, items, _WIDTH, _HEIGHT, area) {
      var prevSide,
        bag = [],
        findFormula = function findFormula(side) {
          var filteredUnits = bag.map(function (id) {return arrayFind(units, function (_) {return _.id === id;});}),
            filteredItems = bag.map(function (id) {return arrayFind(items, function (_) {return _.id === id;});});

          applyFormula(filteredUnits, filteredItems, _WIDTH, _HEIGHT, side, area);
          bag = [];
        };

      units.forEach(function (unit) {
        var enabled = unit.enabled,id = unit.id,
          config = getConfig(unit);

        if (enabled) {
          var side = getSide(config);

          if (side) {
            if (prevSide && prevSide !== side) {
              findFormula(prevSide);
            }

            bag.push(id);
            prevSide = side;
          }
        }
      });

      if (prevSide) {
        findFormula(prevSide);
      }
    }

    function applyFormula(units, items, _WIDTH, _HEIGHT, side, area) {
      var splitFunc = function splitFunc(side) {
          return function (id) {
            var sizeFunc = side === HEIGHT_MEASURE ? _HEIGHT : _WIDTH,
              cur = sizeFunc(id),
              remainingUnits = units.map(function (_) {return _.id;}).filter(function (_) {return _ !== id;}),
              remainingSize = d3_sum(remainingUnits, function (_) {return sizeFunc(_);}),
              totalSize = area[side],
              equal = totalSize / (remainingUnits.length + 1);

            // TODO: have to consider config.maxWigth, maxHeight
            return cur <= equal ? cur : remainingSize < equal ? totalSize - remainingSize : equal;
          };
        },
        w = function w(id) {return _WIDTH(id);},
        h = function h(id) {return _HEIGHT(id);};

      if (side === LEFT_ALIGN || side === RIGHT_ALIGN) {
        h = splitFunc(HEIGHT_MEASURE);
      } else {
        w = splitFunc(WIDTH_MEASURE);
      }

      items.forEach(function (_, i) {
        var config = getConfig(units[i]),
          customWidth = getCustomSize(config, 'width', area),
          customHeight = getCustomSize(config, 'height', area);

        _.width = customWidth || w;
        _.height = customHeight || h;
        _.strict = !!(customWidth || customHeight);
      });
    }

    function getSide(config) {
      var _getLegendAlignment3 = getLegendAlignment(config),vAlign = _getLegendAlignment3.vAlign,hAlign = _getLegendAlignment3.hAlign,floating = _getLegendAlignment3.floating,layout = _getLegendAlignment3.layout;
      var isHorizontal = layout === HORIZONTAL_ALIGN;

      if (floating) {
        return;
      }

      if (isHorizontal) {
        // ---> direction
        if (vAlign === TOP_ALIGN || vAlign === BOTTOM_ALIGN) {
          return vAlign;
        } else if (vAlign === CENTER_ALIGN) {
          return hAlign;
        }
      } else {
        //  direction
        if (hAlign === LEFT_ALIGN || hAlign === RIGHT_ALIGN) {
          return hAlign;
        } else if (hAlign === CENTER_ALIGN) {
          return vAlign;
        }
      }
    }

    function getMaxOccupied(side, bagBound) {
      var measureName = _measureName(side);
      return d3_max(bagBound.map(function (_) {return _[measureName];}));
    }

    function _measureName(side) {
      return side === LEFT_ALIGN || side === RIGHT_ALIGN ? WIDTH_MEASURE : HEIGHT_MEASURE;
    }

    function getDefaultOrder(units, elementBound) {
      // put units in the respective sides
      // find the occupied measure of the each side
      // sort the sides based on the occupied measure

      var orderedIds = [],
        disabledUnits = [],
        floatingUnits = [],
        blockUnits = { left: [], right: [], top: [], bottom: [] },
        blockSizes = { left: 0, right: 0, top: 0, bottom: 0 };

      units.forEach(function (unit) {
        var enabled = unit.enabled,id = unit.id,
          config = getConfig(unit);

        if (enabled) {
          var side = getSide(config);

          if (side) {
            var bb = elementBound[id],
              measureName = side === LEFT_ALIGN || side === RIGHT_ALIGN ? HEIGHT_MEASURE : WIDTH_MEASURE,
              occupied = bb[measureName];

            blockUnits[side].push(id);
            blockSizes[side] += occupied;
          } else {
            floatingUnits.push(id);
          }
        } else {
          disabledUnits.push(id);
        }
      });

      var temp = objectEntries(blockSizes).sort(function (a, b) {return d3_descending(a[1], b[1]);});

      temp.forEach(function (_) {
        var side = _[0],
          orderedBlockUnits = blockUnits[side].sort(function (a, b) {
            var aOrder = getAlignOrder(units, side, a),
              bOrder = getAlignOrder(units, side, b);

            return d3_descending(aOrder, bOrder);
          });

        orderedIds.push.apply(orderedIds, _toConsumableArray(orderedBlockUnits));
      });

      orderedIds.push.apply(orderedIds, floatingUnits);
      orderedIds.push.apply(orderedIds, disabledUnits);

      return orderedIds;
    }

    var alignOrder = {
      top: 2,
      bottom: 1,
      left: 2,
      right: 1,
      center: 0
    };

    function getAlignOrder(units, side, id) {
      var unit = arrayFind(units, function (_) {return _.id === id;}),_getLegendAlignment4 =
        getLegendAlignment(getConfig(unit)),hAlign = _getLegendAlignment4.hAlign,vAlign = _getLegendAlignment4.vAlign,
        alignName = side === LEFT_ALIGN || side === RIGHT_ALIGN ? vAlign : hAlign;

      return alignOrder[alignName];
    }

    function getChangeInAlign(side, bagBound, area) {
      if (side === RIGHT_ALIGN || side === BOTTOM_ALIGN) {
        var mName = _measureName(side),
          total = getMaxOccupied(side, bagBound),
          oppositeSide = side === RIGHT_ALIGN ? LEFT_ALIGN : TOP_ALIGN;

        _updateArea(oppositeSide, area[mName] - total, area);
        return _defineProperty({}, side === RIGHT_ALIGN ? 'hAlign' : 'vAlign', oppositeSide);
      } else {
        return {};
      }
    }

    function getChangeInCenterAlign(side, bagBound, area) {
      var alignName, alignValue, mName;

      if (side === LEFT_ALIGN || side === RIGHT_ALIGN) {
        alignName = 'vAlign';
        alignValue = TOP_ALIGN;
        mName = HEIGHT_MEASURE;
      } else {
        alignName = 'hAlign';
        alignValue = LEFT_ALIGN;
        mName = WIDTH_MEASURE;
      }

      var total = d3_sum(bagBound, function (_) {return _[mName];});
      area[alignValue] += (area[mName] - total) / 2;
      area[mName] -= total;

      return _defineProperty({}, alignName, alignValue);
    }

    function getConfig(unit) {
      return unit.config || unit.meta.config;
    }

    function getBlocks(bag, bagBound, chartArea, measureName, items) {
      var blocks = [],
        blockIndex = 0,
        sum = 0;

      var strict = bag.some(function (b) {return arrayFind(items, function (_) {return _.id === b.id;}).strict;});

      if (!strict) {
        return [d3_range(bag.length)];
      }

      bag.forEach(function (unit, i) {
        sum += bagBound[i][measureName];
        if (sum - chartArea[measureName] > 1) {
          sum = 0;
          blockIndex++;
        }

        blocks[blockIndex] = blocks[blockIndex] || [];
        blocks[blockIndex].push(i);
      });

      return blocks;
    }

    function getCustomSize(config, measure, area) {
      var size = config[measure],
        _size;

      if (size) {
        _size = getPropVal(window, size);
        if (!isFunction(_size)) {
          _size = function _size() {return perToPx(size, area[measure]);};
        }
      }

      return _size;
    }

    //$Id$

    legend.render = function (chartObj) {
      var legendConfig = chartObj.systemConf.legend;
      // call event on legend init
      stateChangeListener(chartObj, legendConfig.events, null, 'init');

      var legendMeta = collect(chartObj);
      var legends = legendMeta.map(render).filter(function (_) {return !!_;});
      addLegendApi(legends, chartObj);

      var colorLegend = legends.get('clr-0');
      chartObj.legendarea = getLegendArea(chartObj, colorLegend); // Adapting old method // Remove

      // Save initial chartarea, plotarea to use on expandable click
      chartObj._chartarea = simpleClone(chartObj.chartarea);
      chartObj._plotarea = simpleClone(chartObj.plotarea);

      legend.align(legends, chartObj, chartObj.chartarea, chartObj.plotarea);
      addEventApi(colorLegend, chartObj); // Remove

      chartObj.legends = legends;

      // call legend on load event
      // #ZC1898
      stateChangeListener(chartObj, legendConfig.events, null, chartObj.updating ? 'onreload' : 'onload');
    };

    legend.align = function (legends, chartObj, area, plotarea) {
      var legendConfig = chartObj.systemConf.legend;

      if (chartObj.legend.isSingleLayout) {
        positionSingleLayout(chartObj); // Remove
      } else {
        var options = {
          area: area,
          order: legendConfig.order,
          getPosition: function getPosition(element, config, area) {return getLegendPosition(area, chartObj, null, element, config);},
          callbackArgs: chartObj
        };

        var layout = new Layout(legends, options);
        legends.layout = layout;
        layout.areaToBeUpdated.push(plotarea);
        layout.create();
      }
    };

    function getLegendArea(chartObj, comp) {
      if (!comp) {
        return {};
      }

      var element = comp.element,
        legendArea = {
          element: element,
          show: comp.enabled
        };

      if (comp.enabled) {
        var xy = getLegendPosition(chartObj.chartarea, chartObj, null, element);
        legendArea.x = xy[0];
        legendArea.y = xy[1];
        legendArea.width = xy[2];
        legendArea.height = xy[3];
      }

      return legendArea;
    }

    function addEventApi(colorLegend, chartObj) {
      if (colorLegend && !colorLegend.enabled && colorLegend.meta.view === 'list') {
        chartObj.legend.component = legend.discrete.get(colorLegend.meta);
        legend.events(chartObj, chartObj.legendarea.element.selectAll('li.series'), {
          allSelected: true,
          isFirstClickAfterDeselection: false //TODO: check
        });
      }
    }

    function positionSingleLayout(chartObj) {
      var _chartObj$legendarea = chartObj.legendarea,x = _chartObj$legendarea.x,y = _chartObj$legendarea.y,element = _chartObj$legendarea.element,show = _chartObj$legendarea.show;
      if (show) {
        Layout.positionElement(element, x, y);
        updateChartAndPlotBound(chartObj);
      }
    }

    var _legendRenderer = legend.render;
    Registry.setComponent('legend.render', _legendRenderer);

    //$Id$

    var getDefaultSelectAllOptions = function getDefaultSelectAllOptions() {return {
        show: false,
        strokeColor: '#262626',
        strokeWidth: 1,
        fillColor: TRANSPARENT,
        fontColor: '#262626',
        fillOpacity: 1,
        strokeOpacity: 1,
        disabledOpacity: 0.3,
        tooltip: {
          enabled: true,
          color: 'red',
          content: 'Select atleast one legend'
        },
        events: {
          click: null,
          tap: null
        }
      };};

    var getLegendData = legend_helpers.getLegendData,
      isDisabled$1 = legend_helpers.isDisabled,
      isAllEnabled = legend_helpers.isAllEnabled,
      getClr$1 = legend_helpers.getClr,
      toggleChartEvents = legend_helpers.toggleChartEvents,
      updateData = legend_helpers.updateData;

    legend.selectAllBox = function (container, chartObj, states, order) {
      // @INFO Memory Leak Fix
      var defaultSelectAllOptions = getDefaultSelectAllOptions();
      defaultSelectAllOptions.events.click = defaultSelectAllOptions.events.tap = chartObj.legend.component.toggleSelectAll = toggleSelectAll;

      var legData = getLegendData(chartObj, order),
        legendOptions = chartObj.systemConf.legend,
        colorBox = legendOptions.colorBox,
        selectAllBoxOptions = mergeJSON$1(defaultSelectAllOptions, legendOptions.selectAllBox, true),
        disabledOptions = getDisabledOptions(legendOptions, 'clr'),
        disabledColorBox = disabledOptions.colorBox || {},
        priorityArray = [legendOptions, chartObj.systemConf.canvas, $ZCG],
        fontSize = +utils.getVal(legendOptions.fontSize || chartObj.systemConf.canvas.fontSize),
        fontColor = getValByPriority(priorityArray, 'fontColor'),
        imagePallete = legendOptions.imagePallete ? legutil.imagePallete.get(legendOptions.imagePallete) : null,
        selectAllColorBoxMerged = mergeJSON$1(colorBox, selectAllBoxOptions, true),
        colorBoxSize = legend_helpers.getFilterBoxSize(selectAllColorBoxMerged, fontSize),
        colorBoxWidth = colorBoxSize[0],
        colorBoxHeight = colorBoxSize[1],
        selectAllFilterSize =
        Math.min(colorBoxWidth, colorBoxHeight) - (
        legendOptions.imagePallete || !defined(legendOptions.shapes) || colorBox.shape === 'square' ? 0 : +colorBox.strokeWidth),
        svgNode = chartObj.container.node(),
        selectAllBoxTooltipOptions = selectAllBoxOptions.tooltip,
        disabledOpacity = selectAllBoxOptions.disabledOpacity,
        defaultTooltipColor;

      states.allSelected = defined(selectAllBoxOptions.selected) ? selectAllBoxOptions.selected : states.allSelected;

      var selectAllFilter = appendEle(container, 'div', [1], '.', 'class', 'selectAll');

      var shapeType = pick(selectAllBoxOptions.shape, colorBox.shape);
      var useSVGImage = shapeType !== 'square',
        styles = {
          display: selectAllBoxOptions.show ? 'inline-block' : NONE,
          width: "".concat(selectAllFilterSize, "px"),
          height: "".concat(selectAllFilterSize, "px"),
          "float": 'left',
          background: selectAllBoxOptions.fillColor,
          position: 'absolute',
          'box-sizing': 'border-box',
          'text-align': 'center',
          'line-height': "".concat(selectAllFilterSize, "px"),
          'font-family': colorBox.fontFamily,
          'font-size': "".concat(colorBox.fontSize || fontSize - 2, "px"),
          color: function color(d) {
            return (
              selectAllBoxOptions.fontColor || (
              isDisabled$1(d, states.allSelected, states.isFirstClickAfterDeselection) ?
              disabledColorBox.fontColor :
              colorBox.fontColor));

          }
        };

      if (useSVGImage) {
        var path = getHTML4SVGSymbol(
        selectAllFilterSize,
        selectAllFilterSize,
        selectAllBoxOptions.strokeColor,
        selectAllBoxOptions.fillColor,
        shapeType,
        selectAllBoxOptions);

        styles.background = getSVGSymbolString(path, selectAllFilterSize, selectAllFilterSize);
        styles.border = 'none'; // #ZC1526
      } else {
        styles.border = "".concat(selectAllBoxOptions.strokeWidth, "px solid ").concat(selectAllBoxOptions.strokeColor);
      }

      selectAllFilter.styles(styles).html(function () {
        return isAllEnabled(legData, states.allSelected) ?
        pick(selectAllBoxOptions.text, colorBox.text) || '&#10003;' :
        disabledColorBox.text || '';
      });

      container.style('cursor', selectAllBoxOptions.show ? POINTER : null);

      var mouseHandlers = {
          click: selectBoxClickFunction
        },
        touchHandlers = {
          tap: selectBoxClickFunction
        };
      if (selectAllBoxOptions.show) {
        attachevents(container, mouseHandlers, touchHandlers);
      } else {
        detachevent(container, null, mouseHandlers);
        detachevent(container, null, touchHandlers);
      }

      if (chartObj.eventHandler) {
        var tooltip = chartObj.eventHandler.tooltipElement;
        tooltip.hide(tooltip.element);
      }

      return {
        element: selectAllFilter,
        options: selectAllBoxOptions,
        size: selectAllFilterSize
      };

      function selectBoxClickFunction() {
        if (!(states.allSelected && !isAllEnabled(legData, states.allSelected))) {
          states.allSelected = !states.allSelected;
        }
        states.isFirstClickAfterDeselection = false;
        selectAllFilter.html(
        states.allSelected ? pick(selectAllBoxOptions.text, colorBox.text) || '&#10003;' : disabledColorBox.text || '');

        var userFunction = selectAllBoxOptions.events[chartObj.zcEventType || 'click'];
        invokeFunction(userFunction, d3_event(), states.allSelected, chartObj);
      }

      function toggleSelectAll() {
        filterAllAxesNUpdate();
        applyStyleToFilterAndLabel();
        toggleChartEvents(chartObj, states.allSelected);
        legend_helpers.fadeChart(states.allSelected, chartObj, disabledOpacity);

        if (selectAllBoxTooltipOptions.enabled) {
          var tooltip = chartObj.eventHandler.tooltipElement;
          if (!defaultTooltipColor) {
            defaultTooltipColor = tooltip.element.selectAll('div#tooltipcontent').style('color');
          }
          var tooltip_data = chartObj.systemConf.tooltip;
          var tooltipBorderWidth = shorthand_px(defined(tooltip_data.borderWidth) ? tooltip_data.borderWidth : 1);
          if (!states.allSelected) {
            var coordinate = getMousePosition(svgNode, d3_event());
            coordinate = {
              x: coordinate[0],
              y: coordinate[1]
            };
            var evt = getEventObject(d3_event());
            var position = getTooltipPosition(evt, coordinate, 0, 0, chartObj, {}, false, false, false, true, false);
            var dLeft = coordinate.x - evt.clientX,
              dTop = coordinate.y - evt.clientY;
            position.dLeft = dLeft;
            position.dTop = dTop;
            position.helpers.color = selectAllBoxTooltipOptions.color;
            position.helpers.backgroundColor = selectAllBoxTooltipOptions.backgroundColor;
            position.helpers.borderColor = selectAllBoxTooltipOptions.borderColor;
            position.helpers.renderTo = 'legendTitle';
            applyTooltipStyle(tooltip, 'center', null, selectAllBoxTooltipOptions.fontColor || defaultTooltipColor);
            tooltip.show(chartObj, position, selectAllBoxTooltipOptions.content, false, position.helpers);
            setTimeout(function () {
              var tooltip = chartObj.eventHandler.tooltipElement;
              applyTooltipStyle(tooltip, null, tooltipBorderWidth, defaultTooltipColor);
              tooltip.hide(tooltip.element);
            }, 4000);
          } else {
            var tooltip = chartObj.eventHandler.tooltipElement;
            applyTooltipStyle(tooltip, null, tooltipBorderWidth, defaultTooltipColor);
            tooltip.hide(tooltip.element);
          }
        }
      }

      function filterAllAxesNUpdate() {
        if (!legData) {
          //If legend is disabled, legData will not be available
          legData = getLegendData(chartObj, order);
        }
        if (states.allSelected) {
          if (hasAssociatedLegendData(chartObj)) {
            var gridList = getGridList(chartObj.dataObject);

            gridList.forEach(function (grid, _gridIndex) {
              var layer = grid.layer;

              if (layer === order) {
                grid.data.forEach(function (_d, _i) {
                  _d.node.filtered = !states.allSelected;
                });
              }
            });

            legData.forEach(function (d, j) {return d.filtered = !states.allSelected;});
          } else {
            legData.forEach(function (d, j) {
              d.disabled = !states.allSelected;
              updateData(d, j, chartObj);
            });
          }

          chartObj.addRemoveSeries(legData, 0, [0, 0], true);
        }
      }

      function applyStyleToFilterAndLabel() {
        var legendContainer = getLegendContainer(chartObj, "clr-".concat(order));

        // #ZC1943
        var legendFilter = legendContainer.selectAll('div.legendfilterbox'),
          legendlabel = legendContainer.selectAll('span.legendlabel, span.legendlabel * ');

        legend.setColorBoxBackground(legendFilter, chartObj, states, order);
        var fontClr, txtDec;
        if (states.allSelected) {
          fontClr = fontColor, txtDec = null;
        } else {
          fontClr = getClr$1(true, fontColor, disabledOptions), txtDec = JSON.parse(disabledOptions.strikeout) ? 'line-through' : null;
        }
        legendlabel.styles({
          color: fontClr,
          'text-decoration': txtDec
        });

        // #ZC1914
        // for custom legend, while enabling legend all items, get the source from the user.
        // because user might set some different colors and can have different hierarchy
        if (states.allSelected && legendOptions.showAs) {
          legendContainer.selectAll('span.legendlabel').html(function (d, i) {return getLegendShowAsText(d, i, legendOptions, chartObj);});
        }
      }

      function applyTooltipStyle(tooltip, align, borderWidth, contentColor) {
        tooltip.element.attr('align', align).styles({
          'border-width': borderWidth
        });
        tooltip.element.selectAll('div#tooltipcontent').style('color', contentColor);
      }
    };

    //
    var LEGEND_EVENT_MAPPINGS = {
      SIZE_SLIDER: {
        _handlers: '_legendSizeSliderHandlers',
        _arguments: '_legendSizeSliderEventArguments'
      },
      SIZE_NESTED: {
        _handlers: '_legendSizeNestedHandlers',
        _arguments: '_legendSizeNestedEventArguments'
      },
      SIZE_LIST: {
        _handlers: '_legendSizeListHandlers',
        _arguments: '_legendSizeListEventArguments'
      },
      COLOR_BAND: {
        _handlers: '_legendColorBandHandlers',
        _arguments: '_legendColorBandEventArguments'
      },
      EXPANDABLE: {
        _handlers: '_legendExpandableHandlers',
        _arguments: '_legendExpandableEventArguments'
      }
    };var

    LegendEventManager = /*#__PURE__*/function (_EventManager) {_inherits(LegendEventManager, _EventManager);var _super6 = _createSuper(LegendEventManager);function LegendEventManager() {_classCallCheck(this, LegendEventManager);return _super6.apply(this, arguments);}_createClass(LegendEventManager, [{ key: "updateSelectionManager", value:
        function updateSelectionManager(data) {
          this.selectionManager.point = data;
        } }, { key: "detachListeners", value:

        function detachListeners(namespace) {var mouseHandlers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var touchHandlers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var manager = this,
            tracker = manager.tracker;

          if (!tracker || tracker.empty()) {
            return;
          }

          detachevent(tracker, namespace, mouseHandlers);
          detachevent(tracker, namespace, touchHandlers);
        } }]);return LegendEventManager;}(EventManager);


    var LEGEND_EVENT_NAMESPACE = 'legend';var

    LegendEvents = /*#__PURE__*/function () {
      function LegendEvents(chart) {_classCallCheck(this, LegendEvents);
        this.chart = chart;
        this.eventManager = {};
        this.reverseEventManager = {};
        this.init();
      }_createClass(LegendEvents, [{ key: "init", value:

        function init() {
          var behaviourEvent = this,
            chart = behaviourEvent.chart,
            legends = chart.legends;

          legends.forEach(function (legend) {
            each(LEGEND_EVENT_MAPPINGS, function (behaviourMap, name) {
              behaviourEvent.initiateBehaviour(name, legend);
            });
          });
        } }, { key: "update", value:

        function update() {
          this.init();
        } }, { key: "initiateBehaviour", value:

        function initiateBehaviour(name, legend) {
          var chart = this.chart,
            eventManager = this.eventManager,reverseEventManager = this.reverseEventManager,
            behaviourMap = LEGEND_EVENT_MAPPINGS[name],
            handlers = Registry.getComponent(getVal(behaviourMap._handlers, [chart])),
            id = legend.id,
            isSupported = !handlers._empty && handlers.SUPPORTED(chart, id);

          if (isSupported) {
            var args = Registry.getComponent(getVal(behaviourMap._arguments, [chart]))(chart, id),
              BEHAVIOUR = handlers.BEHAVIOUR,DATA_FINDER = handlers.DATA_FINDER,LISTENER = handlers.LISTENER,REVERSE_BEHAVIOUR = handlers.REVERSE_BEHAVIOUR,REVERSE_DATA_FINDER = handlers.REVERSE_DATA_FINDER,
              managerID = "".concat(name, "(").concat(id, ")");

            var manager = initManager(managerID, eventManager, chart, args);
            setManager(manager, BEHAVIOUR, DATA_FINDER);
            manager.customBehaviour = getCustomBehaviour(manager);

            if (args.enabled) {
              var _splitListeners2 = splitListeners(manager, LISTENER),mouseHandlers = _splitListeners2.mouseHandlers,touchHandlers = _splitListeners2.touchHandlers,
                tracker = args.trackerElement;

              manager.bindTo(tracker);
              manager.attachListeners(tracker, mouseHandlers, touchHandlers, null, LEGEND_EVENT_NAMESPACE);
            } else {
              manager.detachListeners(LEGEND_EVENT_NAMESPACE);

              // TODO: check CX_OTHERS_CRMCORE_5
              var hoverOptions = legend.meta.encode === 'clr' && getHoverOptions(legend.meta.config, 'clr');
              if (!(legend.meta.encode === 'clr' && hoverOptions.type && hoverOptions.type !== 'none')) {
                return;
              }
            }

            var reverseManager = initManager(managerID, reverseEventManager, chart, args);
            setManager(reverseManager, REVERSE_BEHAVIOUR, REVERSE_DATA_FINDER);
          }
        } }]);return LegendEvents;}();


    function initManager(managerID, managerHead, chart, args) {
      managerHead[managerID] = managerHead[managerID] || new LegendEventManager(chart);
      var manager = managerHead[managerID];
      manager.init();
      manager.options = args;

      return manager;
    }
    function setManager(manager, behaviour, dataFinder) {
      if (!behaviour) {
        return;
      }

      manager.dataFinder(dataFinder);
      manager.defaultBehaviour = behaviour;
      manager.customBehaviour = noOperation;
    }

    function splitListeners(manager, listeners) {
      var mouseHandlers = {},
        touchHandlers = {};

      each(listeners, function (listener, type) {
        var _handler = function _handler() {
          manager.targetEvent = d3_event();
          listener.apply(manager, [].concat(Array.prototype.slice.call(arguments), [type]));
        };

        if (arrayIncludes(TOUCH_EVENTS, type)) {
          touchHandlers[type] = _handler;
        } else {
          mouseHandlers[type] = _handler;
        }
      });

      return { mouseHandlers: mouseHandlers, touchHandlers: touchHandlers };
    }

    function getCustomBehaviour(manager) {
      var options = manager.options,chart = manager.chart,_options$config$event =
        options.config.events,eventsConfig = _options$config$event === void 0 ? {} : _options$config$event;

      return function (selectionManager, eventType) {
        var _callbackName = eventType === 'dblclick' ? 'doubleclick' : eventType,
          customBehaviour = eventsConfig[_callbackName];

        if (customBehaviour) {
          return [
          {
            action: triggerUserCallback(customBehaviour, selectionManager.point, getEventObject(manager.targetEvent), null, chart),
            type: 'custom'
          }];

        }
      };
    }

    Registry.setComponent('LegendEvents', LegendEvents);

    //$Id$

    var legendHighlight = function legendHighlight(chartObj, container) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { encode: 'clr' };
      var legendHighlight = {},
        origProp = {},
        defsLocation = chartObj.defsLocation,
        userdata = chartObj.userdata,
        hasColorScale = !chartObj.nochartdata && colorscale_helpers.isQuantileColorScale(chartObj),

        encode = options.encode,_options$order = options.order,order = _options$order === void 0 ? 0 : _options$order,


        dataProcessorHelpers = DataProcessor.helpers,
        getChartType = dataProcessorHelpers.getChartType,
        filterSelectionByColor = legend_helpers.filterSelectionByColor,
        isItemDisabled = legend_helpers.isItemDisabled,
        filterSelection = function filterSelection(selection, selectedSeries, filterIndex, seriesIndex) {
          var chartType = getChartTypeByIndex(chartObj, '0_0', seriesIndex).value,
            hasSizeLegend = chartcategory.zaxis.indexOf(chartType) > -1 && !isHeatMapChartType(chartType);

          if (encode === 'z' && !hasSizeLegend) {
            return selectedSeries ? d3_selectAll() : selection;
          }

          return filterSelectionByColor(selection, selectedSeries, filterIndex, chartObj, encode);
        },
        config = options.config || chartObj.systemConf.legend;

      /*
       * Highlight effects for Bar,pie,funnel,web,area,line,scatter
       * patterns--> diagonalfill,strokeEnlarge,fadeout
       * diagonal fill not supported for line,scatter
       * fadeout: fillopacity except line and scatter, strokeopacity for line and scatter
       */
      legendHighlight.highlightSelectedSeries = function (legdata, index, filterIndex) {
        legendHighlight.baseClr = getCurrectColor(index, filterIndex);

        if (chartObj.isGeoMap && isGeoHeatMapChartType(getChartTypeByIndex(chartObj, '0_0', index).value)) {
          highlightGeoMap(chartObj, legdata, index, filterIndex);
        } else {
          switch (chartObj.plot.renderer.mode) {
            case 'svg':{
                highlightSVGSeries(legdata, index, filterIndex);
                break;
              }
            case 'canvas':{
                highlightCanvasSeries(chartObj, legdata, index, filterIndex);
                break;
              }
            default:{
                highlightNonSVGSeries(legdata, index);
              }}

        }
      };

      legendHighlight.highlightUnselectedSeries = function (legdata, index, filterIndex) {
        if (chartObj.isGeoMap || chartObj.plot.renderer.mode === 'svg') {
          unHighlightSVGSeries(legdata, index, filterIndex);
        } else {
          unHighlightCanvasSeries(legdata, index, filterIndex);
        }
      };

      legendHighlight.reset = function (legdata, index, filterIndex, resetOriginalProp) {
        if (chartObj.isGeoMap && isGeoHeatMapChartType(getChartTypeByIndex(chartObj, '0_0', index).value)) {
          resetGeoMapSeries();
        } else {
          index = splat(index);
          switch (chartObj.plot.renderer.mode) {
            case 'svg':{
                resetSelectedSeries(legdata, index, filterIndex);
                resetUnselectedSeries(legdata, index, filterIndex);
                break;
              }
            case 'canvas':{
                resetSelectedCanvasSeries();
                resetUnselectedCanvasSeries();

                break;
              }}

        }

        if (resetOriginalProp !== false) {
          //Test_662.json
          origProp = {}; //Deleting the stored style values, will help you to know whether the element is already highlighted are not.
          this.resetSelection();
        }
      };

      legendHighlight.getLegendHighlightEffect = function (index, seriesType, plotOrLegend, paneID) {
        var chartTypeObj = getChartTypeByIndex(chartObj, paneID, index),
          chartName = chartTypeObj.name,
          cType = chartTypeObj.value,
          isAxisCategory = isCategoryOf(chartObj, cType, 'axis'),
          isNonAxisMultiSeriesCategory = isCategoryOf(chartObj, cType, 'nonAxisMultiSeries');

        var plotOptions =
          isAxisCategory || isNonAxisMultiSeriesCategory || chartObj.isGeoMap ?
          (chartObj.seriesdata[index] || chartObj.seriesdata[0]).plotoptions :
          chartObj.seriesdata[0].plotoptions,
          commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[chartName],
          legendEffect = config.highlightEffect[seriesType],
          ef =
          plotOptions && plotOptions.legendHighlightEffect ?
          utils.getValueOfPlotOptions(plotOptions.legendHighlightEffect, commonPlotOptions.legendHighlightEffect)(seriesType) :
          commonPlotOptions.legendHighlightEffect && commonPlotOptions.legendHighlightEffect[seriesType];

        if (plotOrLegend === 'plot') {
          if (seriesType === 'unselectedSeries' && !config.highlightEffect.applyUnselectedSeriesToPlot) {
            return NONE;
          } else {
            return ef || legendEffect || defaultEffect(chartName);
          }
        } else {
          var defaultEf =
          seriesType === 'selectedSeries' && hasColorScale && (isAreaChartType(cType) || cType === charttype.line) ?
          'strokeEnlarge(6)' :
          defaultEffect(chartName);

          return ef || legendEffect || defaultEf;
        }
      };

      legendHighlight.getEffect = function (effect, chartName, baseClr, additionalStyles, index, from, point, originalChartName) {
        if (chartName === 'waterfall') {
          baseClr = function baseClr(d, i) {return getRawColor(chartObj, i, d, index);};
        } else {
          var customColor = getUserFillColor(index, originalChartName || chartName); // originalChartName: map-evens sends chartName as 'area' always
          baseClr = customColor || baseClr || legendHighlight.baseClr;
        }

        var isColorFunction = isFunction(baseClr);
        var userEffect = invokeFunction(effect, chartObj, baseClr, patternThemes, from || 'legend');
        if (userEffect && userEffect.constructor == Object) {
          return userEffect;
        }
        effect = effect === null || invalidEffect(effect, chartName) ? defaultEffect(chartName) : effect;
        var eStyle = {};

        if (chartObj.patternPallete && /(flip|moody|illuminate)/.test(effect)) {
          var svgPattern = chartObj.patternPallete[(index || 0) % chartObj.patternPallete.length];
          var prop = patternThemes[svgPattern] ? getPattern(svgPattern) : addPatternThemeByEle(svgPattern);

          var effectCallBack = function effectCallBack(data, index) {
            var baseColor = getVal(baseClr, [data, index]);
            if (prop.ele) {
              // If custom pallete is given, moody effect will be applied
              prop.bgClr_base = getColorCopy(baseColor, 1, 'darker', d3_hsl);
            } else {
              var colorCopy =
              effect === 'flip' ? baseColor : getColorCopy(baseColor, 1, effect === 'moody' ? 'darker' : 'brighter', d3_hsl);
              prop.bgClr_base = colorCopy;
              prop.stroke_base = colorCopy;
              prop.customStaticClr = chartObj.userdata.legend.customPatternColor;

              if (effect === 'flip') {
                prop = simpleClone(prop); // To avoid inplace change in the pattern object

                //swapping bgClr_base and stroke_base
                var temp = prop.bgClr_base;
                prop.bgClr_base = prop.stroke_base;
                prop.stroke_base = temp;

                //swapping bgClr and stroke
                var copy_bgClr = stringifiedArrayReverse(prop.bgClr),
                  copy_stroke = stringifiedArrayReverse(prop.stroke);

                prop.bgClr = copy_stroke;
                prop.stroke = copy_bgClr;
              }
            }

            var patternId = effects.get(effects.svg_patterns, 'svgPatternFill', prop, { chartObj: chartObj });
            return "url(".concat(defsLocation, "#").concat(patternId, ")");
          };
          eStyle.fill = isColorFunction ? effectCallBack : effectCallBack();
        } else if (/(saturate|grayscale|blur|glow|shadow|boxShadow)/.test(effect)) {
          var filterType = /(saturate|grayscale)/.test(effect) ? 'colorMatrix' : 'dropShadow',
            options;
          switch (effect) {
            case 'saturate':
              options = {
                type: 'saturate',
                values: '0.3'
              };
              break;
            case 'grayscale':
              options = {
                type: 'matrix',
                values: '.33 .33 .33 0 0 .33 .33 .33 0 0 .33 .33 .33 0 0 0 0 0 1 0'
              };
              break;
            case 'blur':
              options = {
                blur: 2,
                source: 'SourceGraphic'
              };
              eStyle.opacity = 0.7;
              break;
            case 'glow':
              options = {
                blur: 3,
                color: 'gold'
              };
              break;
            case 'shadow':
              options = {
                dx: 5,
                dy: 5,
                blur: 3
              };
              break;
            case 'boxShadow':
              eStyle.fill = baseClr;
              eStyle.stroke = 'white';
              options = {
                dx: 0,
                dy: 0,
                blur: 5,
                color: 'rgba(0,0,0,0.3)'
              };
              break;}

          var filterId = effects.get(effects.svg_filters, filterType, options, { chartObj: chartObj });
          eStyle.filter = "url(".concat(defsLocation, "#").concat(filterId, ")");
        } else if (/(moody|illuminate)/.test(effect)) {
          var ismoody = effect === 'moody';
          var effectCallback = function effectCallback(data, index) {
            var baseColor = getVal(baseClr, [data, index]);

            if (stringIncludes(baseColor, 'url')) {
              return ismoody ? 'grey' : 'silver';
            } else {
              if (isArray$1(baseColor)) {
                return baseColor.map(function (color) {return getColorCopy(color, 0.6, ismoody ? 'darker' : 'brighter', d3_hsl);});
              } else {
                return getColorCopy(baseColor, 0.6, ismoody ? 'darker' : 'brighter', d3_hsl);
              }
            }

            // return baseColor.indexOf('url') != -1
            //     ? ismoody
            //         ? 'grey'
            //         : 'silver'
            //     : getColorCopy(baseColor, 0.6, ismoody ? 'darker' : 'brighter', d3_hsl);
          };
          eStyle.fill = isColorFunction ? effectCallback : effectCallback();
        } else if (effect.indexOf('strokeEnlarge') > -1) {
          var customStrokeWidth = effect.split(/(\d+)/g)[1];
          eStyle['stroke-width'] = defined(customStrokeWidth) ? +customStrokeWidth : 3;

          if (hasColorScale) {
            eStyle.visibility = NULL$1;
          }

          if (additionalStyles) {
            for (var a in additionalStyles) {
              eStyle[a] = additionalStyles[a];
            }
          }
        } else if (effect === 'fadeOut') {
          eStyle.opacity = 0.3;
        } else if (effect === 'blackyBorder') {
          eStyle.stroke = 'rgba(0,0,0,0.5)';
          eStyle['stroke-width'] = 1;
        } else if (effect === 'invert') {
          eStyle.fill = 'white';
          eStyle.stroke = baseClr;
          eStyle['stroke-width'] = 1;
          eStyle['paint-order'] = null;
        } else if (effect === 'ridge') {
          eStyle.fill = baseClr;
          eStyle.stroke = 'white';
          eStyle['stroke-width'] = 7;
        } else if (effect !== NONE) {
          var prop = getPattern(effect);

          if (prop) {
            var effectCallback = function effectCallback(data, index) {
              var baseColor = getVal(baseClr, [data, index]);
              var prop = getPattern(effect);
              prop.bgClr_base = baseColor;
              prop.stroke = 'transparent,white,white'; //need to check
              var patternId = effects.get(effects.svg_patterns, 'svgPatternFill', prop, { chartObj: chartObj });
              return "url(".concat(defsLocation, "#").concat(patternId, ")");
            };
            eStyle.fill = isColorFunction ? effectCallback : effectCallback();
          } else {
            eStyle.fill = baseClr;
          }
        }

        // check if the gradient is enabled
        var optionsKey = chartName;
        // #ZC2586 $NONE
        if ((chartName === 'sankey' || chartName === 36) && effect !== NONE) {
          optionsKey = "".concat(optionsKey, ".link");
          // check the hover options

          // #ZC2584 chartName is passed as number. we should pass as chart name

          // can be done for all charges
          var hoverOptions = getPropVal(chartObj.systemConf, "chart.plot.plotoptions.sankey.hoveroptions");
          eStyle['fill-opacity'] = hoverOptions.fillOpacity;
        }

        var gradientOptions = getPropVal(chartObj.systemConf, "chart.plot.plotoptions.".concat(optionsKey, ".gradients")) || {};

        if (defined(gradientOptions.type) && isArray$1(baseClr) && chartName === SANKEY_CHARTNAME) {
          gradientOptions.options[gradientOptions.type].stopColor = baseClr;
          if (!gradientOptions.customGradient && point) {
            sankeyGradientDimension(point, gradientOptions);
          }

          var gradientDimension = [chartObj.plotarea.width, chartObj.plotarea.height];
          eStyle.fill = getGradients(gradientOptions, gradientDimension, baseClr, 'svg', 1, chartName, false, chartObj);
        }

        return eStyle;
      };

      legendHighlight.raiseSelection = function (elements, paneID) {
        if (doArrangeSelection(paneID)) {
          elements.raise();
        }
      };

      legendHighlight.resetSelection = function () {
        var seriesHolderWrap = container.selectAll('g.seriesholder');

        if (isFacet(chartObj)) {
          var gridList = getGridList(chartObj.dataObject);

          gridList.forEach(function (grid) {
            var row = grid.row,column = grid.column,
              paneID = "".concat(row, "_").concat(column),
              gridWrap = seriesHolderWrap.selectAll("g.grid".concat(paneID));

            if (doArrangeSelection(paneID)) {
              _resetSelection(gridWrap);
            }
          });
        } else {
          if (doArrangeSelection()) {
            _resetSelection(seriesHolderWrap);
          }
        }
      };

      function _resetSelection(g) {
        var elements;

        if (chartObj.dataObject.noofAreaEnabledSeries || chartObj.dataObject.noofAreaRangeEnabledSeries) {
          var getAllChildNodes = function getAllChildNodes() {
              return this.childNodes;
            },
            getAllGroupNodes = function getAllGroupNodes() {
              return this.tagName == 'g';
            };
          elements = g.selectAll(getAllChildNodes).filter(getAllGroupNodes);
        } else if (chartObj.dataObject.isFlowChartCategory) {
          elements = g.selectAll('g.sankey-links').selectAll('path.sankey-link');
        } else {
          elements = g.selectAll('g.hierarchychart').selectAll('*');
        }

        elements.sort(function (a, b) {return a.index - b.index;});
      }

      function resetSelectedSeries(legdata, index, filterIndex) {
        legendHighlight.selSeriesObj = [];
        index.forEach(function (ii) {
          var selected = getSelectedSeries(ii, filterIndex),
            selecteffect = legendHighlight.getLegendHighlightEffect(ii, 'selectedSeries'),
            selectedSeries = selected.selectedSeries,
            charttypes = selected.charttypes,
            paneIDs = selected.paneIDs,
            length = selectedSeries.length;var _loop6 = function _loop6()

          {
            var prop,
              cType = charttypenames.get(charttypes[i]);

            if (chartObj.dataObject.isFlowChartCategory) {
              // eslint-disable-next-line no-loop-func
              selectedSeries[i].each(function (p) {
                // every sankey point has different colors. so getting the color for individuals points
                prop = legendHighlight.getEffect(selecteffect, cType, null, null, ii);
                resetProp(d3_select(this), prop, p.point.itemIndex, 'select');
              });
            } else {
              prop = legendHighlight.getEffect(selecteffect, cType, null, null, ii);
              resetProp(selectedSeries[i], prop, ii, 'select', paneIDs[i]);
            }
          };for (var i = 0; i < length; i++) {_loop6();}
          legendHighlight.selSeriesObj.push(selected);
        });
      }

      function resetUnselectedSeries(legdata, index, filterIndex) {
        legendHighlight.unselSeriesObj = getUnselectedSeries(index, filterIndex);
        var unselectedSeries = legendHighlight.unselSeriesObj.unselectedSeries;
        var indices = legendHighlight.unselSeriesObj.indices;
        var charttypes = legendHighlight.unselSeriesObj.charttypes;
        var paneIDs = legendHighlight.unselSeriesObj.paneIDs;
        var length = unselectedSeries.length;
        for (var i = 0; i < length; i++) {
          var cType = charttypenames.get(charttypes[i]);
          var unselecteffect = legendHighlight.getLegendHighlightEffect(indices[i], 'unselectedSeries');

          if (chartObj.dataObject.isFlowChartCategory) {
            // eslint-disable-next-line no-loop-func
            unselectedSeries[i].each(function (p) {
              // every sankey point has different colors. so getting the color for individuals points
              prop = legendHighlight.getEffect(unselecteffect, cType, NULL$1, NULL$1, indices[i]);
              resetProp(d3_select(this), prop, p.point.itemIndex, 'unselect');
            });
          } else {
            var prop = legendHighlight.getEffect(unselecteffect, cType, null, null, indices[i]);
            resetProp(unselectedSeries[i], prop, indices[i], 'unselect', paneIDs[i]);
          }
        }
      }

      function getSelectedSeries(index, filterIndex) {
        var _seriesHolder = container.selectAll('g.seriesholder');
        var type = getChartType(null, 'object', index, userdata).value;
        var charttypes = [],
          selectedSeries = [],
          parentSeries = [],
          paneIDs = [];

        if (isFacet(chartObj)) {
          if (noColorColumn(chartObj)) {
            collectSelectedSeries(type, index, _seriesHolder);
          } else {
            var gridList = getGridList(chartObj.dataObject),
              count = -1;

            gridList.forEach(function (grid) {
              var row = grid.row,column = grid.column,layer = grid.layer,
                paneid = "".concat(row, "_").concat(column),
                gridWrap = _seriesHolder.selectAll("g.grid".concat(paneid));

              grid.data.forEach(function (_d, _i) {
                var enabled = !isItemDisabled(_d);
                count++;
                if (
                (!chartObj.userdata.facets.color.length || layer === order) &&
                chartObj.rendererConf[count].legendIndex() === index &&
                enabled)
                {
                  type = getChartTypeByIndex(chartObj, paneid, _i).value;
                  collectSelectedSeries(type, _i, gridWrap, paneid);
                }
              });
            });
          }
        } else {
          collectSelectedSeries(type, index, _seriesHolder);
        }

        return {
          selectedSeries: selectedSeries,
          charttypes: charttypes,
          parentSeries: parentSeries,
          paneIDs: paneIDs
        };

        function collectSelectedSeries(type, index, seriesHolder) {var paneID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          /*
           * This function adds the selected series to the selectedSeries array and respective chart type to the charttypes array.
           * Scatter chart = outer scatter series + inner scatter series.
           * Area chart = area series + line series.
           * Line chart = line series + scatter series.(for IE and SAFARI)
           */
          var groupHolderIndex = index;
          if (chartObj.seriesAddRemoveDetails) {
            // addRemoveSeriesPhase
            groupHolderIndex = chartObj.renderer[index].commonRendererProp().params.dynamicSeriesPosition;
          }

          var series, parent;
          if (isHeatMapChartType(type)) {
            var heatmapSeries = seriesHolder.selectAll("g.heatmapseries_".concat(index));
            series = heatmapSeries.selectAll('path');
          } else if (isBarChartType(type)) {
            var barSeries = seriesHolder.selectAll("g.barseries_".concat(groupHolderIndex));
            series = barSeries.selectAll('path.zc_bar');

            //whiskers
            selectedSeries.push(chartObj.staticPaneSVG.selectAll("g.medianSeries".concat(index)).selectAll('path.outer'));
            selectedSeries.push(chartObj.staticPaneSVG.selectAll("g.whiskerSeries".concat(index)).selectAll('path.outer'));
            charttypes.push(charttype.scatter);
            charttypes.push(charttype.scatter);
            paneIDs.push(paneID, paneID);
          } else if (type == charttype.line) {
            var lineSeries = seriesHolder.selectAll("g.lineseries_".concat(groupHolderIndex));
            series = lineSeries.selectAll('path.line');
            parent = lineSeries;
          } else if (isAreaChartType(type) || type == charttype.web) {
            var areaSeries = seriesHolder.selectAll("g.areaseries_".concat(groupHolderIndex));
            series = areaSeries.selectAll('path.area');
            parent = areaSeries;
          } else if (isScatterChartType(type)) {
            var scatterSeries = seriesHolder.selectAll("g.scatterseries_".concat(groupHolderIndex));
            series = scatterSeries.selectAll('g.scatter');
            series = filterSelection(series, true, filterIndex, index);

            var outerScatters = series.selectAll('path.outer');
            var innerScatters = series.selectAll('path.inner');

            selectedSeries.push(outerScatters, innerScatters);
            charttypes.push(type, type);
            paneIDs.push(paneID, paneID);

            parent = scatterSeries;
            parentSeries.push(parent);
            return;
          } else if (type === charttype.bubblepie || type === charttype.geobubblepie) {
            var pieSeries = seriesHolder.selectAll('g.piegroup');
            series = pieSeries.selectAll("path#arc_".concat(groupHolderIndex));
          } else if (isPieChartType(type) || type === charttype.dial) {
            var pieSeries = seriesHolder.selectAll('g.piegroup');
            series = pieSeries.selectAll(defined(filterIndex) ? 'path' : "path#arc_".concat(index));
          } else if (type == charttype.funnel) {
            var funnelSeries = seriesHolder.selectAll('g.funnelgroup');
            var trapezoidgroup = funnelSeries.selectAll('g.trapezoidgroup');
            series = trapezoidgroup.selectAll(defined(filterIndex) ? 'path' : "path#funnel".concat(index));
          } else if (type == charttype.pyramid) {
            var pyramidSeries = seriesHolder.selectAll('g.pyramidgroup');
            series = pyramidSeries.selectAll(defined(filterIndex) ? 'g' : "g#section_".concat(index));
          } else if (type == charttype.wordcloud) {
            var wordCloudSeries = seriesHolder.selectAll('g.wordcloudgroup');
            series = wordCloudSeries.selectAll("text.series_".concat(groupHolderIndex));
          } else if (chartcategory.hierarchy.indexOf(type) != -1) {
            var burstseries = seriesHolder.selectAll('g.hierarchychart');
            series = burstseries.selectAll(".series_".concat(index));
          } else if (type == charttype.sankey) {
            var point = chartObj.cache.sankey.legend[index];
            var dependentsPoints = chartObj.renderer[0].highlighter.getDependentLayoutPoints(point, true, 'legend');
            series = seriesHolder.selectAll('path').filter(function (currentLayoutPoint) {
              return arrayIncludes(dependentsPoints, currentLayoutPoint);
            });
          }

          var isAxisCategory = isCategoryOf(chartObj, type, 'axis'),
            isNonAxisMultiSeriesCategory = isCategoryOf(chartObj, type, 'nonAxisMultiSeries'),
            _seriesIndex = isAxisCategory || isNonAxisMultiSeriesCategory || chartObj.isGeoMap ? index : 0;
          series = filterSelection(series, true, filterIndex, _seriesIndex);

          selectedSeries.push(series);
          charttypes.push(type);
          parentSeries.push(parent);
          paneIDs.push(paneID);

          if (isAreaChartType(type) || type == charttype.web) {
            collectSelectedSeries(charttype.line, index, seriesHolder, paneID);
          }

          if (type == charttype.line && hasSubScatterRenderer(filterIndex)) {
            collectSelectedSeries(charttype.scatter, index, seriesHolder, paneID);
          }
        }
      }

      function getUnselectedSeries(index, filterIndex) {
        var unSelectedSeries = [],
          indices = [],
          charttypes = [],
          paneIDs = [],
          parentSeries;
        var _seriesHolder = container.selectAll('g.seriesholder'),
          count = 0;

        if (isFacet(chartObj)) {
          if (noColorColumn(chartObj)) {
            collectUnselectedSeries(null, index, _seriesHolder, chartObj.seriesdata);
          } else {
            var gridList = getGridList(chartObj.dataObject);

            gridList.forEach(function (grid) {
              var row = grid.row,column = grid.column,layer = grid.layer,
                gridWrap = _seriesHolder.selectAll("g.grid".concat(row, "_").concat(column));

              if (!chartObj.userdata.facets.color.length || layer === order) {
                collectUnselectedSeries(null, index, gridWrap, grid.data, count, "".concat(row, "_").concat(column));
              } else {
                collectUnselectedSeries(null, [-1], gridWrap, grid.data, count, "".concat(row, "_").concat(column));
              }
              count += grid.data.length;
            });
          }
        } else {
          collectUnselectedSeries(null, index, _seriesHolder, chartObj.seriesdata);
        }

        return {
          unselectedSeries: unSelectedSeries,
          indices: indices,
          charttypes: charttypes,
          parentSeries: parentSeries,
          paneIDs: paneIDs
        };

        function collectUnselectedSeries(subcharttype, index, seriesHolder, seriesdata) {var startingRendererIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;var paneID = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
          /*
           * This function adds the unselected series to the selectedSeries array, respective chart type to the charttypes array, respective index to the indices array.
           * Scatter chart = outer scatter series + inner scatter series.
           * Area chart = area series + line series.
           * Line chart = line series + scatter series.(for IE and SAFARI)
           */
          var chartType = getChartTypeByIndex(chartObj, paneID, index[0]).value, // Have to check with multiple indices
            isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
            isNonAxisMultiSeriesCategory = isCategoryOf(chartObj, chartType, 'nonAxisMultiSeries');

          var series, type;
          if (isAxisCategory || isNonAxisMultiSeriesCategory || chartObj.isGeoMap) {
            seriesdata.forEach(function (d, i) {
              var legendOrder = noColorColumn(chartObj) ? i : chartObj.rendererConf[startingRendererIndex + i].legendIndex();
              if (d.disabled != true && (defined(filterIndex) ? arrayIncludes(index, i) : !arrayIncludes(index, legendOrder))) {
                type = subcharttype || getChartTypeByIndex(chartObj, paneID, i).value;
                var selectionIndex = defined(filterIndex) ? index : i,
                  groupHolderIndex = selectionIndex;
                if (chartObj.seriesAddRemoveDetails) {
                  // addRemoveSeriesPhase,
                  groupHolderIndex = chartObj.renderer[i].commonRendererProp().params.dynamicSeriesPosition;
                }

                if (isHeatMapChartType(type)) {
                  var heatmapSeries = seriesHolder.selectAll("g.heatmapseries_".concat(selectionIndex));
                  series = heatmapSeries.selectAll('path');
                } else if (isBarChartType(type)) {
                  var barSeries = seriesHolder.selectAll("g.barseries_".concat(groupHolderIndex));
                  series = barSeries.selectAll('path.zc_bar');

                  var whiskers = chartObj.renderer[selectionIndex].commonRendererProp().params.whiskers,
                    hasWhisker = whiskers && whiskers.enabled && whiskers.showOn == 'overlay';

                  if (hasWhisker) {
                    unSelectedSeries.push(
                    chartObj.staticPaneSVG.selectAll("g.whiskerSeries".concat(selectionIndex)).selectAll('path.outer'));

                    charttypes.push(charttype.scatter);
                    indices.push(selectionIndex, selectionIndex);
                    paneIDs.push(paneID, paneID);
                  }
                } else if (type == charttype.line) {
                  var lineSeries = seriesHolder.selectAll("g.lineseries_".concat(groupHolderIndex));
                  series = lineSeries.selectAll('path.line');
                } else if (isAreaChartType(type) || type == charttype.web) {
                  var areaSeries = seriesHolder.selectAll("g.areaseries_".concat(groupHolderIndex));
                  series = areaSeries.selectAll('path.area');
                  parentSeries = areaSeries;
                } else if (isScatterChartType(type)) {
                  var scatterSeries = seriesHolder.selectAll("g.scatterseries_".concat(groupHolderIndex));
                  series = scatterSeries.selectAll('g.scatter');
                  series = filterSelection(series, false, filterIndex, i);

                  var outerScatters = series.selectAll('path.outer');
                  var innerScatters = series.selectAll('path.inner');

                  unSelectedSeries.push(outerScatters, innerScatters);
                  charttypes.push(type, type);
                  indices.push(selectionIndex, selectionIndex);
                  paneIDs.push(paneID, paneID);
                  return;
                } else if (chartcategory.hierarchy.indexOf(type) != -1) {
                  var burstseries = seriesHolder.selectAll('g.hierarchychart');
                  series = burstseries.selectAll(".series_".concat(selectionIndex));
                } else if (type == charttype.wordcloud) {
                  var wordCloudSeries = seriesHolder.selectAll('g.wordcloudgroup');
                  series = wordCloudSeries.selectAll(".series_".concat(selectionIndex));
                } else if (chartcategory.bubblePie.has(type)) {
                  series = seriesHolder.selectAll('g.piegroup').selectAll("path#arc_".concat(i));
                }

                series = filterSelection(series, false, filterIndex, i);

                unSelectedSeries.push(series);
                indices.push(i);
                charttypes.push(type);
                paneIDs.push(paneID);
              }
            });
          } else {
            type = subcharttype || chartType;
            var prefix_ID,
              processFunc = function processFunc(d, i) {
                var ele = d3_select(this),
                  elementIndex = +this.getAttribute('id').
                  split(prefix_ID).
                  pop(),
                  unselect = defined(filterIndex) ?
                  !filterSelection(ele, false, filterIndex, 0).empty() :
                  this.getAttribute('id') != prefix_ID + index;

                if (unselect && (defined(filterIndex) ? true : !arrayIncludes(index, elementIndex))) {
                  unSelectedSeries.push(ele);
                  indices.push(elementIndex);
                  charttypes.push(type);
                  paneIDs.push(paneID);
                }
                return unselect;
              };

            if (isPieChartType(type) || type === charttype.dial) {
              prefix_ID = 'arc_';
              series = seriesHolder.
              selectAll('g.piegroup').
              selectAll('path').
              filter(processFunc);
            } else if (type == charttype.funnel) {
              prefix_ID = 'funnel';
              series = seriesHolder.
              selectAll('g.trapezoidgroup').
              selectAll('path').
              filter(processFunc);

              // ZC2713
              prefix_ID = 'ellipse';
              series = seriesHolder.
              selectAll('g.ellipsegroup').
              selectAll('path').
              filter(processFunc);
            } else if (type == charttype.pyramid) {
              prefix_ID = 'section_';
              var pyramidGroup = seriesHolder.selectAll('g.pyramidgroup');
              series = pyramidGroup.selectAll('g').filter(processFunc);
            } else if (type === charttype.sankey) {
              var sankeySeriesIndex = 0,
                point = chartObj.cache.sankey.legend[index],
                dependentsPoints = chartObj.renderer[sankeySeriesIndex].highlighter.getDependentLayoutPoints(point, true, 'legend');

              series = seriesHolder.selectAll('path').filter(function (currentLayoutPoint) {
                return !arrayIncludes(dependentsPoints, currentLayoutPoint);
              });

              unSelectedSeries.push(series);
              charttypes.push(type);
              indices.push(sankeySeriesIndex);
              paneIDs.push(paneID);
            }
          }

          if (isAreaChartType(type) || type == charttype.web) {
            collectUnselectedSeries(charttype.line, index, seriesHolder, seriesdata, startingRendererIndex, paneID);
          }
          if (type == charttype.line && hasSubScatterRenderer(filterIndex)) {
            collectUnselectedSeries(charttype.scatter, index, seriesHolder, seriesdata, startingRendererIndex, paneID);
          }
        }
      }

      function applyProp(series, parentSeries, prop, index, type, paneID) {
        if (prop == null || prop.constructor != Object || series == null || series.node() == null) {
          return;
        }
        var key = getKey(series, index, type, paneID),
          currentOrigProp = {},
          multipleStyles = hasMultipleStyles(index),
          priorityStyles = elementPriority(series);

        for (var attr in prop) {
          if (prop.hasOwnProperty(attr) && !arrayIncludes(priorityStyles, attr)) {
            if (multipleStyles) {
              currentOrigProp[attr] = currentOrigProp[attr] || [];
              series.each(function () {
                currentOrigProp[attr].push(d3_select(this).style(attr));
              });
            } else {
              // TODO Check
              currentOrigProp[attr] = series.style(attr);
            }

            var val = prop[attr];
            if ($Browser.SAFARI || $Browser.IE) {
              series.
              attr(attr, function (d) {
                return utils.getVal(val, [d, index]);
              }).
              style(attr, function (d) {
                return utils.getVal(val, [d, index]);
              });
            } else {
              series.style(attr, function (d) {
                return utils.getVal(val, [d, index]);
              });
            }
          }
        }
        origProp[key] = origProp[key] || currentOrigProp; //If the style values are already stored, don't store again. If u store again, the origProp[key] object will be replaced with the highlighting props instead of containing the style values of the original element.

        if (type === 'select') {
          legendHighlight.raiseSelection(parentSeries || series, paneID);
        }
      }

      function resetProp(series, prop, index, type, paneID) {
        if (prop == null || prop.constructor != Object || series == null || series.node() == null) {
          return;
        }

        var key = getKey(series, index, type, paneID),
          currentOrigProp = origProp[key],
          multipleStyles = hasMultipleStyles(index),
          priorityStyles = elementPriority(series);

        for (var attr in currentOrigProp) {
          if (currentOrigProp.hasOwnProperty(attr) && !arrayIncludes(priorityStyles, attr)) {
            var val = currentOrigProp[attr],
              actualVal = function actualVal() {
                return multipleStyles ? val[count++] : val;
              },
              count = 0;
            if ($Browser.SAFARI || $Browser.IE) {
              series.style(attr, actualVal).attr(attr, actualVal);
            } else {
              series.style(attr, actualVal);
            }
          }
        }
      }

      function getKey(series, index, selectionType, paneID) {
        /*
         * This function returns a unique key that is generated from the localName, class, id of the series element and index.
         * The key will be used to store the style values of the element on legend highlighting. The stored values will be applied to the element on unhighlighting.
         */
        var node = series.node();
        var localName = node.localName,
          className = node.getAttribute('class'),
          idName = node.getAttribute('id');
        var KEY = "".concat(localName, "_").concat(index);
        if (className != null) {
          KEY += "_".concat(className);
        }
        if (idName != null) {
          KEY += "_".concat(idName);
        }
        if (selectionType !== null) {
          KEY += "_".concat(selectionType);
        }

        if (paneID !== null) {
          KEY += "_".concat(paneID);
        }
        return KEY;
      }

      function setSeriesVisible(series, visible) {
        series.style('visibility', visible ? 'visible' : 'hidden');
      }

      function defaultEffect(chartName) {
        if (legend_helpers.hasPatternPallete(chartObj)) {
          return /(area|arearange)/.test(chartName) ? 'moody' : 'strokeEnlarge';
        }

        if (/(bar|bullet|gantt|area|arearange|pie|funnel|pyramid|web|sunburst|waterfall|boxplot|sankey|barrange|dial)/.test(chartName)) {
          return 'hatchfill';
        } else if (chartName === 'heatmap' || chartName === 'geoheatmap') {
          return 'tinyHatchfill';
        } else if (/(treemap|wordcloud)/.test(chartName)) {
          return 'blackyBorder';
        } else {
          return 'strokeEnlarge';
        }
      }

      function invalidEffect(effect, chartName) {
        return /(line|scatter)/.test(chartName) && /(((\D)+fill$)|illuminate|moody|flip)/.test(effect);
      }

      function highlightSVGSeries(legdata, index, filterIndex) {
        legendHighlight.selSeriesObj = [];
        index = splat(index);
        index.forEach(function (ii) {
          var selected = getSelectedSeries(ii, filterIndex);
          legendHighlight.selSeriesObj.push(selected);

          var selectedSeries = selected.selectedSeries;
          var charttypes = selected.charttypes;
          var parentSeries = selected.parentSeries;
          var paneIDs = selected.paneIDs;
          var length = selectedSeries.length,
            prop;

          for (var i = 0; i < length; i++) {
            var selecteffect = legendHighlight.getLegendHighlightEffect(ii, 'selectedSeries', undefined, paneIDs[i]);
            var cType = charttypenames.get(charttypes[i]),
              baseColor = legendHighlight.baseClr || getCurrectColor(ii, filterIndex);

            if (chartObj.dataObject.isFlowChartCategory) {
              // eslint-disable-next-line no-loop-func
              selectedSeries[i].each(function (p) {
                // every sankey point has different colors. so getting the color for individuals points
                baseColor = chartObj.renderer[0].getColor(p.point);
                // baseColor = p.point.arcColor;
                prop = legendHighlight.getEffect(selecteffect, cType, baseColor, null, ii, null, p);
                applyProp(d3_select(this), parentSeries[i], prop, p.point.itemIndex, 'select');
              });
            } else {
              // TODO below line
              // baseColor = legendHighlight.baseClr || getCurrectColor(ii, filterIndex);
              prop = legendHighlight.getEffect(selecteffect, cType, baseColor, null, ii);
              applyProp(selectedSeries[i], parentSeries[i], prop, ii, 'select', paneIDs[i]);
            }
          }
        });
      }

      function highlightCanvasSeries(chartObj, legdata, index, filterIndex) {
        // if (!chartObj.chartRendered) {
        //     return;
        // }

        var context =
          chartObj.highlightContext || (
          chartObj.highlightContext = plot.canvasRenderer.updateCanvasContext(
          chartObj,
          'highlight-canvas',
          null,
          chartObj.canvasScrollGroup)),

          scrollPosition = [0, 0];

        if (chartObj.canvasScrollGroup) {
          var axisrotated = chartObj.axes.rotated,
            scrolled = !axisrotated ? chartObj.scrolledX : chartObj.scrolledY;

          d3_select(context.canvas).styles({
            left: '0px',
            top: '0px'
          });
          scrollPosition = [axisrotated ? 0 : -scrolled, axisrotated ? -scrolled : 0];
        }
        index = splat(index);

        var canvasSeriesHighlight = function canvasSeriesHighlight(index, seriesdata, rendererIndex, layerIndex, seriesIndex, paneID) {
          var chartTypeObj = getChartTypeByIndex(chartObj, paneID, index),
            chartName = chartTypeObj.name,
            cType = chartTypeObj.value,
            isAxisCategory = isCategoryOf(chartObj, cType, 'axis'),
            isPolarAxisCategory = isCategoryOf(chartObj, cType, 'polarAxis'),
            isNonAxisMultiSeriesCategory = isCategoryOf(chartObj, cType, 'nonAxisMultiSeries');

          var effect = legendHighlight.getLegendHighlightEffect(index, 'selectedSeries', undefined, paneID),
            unHighlightEffect = legendHighlight.getLegendHighlightEffect(index, 'unselectedSeries', undefined, paneID);
          seriesIndex = pick(seriesIndex, isAxisCategory || isNonAxisMultiSeriesCategory || chartObj.isGeoMap ? index : 0);

          if (effect === NONE && !UNHIGHLIGHT_EFFECT_REGEX.test(unHighlightEffect)) {
            return;
          }
          var renderer = plot.canvasRenderer.createCanvasRenderer(chartName),
            currentSeries = seriesdata[seriesIndex],
            pattern = null,
            highlightSeriesindex =
            isNonAxisMultiSeriesCategory && !isPolarAxisCategory || chartObj.dataObject.isFlowChartCategory ? 0 : index,
            fillOpacity = chartObj.systemConf.chart.plot.plotoptions[chartName].fillOpacity;

          if (encode === 'z' && !(chartcategory.zaxis.indexOf(cType) > -1 && !isHeatMapChartType(cType))) {
            // Size legend highlight: non-zaxis charts need not to drawn
            return;
          }
          rendererIndex = pick(rendererIndex, highlightSeriesindex);

          var rp = chartObj.renderer[rendererIndex].commonRendererProp().params,
            legendIndex = isFacet(chartObj) ? rp.legendIndex : index,
            baseColor = getUserFillColor(index, chartName) || getCurrectColor(legendIndex, filterIndex) || legendHighlight.baseClr;

          renderer_helpers.setRendererProp(
          chartObj,
          renderer,
          seriesdata,
          highlightSeriesindex,
          highlightSeriesindex,
          {
            labelQueue: [],
            labelArray: {}
          },
          rendererIndex,
          DataProcessor.helpers.getChartType(
          (isFacet(chartObj) ? currentSeries.node.type : currentSeries.type) || chartObj.userdata.seriesdata.type,
          NUMERIC_DATATYPE),

          layerIndex);


          if (hasColorScale && (isAreaChartType(cType) || isScatterChartType(cType))) {
            pattern = legendHighlight.getEffect(effect, cType);
          } else {
            switch (chartName) {
              case 'bar':
              case 'bullet':
              case 'area':
              case 'arearange':
              case 'heatmap':
              case 'treemap':
              case 'web':{
                  var prop = patternThemes[effect] ? getPattern(effect) : null;
                  if (prop) {
                    pattern = getCanvasPattern(prop, baseColor, fillOpacity, chartObj);
                  }
                  break;
                }
              case 'sankey':
              case 'wordcloud':{
                  var prop = patternThemes[effect] ? getPattern(effect) : null;
                  if (prop) {
                    pattern = { fill: getCanvasPattern(prop, baseColor, fillOpacity, chartObj) };
                  } else {
                    pattern = legendHighlight.getEffect(effect, cType);
                  }
                  break;
                }
              case 'scatter':
              case 'geoscatter':
              case 'bubble':
              case 'geobubble':
              case 'line':{
                  // TODO CHECK
                  // getEffect expect a chart name but we were giving as number
                  pattern = legendHighlight.getEffect(effect, chartName);
                }}

          }
          var dataForCanvas = isAxisCategory || isFacet(chartObj) ? seriesdata : currentSeries;

          var bound = rp.bound,
            x = scrollPosition[0] + (isAxisCategory ? 0 : bound.x + (isPolarAxisCategory ? bound.polar.x : 0)),
            y = scrollPosition[1] + (isAxisCategory ? 0 : bound.y + (isPolarAxisCategory ? bound.polar.y : 0));

          context.translate(x, y);
          plot.canvasRenderer.drawCanvas(
          chartObj,
          dataForCanvas,
          renderer,
          context,
          pattern,
          filterIndex,
          encode,
          chartObj.dataObject.isFlowChartCategory ? index : seriesIndex);

          context.translate(-x, -y);
        };

        index.forEach(function (ii) {
          if (isFacet(chartObj)) {
            var gridList = getGridList(chartObj.dataObject),
              count = 0;

            gridList.forEach(function (grid) {
              var layer = grid.layer,row = grid.row,column = grid.column,
                paneID = "".concat(row, "_").concat(column);

              grid.data.forEach(function (_d, _i) {
                var chartType = getChartTypeByIndex(chartObj, paneID, _i).value,
                  isAxisCategory = isCategoryOf(chartObj, chartType, 'axis'),
                  isPolarAxisCategory = isCategoryOf(chartObj, chartType, 'polarAxis');

                if (isAxisCategory || isPolarAxisCategory) {
                  if (
                  (!chartObj.userdata.facets.color.length || layer === order) &&
                  chartObj.rendererConf[count].legendIndex() === ii)
                  {
                    canvasSeriesHighlight(_i, grid.data, count, _d.layer, undefined, paneID);
                  }
                } else {
                  if (
                  (!chartObj.userdata.facets.color.length || layer === order) &&
                  chartObj.rendererConf[count].legendIndex() === ii)
                  {
                    var _rendererIndex = count - _i;
                    canvasSeriesHighlight(
                    ii,
                    grid.data,
                    _rendererIndex,
                    _d.layer,
                    chartObj.rendererConf[count].datasetIndex(),
                    paneID);

                  }
                }

                count++;
              });
            });
          } else {
            canvasSeriesHighlight(ii, chartObj.seriesdata);
          }
        });
      }

      /**
       *
       * @param chartObj
       * @param legdata
       * @param index
       * @param filterIndex
       */
      function highlightGeoMap(chartObj, legdata, index, filterIndex) {
        if (legendHighlight.previousFilterIndex !== filterIndex) {
          var mapEvents = chartObj.eventHandler.mapEvents,
            points = mapEvents.getPointsByIndex(index, filterIndex),
            features = chartObj.dataObject.getMapFeaturesByDataPoint(points, 'array'),
            highlightStyle = mapEvents.getHighlightEffect(index, null, 'selectedSeries', 'legend');

          mapEvents.highlightPoints(features, 'feature', highlightStyle);
          legendHighlight.previousFilterIndex = filterIndex;
        }
      }

      function unHighlightSVGSeries(legdata, index, filterIndex) {
        index = splat(index);
        var unselSeriesObj = getUnselectedSeries(index, filterIndex);
        var unselectedSeries = unselSeriesObj.unselectedSeries;
        var indices = unselSeriesObj.indices;
        var charttypes = unselSeriesObj.charttypes;
        var paneIDs = unselSeriesObj.paneIDs;
        var length = unselectedSeries.length;
        for (var i = 0; i < length; i++) {
          var cType = charttypenames.get(charttypes[i]);
          var unselecteffect = legendHighlight.getLegendHighlightEffect(indices[i], 'unselectedSeries', undefined, paneIDs[i]);

          if (chartObj.dataObject.isFlowChartCategory) {
            // eslint-disable-next-line no-loop-func
            unselectedSeries[i].each(function (p) {
              // every sankey point has different colors. so getting the color for individuals points

              prop = legendHighlight.getEffect(unselecteffect, cType, NULL$1, NULL$1, indices[i]);
              applyProp(d3_select(this), NULL$1, prop, p.point.itemIndex, 'unselect');
            });
          } else {
            var prop = legendHighlight.getEffect(unselecteffect, cType, NULL$1, NULL$1, indices[i]);
            applyProp(unselectedSeries[i], NULL$1, prop, indices[i], 'unselect', paneIDs[i]);
          }
        }
      }

      function unHighlightCanvasSeries(legdata, index, filterIndex) {
        var ele = d3_select(chartObj.context.canvas),
          highlightEffect = legendHighlight.getLegendHighlightEffect(0, 'unselectedSeries'),
          prop = legendHighlight.getEffect(highlightEffect, NULL$1, NULL$1, NULL$1, 0);
        applyProp(ele, NULL$1, prop, 0, 'unselect');
      }

      function resetSelectedCanvasSeries(legdata, index, filterIndex) {
        chartObj.container.select('.highlight-canvas').style('visibility', 'hidden');
      }

      function resetUnselectedCanvasSeries(legdata, index, filterIndex) {
        var ele = d3_select(chartObj.context.canvas),
          highlightEffect = legendHighlight.getLegendHighlightEffect(0, 'unselectedSeries'),
          prop = legendHighlight.getEffect(highlightEffect, NULL$1, NULL$1, NULL$1, 0);
        resetProp(ele, prop, 0, 'unselect');
      }

      function resetGeoMapSeries() {
        legendHighlight.previousFilterIndex = null;
        chartObj.eventHandler.mapEvents.clearHighlightedPoints();
      }

      function highlightNonSVGSeries(legdata, index) {
        var selecteffect = legendHighlight.getLegendHighlightEffect(index, 'selectedSeries');
        if (selecteffect === NONE) {
          return;
        }

        legendHighlight.baseClr = getColorByIndex(chartObj, index, null, order);

        var cType = getChartTypeByIndex(chartObj, '0_0', index);
        var cName = cType.name;
        var cTypeNumeric = cType.value;

        var selectedSeriesObj = getSelectedSeries(index);

        if (selectedSeriesObj.selectedSeries[0].length > 0) {
          setSeriesVisible(selectedSeriesObj.selectedSeries[0], true);
          return;
        }

        if (!chartObj.chartRendered) {
          return;
        }

        /*
         * Disable animation during the chartObj drwaing proccess and disable the datalabels also.
         */

        chartObj.systemConf.chart.plot.animation.enabled = false;
        chartObj.systemConf.chart.plot.plotoptions[cName].animation.enabled = false;
        if (chartObj.seriesdata[index].plotoptions && chartObj.seriesdata[index].plotoptions.animation) {
          chartObj.seriesdata[index].plotoptions.animation.enabled = false;
        }

        var renderer = createSVGRenderer(cName, chartObj);
        var currOrdereddata = chartObj.systemConf.seriesdata.chartdata[index];
        var barDatasetIndex = 0;
        if (cTypeNumeric === charttype.bar || cTypeNumeric === charttype.stkdbar) {
          for (var i = 0; i < index; i++) {
            cType = getChartTypeByIndex(chartObj, '0_0', i);
            cTypeNumeric = cType.value;
            if ((chartObj.seriesdata[i].disabled == undefined || !chartObj.seriesdata[i].disabled) && isBarChartType(cTypeNumeric)) {
              barDatasetIndex = barDatasetIndex + chartObj.seriesdata[i].data.length;
            }
          }
        }
        renderer_helpers.setRendererProp(chartObj, renderer, currOrdereddata, index, index, {
          labelQueue: [],
          barDatasetIndex: barDatasetIndex
        });
        drawSVG(chartObj, currOrdereddata, renderer);

        highlightSVGSeries(legdata, index);
        return true;
      }

      function hasMultipleStyles(seriesIndex) {
        var cType = getChartType(null, NUMERIC_DATATYPE, seriesIndex, userdata);

        if (cType === charttype.sankey) {
          return false;
        }

        return (
          chartcategory.hierarchy.indexOf(cType) != -1 ||
          hasColorScale ||
          isBubbleChartType$1(cType) ||
          chartObj.rendererConf && chartObj.rendererConf[chartObj.isAxisCategory ? seriesIndex : 0].thresholdType);

      }

      function doArrangeSelection() {var paneID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0_0';
        var cType_obj = getChartTypeByIndex(chartObj, paneID, 0),
          dataObject = chartObj.dataObject;

        if (dataObject.isFlowChartCategory) {
          return true;
        } else if (isCategoryOf(chartObj, cType_obj.value, 'hierarchy')) {
          var styles = legendHighlight.getEffect(legendHighlight.getLegendHighlightEffect(0, 'selectedSeries'), cType_obj.name);
          var keys = Object.keys(styles);

          return (
            keys.length > 0 &&
            keys.some(function (key) {
              return key !== 'fill';
            }));

        } else if (
        isCategoryOf(chartObj, cType_obj.value, 'axis') && (
        dataObject.noofAreaEnabledSeries || dataObject.noofAreaRangeEnabledSeries))
        {
          return true;
        }
      }

      function hasSubScatterRenderer(filterValue) {
        return $Browser.IE || $Browser.SAFARI || defined(filterValue);
      }

      function getCurrectColor(index, filterIndex) {
        // let _custom = getUserFillColor(index, chartName);
        //
        // if (_custom) {
        //     return _custom;
        // }
        if (defined(filterIndex) && encode === 'clr') {
          var userRanges = chartObj.systemConf.legend.colorBand.ranges;
          if (userRanges && userRanges.length) {
            return getColorByIndex(chartObj, filterIndex, null, order);
          } else {
            return chartObj.axes.clr.scale((filterIndex[0] + filterIndex[1]) / 2);
          }
        } else if (encode === 'z') {
          return function (d, i) {return getRawColor(chartObj, i, d && (d.data || d), index);};
        } else {
          return getColorByIndex(chartObj, index, null, order);
        }
      }

      function getUserFillColor(index, chartName) {
        if (isFacet(chartObj)) {
          return;
        }

        if (arrayIncludes([AREA_CHARTNAME, AREARANGE_CHARTNAME, WEB_CHARTNAME], chartName)) {
          var _data = chartObj.seriesdata[index],
            commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[chartName];
          return isObjectPropDefined(_data, 'plotoptions.fillColor', true) || commonPlotOptions.fillColor;
        }
      }

      return legendHighlight;
    };

    function getCanvasPattern(prop, baseClr, fillOpacity, chartObj) {
      prop.bgClr_base = rgba_canvas(baseClr, fillOpacity);
      prop.stroke = 'transparent,white,white'; //need to check
      return effects.get(effects.canvas_patterns, 'canvasPatternFill', prop, { chartObj: chartObj });
    }

    function noColorColumn(chartObj) {
      return (
        !isFacet(chartObj) ||
        isFacet(chartObj) &&
        arrayIncludes([PIE_CHARTNAME, FUNNEL_CHARTNAME, PYRAMID_CHARTNAME], chartObj.chartTypes[0].name) &&
        !chartObj.userdata.facets.color.length);

    }

    Registry.setComponent('LegendHighlight', legendHighlight);

    //

    function ExpandableAdjustFactor() {var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var w = arguments.length > 1 ? arguments[1] : undefined;var h = arguments.length > 2 ? arguments[2] : undefined;var globalFont = arguments.length > 3 ? arguments[3] : undefined;var align = arguments.length > 4 ? arguments[4] : undefined;var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;
      var isHorizontal = align.layout === HORIZONTAL_ALIGN,
        show = config.show,keepAligned = config.keepAligned,
        adjust = [0, 0];

      if (show) {
        if (isHorizontal && keepAligned) {
          adjust[0] += w * 0.2 + padding * 2;
        } else {
          adjust[1] += getTextHeight([config, globalFont, $ZCG]) + padding * 2;
        }
      }

      return adjust;
    }
    Registry.setComponent('expandable.adjust', ExpandableAdjustFactor);

    /**
     *
     * @param chart
     * @param legData
     * @param legSeries
     * @param legData_length
     * @param colorBoxSize
     * @param legendAlign
     * @param lineHeight
     * @param ImpFontProp
     * @return {{getLegendItemText: getLegendItemText, setItemParent(*): void}}
     */
    var helpers = function helpers(chart, legSeries, legData, legData_length, colorBoxSize, legendAlign, lineHeight, ImpFontProp) {
      var systemConf = chart.systemConf,
        data = systemConf.legend,
        colorBoxWidth = colorBoxSize[0],
        showAs = data.showAs,
        colIdx = chart.dataset.getColumnIdx(
        chart.isAxisCategory ||
        chart.isGeoMap ||
        chart.isNonAxisMultiSeriesCategory ||
        colorscale_helpers.isQuantileColorScale(chart) ||
        hasColorColumnInNonAxis(chart) ?
        'clr' :
        'x'),

        isColumnView = legendAlign.layout === 'horizontal',
        itemWithIsNumber = typeof data.itemWidth === 'number';

      /**
       * For creating list
       * @param d
       * @param i
       * @return {string|*}
       */
      var methods = {
        getLegendItemText: function getLegendItemText(d, i) {
          if (colorscale_helpers.isQuantileColorScale(chart)) {
            var colorBandOptions = data.colorBand,
              userLabels = colorBandOptions.labels;

            if (userLabels && userLabels.length) {
              return encodeHTML(userLabels[i]); //check with unorders ranges input
            }
          }

          var seriesPos =
            chart.isAxisCategory || chart.isNonAxisMultiSeriesCategory || chart.isGeoMap || hasColorColumnInNonAxis(chart) ? i : 0,
            showAsText = getLegendShowAsText(d, i, data, chart),
            nodeData = d.node || d;
          return showAs ? showAsText : chart.dataset.getDataPointValue(chart, nodeData, colIdx, seriesPos, null, 'legend');
        },

        /**
         *
         * @param item
         * @return {{item: {width: *, height: *}, label: {width: number, height: number}}}
         */
        getItemDimension: function getItemDimension(item) {
          var _createTempItems = createTempItems([item]),ul = _createTempItems.ul,li = _createTempItems.li,span = _createTempItems.span;

          var dim = {
            label: {
              width: span.node().offsetWidth,
              height: span.node().offsetHeight
            },
            item: {
              width: li.node().offsetWidth,
              height: li.node().offsetHeight
            }
          };
          ul.remove();
          // remove the temp element
          return dim;
        },

        /**
         *
         * @return {*}
         */
        getMaxItemWidth: function getMaxItemWidth() {
          // we create only one element and put inner html in that and take dimension
          var tempElement = createTempItems([legData[0]]), // #ZC1911
            tempItemLabelElement = tempElement.span,
            itemElement = tempElement.li;

          var maxItemWidth = null,
            currentItemWidth;

          if (itemWithIsNumber) {
            return data.itemWidth;
          } else if (data.itemWidth === 'auto') {
            legData.forEach(function (d, i) {
              if (!d.hideInLegend) {
                tempItemLabelElement.html(function () {return methods.getLegendItemText(d, i);});

                currentItemWidth = getBoundingRect(itemElement).width;

                if (currentItemWidth > maxItemWidth) {
                  maxItemWidth = currentItemWidth;
                }
              }
            });
          }
          tempElement.li.remove();
          return maxItemWidth;
        },

        /**
         *
         * @param itemHeight
         * @param maxHeight
         * @return {number}
         */
        getRowsCount: function getRowsCount(itemHeight, maxHeight) {
          var actualRows = maxHeight / itemHeight,
            fullyPossibleRows = mathFloor(maxHeight / itemHeight) || 1,
            lastItemVisibility = actualRows - fullyPossibleRows,
            rowsCount = 0;

          // if the last item is visible more than 90%, then take that in account
          if (lastItemVisibility > 0.9) {
            rowsCount = mathRound(maxHeight / itemHeight) || 1;
          } else {
            rowsCount = mathFloor(maxHeight / itemHeight) || 1;
          }
          return rowsCount;
        },

        /**
         *
         * @param wrap
         * @param rowsCount
         * @param maxWidth
         * @param maxHeight
         * @param itemHeight
         * @return {number}
         */
        getVisibleItemRenderCount: function getVisibleItemRenderCount(wrap, rowsCount, maxWidth, maxHeight, itemHeight) {
          //
          var itemCount = 0;

          if (isColumnView) {
            var lastRowOverflow = false;

            if (itemWithIsNumber) {
              var actualItemWidth = data.itemWidth + 2 * +data.itemMargin;
              itemCount = mathFloor(maxWidth / actualItemWidth) * rowsCount; // plus 1 because we are rendering one extra element while auto calculate;
            } else {
              var rowOverflow = false,
                temp,
                lastOffsetTop = null,
                activeRow = -1;
              while (!lastRowOverflow) {
                itemCount++;

                var legItems = legData.slice(0, itemCount);
                temp = createTempItems(legItems, maxWidth, maxHeight);

                var lastNode = temp.li.last().node(),
                  top = lastNode.offsetTop;

                if (lastOffsetTop !== top) {
                  lastOffsetTop = top;
                  activeRow++;
                }

                rowOverflow = activeRow > rowsCount - 1;
                lastRowOverflow = legData_length === itemCount || rowOverflow;
              }
              if (rowOverflow) {
                itemCount -= 1;
              }
              temp.ul.remove();
            }
          } else {
            itemCount = rowsCount;
          }

          return itemCount;
        }
      };

      /**
       *
       * @param items
       * @param maxWidth
       * @param maxHeight
       * @return {{li: *, span: *}}
       */
      var createTempItems = function createTempItems(items, maxWidth, maxHeight) {
        var ul = createElement('ul', '.tempUl', [1], chart.d3container).styles({
          'max-width': defined(maxWidth) ? "".concat(maxWidth, "px") : null, // ie9 issue
          'max-height': defined(maxHeight) ? "".concat(maxHeight, "px") : null, // ie9 issue
          position: 'absolute',
          // opacity: 0,
          top: 0,
          left: 0,
          padding: 0 // [#ZC2000] fix global padding conflict
        });

        var tempElement = createElement('li', '.tempItem', items, ul).styles({
          display: isColumnView ? 'inline-block' : 'block',
          'line-height': lineHeight,
          'white-space': 'nowrap',
          padding: "".concat(data.itemMargin, "px"),
          width: itemWithIsNumber ? "".concat(data.itemWidth, "px") : null,
          height: defined(data.itemHeight) ? "".concat(data.itemHeight, "px") : null,
          'padding-left': "".concat(colorBoxWidth + data.itemMargin, "px")
        });

        var span = createElement('span', '.tempLabel', function (d) {return [d];}, tempElement).
        style('padding-left', "".concat(data.textPadding, "px")).
        style('display', systemConf.legend.showAs ? 'block' : null);

        if (systemConf.legend.showAs) {
          span.styles({
            // #ZC2002
            display: pick(systemConf.legend.showAsDisplay, 'inline-block'),
            overflow: 'hidden'
          });
        }

        // [#ZC2000] propagate data and index
        tempElement.select('span.tempLabel').html(function (d, i) {return methods.getLegendItemText(d, i);});

        // apply font
        applyFont(tempElement, [ImpFontProp, data, systemConf.canvas, $ZCG], true);

        return {
          ul: ul,
          li: tempElement,
          span: span
        };
      };

      return methods;
    };

    function expandableLegend(
    chart,
    wrap,
    legData,
    legseries,
    legData_length,
    maxWidth,
    maxHeight,
    isColumnView,
    headerWidth,
    renderLegendList,
    setLegendDimension,
    alignLegend,
    floating,
    container,
    chartarea,
    plotarea)
    {
      var systemConf = chart.systemConf,
        data = systemConf.legend,
        priorityArray = [data, systemConf.canvas, $ZCG],
        expandable = data.expandable || {},
        legendExpandable = expandable.show === true,
        title_data = data.title,
        keepLegendTitleAligned = title_data.keepAligned && isColumnView,
        redrawing = !!chart.renderer.length;

      return {
        /**
         *
         * @param remainingCount
         * @return {*}
         */
        create: function create(remainingCount) {
          if (legendExpandable) {
            legseries.style('overflow', 'hidden');

            var showMoreElement = appendEle(wrap, 'div', [1], '.', 'class', 'expandable').styles({
                color: expandable.fontColor,
                'font-size': "".concat(utils.getVal(expandable.fontSize), "px"),
                'font-family': expandable.fontFamily || getValByPriority(priorityArray, 'fontFamily'),
                'text-align': expandable.textAlign,
                cursor: POINTER,
                display: 'block',
                padding: "".concat(data.itemMargin, "px"),
                overflow: 'hidden',
                'text-overflow': 'ellipsis',
                'white-space': 'nowrap',
                'max-width': "".concat(maxWidth, "px"),
                'margin-left': keepLegendTitleAligned ? headerWidth + PX : 0
              }),
              legendExpanded = chart.legend.expanded;

            if (!legendExpanded) {
              showMoreElement.html(invokeFunction(expandable.text, remainingCount, chart) || "".concat(remainingCount, " more..."));
            } else if (redrawing && legendExpanded) {
              showMoreElement.html(function () {
                return invokeFunction(expandable.ontoggle, this, legendExpanded, chart) || 'Show less..';
              });
            }

            showMoreClickAction(remainingCount, showMoreElement);

            return showMoreElement;
          } else {
            if (!wrap.select('.expandable').empty()) {
              wrap.selectAll('.expandable').remove();
              legseries.style('overflow-y', 'hidden');
              legseries.style('overflow-x', 'hidden');
            }
          }
        },
        remove: function remove() {
          if (!wrap.select('.expandable').empty()) {
            wrap.selectAll('.expandable').remove();
            legseries.style('overflow-y', 'hidden');
            legseries.style('overflow-x', 'hidden');
          }
        }
      };

      function updateChart() {
        if (chart.legend.isSingleLayout) {
          chart.updatePlotArea();
          updateChartAndPlotBound(chart, true);
        } else {
          chart.chartarea = chartarea;
          chart.plotarea = plotarea;
        }

        if (chart.isAxisCategory) {
          axis.render(chart, chart.chartWidth, chart.chartHeight, true);
        } else if (chart.dataObject.isPolarAxisCategory) {
          axis.polar.render(chart, 'x');
        }
        chart.drawThreshold(true);
        chart.drawPlotareaClippath();
        chart.updatePlotareaProp();
        chart.plot.renderer.draw(true);

        if (chart.isAxisCategory || chart.dataObject.isPolarAxisCategory) {
          chart.positionEventTrackerElement();
        }

        // chart.eventHandler.updateParams(chart);
      }

      function showMoreClickAction(remainingCount, showMoreElement) {
        showMoreElement.on('click', function () {
          if (!chart.legend.allRendered && remainingCount > 0) {
            //Reset cache for data
            chart.cache.data = {};
            chart.cache.search = {};
            chart.cache.correction = {};

            chart.legend.allRendered = true;

            var series = renderLegendList(legData);
            setLegendDimension(series);
            if (chart.legend.isSingleLayout) {
              alignLegend(container);
            } else {
              legend.align(chart.legends, chart, chartarea, plotarea);
            }

            if (!isColumnView && container.node().offsetWidth > chart.legendarea.width) {
              var colorLegend = arrayFind(chart.legends, function (_) {return _.id === 'clr-0';});
              chart.legendarea = getLegendArea(chart, colorLegend); // Adapting old method // Remove
              updateChart();
            }
          }

          var legendExpanded = chart.legend.expanded = !chart.legend.expanded;
          var updatedText = invokeFunction(expandable.ontoggle, this, legendExpanded, chart);
          if (defined(updatedText)) {
            updatedText = "".concat(updatedText);
          }

          if (legendExpanded) {
            this.innerHTML = updatedText || 'Show less..';
            legseries.style('overflow-y', 'auto');
          } else {
            legseries.node().scrollTop = 0;
            this.innerHTML = updatedText || invokeFunction(expandable.text, remainingCount, chart) || "".concat(remainingCount, " more...");

            legseries.style('overflow-y', 'hidden');
          }
        });
      }
    }

    //$Id$

    legend.discrete = function () {};
    legend.discrete.get = function (spec) {
      var chartarea,
        color,
        dispatch = d3_dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout'),
        scrollbarwid = 20,
        systemconf,
        chartObj,
        bound = spec.bound,globalFont = spec.globalFont,callbackArgs = spec.callbackArgs,order = spec.order,
        getLegendData = legend_helpers.getLegendData,
        getLegendDataLength = legend_helpers.getLegendDataLength,
        isHiddenItem = legend_helpers.isHiddenItem,
        getClr = legend_helpers.getClr,
        isDisabled = legend_helpers.isDisabled;

      function chart(selection) {
        selection.each(function (data) {
          chartObj.legend.state = chartObj.legend.state || {};
          var legData = getLegendData(chartObj, order),
            legData_length = getLegendDataLength(chartObj, legData),
            colorBoxOptions = data.colorBox,
            disabledOptions = getDisabledOptions(data, 'clr'),
            priorityArray = [data, systemconf.canvas, $ZCG],
            floating = data.x != null && data.x !== '' && data.y != null && data.y !== '',
            fontSize = +utils.getVal(data.fontSize || systemconf.canvas.fontSize),
            _fontColor2 = getValByPriority(priorityArray, 'fontColor'),
            colIdx = chartObj.dataset.getColumnIdx(
            chartObj.isAxisCategory ||
            chartObj.isGeoMap ||
            chartObj.isNonAxisMultiSeriesCategory ||
            colorscale_helpers.isQuantileColorScale(chartObj) ?
            'clr' :
            'x'),

            showAs = data.showAs,
            colorBoxPosition = colorBoxOptions.position || 'left',
            expandable = data.expandable || {},
            legendExpandable = expandable.show === true,
            redrawing = !!chartObj.renderer.length,
            colorBoxSize = legend_helpers.getFilterBoxSize(colorBoxOptions, fontSize),
            colorBoxWidth = colorBoxSize[0],
            colorBoxHeight = colorBoxSize[1],
            legendAlign = getLegendAlignment(data),
            states = chartObj.legend.state["clr-".concat(order)] = chartObj.legend.state["clr-".concat(order)] || {
              allSelected: true,
              isFirstClickAfterDeselection: false
            },
            lineHeight = defined(colorBoxOptions.size) ? "".concat(
            mathMax(fontSize, colorBoxHeight), "px") :
            ($Browser.OSX || $Browser.LINUX) && $Browser.FIREFOX ?
            '1.2' :
            'normal',
            isColumnView = legendAlign.layout === 'horizontal',
            plotarea = simpleClone(chartObj.plotarea);

          chartObj.legend.states = chartObj.legend.state['clr-0'];

          // moved here from inner function
          var ImpFontProp = {
            fontColor: function fontColor(d) {
              return getClr(isDisabled(d, states.allSelected, states.isFirstClickAfterDeselection), _fontColor2, disabledOptions);
            },
            textDecoration: function textDecoration(d) {
              return isDisabled(d, states.allSelected, states.isFirstClickAfterDeselection) && disabledOptions.strikeout ?
              'line-through' :
              null;
            }
          };

          //text-overflow properties
          var item_textOverflow_properties;
          if (data.textOverflow === 'wrap') {
            item_textOverflow_properties = {
              'word-wrap': 'break-word',
              'white-space': 'normal',
              'vertical-align': 'top'
            };
          } else {
            item_textOverflow_properties = {
              'text-overflow': 'ellipsis',
              'vertical-align': 'middle'
            };
          }

          var container = d3_select(this);
          chart.update = function () {
            container.transition().call(chart);
          };
          var styleObj = {
            display: 'block',
            position: 'absolute',
            left: null, //Reset left and top position. so that floating legend won't get trimmedon redraw (legend-03.json)
            top: null
          };
          container.styles(styleObj);
          var wrap = appendEle(container, 'div', [data], '.', 'class', 'legendgroup');

          //shadow properties
          var shadow = data.shadow;
          if (shadow.show === true) {
            var shadowstyle = "".concat(shadow.x, "px ").concat(shadow.y, "px ").concat(shadow.blur, "px ").concat(shadow.color);
            shadowstyle = shadow.inset ? "".concat(shadowstyle, " inset") : shadowstyle;
            container.style('box-shadow', shadowstyle);
          } else {
            container.style('box-shadow', null);
          }

          //Background properties
          var rgb = d3_rgb(data.background.color.toString());
          container.style('background-color', "rgba(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ",").concat(data.background.alpha, ")"));

          //Border Properties
          var border = data.border;
          if (border.show === true) {
            container.styles({
              border: "".concat(+border.size, "px ").concat(border.style, " ").concat(border.color),
              'border-radius': "".concat(border.radius, "px")
            });
          } else {
            container.style('border', null);
          }

          //Legend title
          var title_data = data.title,
            keepLegendTitleAligned = title_data.keepAligned && isColumnView,
            titleMargin = defined(title_data.margin) ? title_data.margin : 3,
            legendText = title_data.text,
            titleAlignedStyles = {
              display: keepLegendTitleAligned ? 'inline-block' : null,
              'vertical-align': 'top'
            };

          var header = createElement('ul', '.zcheader', title_data.show === true ? [title_data] : [], wrap, ':first-child').styles(
          titleAlignedStyles);


          var headerLI = appendEle(header, 'li', [1], '.', 'class', 'zcheader');
          header.styles({
            'white-space': 'normal',
            overflow: 'hidden',
            width: '',
            'list-style-type': NONE,
            margin: 0,
            padding: 0
          });

          headerLI.styles({
            padding: shorthand_px(titleMargin),
            'white-space': 'nowrap',
            overflow: 'hidden',
            'text-align': 'left',
            'text-overflow': 'ellipsis',
            'vertical-align': 'middle'
          });

          var selectAllObj = legend.selectAllBox(headerLI, chartObj, states, order);
          var selectAllFilter = selectAllObj.element,
            selectAllBoxOptions = selectAllObj.options,
            selectAllFilterSize = selectAllObj.size,
            disabledOpacity = selectAllBoxOptions.disabledOpacity;

          if (!isFacet(chartObj)) {
            legend_helpers.fadeChart(states.allSelected, chartObj, disabledOpacity);
          }

          var legtitle = appendEle(headerLI, 'span', [1], '.', 'class', 'legendtitle');
          legtitle.
          style("padding-".concat(colorBoxPosition), selectAllBoxOptions.show ? "".concat(data.textPadding, "px") : null).
          style("margin-".concat(colorBoxPosition), selectAllBoxOptions.show ? "".concat(selectAllFilterSize, "px") : null);

          if (isFunction(legendText)) {
            legtitle.html(invokeFunction(legendText, chartObj));
          } else {
            legtitle.text(decodeHTML(legendText));
          }
          applyFont(legtitle, [title_data, systemconf.canvas, $ZCG], true);

          selectAllFilter.style('margin', function () {
            var top = "".concat(Math.max(0, (legtitle.node().offsetHeight - selectAllFilter.node().offsetHeight) / 2), "px");

            // The bellow lines are commented because of #ZC1538 & #ZC1510
            //     bottom = "0px",
            //     left = ((colorBoxWidth - selectAllFilterSize) / 2) + "px",
            //     right = ((colorBoxWidth - selectAllFilterSize) / 2) + "px";
            //     return top + " " + right + " " + bottom + " " + left;

            return "".concat(top, " 0px 0px 0px");
          });

          headerLI.style('line-height', function () {
            var selectAllFilterHeight = selectAllBoxOptions.show ? selectAllFilter.node().offsetHeight : 0;
            var headerLineHeight = Math.max(legtitle.node().offsetHeight, selectAllFilterHeight);
            return "".concat(headerLineHeight, "px");
          });

          var legseries = appendEle(wrap, 'ul', [data], '.', 'class', 'legseries');
          legseries.
          styles({
            'white-space': 'normal',
            'overflow-y': 'hidden',
            // "cursor": cursor,
            width: '',
            'list-style-type': NONE,
            margin: 0,
            padding: 0,
            '-webkit-overflow-scrolling': 'touch',

            // #ZC758
            // https://stackoverflow.com/questions/5256533/
            'font-size': '0px'
          }).
          styles(titleAlignedStyles);

          // set the ul to legend discrete helper to work
          // legendDiscreteHelper.setItemParent(legseries);

          // moved code to a function to render the legend list
          var renderLegendList = function renderLegendList(legData) {
            var series = appendEle(legseries, 'li', legData, '.', 'class', 'series');
            appendEle(series, 'div', [1], '.', 'class', 'legendfilterbox');
            appendEle(series, 'span', [1], '.', 'class', 'legendlabel');

            series.
            styles({
              color: function color(d) {
                return getClr(
                isDisabled(d, states.allSelected, states.isFirstClickAfterDeselection),
                _fontColor2,
                disabledOptions);

              },
              position: 'relative',
              'white-space': 'nowrap',
              padding: "".concat(+data.itemMargin, "px"),
              overflow: 'hidden',
              'text-align': 'left',
              'line-height': lineHeight,
              'font-size': "".concat(fontSize, "px"),
              // width: data.itemWidth == null || data.itemWidth == '' ? null : `${data.itemWidth}px`,
              width: itemWithIsNumber ? "".concat(data.itemWidth, "px") : null,
              height: data.itemHeight == null || data.itemHeight == '' ? null : "".concat(data.itemHeight, "px"),
              'font-family': getValByPriority(priorityArray, 'fontFamily'),
              'font-weight': getValByPriority(priorityArray, 'fontWeight'),
              display: function display(d) {
                return isHiddenItem(d) ? NONE : isColumnView ? 'inline-block' : 'block';
                // return isHiddenItem(d) ? NONE : (isColumnView ? "inline-block" : "inline-block");
              }
            }).
            styles(item_textOverflow_properties).
            style('vertical-align', 'top');

            legend.events(chartObj, series, states, disabledOpacity, order);

            var legendlabel = series.select('span.legendlabel');

            // #ZC1594
            //TODO itemWidth: auto should be supported for all.
            if (defined(showAs)) {
              legendlabel.styles({
                // #ZC2002
                display: pick(data.showAsDisplay, 'inline-block'),
                overflow: 'hidden'
              });
              if (defined(chart.legendLabelMaxWidth) && isAutoItemWidth) {
                legendlabel.style('width', chart.legendLabelMaxWidth + PX);
              }
            }

            legendlabel.
            style("padding-".concat(colorBoxPosition), "".concat(data.textPadding, "px")).
            style("margin-".concat(colorBoxPosition), "".concat(colorBoxWidth, "px")).
            html(function (d, i) {
              return legendDiscreteHelper.getLegendItemText(d, i);
            }).
            attr('title', function () {
              return data.tooltip ? this.textContent : null;
            });

            applyFont(legendlabel, [ImpFontProp, data, systemconf.canvas, $ZCG], true);

            // apply disabled showAs styles
            // #ZC1943
            if (defined(showAs)) {
              series.each(function (d) {
                // #ZC1872 -- apply only if the data is disabled
                if (isDisabled(d, states.allSelected, states.isFirstClickAfterDeselection)) {
                  applyFont(
                  d3_select(this).selectAll('.legendlabel, .legendlabel *'),
                  [
                  { fontColor: ImpFontProp.fontColor(d), textDecoration: ImpFontProp.textDecoration(d) },
                  data,
                  systemconf.canvas,
                  $ZCG],

                  true);

                }
              });
            }

            var labelHeight = series.select('span.legendlabel').node().offsetHeight,
              legendFilter = series.select('div.legendfilterbox'),
              margin_top = getColorBoxVerticalPosition(
              colorBoxOptions.vAlign,
              labelHeight,
              colorBoxHeight,
              fontSize,
              colorBoxOptions.size,
              data.textOverflow);


            legendFilter.styles({
              width: colorBoxWidth + PX,
              height: colorBoxHeight + PX,
              "float": colorBoxPosition,
              'margin-top': margin_top + PX, // ISSUE:ZC429 -> line-height will not be applied to float element
              'border-color': TRANSPARENT,
              'background-repeat': 'repeat',
              'line-height': colorBoxHeight - colorBoxOptions.strokeWidth + PX,
              'text-align': 'center',
              'font-family': colorBoxOptions.fontFamily,
              'font-size': (colorBoxOptions.fontSize || fontSize) + PX,
              position: 'absolute',
              display: 'inline-block',
              'box-sizing': 'border-box'
            });

            // background for colorBox
            legend.setColorBoxBackground(legendFilter, chartObj, states, order);
            return series;
          };

          // create the helpers
          var legendDiscreteHelper = helpers(
          chartObj,
          legseries,
          legData,
          legData_length,
          colorBoxSize,
          legendAlign,
          lineHeight,
          ImpFontProp);


          // title max with depends on the -> calculated legend max width
          // since the legend max width can change based on the layout, so we have put this as a function
          var getTitleMaxWidth = function getTitleMaxWidth(maxWidth) {
            return mathMin(
            perToPx(
            title_data.maxWidth || (
            keepLegendTitleAligned ? LEGEND_TITLE_MAX_WIDTH_HORIZONTAL : LEGEND_TITLE_MAX_WIDTH_VERTICAL),
            maxWidth),

            maxWidth);

          };

          // calcualate the temp height for max number of rows;
          var maxHeight = perToPx(
            data.maxHeight || (isColumnView ? ZC_LEGEND_maxHeightHoriRatio : ZC_LEGEND_maxHeightVertRatio),
            chartarea.height),

            maxWidth = perToPx(
            data.maxWidth || (isColumnView ? ZC_LEGEND_maxWidthHoriRatio : ZC_LEGEND_maxWidthVertRatio),
            chartarea.width);


          if (bound.adjust) {
            maxWidth = mathMin(bound.maxWidth || maxWidth, maxWidth);
            maxHeight -= getBoundingRect(header).height;
            maxHeight = mathMin(bound.maxHeight ? bound.maxHeight - getBoundingRect(header).height : maxHeight, maxHeight);
          }

          var maxWidthTitle = getTitleMaxWidth(maxWidth),
            rowsCount,
            tempDimension = legendDiscreteHelper.getItemDimension(legData[0]),
            tempLabelHeight = tempDimension.label.height,
            tempItemHeight = tempDimension.item.height,
            series = null,
            visibleItemCount = null,
            isAutoItemWidth = data.itemWidth === 'auto',
            itemWithIsNumber = typeof data.itemWidth === 'number',
            // TODO below line issue in bottom horizontal legend
            maxItemHeight = pick(data.itemHeight && +data.itemHeight, mathMax(tempLabelHeight, colorBoxHeight) + 2 * +data.itemMargin),
            headerDimension,
            headerWidth,
            scrollWid,
            constrainedMaxWidth,
            wrapMaxWidth = maxWidth;

          // [#ZC1999] if the max height is less than the item height change the max-height to the item height
          // TODO the same problem will occur in vertical layout and for non expandable legend too
          //  To fix it assign [maxHeight = mathMax(tempItemHeight, maxHeight);] directly with out the condition.
          // if (legendExpandable && isColumnView) {
          //     maxHeight = mathMax(tempItemHeight, maxHeight);
          // }
          if (legendExpandable && isColumnView) {
            maxHeight = mathFloor(maxHeight / tempItemHeight) * tempItemHeight;
            if (maxHeight < tempItemHeight) {
              maxHeight = tempItemHeight;
            }
          }

          // set if legend is scrollable
          chartObj.legend.hasScroll = legData_length * maxItemHeight > maxHeight;

          // set the max width
          wrap.style('max-width', "".concat(maxWidth, "px"));
          header.style('max-width', "".concat(maxWidthTitle, "px"));

          headerDimension = getBoundingRect(header);
          headerWidth = headerDimension.width;

          if (isColumnView) {
            // if user has not defined any width then subtract the margin and border
            var extraSpaces = +data.marginLeft + +data.marginRight + (data.border.show ? 2 * data.border.size : 0),
              allowedLegMaxWidth = chartObj.canvasarea.width - extraSpaces;

            if (maxWidth > allowedLegMaxWidth) {
              maxWidth = allowedLegMaxWidth;
            }

            // get the new legend maxWidth
            maxWidthTitle = getTitleMaxWidth(maxWidth);

            if (keepLegendTitleAligned) {
              maxWidth = maxWidth - headerWidth;
            }

            wrap.style('max-width', "".concat(maxWidth, "px"));
            header.style('max-width', "".concat(maxWidthTitle, "px"));
          }

          // test cases affected
          if (legendExpandable) {
            rowsCount = legendDiscreteHelper.getRowsCount(tempItemHeight, maxHeight);
            maxHeight = mathMin(rowsCount * tempItemHeight, maxHeight);

            if (bound.adjust) {
              var count = legendDiscreteHelper.getVisibleItemRenderCount(wrap, rowsCount, maxWidth, maxHeight, tempItemHeight),
                maxW = bound.maxWidth,maxH = bound.maxHeight;

              if (legData.length !== count) {
                var expandableAdjust = ExpandableAdjustFactor(expandable, maxW, maxH, globalFont, legendAlign, data.itemMargin);
                maxHeight -= expandableAdjust[1];
                maxHeight = mathMin(maxH ? maxH - expandableAdjust[1] : maxHeight, maxHeight);
              }
            }
          }

          legseries.styles({
            'max-width': maxWidth + PX,
            'max-height': maxHeight + PX
          });
          /**
           * *****************************************************************
           *                      itemWidth: auto                           *
           * *****************************************************************
           */

          // set the max item width possible
          chart.itemMaxWidth = null;
          chart.legendLabelMaxWidth = null;

          if (showAs && isAutoItemWidth) {
            var maxItemWidth = legendDiscreteHelper.getMaxItemWidth(legData);
            constrainedMaxWidth = mathMin(maxItemWidth, maxWidth);
            chart.itemMaxWidth = constrainedMaxWidth;
            // #ZC1904 subtract the itemMargin
            chart.legendLabelMaxWidth = constrainedMaxWidth - colorBoxWidth - data.itemMargin * 2;

            // windows wraps unnecessary with floating point in dimension on horizontal legend
            // so we are adding 2px to the max width for avoiding unnecessary wrap
            if ($Browser.WINDOWS && isColumnView) {
              var adjustMaxWidth = 2;
              legseries.style('max-width', "".concat(maxWidth + adjustMaxWidth, "px"));
            }
          }

          /**
           * *****************************************************************
           *                      Legend Expandable                          *
           * *****************************************************************
           */

          // get number of visible item count
          visibleItemCount = legendDiscreteHelper.getVisibleItemRenderCount(wrap, rowsCount, maxWidth, maxHeight, tempItemHeight);

          /* New Expandable
          let keepTitleAligned = title_data.keepAligned && isColumnView;
          let expandableSpec = {
              globalFont,
              bound,
              alignLegend,
              container,
              callbackArgs,
              padding: data.itemMargin,
              config: expandable,
              expanded: expandable._expanded,
              remainingCount: legData.length - visibleItemCount,
              isHorizontal: isColumnView,
              height: () => (keepTitleAligned ? mathMax(tempItemHeight, headerDimension.height) : tempItemHeight), // TODO: work
              target: () => legseries,
              margin: () => (keepTitleAligned && !expandable.keepAligned ? `0 0 0 ${headerWidth}` : 0),
              renderList: () => renderLegendList(legData),
              setLegendDimension: () => setLegendDimension(legseries.selectAll('li'))
          };
          let expandableObj = new Expandable(expandableSpec);
          expandableObj.create();
          expandableObj.draw(container);
          expandableObj.element.selectAll('.zc-expandable').style('font-size', `${utils.getVal(expandable.fontSize)}px`); // Actually this is an issue
          chart.expandableObj = expandableObj;
            if (visibleItemCount > 0 && !expandableObj.expanded()) {
              series = renderLegendList(legData.slice(0, visibleItemCount));
          } else {
              series = renderLegendList(legData);
          }
           var legendExpanded = expandableObj.expanded(),
          */




          var expandableUtils = expandableLegend(
            chartObj,
            wrap,
            legData,
            legseries,
            legData_length,
            maxWidth,
            maxHeight,
            isColumnView,
            headerWidth,
            renderLegendList,
            setLegendDimension,
            alignLegend,
            floating,
            container,
            chartarea,
            plotarea),

            remainingItemCount = mathMax(0, legData_length - visibleItemCount);

          if (legendExpandable && remainingItemCount > 0 && !chartObj.legend.allRendered) {
            series = renderLegendList(legData.slice(0, visibleItemCount));
          } else {
            series = renderLegendList(legData);
          }

          // #ZC1891, #ZC1952
          if (legendExpandable && remainingItemCount > 0) {
            expandableUtils.create(remainingItemCount);
          } else if (legendExpandable && remainingItemCount === 0 || !legendExpandable) {
            expandableUtils.remove();
          }

          // *********************
          var legendExpanded = chartObj.legend.expanded,
            activeRows = 1;

          scrollWid = elementIsScrollable(legseries) || legendExpandable && visibleItemCount < legData_length ? scrollbarwid : 0;

          function setLegendDimension(series) {
            if (isColumnView) {
              // horizontal align ------->

              // reset the dimension for auto calculation, if any
              legseries.styles({ width: null, height: null });

              // set the max width for each item. it will solve text overlapping issue.
              series.style('max-width', "".concat(maxWidth, "px"));

              // set the calculated max width in the wrap element,
              // so that when we set inline to the legseries[ul], it won't stress to the full width.
              // will reset after calculating the inline content width
              wrap.style('max-width', "".concat(maxWidth, "px"));

              // calculate the actual content width
              // previously we were calculating with each item and sum their width.

              // apply dummy style to get the content width
              // the border will set the max with to the parent
              legseries.styles({ display: 'inline', 'border-top': '1px solid' });

              var legendWidth = getBoundingRect(legseries).width;
              legseries.styles({ display: titleAlignedStyles.display, 'border-top': null });

              wrap.style('max-width', "".concat(wrapMaxWidth, "px")); // resetting it

              // do need the below 2 lines. to get rid of image diff setting the height.
              activeRows = mathRound(legseries.node().offsetHeight / maxItemHeight) || 1;
              legseries.style('height', "".concat(activeRows * maxItemHeight + 2, "px"));

              // check the scroll width after setting the height; // phantomjs issue
              scrollWid =
              elementIsScrollable(legseries) || legendExpandable && visibleItemCount < legData_length ? scrollbarwid : 0;

              // inline block needs and width. otherwise when it auto wraps, it sets the width to the max-width
              legseries.style('width', "".concat(legendWidth + scrollWid + 2, "px"));
            } else {
              // reset the width first
              legseries.style('width', null);

              // calculate the max item width
              var _legendWidth = getBoundingRect(legseries.style('display', 'inline-block')).width;
              legseries.style('display', titleAlignedStyles.display);
              legseries.style('width', "".concat(_legendWidth + scrollWid + 2, "px"));
              legseries.style('height', null);
            }
          }

          // set the legend dimension
          setLegendDimension(series);
          // then align the legend
          alignLegend(container, floating, maxWidth, maxHeight);

          // Add the overflow after calculating the dimension.
          // Because IE ads scroll bar on `overflow:auto` by default without checking max-[width,height].
          // So add overflow auto only if the scroll height is more than the offsetHeight [IE ONLY]

          var addOverFlowY = (legendExpandable && legendExpanded || !legendExpandable) === true;

          if ($Browser.IE && addOverFlowY) {
            addOverFlowY = legseries.node().scrollHeight - activeRows > legseries.node().offsetHeight;
          }

          legseries.style('overflow-x', 'hidden'); // this is not needed
          legseries.style('overflow-y', addOverFlowY ? 'auto' : 'hidden');
        });
        return chart;
      }

      chart.dispatch = dispatch;

      chart.chartarea = function (_) {
        if (!arguments.length) {
          return chartarea;
        }
        chartarea = simpleClone(_);
        return chart;
      };

      chart.systemconf = function (_) {
        if (!arguments.length) {
          return systemconf;
        }
        systemconf = _;
        return chart;
      };

      chart.chartObj = function (_) {
        if (!arguments.length) {
          return chartObj;
        }
        chartObj = _;
        return chart;
      };

      chart.color = function (_) {
        if (!arguments.length) {
          return color;
        }
        color = _;
        return chart;
      };

      function alignLegend(container) {var floating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var maxWidth = arguments.length > 2 ? arguments[2] : undefined;var maxHeight = arguments.length > 3 ? arguments[3] : undefined;
        var x = 0,
          y = 0;
        if (floating) {
          var _legend = systemconf.legend;
          var dimension = chartObj.legendarea.element.node().getBoundingClientRect();
          x = mathMin(chartObj.canvasarea.width - dimension.width, _legend.x);
          y = mathMin(chartObj.canvasarea.height - mathMin(dimension.height, maxHeight), _legend.y);
        } else {
          var position = getLegendPosition(chartarea, chartObj);
          x = position[0];
          y = position[1];
        }
        container.styles({
          left: "".concat(x, "px"),
          top: "".concat(y, "px")
        });
      }

      return chart;
    };

    /**
     *
     * @param legendPoint
     * @param chartInstance
     * @param states
     * @return {[]}
     */
    function getSankeyDependentPoint(legendPoint, chartInstance, states) {
      var sankeyLayout = chartInstance.dataObject.sankeyLayout,
        legendItemsMap = d3_map(chartInstance.cache.sankey.legendSankeyLayout.nodes, function (n) {return n.name;}),
        enableManually = !states.allSelected && !states.isFirstClickAfterDeselection || legendPoint.disabled,
        node = chartInstance.renderer[0].getSankeyNodeByPoint(legendPoint, legendItemsMap),
        enableList = [];

      if (enableManually) {
        [].concat(_toConsumableArray(node.sourceLinks), _toConsumableArray(node.targetLinks)).forEach(function (link) {
          enableList = [].concat(_toConsumableArray(enableList), _toConsumableArray(sankeyLayout.getConnectedNodes(link)));
        });
        enableList = getDistinct(enableList.map(function (node) {return node.point;}));
      }
      return enableList;
    }

    /**
     *
     * @param legendPoint
     * @param chartInstance
     * @return {[]}
     */
    function getEmptySankeyNode(legendPoint, chartInstance) {
      var layout = chartInstance.dataObject.sankeyLayout;
      var currentNode = chartInstance.renderer[0].getSankeyNodeByPoint(legendPoint),
        emptyNodes = [];

      if (currentNode) {
        var allConnectedPoints = layout.getAllConnectedPoints(currentNode, true),
          allConnectedLinks = allConnectedPoints.filter(function (p) {return p._type === 'link';}),
          allConnectedNodes = allConnectedPoints.filter(function (p) {return p._type === 'node';});

        allConnectedNodes.forEach(function (node) {
          if (node !== currentNode) {
            var links = [].concat(_toConsumableArray(node.sourceLinks), _toConsumableArray(node.targetLinks)).filter(function (link) {
              return !arrayIncludes(allConnectedLinks, link);
            });

            if (links.length === 0) {
              emptyNodes.push(node.point);
            }
          }
        });
      }

      return emptyNodes;
    }

    //$Id$

    var getLegendData$1 = legend_helpers.getLegendData,
      getLegendDataLength = legend_helpers.getLegendDataLength,
      isHiddenItem = legend_helpers.isHiddenItem,
      isDisabled$2 = legend_helpers.isDisabled,
      isItemDisabled = legend_helpers.isItemDisabled,
      isAllEnabled$1 = legend_helpers.isAllEnabled,
      getClr$2 = legend_helpers.getClr,
      updateData$1 = legend_helpers.updateData;

    legend.events = function (chartObj, element, states, disabledOpacity) {var _this27 = this;var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var legendComponent = chartObj.legend.component,
        legendOptions = chartObj.systemConf.legend,
        hoverOptions = getHoverOptions(legendOptions, 'clr'),
        disabledOptions = getDisabledOptions(legendOptions, 'clr'),
        colorBoxOptions = legendOptions.colorBox,
        priorityArray = [legendOptions, chartObj.systemConf.canvas, $ZCG],
        priorityArrayOnhover = [hoverOptions, legendOptions, chartObj.systemConf.canvas, $ZCG],
        fontColor = getValByPriority(priorityArray, 'fontColor'),
        legendFilter,
        selectAllFilter,
        legData,
        legData_length,
        chartName = chartObj.chartTypes[0].name,
        isSankeyChart = chartName === SANKEY_CHARTNAME,
        associatedData = [];

      /*
       * legend event variables
       */
      var events_legend = chartObj.systemConf.legend.events;
      var onClickFn, onDblClickFn, onMouseOverFn, onMouseOutFn, onTapFn, onTapHoldFn, onTapHoldEndFn, cursor, eventDisabled;
      if (events_legend != null) {
        eventDisabled = validateNullVal(events_legend.enabled, true) == false;
        onClickFn = events_legend.click;
        onDblClickFn = events_legend.doubleclick;
        onMouseOverFn = events_legend.mouseover;
        onMouseOutFn = events_legend.mouseout;
        cursor = events_legend.cursor;
        onTapFn = events_legend.tap;
        onTapHoldFn = events_legend.taphold;
        onTapHoldEndFn = events_legend.tapholdend;
      }

      if (!eventDisabled) {var _mouseHandlers;
        element.style('cursor', cursor || POINTER);

        var eventAttacherOptions = {
          chartObj: chartObj
        };
        var mousemove = function mousemove(d, i) {
            $ZCG.clickedTime = null;
            if (onMouseOverFn == null) {
              defaultOnMouseOverFunc(this, d, i);
            } else {
              var userFunction = chartObj.zcEventType ? onTapHoldFn : onMouseOverFn;
              invokeFunction(userFunction, d3_event(), d, i, chartObj);
            }
          },
          mouseout = function mouseout(d, i) {
            if (onMouseOutFn == null) {
              defaultOnMouseOutFunc(this, d, i);
            } else {
              var userFunction = chartObj.zcEventType ? onTapHoldEndFn : onMouseOutFn;
              invokeFunction(userFunction, d3_event(), d, i, chartObj);
            }
          },
          click = function click(d, i) {
            var isTouchEvent = d3_event() && d3_event().touches;
            if (isTouchEvent) {
              docTapFunction();
            }
            if (onClickFn == null) {
              defaultOnClickFunc(this, d, i);
            } else {
              var userFunction = chartObj.zcEventType ? onTapFn : onClickFn;
              invokeFunction(userFunction, d3_event(), d, i, chartObj);
            }
          },
          dblclick = function dblclick(d, i) {
            if (onDblClickFn == null) ;else {
              invokeFunction(onDblClickFn, d3_event(), d, i, chartObj);
            }
          };

        var _tempEventName = $Browser.PHANTOMJS ?
        {
          move: 'mousemove',
          out: 'mouseout'
        } :
        {
          move: 'mouseenter',
          out: 'mouseleave'
        };

        var mouseHandlers = (_mouseHandlers = {}, _defineProperty(_mouseHandlers,




          _tempEventName.move, mousemove), _defineProperty(_mouseHandlers,
          _tempEventName.out, mouseout), _defineProperty(_mouseHandlers, "click",
          click), _defineProperty(_mouseHandlers, "dblclick",
          dblclick), _mouseHandlers),

          touchHandlers = {
            taphold: mousemove,
            tapholdend: mouseout,
            tap: click,
            dbltap: dblclick
          };
        attachevents(element, mouseHandlers, touchHandlers, eventAttacherOptions);

        var callCustomHandler = function callCustomHandler(eventType, targetEvent, d, i, element) {
          if (events_legend && events_legend[eventType]) {
            invokeFunction(events_legend[eventType], targetEvent, d, i, chartObj, element);
          }
        };

        if (customGestureList) {
          var gestureKeys = Object.keys(customGestureList),
            _CustomGesture3 = Registry.getComponent('CustomGesture');
          gestureKeys.map(function (d) {
            _CustomGesture3.call(_this27, d, element, 'legend', callCustomHandler);
          });
        }
      }

      function defaultOnClickFunc(ele, d, i) {
        legendComponent.toggleItemNUpdateChart(ele, d, i, legendOptions);
      }

      function defaultOnMouseOverFunc(ele, d, i) {
        legendComponent.highlightSeries(ele, d, i, legendOptions, chartObj, true);
        legendComponent.highlightItem(ele, d, i, legendOptions, true);
      }

      function defaultOnMouseOutFunc(ele, d, i) {
        legendComponent.highlightSeries(ele, d, i, legendOptions, chartObj);
        legendComponent.highlightItem(ele, d, i, legendOptions);
      }

      legendComponent.filterSeriesNUpdate = function (d, i, chartObj) {
        var indices = splat(i),
          legendFilterAllowed = allowLegendFilter(d, i);

        initLegendData();

        if (isAlldisabled(indices, legendFilterAllowed) || !legendFilterAllowed) {
          return;
        }

        indices.forEach(function (i) {
          if (hasAssociatedLegendData(chartObj)) {
            var gridList = getGridList(chartObj.dataObject),
              count = -1;

            gridList.forEach(function (grid, _gridIndex) {
              var layer = grid.layer;

              grid.data.forEach(function (_d, _i) {
                count++;
                if (
                (!chartObj.userdata.facets.color.length || layer === order) &&
                chartObj.rendererConf[count].legendIndex() === i)
                {
                  _d.node.filtered = !_d.node.filtered;
                }

                if (layer === order) {
                  legData[chartObj.rendererConf[count].legendIndex()].filtered = _d.node.filtered;
                }
              });
            });
            //TODO: check bubblepie
          } else {
            var d = legData[i];
            d.disabled = !d.disabled;

            if (chartObj.dataObject.hierarchical && !colorscale_helpers.isQuantileColorScale(chartObj)) {
              chartObj.systemConf.seriesdata.chartdata[i].disabled = d.disabled;
            }

            updateData$1(d, i, chartObj);
          }
        });

        var distinctAxes = getDistinctAxes(indices);
        distinctAxes.forEach(function (i) {
          var dt = legData[i];
          chartObj.addRemoveSeries(dt, i, dt.yaxiscolumnorder, !states.allSelected && !states.isFirstClickAfterDeselection);
        });
        updateStates();
      };

      legendComponent.toggleItemNUpdateChart = function (ele, d, i, legendOptions) {
        var indices = splat(i);
        legendFilter = legendFilter || getLegendContainer(chartObj, "clr-".concat(order)).selectAll('div.legendfilterbox');

        if (isLegendFilterEnabled()) {
          var highlightObj = getLegendHighlightComp();
          highlightObj.resetSelection();
          legendComponent.filterSeriesNUpdate(d, indices, chartObj);

          // Reset the hoverstyle for disabled series; strictApply=true
          var disabledIndices = indices.filter(function (i) {return isItemDisabled(legData[i]);});
          legendComponent.highlightItem(ele, d, disabledIndices, legendOptions, false, true);

          // update all the connected labels
          if (isSankeyChart) {
            var _indices2 = legData.map(function (l) {return l.itemIndex;});
            legendComponent.updateLabel(_indices2);
          } else {
            // Paint legend labels
            legendComponent.updateLabel(indices);
          }

          // update the colorBox
          legend.setColorBoxBackground(legendFilter, chartObj, states, order);

          // Mouse actions for non-touch devices
          if (d3_event() && !d3_event().touches) {
            if (chartObj.plot.renderer.mode === 'canvas') {
              legendComponent.highlightSeries(ele, d, indices, legendOptions, chartObj); //reset canvas' unhighlighted effects
            }

            var mouseAction = isItemDisabled(legData[indices[0]]) ? defaultOnMouseOutFunc : defaultOnMouseOverFunc;
            mouseAction(ele, d, indices);
          }
        }

        updateSelectAllBox();
      };

      legendComponent.highlightItem = function (ele, d, i, legendOptions, onLegHover, strictApply) {
        var indices = splat(i);
        initLegendData();

        indices.forEach(function (index) {
          var d = legData[index],
            ele = getLegendItem(index).node();

          _highlightItem(ele, d, index, legendOptions, onLegHover, strictApply);
        });
      };

      function _highlightItem(ele, d, i, legendOptions, onLegHover, strictApply) {
        if (strictApply || !isDisabled$2(d, states.allSelected, states.isFirstClickAfterDeselection)) {
          var hoverOptions = getHoverOptions(legendOptions, 'clr');

          if (!isEmptyObject(hoverOptions)) {
            var filteredEle = d3_select(ele),
              legendLabel = filteredEle.selectAll('.legendlabel'),
              backgroundColor = (onLegHover ? hoverOptions : legendOptions).backgroundColor;
            filteredEle.style('background-color', backgroundColor);
            if (!onLegHover && defined(legendOptions.showAs)) {
              legendLabel.html(getLegendShowAsText(d, i, legendOptions, chartObj));
            }
            applyFont(
            filteredEle.selectAll(onLegHover ? '.legendlabel, .legendlabel *' : '.legendlabel'),
            onLegHover ? priorityArrayOnhover : priorityArray,
            true);

          }
        }
      }

      legendComponent.highlightSeries = function (ele, d, i, legendOptions, chartObj, onLegHover) {
        var highlightObj = getLegendHighlightComp();
        chartObj.highlightContext = null;
        legendComponent.handlePreviousHighlight.apply(legendComponent, arguments);

        if (colorscale_helpers.isQuantileColorScale(chartObj)) {
          var filterIndex = i;
          if (isFacet(chartObj)) {
            if (onLegHover) {
              if (!isItemDisabled(d)) {
                highlightObj.highlightSelectedSeries(legendOptions, 0, filterIndex);
                highlightObj.highlightUnselectedSeries(legendOptions, 0, filterIndex);
              }
            } else {
              highlightObj.reset(legendOptions, 0, filterIndex);
            }
          } else {
            if (onLegHover) {
              if (!isItemDisabled(d)) {
                chartObj.seriesdata.forEach(function (d, j) {
                  highlightObj.highlightSelectedSeries(legendOptions, j, filterIndex);
                  highlightObj.highlightUnselectedSeries(legendOptions, j, filterIndex);
                });
              }
            } else {
              chartObj.seriesdata.forEach(function (d, j) {
                highlightObj.reset(legendOptions, j, filterIndex, chartObj.seriesdata.length - 1 === j);
              });
            }
          }
        } else {
          if (onLegHover) {
            if (!isItemDisabled(d)) {
              highlightObj.highlightSelectedSeries(legendOptions, i);
              highlightObj.highlightUnselectedSeries(legendOptions, i);
            }
          } else {
            highlightObj.reset(legendOptions, i);
          }
        }
      };

      legendComponent.updateLabel = function (i) {
        var indices = splat(i);
        indices.forEach(function (index) {return _updateLabel(index);});
      };

      legendComponent.handlePreviousHighlight = function () {
        var highlightObj = getLegendHighlightComp(),
          prev = highlightObj.prevData,
          toggleIndex = 5,
          onLegHover = arguments[toggleIndex];

        // ZC1758: Reset previous highlight effects
        if (onLegHover && prev) {
          prev[toggleIndex] = false;
          highlightObj.prevData = NULL$1;
          legendComponent.highlightSeries.apply(legendComponent, prev);
        }
        highlightObj.prevData = onLegHover ? arguments : NULL$1;
      };

      function _updateLabel(i) {
        var d = legData[i],
          legendItem = getLegendItem(i),
          labelFontColor = getClr$2(isItemDisabled(d), fontColor, disabledOptions),
          labelDecoration = isItemDisabled(d) && disabledOptions.strikeout ? 'line-through' : null;

        legendItem.selectAll('.legendlabel, .legendlabel *').styles({
          color: labelFontColor,
          'text-decoration': labelDecoration
        });

        // for custom legend, while enabling legend items, get the source from the user.
        // because user might set some different colors and can have different hierarchy
        if (!isItemDisabled(d) && legendOptions.showAs) {
          legendItem.selectAll('.legendlabel').html(getLegendShowAsText(d, i, legendOptions, chartObj));
        }
      }

      function getLegendItem(i) {
        return d3_select(element.nodes()[i]);
      }

      function initLegendData() {
        if (legData) {
          return;
        }

        //If legend is disabled, legData will not be available
        legData = getLegendData$1(chartObj, order);
        legData_length = getLegendDataLength(chartObj, legData);

        if (hasAssociatedLegendData(chartObj)) {
          var gridList = getGridList(chartObj.dataObject),
            count = -1;

          gridList.forEach(function (grid, _gridIndex) {
            var layer = grid.layer;

            grid.data.forEach(function (_d, _i) {
              count++;
              if (layer === order) {
                var legendIndex = chartObj.rendererConf[count].legendIndex();
                associatedData[legendIndex] = associatedData[legendIndex] || [];
                associatedData[legendIndex].push(_d);
              }
            });
          });
        }
      }

      function updateStates() {
        if (!states.allSelected && !states.isFirstClickAfterDeselection) {
          states.isFirstClickAfterDeselection = true;
        }
      }

      function isAlldisabled(indices, legendFilterAllowed) {
        var sankeyDependentPoints,
          sankeyEmptyNodes,
          currentLegendPoint = legData[indices[0]],
          enabling = isItemDisabled(currentLegendPoint) === true;

        if (isSankeyChart) {
          sankeyDependentPoints = getSankeyDependentPoint(currentLegendPoint, chartObj, states);
          sankeyEmptyNodes = getEmptySankeyNode(currentLegendPoint, chartObj).filter(function (p) {return !arrayIncludes(sankeyDependentPoints, p);});
        }

        var disabledEle = legData.filter(function (d, j) {
            if (!states.allSelected && !states.isFirstClickAfterDeselection) {
              // sankey dependent points check
              if (associatedData && associatedData.length) {
                associatedData[j].forEach(function (_d) {return _d.node.filtered = !states.allSelected;});
              } else if (isSankeyChart && currentLegendPoint !== d) {
                d.disabled = !arrayIncludes(sankeyDependentPoints, d);
              } else {
                d.disabled = !states.allSelected;
              }

              updateData$1(d, j, chartObj);
              legend_helpers.toggleChartEvents(chartObj, true);
              legend_helpers.fadeChart(true, chartObj, disabledOpacity, true, order);
              chartObj.eventHandler.tooltipElement.hide();
            }

            if (isSankeyChart && currentLegendPoint !== d && legendFilterAllowed) {
              if (enabling) {
                if (d.disabled) {
                  d.disabled = !arrayIncludes(sankeyDependentPoints, d);
                }
              } else {
                if (!d.disabled) {
                  d.disabled = arrayIncludes(sankeyEmptyNodes, d);
                }
              }
            }

            return !isHiddenItem(d) && isItemDisabled(d);
          }),
          disableCheck = function disableCheck(i) {
            var d = legData[i];
            return !isItemDisabled(d);
          },
          activeCheck = function activeCheck(i) {
            var d = legData[i];
            return !isHiddenItem(d);
          },
          activeItems = indices.filter(activeCheck);

        return disabledEle.length == legData_length - activeItems.length && activeItems.every(disableCheck);
      }

      /**
       *
       * @param point
       * @return {boolean}
       */
      function allowLegendFilter(point) {
        // #ZC2653 allow legend click after first click after select all deselection
        if (!states.allSelected && !states.isFirstClickAfterDeselection) {
          return true;
        } else if (isSankeyChart && !point.disabled) {
          var node = chartObj.renderer[0].getSankeyNodeByPoint(point),
            linkLength = chartObj.dataObject.sankeyLayout.linkLength,
            totalConnectedLinks = node.sourceLinks.length + node.targetLinks.length;

          return linkLength > totalConnectedLinks;
        }
        return true;
      }

      function updateSelectAllBox() {
        if (!states.allSelected) {
          states.allSelected = !states.allSelected;
        }

        selectAllFilter = selectAllFilter || getLegendContainer(chartObj, "clr-".concat(order)).selectAll('div.selectAll');

        if (!selectAllFilter.empty()) {
          initLegendData(); // ZC1435
          selectAllFilter.html(
          isAllEnabled$1(legData, states.allSelected) ? colorBoxOptions.text || '&#10003;' : (disabledOptions.colorBox || {}).text || '');

        }
      }

      /**
       *
       * Manually disabling the legend filter for this milestone
       * @return {boolean|*}
       */
      function isLegendFilterEnabled() {
        return legendOptions.filter.enabled;
      }

      function getDistinctAxes(indices) {
        if (chartObj.ismultiy) {
          var set = d3_set();
          return indices.filter(function (i) {
            var dt = legData[i],
              key = DataProcessor.helpers.getParsedYAxisOrder(dt.yaxiscolumnorder);

            if (set.has(key)) {
              return false;
            } else {
              set.add(key);
              return true;
            }
          });
        } else {
          return splat(indices[0]);
        }
      }

      function getLegendHighlightComp() {
        if (isFacet(chartObj)) {
          return chartObj.legends.get("clr-".concat(order)).highlightManager || chartObj.legendHighlight;
        }

        return chartObj.legendHighlight;
      }
    };var

    ColorLegendList = /*#__PURE__*/function (_ColorLegend2) {_inherits(ColorLegendList, _ColorLegend2);var _super7 = _createSuper(ColorLegendList);function ColorLegendList() {_classCallCheck(this, ColorLegendList);return _super7.apply(this, arguments);}return _createClass(ColorLegendList);}(ColorLegend);

    // import { renderDom } from '../../../mark/dom-render';
    // import { NULL } from '../../../core/zc-constants';
    // import { ListLegend } from '../../list-legend/list-legend';
    // import { d3_scaleOrdinalOrg } from '../../../core/d3-constants';
    // import { ColorListAdapter } from './color-list-helper';
    //
    // export class ColorLegendList extends ColorListAdapter {
    //     constructor(spec) {
    //         super(spec);
    //         spec.config = {
    //             ...spec.config,
    //             list: {
    //                 marker: { ...spec.config.colorBox },
    //                 label: {
    //                     ...spec.config
    //                 }
    //             }
    //         };
    //
    //         this.spec = spec;
    //     }
    //     create() {
    //         let depends = this.get();
    //         this.spec.data = depends.ticks;
    //         this.spec.format = depends.format;
    //
    //         this.spec.scaleComponent = {
    //             getScale: () => d3_scaleOrdinalOrg().domain(this.spec.data),
    //             schema: {
    //                 domain: {
    //                     ranges: this.spec.data
    //                 },
    //                 data: {
    //                     meta: { datatype: 'ordinal' },
    //                     dataType: 'ordinal'
    //                 }
    //             }
    //         };
    //
    //         this.spec.config.list.marker.fillColor = depends.color;
    //
    //         let viewObj = new ListLegend(this.spec, this.viewScaleComponent);
    //         let encode = (this.encode = viewObj.create());
    //
    //         return encode;
    //     }
    //     draw(parent) {
    //         parent.styles({
    //             display: 'block',
    //             position: 'absolute',
    //             left: NULL, //Reset left and top position. so that floating legend won't get trimmedon redraw (legend-03.json)
    //             top: NULL
    //         });
    //         renderDom(this.encode, parent);
    //         this.parent = parent;
    //     }
    //
    //     resize(width, height) {
    //         this.parent.styles({
    //             height: `${height}px`,
    //             width: `${width}px`,
    //             overflow: 'hidden'
    //         });
    //     }
    // }

    ColorLegendList.encode = 'clr';
    ColorLegendList.view = 'list';
    ColorLegendList.domMode = 'html';

    Registry.setComponent('colorLegendList', ColorLegendList);
    LegendRegistry.add(ColorLegendList);

    function ExpandableListener(d, i, ele, eventType) {
      var manager = this;
      manager.associateBehaviours(eventType, manager.selectionManager);
    }

    //

    function ExpandableParser(spec) {
      var _helper = helper$9(spec),
        show = _helper.show,styles = _helper.styles,html = _helper.html,expanded = _helper.expanded,config = _helper.config,onEnd = _helper.onEnd;

      var expandableMark = Mark(DIV_ELEMENT, ".".concat(EXPANDABLE_CLASSNAME), show ? [1] : []);
      expandableMark.config = _objectSpread(_objectSpread({}, config), {}, { html: html(expanded) });
      expandableMark._parser = _helper;
      expandableMark._spec = spec; // TODO: check
      expandableMark.onEnd = onEnd;
      setPropVal(expandableMark, 'properties.styles', styles);
      expandableState(expandableMark, expanded);

      return expandableMark;
    }

    function helper$9(spec) {
      var
        config =









        spec.config,_spec$margin = spec.margin,_margin2 = _spec$margin === void 0 ? 0 : _spec$margin,bound = spec.bound,height = spec.height,_spec$padding = spec.padding,padding = _spec$padding === void 0 ? 3 : _spec$padding,target = spec.target,remainingCount = spec.remainingCount,_spec$callbackArgs2 = spec.callbackArgs,callbackArgs = _spec$callbackArgs2 === void 0 ? [] : _spec$callbackArgs2,_spec$expanded = spec.expanded,expanded = _spec$expanded === void 0 ? false : _spec$expanded,isHorizontal = spec.isHorizontal,
        show = config.show,textAlign = config.textAlign,ontoggle = config.ontoggle,text = config.text,keepAligned = config.keepAligned,
        keepExpandableAligned = keepAligned && isHorizontal,
        html = getContent,
        styles = {
          display: keepExpandableAligned ? 'inline-block' : 'block',
          padding: "".concat(padding, "px"),
          margin: function margin() {return shorthand_px(invokeFunction(_margin2));},
          'text-align': keepExpandableAligned ? null : textAlign, // TODO: Text align for horizontal
          'max-width': "".concat(bound.maxWidth, "px"),
          'line-height': keepExpandableAligned && height ? function () {return "".concat(height(), "px");} : null,
          cursor: POINTER,
          overflow: 'hidden',
          'text-overflow': 'ellipsis',
          'white-space': 'nowrap'
        },
        onEnd = function onEnd(ele) {
          var _target = target(),
            scrollType = isHorizontal ? 'scrollLeft' : 'scrollTop';

          // On reverse hover scrollTop | scrollLeft will be change. Reset here
          _target.node()[scrollType] = 0;

          if (show) {
            _target.style('overflow', 'hidden');
          } else if (!ele.empty()) {
            ele.remove();
            _target.styles({
              'overflow-x': 'hidden',
              'overflow-y': 'hidden'
            });
          }
        };

      show = show && remainingCount > 0;

      return { show: show, styles: styles, html: html, expanded: expanded, config: config, onEnd: onEnd };

      //
      function getContent(expanded, update) {
        return function () {
          if (expanded) {
            var _toggleText = invokeFunction.apply(void 0, [ontoggle, this, expanded, remainingCount].concat(_toConsumableArray(callbackArgs)));

            return _toggleText || 'Show less..';
          } else {
            var _toggleText2 = update ? invokeFunction.apply(void 0, [ontoggle, this, expanded, remainingCount].concat(_toConsumableArray(callbackArgs))) : null,
              _text = invokeFunction.apply(void 0, [text, remainingCount].concat(_toConsumableArray(callbackArgs)));

            return _toggleText2 || _text || "".concat(remainingCount, " more...");
          }
        };
      }
    }

    function expandableState(parser, _) {
      if (defined(_)) {
        setPropVal(parser, 'cache.expanded', _);
      } else {
        return pick(parser.cache.expanded, false);
      }
    }
    Registry.setComponent('expandable.parser', ExpandableParser);

    //

    function SetState() {
      var manager = this,
        options = manager.options,
        config = options.config,markParser = options.markParser,
        expandableConfig = config.list.expandable,
        expanded = expandableState(markParser);

      expandableState(markParser, !expanded);
      expandableConfig._expanded = !expanded; // TODO: change
    }

    //

    function UpdateLegendAndPlot() {
      var manager = this,
        chart = manager.chart,options = manager.options,
        legendInstance = options.legendInstance,markParser = options.markParser,
        element = legendInstance.element;

      var expanded = expandableState(markParser),
        allRendered = markParser.allRendered; // TODO: check

      if (allRendered || !expanded) {
        return;
      }

      var isHorizontal = markParser._spec.isHorizontal,
        side = isHorizontal ? 'height' : 'width',
        isSVG = isSvgElement(element),
        oldBound = isSVG ? bbox(element) : getBoundingRect(element);

      updateLegend(element, markParser, chart);

      var newBound = isSVG ? bbox(element) : getBoundingRect(element);

      if (mathAbs(newBound[side] - oldBound[side]) > 1) {
        var colorLegend = chart.legends.get('clr-0');
        chart.legendarea = getLegendArea(chart, colorLegend); // Adapting old method // TODO: Remove
        updatePlot(chart);
      }

      markParser.allRendered = true;
    }

    function updateLegend(element, markParser, chart) {
      var _markParser$_spec = markParser._spec,renderList = _markParser$_spec.renderList,setLegendDimension = _markParser$_spec.setLegendDimension,alignLegend = _markParser$_spec.alignLegend;

      element.styles({
        left: null,
        top: null
      });

      invokeFunction(renderList);
      invokeFunction(setLegendDimension);

      chart.chartarea = simpleClone(chart._chartarea);
      chart.plotarea = simpleClone(chart._plotarea);

      if (chart.legend.isSingleLayout) {
        invokeFunction(alignLegend, element);
      } else {
        legend.align(chart.legends, chart, chart.chartarea, chart.plotarea);
      }
    }

    function updatePlot(chart) {
      if (chart.legend.isSingleLayout) {
        chart.updatePlotArea();
        updateChartAndPlotBound(chart, true);
      }

      if (chart.isAxisCategory) {
        axis.render(chart, chart.chartWidth, chart.chartHeight, true);
      } else if (chart.dataObject.isPolarAxisCategory) {
        axis.polar.render(chart, 'x');
      }
      chart.drawThreshold(true);
      chart.drawPlotareaClippath();
      chart.updatePlotareaProp();
      chart.plot.renderer.draw(true);

      if (chart.isAxisCategory || chart.dataObject.isPolarAxisCategory) {
        chart.positionEventTrackerElement();
      }
    }

    //

    function StyleElement() {
      var manager = this,
        options = manager.options,
        markParser = options.markParser,trackerElement = options.trackerElement,expandableParser = options.expandableParser,
        expanded = expandableState(markParser),
        isHorizontal = markParser._spec.isHorizontal,

        overflowType = isHorizontal ? 'x' : 'y',
        scrollType = isHorizontal ? 'scrollLeft' : 'scrollTop',
        html = expandableParser.html,
        target = markParser._spec.target,
        _target = target();

      trackerElement.html(html(expanded, true));

      if (expanded) {
        _target.style("overflow-".concat(overflowType), 'auto');
      } else {
        _target.node()[scrollType] = 0;
        _target.style("overflow-".concat(overflowType), 'hidden');
      }
    }

    //
    function UpdateLegendEvent() {
      var manager = this,
        chart = manager.chart,options = manager.options,
        legendInstance = options.legendInstance;

      chart.legendEvents.initiateBehaviour('SIZE_LIST', legendInstance);
    }

    //

    var _legendExpandableHandlers = {
      LISTENER: {
        click: ExpandableListener,
        tap: ExpandableListener
      },
      BEHAVIOUR: {
        click: [ClearCache, SetState, StyleElement, UpdateLegendAndPlot, UpdateLegendEvent],
        tap: [ClearCache, SetState, StyleElement, UpdateLegendAndPlot, UpdateLegendEvent]
      },
      SUPPORTED: function SUPPORTED(chart, id) {
        return id === 'z-0' && isSupported(LIST_LEGEND_TYPE)(chart, id);
      }
    };
    Registry.setComponent('_legendExpandableHandlers', _legendExpandableHandlers);

    //

    /**
     *
     * @param chart
     * @return {Legend Event options}
     */
    function _legendExpandableEventArguments(chart, id) {
      var legendInstance = chart.legends.get(id),
        component = legendInstance.component,meta = legendInstance.meta,element = legendInstance.element,
        config = meta.config,globalFont = meta.globalFont,

        trackerElement = getTrackerElement$2(element),
        expandableParser,
        enabled = legendInstance.enabled;

      if (enabled) {
        expandableParser = component.encode.children[2]._parser; //TODO: code clean
        enabled = expandableParser.show;
      }

      return { enabled: enabled, trackerElement: trackerElement, config: config, globalFont: globalFont, expandableParser: expandableParser, legendInstance: legendInstance, markParser: component.encode.children[2] };
    }

    /**
     * Returns tracker element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getTrackerElement$2(container) {
      return container.selectAll("div.".concat(EXPANDABLE_CLASSNAME));
    }
    Registry.setComponent('_legendExpandableEventArguments', _legendExpandableEventArguments);

    //

    var shapeListOptions = function shapeListOptions(userProp) {
      return {
        marker: {
          hAlign: CENTER_ALIGN,
          vAlign: CENTER_ALIGN,
          fillColor: TRANSPARENT,
          strokeColor: '#808080'
        },
        label: {
          fontSize: userProp.fontL1Size.l5,
          padding: 5,
          keepAligned: true
        }
      };
    };

    Registry.setComponent('shapeListOptions', shapeListOptions);

    //

    defaultTheme.shapeLegend = function (userProp) {
      var listOptions = Registry.getComponent('shapeListOptions')(userProp);

      return {
        enabled: true,
        hAlign: RIGHT_ALIGN, //left, right, center
        vAlign: TOP_ALIGN, //top, center, bottom
        layout: VERTICAL_ALIGN,
        itemMargin: 3,
        marginTop: 10,
        marginRight: 10,
        marginBottom: 10,
        marginLeft: 10,
        title: {
          show: false,
          text: 'Legend',
          fontSize: userProp.fontL1Size.l4
        },
        background: {
          color: TRANSPARENT,
          alpha: 0
        },
        border: {
          show: true,
          size: 1,
          style: 'solid',
          radius: 0,
          color: TRANSPARENT
        },
        shadow: {
          show: false,
          color: 'rgba(0,0,0,0.3)',
          x: 2,
          y: 2,
          blur: 3,
          inset: false
        },
        highlightEffect: {
          selectedSeries: null,
          unselectedSeries: 'none'
        },
        list: listOptions,
        hoverOptions: {},
        filter: {
          enabled: true
        }
      };
    };

    //$Id$

    // TODO: work with config. remove 'background-color' with 'fillColor'
    function LegendBackgroundHtmlParser(spec) {
      var config = spec.config,
        backgroundSpec = parseBackground$1(config.background),
        borderSpec = parseBorder$1(config.border),
        shadowSpec = parseShadow(config.shadow);

      return _objectSpread(_objectSpread(_objectSpread({},
      backgroundSpec),
      borderSpec),
      shadowSpec);

    }

    function parseBackground$1() {var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _config$color2 = config.color,color = _config$color2 === void 0 ? TRANSPARENT : _config$color2,alpha = config.alpha,
        rgb = d3_rgb(color.toString());

      return { 'background-color': "rgba(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ",").concat(alpha, ")") };
    }

    function parseBorder$1() {var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var show = config.show,size = config.size,style = config.style,color = config.color,radius = config.radius;

      if (show) {
        return {
          border: "".concat(+size, "px ").concat(style, " ").concat(color),
          'border-radius': "".concat(radius, "px")
        };
      }

      return { border: NULL$1 };
    }

    function parseShadow() {var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var show = config.show,x = config.x,y = config.y,blur = config.blur,color = config.color,inset = config.inset;

      if (show) {
        return { 'box-shadow': "".concat(x, "px ").concat(y, "px ").concat(blur, "px ").concat(color).concat(inset ? ' inset' : '') };
      }

      return { 'box-shadow': NULL$1 };
    }

    //

    function markerDataURI(config, scale, advanced) {
      return function (d) {
        var width = scale.width ? scale.width(d) : scale(d),
          height = scale.height ? scale.height(d) : scale(d),
          dataURI = _getHTML4SVGSymbol(width, height, config);

        if (advanced) {
          return getSVGSymbolString(dataURI, width, height);
        } else {
          return dataURI;
        }
      };
    }

    function _getHTML4SVGSymbol(width, height, markerConfig) {
      var _markerConfig$fillCol = markerConfig.fillColor,fillColor = _markerConfig$fillCol === void 0 ? TRANSPARENT : _markerConfig$fillCol,_markerConfig$strokeC = markerConfig.strokeColor,strokeColor = _markerConfig$strokeC === void 0 ? TRANSPARENT : _markerConfig$strokeC,_markerConfig$shape = markerConfig.shape,shape = _markerConfig$shape === void 0 ? 'square' : _markerConfig$shape;

      return getHTML4SVGSymbol(width, height, strokeColor, fillColor, shape, markerConfig, true);
    }

    function markerBackground(boxConfig, boxSize) {
      var _boxConfig$fillColor = boxConfig.fillColor,fillColor = _boxConfig$fillColor === void 0 ? TRANSPARENT : _boxConfig$fillColor,_boxConfig$strokeColo = boxConfig.strokeColor,strokeColor = _boxConfig$strokeColo === void 0 ? TRANSPARENT : _boxConfig$strokeColo,strokeWidth = boxConfig.strokeWidth,borderRadius = boxConfig.borderRadius,_boxConfig$shape = boxConfig.shape,shape = _boxConfig$shape === void 0 ? 'square' : _boxConfig$shape,
        useSVGImage = shape !== 'square' && shape !== 'rect',
        border,
        background;

      if (useSVGImage) {
        background = markerDataURI(boxConfig, boxSize, true);
        border = NONE;
        borderRadius = NULL$1;
      } else {
        background = fillColor;
        border = function border(d, i) {return "".concat(pick(strokeWidth, 1), "px solid ").concat(invokeFunction(strokeColor, d, i));};
        borderRadius = defined(borderRadius) ? "".concat(borderRadius, "px") : NULL$1;
      }

      return _defineProperty({ background: background, border: border }, 'border-radius', borderRadius);
    }

    function getBoxSize(boxConfig, labelConfig, align, scale, fontSize) {
      var size = _size$1(scale, boxConfig, fontSize),
        overflow = getBoxOverfow(boxConfig, labelConfig, align),
        width = boxConfig.width,height = boxConfig.height,shape = boxConfig.shape,
        totalWidth,
        totalHeight,
        clientWidth,
        clientHeight;

      if (overflow) {
        totalWidth = width;
        totalHeight = height;
      }

      if (overflow === 'hidden') {
        clientWidth = width;
        clientHeight = height;
      }

      return {
        width: function width(d) {return clientWidth || size(d)[0];},
        height: shape === 'half-circle' ? function (d) {return (clientHeight || size(d)[1]) / 2;} : function (d) {return clientHeight || size(d)[1];},
        totalWidth: totalWidth,
        totalHeight: totalHeight,
        overflow: overflow,
        size: size
      };
    }

    function getBoxOverfow(boxConfig, labelConfig, align) {
      var width = boxConfig.width,height = boxConfig.height,_boxConfig$overflow = boxConfig.overflow,overflow = _boxConfig$overflow === void 0 ? 'hidden' : _boxConfig$overflow,
        isHorizontal = align.layout === HORIZONTAL_ALIGN;

      if (!(!isHorizontal && labelConfig.keepAligned) && overflow === 'visible') {
        return;
      }

      if (height || width) {
        return overflow;
      }
    }

    function _size$1(scale, boxConfig, fontSize) {
      if (scale) {
        return function (d) {return [scale(d), scale(d)];};
      }

      return function () {return legend_helpers.getFilterBoxSize(boxConfig, fontSize);};
    }
    Registry.setComponent('listView.markerSize', getBoxSize);

    //

    function getHighlightElement$1(trackerElement, i) {
      return d3_select(trackerElement.nodes()[i]);
    }

    function highlightLI(ele, config) {
      var backgroundColor = config.backgroundColor,borderRadius = config.borderRadius;
      ele.styles({
        'background-color': backgroundColor,
        'border-radius': defined(borderRadius) ? "".concat(borderRadius, "px") : null
      });
    }

    function highlightLabel(ele, config, globalFont, priorityConfig) {
      applyFont(ele, [priorityConfig, config.list.label, globalFont, $ZCG], true);
    }

    function highlightMarker(ele, scale, config, priorityConfig) {
      if (priorityConfig) {
        var background = function background(d) {
          var width = scale.width ? scale.width(d) : scale(d),
            height = scale.height ? scale.height(d) : scale(d),
            dataURI1 = markerDataURI(config, scale)(d),
            dataURI2 = priorityConfig ? markerDataURI(priorityConfig, scale)(d) : '';

          return getSVGSymbolString(dataURI1 + dataURI2, width, height);
        };

        ele.styles({
          background: background,
          border: 'none',
          'border-radius': null
        });
      } else {
        ele.styles(markerBackground(config, scale));
      }
    }

    function getListIndex(data, options) {
      var config = options.config,ticks = options.ticks,
        reversed = config.reversed,
        point = pick(data.point, data);

      return reversed ? ticks.length - 1 - point : point;
    }

    //

    function ListParser(spec) {
      var _helper = helper$a(spec),
        _class = _helper._class,show = _helper.show,data = _helper.data,ulSpec = _helper.ulSpec,liSpec = _helper.liSpec,markerSpec = _helper.markerSpec,labelSpec = _helper.labelSpec,
        marker_P = MarkerParser$1(markerSpec),
        label_P = LabelParser(labelSpec);

      var ulMark = Mark('ul', ".".concat(_class, "legseries"));
      ulMark.properties = { styles: ulSpec };

      var liMark = Mark('li', ".".concat(_class, "series"), show ? data : []);
      liMark.properties = { styles: liSpec };
      liMark.children = [marker_P, label_P];

      ulMark.children = [liMark];
      return ulMark;
    }

    function MarkerParser$1(spec) {
      var show = spec.show,bound = spec.bound,config = spec.config,_class = spec._class,onEnd = spec.onEnd,_styles = spec.styles,
        staticConfig = { 'background-repeat': 'repeat', 'box-sizing': 'border-box', 'text-align': CENTER_ALIGN };

      var markerMark = Mark('_div', ".".concat(_class, "legendfilterbox"), show ? function (d) {return [d];} : []);
      setPropVal(markerMark, 'properties.styles', _objectSpread(_objectSpread({}, staticConfig), _styles));
      markerMark.onEnd = onEnd;
      markerMark.depends = true;
      markerMark.config = _objectSpread(_objectSpread({}, config), {}, { width: bound.width, height: bound.height });

      return markerMark;
    }

    function LabelParser(spec) {
      var _class = spec._class,onEnd = spec.onEnd,config = spec.config,_spec$format2 = spec.format,format = _spec$format2 === void 0 ? function (d) {return d;} : _spec$format2,_styles = spec.styles;

      var labelMark = Mark('span', ".".concat(_class, "legendlabel"), function (d) {return [d];});
      setPropVal(labelMark, 'properties.styles', _styles);
      labelMark.onEnd = onEnd;
      labelMark.depends = true;
      labelMark.config = _objectSpread(_objectSpread({}, config), {}, { html: format });

      return labelMark;
    }

    function helper$a(spec) {
      var data = spec.data,config = spec.config,align = spec.align,_spec$format3 = spec.format,format = _spec$format3 === void 0 ? function (d) {return d;} : _spec$format3,_spec$globalFont2 = spec.globalFont,globalFont = _spec$globalFont2 === void 0 ? {} : _spec$globalFont2,_spec$class = spec["class"],_class = _spec$class === void 0 ? '' : _spec$class,_spec$scales = spec.scales,scales = _spec$scales === void 0 ? {} : _spec$scales,
        globalFontSize = spec.label.fontSize,
        listConfig = config.list,_config$show = config.show,show = _config$show === void 0 ? true : _config$show,
        markerConfig = listConfig.marker,labelConfig = listConfig.label,
        boxSize = getBoxSize$1(markerConfig, labelConfig, align, scales.size, globalFontSize),
        place = _place(spec);

      return {
        show: show,
        data: data,
        _class: _class,
        ulSpec: parseUL(align),
        liSpec: parseLI(config, align, place.li),
        markerSpec: _objectSpread({
          show: isBoxEnabled(markerConfig),
          config: _objectSpread(_objectSpread({}, markerConfig), configByEncode(scales)),
          bound: boxSize,
          _class: _class },
        place.marker),

        labelSpec: _objectSpread({
          config: labelConfig,
          format: format,
          globalFont: globalFont,
          _class: _class },
        place.label)

      };
    }

    function parseUL(align) {var _ref19;
      var isHorizontal = align.layout === HORIZONTAL_ALIGN;

      return _ref19 = {
        width: '',
        margin: 0,
        padding: 0,
        'white-space': isHorizontal ? 'nowrap' : NULL$1 }, _defineProperty(_ref19,
      isHorizontal ? 'overflow-x' : 'overflow-y', 'hidden'), _defineProperty(_ref19,
      'list-style-type', NONE), _defineProperty(_ref19,
      '-webkit-overflow-scrolling', 'touch'), _defineProperty(_ref19,
      'vertical-align', TOP_ALIGN), _defineProperty(_ref19,
      'font-size', '0px'), _ref19;

    }

    function parseLI(config, align, place) {
      var labelConfig = config.list.label;
      //text-overflow properties
      var overflowStyles;
      if (labelConfig.overflow === 'wrap') {
        overflowStyles = {
          'word-wrap': 'break-word',
          'white-space': 'normal',
          'vertical-align': TOP_ALIGN
        };
      } else {
        overflowStyles = {
          'text-overflow': 'ellipsis',
          'vertical-align': MIDDLE_ALIGN
        };
      }

      return _objectSpread(_objectSpread(_objectSpread({
        'white-space': 'nowrap',
        position: 'relative',
        overflow: 'hidden',
        'text-align': LEFT_ALIGN,
        padding: shorthand_px(pick(config.itemMargin, 3)),
        height: defined(config.itemHeight) ? "".concat(config.itemHeight, "px") : NULL$1 },
      overflowStyles), {}, { //have to check this should be placed under li or span?
        'vertical-align': TOP_ALIGN,
        display: function display(d) {return legend_helpers.isHiddenItem(d) ? NONE : align.layout === HORIZONTAL_ALIGN ? 'inline-block' : 'block';} },
      place.styles), {}, {
        'font-size': '0px' },
      applyFont(NULL$1, [labelConfig], true));


    }

    function _place(spec) {
      var data = spec.data,config = spec.config,align = spec.align,ticks = spec.ticks,globalFont = spec.globalFont,_spec$scales2 = spec.scales,scales = _spec$scales2 === void 0 ? {} : _spec$scales2,
        globalFontSize = spec.label.fontSize,
        listConfig = config.list,userRanges = config.ranges,
        markerConfig = listConfig.marker,labelConfig = listConfig.label,
        disabledOptions = getDisabledOptions(config),
        _defaultBoxSize = legend_helpers.getFilterBoxSize(markerConfig, globalFontSize),
        bound = spec.bound || { width: _defaultBoxSize[0], height: _defaultBoxSize[1] },
        boxSize = getBoxSize$1(markerConfig, labelConfig, align, scales.size, globalFontSize),
        hoverMarkerConfig = disabledOptions.marker,
        mergedHoverMarkerConfig = isEmptyObject(hoverMarkerConfig) ? hoverMarkerConfig : mergeJSON$1(hoverMarkerConfig, markerConfig),
        disabledLabelConfig = disabledOptions.label,
        isDisabled = function isDisabled(d, i) {return (
            config.filter &&
            config.filter.range && // ZC2406
            userRanges &&
            userRanges.length &&
            userRanges[getListIndex(i, { config: config, ticks: ticks || data })].disabled);};

      var hAlign = markerConfig.hAlign,
        width = boxSize.width,height = boxSize.height,size = boxSize.size,overflow = boxSize.overflow,totalHeight = boxSize.totalHeight,_labelConfig$keepAlig =
        labelConfig.keepAligned,keepAligned = _labelConfig$keepAlig === void 0 ? true : _labelConfig$keepAlig,_labelConfig$padding = labelConfig.padding,padding = _labelConfig$padding === void 0 ? 0 : _labelConfig$padding,showAs = labelConfig.showAs,
        isHorizontal = align.layout === HORIZONTAL_ALIGN,
        markerEle,
        markerOnEnd = function markerOnEnd(ele) {
          // TODO: clean
          ele.each(function (d, i) {
            if (isDisabled(d, i)) {
              highlightMarker(d3_select(this), boxSize, markerConfig, mergedHoverMarkerConfig);
            }
          });
          markerEle = ele;
        },
        labelOnEnd = function labelOnEnd(ele) {
          ele.each(function (d, i) {
            // TODO: clean
            if (isDisabled(d, i)) {
              highlightLabel(d3_select(this), config, globalFont, disabledLabelConfig);
            }
          });

          if (isHorizontal) {
            return;
          }

          var labelNode = ele.node(),
            labelHeight = labelNode && labelNode.offsetHeight,
            margin_top = function margin_top(d) {return (
                getColorBoxVerticalPosition(
                CENTER_ALIGN,
                labelHeight,
                boxSize.height(d),
                globalFontSize,
                scales.size ? boxSize.height(d) : markerConfig.size,
                labelConfig.overflow));};

          markerEle.style('margin-top', function (d) {return "".concat(margin_top(d), "px");});
        },
        boxStyles = {},
        labelStyles = {},
        liStyles = {};

      if (!isBoxEnabled(markerConfig)) {
        padding = 0;
      }

      if (keepAligned) {
        var boxMargin = NULL$1,
          labelMargin = NULL$1,
          liMargin = NULL$1,
          zIndexLI = NULL$1,
          lineHeight;

        if (isHorizontal) {
          boxMargin = function boxMargin(d) {return "".concat((mathMax(globalFontSize, bound.height) - height(d)) / 2, "px");};
          labelMargin = function labelMargin() {return "".concat(padding, "px");};
          lineHeight = "".concat(bound.height, "px");
          // boxMargin = d =>
          //     `${vAlign === BOTTOM_ALIGN ? bound.height - size(d)[1] : vAlign === CENTER_ALIGN ? (bound.height - size(d)[1]) / 2 : 0}px`;
          // labelMargin = d =>
          //     `${(vAlign === BOTTOM_ALIGN ? 0 : vAlign === CENTER_ALIGN ? (bound.height - size(d)[1]) / 2 : bound.height - size(d)[1]) +
          //         padding}px`;
        } else {
          boxMargin = function boxMargin(d) {return "".concat(
            hAlign === RIGHT_ALIGN ? bound.width - width(d) : hAlign === CENTER_ALIGN ? (bound.width - width(d)) / 2 : 0, "px");};
          labelMargin = function labelMargin(d) {return "".concat(
            (hAlign === RIGHT_ALIGN ? 0 : hAlign === CENTER_ALIGN ? (bound.width - width(d)) / 2 : bound.width - width(d)) +
            padding, "px");};

          if (overflow === 'visible') {
            liMargin = function liMargin(d, i) {
              var top = i ? -(height(d) - totalHeight) : 0;
              return "".concat(top, "px 0 0 0");
            };

            if (size(data[0])[0] < size(data[data.length - 1])[0]) {
              zIndexLI = function zIndexLI(d, i) {return data.length - 1 - i;};
            }
          }

          var textHeight = NULL$1;
          lineHeight = function lineHeight(d) {
            if (!textHeight) {
              textHeight = getTextHeight([labelConfig, globalFont, $ZCG]);
            }

            return "".concat(mathMax(textHeight, height(d)), "px");
          };
        }

        boxStyles = {
          "float": LEFT_ALIGN,
          display: 'inline-block',
          margin: function margin(d) {return isHorizontal ? "".concat(boxMargin(d), " 0 0 0") : "0 0 0 ".concat(boxMargin(d));}
        };
        labelStyles = {
          display: showAs ? 'inline-block' : NULL$1,
          margin: function margin(d) {return "0 0 0 ".concat(labelMargin(d));}
        };

        liStyles = { 'line-height': lineHeight, margin: liMargin, 'z-index': zIndexLI };
      } else {
        if (isHorizontal) {
          var _boxMargin = function _boxMargin(d) {return "".concat(bound.height / 2 - height(d) / 2, "px");};
          boxStyles = { margin: function margin(d) {return "".concat(_boxMargin(d), " auto 0px 0px");} };
          boxStyles = {
            margin: function margin(d) {
              var top = _boxMargin(d);
              return hAlign === 'left' ? "".concat(
              top, " auto ").concat(padding, "px 0") :
              hAlign === 'right' ? "".concat(
              top, " 0 ").concat(padding, "px auto") : "".concat(
              top, " auto ").concat(padding, "px auto");
            }
          };
        } else {
          liStyles = { 'text-align': hAlign };
          boxStyles = {
            margin:
            hAlign === 'right' ? "0 0 ".concat(
            padding, "px auto") :
            hAlign === CENTER_ALIGN ? "0 auto ".concat(
            padding, "px auto") : "0 auto ".concat(
            padding, "px 0")
          };
        }

        boxStyles["float"] = NULL$1;
        boxStyles.display = NULL$1;
        labelStyles.display = NULL$1;
        labelStyles.margin = NULL$1;
        liStyles = _objectSpread(_objectSpread({}, liStyles), {}, { 'line-height': NULL$1, 'z-index': NULL$1, margin: NULL$1 });
      }

      return {
        marker: { styles: boxStyles, onEnd: markerOnEnd },
        label: { styles: labelStyles, onEnd: labelOnEnd },
        li: { styles: liStyles }
      };
    }

    function getBoxSize$1(boxConfig, labelConfig, align, scale, fontSize) {
      var size = _size$2(scale, boxConfig, fontSize),
        overflow = getBoxOverfow$1(boxConfig, labelConfig, align),
        width = boxConfig.width,height = boxConfig.height,shape = boxConfig.shape,
        totalWidth,
        totalHeight,
        clientWidth,
        clientHeight;

      if (overflow) {
        totalWidth = width;
        totalHeight = height;
      }

      if (overflow === 'hidden') {
        clientWidth = width;
        clientHeight = height;
      }

      return {
        width: function width(d) {return clientWidth || size(d)[0];},
        height: shape === 'half-circle' ? function (d) {return (clientHeight || size(d)[1]) / 2;} : function (d) {return clientHeight || size(d)[1];},
        totalWidth: totalWidth,
        totalHeight: totalHeight,
        overflow: overflow,
        size: size
      };
    }

    function getBoxOverfow$1(boxConfig, labelConfig, align) {
      var width = boxConfig.width,height = boxConfig.height,_boxConfig$overflow2 = boxConfig.overflow,overflow = _boxConfig$overflow2 === void 0 ? 'hidden' : _boxConfig$overflow2,
        isHorizontal = align.layout === HORIZONTAL_ALIGN;

      if (!(!isHorizontal && labelConfig.keepAligned) && overflow === 'visible') {
        return;
      }

      if (height || width) {
        return overflow;
      }
    }

    function _size$2(scale, boxConfig, fontSize) {
      if (scale) {
        return function (d) {return [scale(d), scale(d)];};
      }

      return function () {return legend_helpers.getFilterBoxSize(boxConfig, fontSize);};
    }

    function isBoxEnabled(boxConfig) {
      return boxConfig.show !== false;
    }

    function configByEncode(scales) {
      var _config = {};
      each(scales, function (scale, encode) {return _config[encode] = { _type: 'encode', scale: scale };});
      return _config;
    }

    //

    function LegendTitleHtmlParser(spec) {
      var config = spec.config,globalFont = spec.globalFont;

      var titleConfig = config.title || {},
        boxConfig = mergeJSON$1(config.list.marker, config.selectAllBox, true),
        labelConfig = _objectSpread(_objectSpread({}, titleConfig), {}, { keepAligned: true, padding: config.textPadding }),
        c = {
          show: titleConfig.show,
          itemMargin: titleConfig.margin,
          list: { marker: _objectSpread(_objectSpread({}, boxConfig), {}, { show: false }), label: labelConfig }
        };

      var viewSpec = {
        config: c,
        data: [titleConfig.text],
        align: { layout: VERTICAL_ALIGN },
        format: function format(d) {return decodeHTML(d);},
        globalFont: globalFont,
        label: {
          fontSize: +utils.getVal(titleConfig.fontSize || globalFont.fontSize)
        },
        "class": 'zc-header-' //remove
      };

      return ListParser(viewSpec);
    }

    //

    /*
    spec = {
        bound: {
            width: 15,
            height: 15
        },
        data: [
            [0, 25],
            [25, 50],
            [50, 75],
            [75, 100]
        ],
        // format: d => d,
        // scale: d => d,
        config: {
            list: {
                marker: {
                    shape: "star",
                    fillColor: "#FEAB67",
                    strokeColor: "green",
                    size: 15
                },
                label: {
                    fontSize: 13,
                    padding: 5
                }
            }
        },
        globalFont: {},
        align: {},
        label: {}
    }
     */var
    ListView = /*#__PURE__*/function (_BaseView2) {_inherits(ListView, _BaseView2);var _super8 = _createSuper(ListView);function ListView() {_classCallCheck(this, ListView);return _super8.apply(this, arguments);}return _createClass(ListView);}(BaseView);
    ListView.parser = ListParser;
    Registry.setComponent('listView', ListView);

    //

    function ListLegendParser(spec, viewScaleComponent, self) {
      var _helper = helper$b(spec, viewScaleComponent, self),
        titleSpec = _helper.titleSpec,backgroundSpec = _helper.backgroundSpec,viewSpec = _helper.viewSpec,expandableSpec = _helper.expandableSpec,keepTitleAligned = _helper.keepTitleAligned,setDimension = _helper.setDimension,keepExpandableAligned = _helper.keepExpandableAligned;

      // Wrap
      var groupMark = Mark(DIV_ELEMENT, ".legendgroup");
      groupMark.onEnd = setDimension;

      // Background
      setPropVal(groupMark, 'properties.styles', LegendBackgroundHtmlParser(backgroundSpec)); // TODO: change by config

      // Title
      var titleMark = LegendTitleHtmlParser(titleSpec);
      setPropVal(titleMark, 'properties.styles.display', getDisplay(keepTitleAligned));

      // View
      var listMark = ListParser(viewSpec);
      setPropVal(listMark, 'properties.styles.display', getDisplay(keepTitleAligned, keepExpandableAligned));

      // Expandable
      var expandableMark = ExpandableParser(_objectSpread(_objectSpread({}, expandableSpec), {}, { target: function target() {return listMark.element;} }));

      groupMark.children = [titleMark, listMark, expandableMark];
      groupMark._helper = _helper;
      return groupMark;
    }

    function helper$b(spec, viewScaleComponent, self) {
      var config = spec.config,globalFont = spec.globalFont,format = spec.format,data = spec.data,bound = spec.bound,callbackArgs = spec.callbackArgs,_spec$scales3 = spec.scales,scales = _spec$scales3 === void 0 ? {} : _spec$scales3,
        titleConfig = config.title,listConfig = config.list,_listConfig$expandabl =
        listConfig.expandable,expandableConfig = _listConfig$expandabl === void 0 ? {} : _listConfig$expandabl,

        viewScale = viewScaleComponent.scale,viewBound = viewScaleComponent.bound,ticks = viewScaleComponent.ticks,labelData = viewScaleComponent.labelData,

        legendAlign = getLegendAlignment(config),
        isHorizontal = legendAlign.layout === HORIZONTAL_ALIGN,

        visibleItemCount = pick(spec.visibleItemCount, data.length),
        visibleCount = !expandableConfig._expanded ? visibleItemCount : data.length,
        getViewData = function getViewData(visibleCount) {
          var d = config.reversed ? d3_values(data).reverse() : data;
          return defined(visibleCount) ? d.slice(0, visibleCount) : d;
        },
        viewData = getViewData(visibleCount),
        size = viewScale && mathMax(viewScale(viewData[viewData.length - 1]), viewScale(viewData[0])),
        renderList = function renderList() {
          var newViewSpec = _objectSpread(_objectSpread({},
          viewSpec), {}, {
            bound: { width: viewBound.width, height: mathMin(maxBoxHeight, viewBound.height) },
            data: getViewData() });

          var viewObj = new ListView(newViewSpec);
          viewObj.create();
          viewObj.draw(self.encode.element);
        },
        keepTitleAligned = titleConfig && titleConfig.show && titleConfig.keepAligned && legendAlign.layout === HORIZONTAL_ALIGN,
        setDimension = function setDimension(ele) {
          var expanded = expandableConfig.show ? expandableState(self.encode.children[2]) : true;
          setLegendDimension(ele, legendAlign, keepTitleAligned, bound, config, expanded);
        },
        boxConfig = listConfig.marker,labelConfig = listConfig.label,
        _f = +utils.getVal(getValByPriority([listConfig.label, globalFont, $ZCG], 'fontSize')),
        boxSize = getBoxSize(boxConfig, labelConfig, legendAlign, viewScale, _f),
        maxBoxHeight = viewScale ? d3_max(viewData, function (d) {return boxSize.height(d);}) : viewBound && viewBound.height;

      var backgroundSpec = { config: config },
        titleSpec = {
          align: legendAlign,
          config: config,
          globalFont: globalFont
        },
        viewSpec = {
          bound: scales.size && (size ? { width: size, height: maxBoxHeight } : viewBound),
          config: config,
          format: format && function (d, i) {return format(labelData ? labelData[i] : d, i);},
          globalFont: globalFont,
          data: viewData,
          ticks: ticks,
          scale: viewScale,
          scales: scales,
          align: legendAlign,
          label: { fontSize: +utils.getVal(getValByPriority([listConfig.label, globalFont, $ZCG], 'fontSize')) },
          "class": 'zc-legend-'
        },
        expandableSpec = {
          config: expandableConfig,
          globalFont: globalFont,
          callbackArgs: callbackArgs,
          renderList: renderList,
          bound: bound,
          height: function height() {
            var headerHeight = getBoundingRect(getEle$1(self, 'LegendTitleHtml')).height;
            if (keepTitleAligned) {
              return mathMax(headerHeight, mathMin(maxBoxHeight, pick(size, viewBound.height)));
            } else {
              return mathMin(maxBoxHeight, pick(size, viewBound.height));
            }
          },
          isHorizontal: isHorizontal,
          padding: config.itemMargin,
          expanded: expandableConfig._expanded,
          remainingCount: data.length - visibleItemCount,
          margin: function margin() {
            if (keepTitleAligned && !expandableConfig.keepAligned) {
              var headerWidth = getBoundingRect(getEle$1(self, 'LegendTitleHtml')).width;
              return "0 0 0 ".concat(headerWidth);
            } else {
              return 0;
            }
          },
          setLegendDimension: function setLegendDimension() {return setDimension(self.encode.element);}
        };

      return {
        titleSpec: titleSpec,
        backgroundSpec: backgroundSpec,
        viewSpec: viewSpec,
        expandableSpec: expandableSpec,
        keepTitleAligned: keepTitleAligned,
        keepExpandableAligned: expandableConfig.keepAligned, // TODO: work
        setDimension: setDimension
      };
    }

    function setLegendDimension(wrap, legendAlign, keepTitleAligned, bound, config, legendExpanded) {
      var legseries = wrap.selectAll("ul.".concat(LEGSERIES_LEGEND_CLASSNAME)),
        series = wrap.selectAll("li.".concat(SERIES_LEGEND_CLASSNAME)),
        header = wrap.selectAll("ul.".concat(LEGSERIES_HEADER_CLASSNAME)),
        expandable = wrap.selectAll("".concat(DIV_ELEMENT, ".").concat(EXPANDABLE_CLASSNAME)),
        scrollbarwid = 20,
        scrollType = legendAlign.layout,
        titleConfig = config.title,_config$border = config.border,borderConfig = _config$border === void 0 ? {} : _config$border,_config$list$expandab =
        config.list.expandable,expandableConfig = _config$list$expandab === void 0 ? {} : _config$list$expandab,
        borderWidth = borderConfig.show ? borderConfig.size : 0,
        maxWidth = bound.maxWidth,maxHeight = bound.maxHeight,

        keepExpandableAligned = expandableConfig.show && expandableConfig.keepAligned,
        keepAligned = getDisplay(keepTitleAligned, keepExpandableAligned);

      maxWidth -= 2 * borderWidth;
      maxHeight -= 2 * borderWidth;

      // Max width for title
      var defaultTitleMaxWidth = keepTitleAligned ? LEGEND_TITLE_MAX_WIDTH_HORIZONTAL : LEGEND_TITLE_MAX_WIDTH_VERTICAL,
        titleMaxWidth = mathMin(perToPx(titleConfig.maxWidth || defaultTitleMaxWidth, maxWidth), maxWidth);
      header.style('max-width', "".concat(titleMaxWidth, "px"));

      var headerDimension = getBoundingRect(header),
        expandableDimension = getBoundingRect(expandable);

      if (!keepTitleAligned) {
        maxHeight = mathMin(maxHeight - headerDimension.height, maxHeight);
      }

      wrap.style('max-width', "".concat(maxWidth, "px"));
      legseries.styles({
        'max-width': "".concat(maxWidth, "px"),
        'max-height': "".concat(maxHeight, "px")
      });

      if (scrollType === HORIZONTAL_ALIGN) {
        legseries.styles({ width: NULL$1, height: NULL$1 });

        var maxW = maxWidth - (keepTitleAligned ? headerDimension.width : 0) - (keepExpandableAligned ? expandableDimension.width : 0);
        maxW -= keepTitleAligned || keepExpandableAligned ? 2 : 0;
        var maxH = maxHeight - (!keepExpandableAligned ? expandableDimension.height : 0);

        legseries.style('max-width', "".concat(maxW, "px"));
        legseries.style('max-height', "".concat(maxH, "px"));

        legseries.style('border', '1px solid');
        var bb = getBoundingRect(legseries);
        legseries.style('border', NULL$1);

        legseries.style('width', "".concat(bb.width + 2, "px"));
        var scrollWid = elementIsScrollable(legseries, 'width') ? scrollbarwid : 0;
        legseries.style('height', "".concat(bb.height + scrollWid + 2, "px"));

        var addOverFlowY = legseries.node().scrollHeight - 2 > legseries.node().offsetHeight;
        legseries.style('overflow-x', 'auto');
        legseries.style('overflow-y', addOverFlowY ? 'auto' : 'hidden');
      } else if (legendAlign.layout === HORIZONTAL_ALIGN) {
        // horizontal align ------->

        // reset the dimension for auto calculation, if any
        legseries.styles({ width: NULL$1, height: NULL$1 });

        // set the max width for each item. it will solve text overlapping issue.
        series.style('max-width', "".concat(maxWidth, "px"));

        // set the calculated max width in the wrap element,
        // so that when we set inline to the legseries[ul], it won't stress to the full width.
        // will reset after calculating the inline content width
        wrap.style('max-width', "".concat(maxWidth, "px"));

        // calculate the actual content width
        // previously we were calculating with each item and sum their width.

        // apply dummy style to get the content width
        // the border will set the max with to the parent
        legseries.styles({ display: 'inline', 'border-top': '1px solid' });

        var legendWidth = getBoundingRect(legseries).width;
        legseries.styles({ display: keepAligned, 'border-top': NULL$1 });

        wrap.style('max-width', "".concat(maxWidth, "px")); // resetting it

        // do need the below 2 lines. to get rid of image diff setting the height.
        legseries.style('height', "".concat(getComputedHeight(series, maxWidth, legendAlign) + 2, "px"));

        // check the scroll width after setting the height; // phantomjs issue
        var _scrollWid = elementIsScrollable(legseries) ? scrollbarwid : 0;

        // inline block needs and width. otherwise when it auto wraps, it sets the width to the max-width
        legseries.style('width', "".concat(legendWidth + _scrollWid + 2, "px"));
        legseries.style('overflow', 'auto');
      } else {
        // if ($Browser.IE && addOverFlowY) {
        //     addOverFlowY = legseries.node().scrollHeight - activeRows > legseries.node().offsetHeight;
        // }

        var _maxH = maxHeight - expandableDimension.height;
        legseries.style('max-height', "".concat(_maxH, "px"));

        var _scrollWid2 = elementIsScrollable(legseries) ? scrollbarwid : 0;
        // reset the width first
        legseries.style('width', NULL$1);

        // calculate the max item width
        var _legendWidth2 = getBoundingRect(legseries.style('display', 'inline-block')).width;
        legseries.style('display', keepAligned);
        legseries.style('width', "".concat(_legendWidth2 + _scrollWid2 + 2, "px"));
        legseries.style('height', NULL$1);

        //  ZC2423 - if expandable, overflow-x & overflow-y needs to be updated for IE
        legseries.style('overflow-x', legendExpanded ? 'auto' : 'hidden');
        legseries.style('overflow-y', legendExpanded ? 'auto' : 'hidden');
      }
    }

    function getComputedHeight(series, maxWidth) {
      var h = 0,
        prevWidth = 0,
        prevHeight = 0;

      series.each(function () {
        var bb = getBoundingRect(this);
        if (prevWidth + bb.width > maxWidth) {
          h += prevHeight;
          prevHeight = 0;
          prevWidth = 0;
        }

        prevWidth += bb.width;
        prevHeight = mathMax(prevHeight, bb.height);
      });
      h += prevHeight;

      return h;
    }

    function getDisplay(keepTitleAligned, keepExpandableAligned) {
      return keepTitleAligned || keepExpandableAligned ? 'inline-block' : NULL$1;
    }

    function getEle$1(self, view) {
      var order = {
        LegendTitleHtml: 0
      };
      return self.encode.children[0].children[order[view]].element;
    }

    //

    var EMPTY_RETURN_FUNCTION = function EMPTY_RETURN_FUNCTION() {return {};};

    /*
    spec = {
        data: ['North', 'South', 'East', 'West'],
        bound: {
            maxWidth: 150,
            maxHeight: 150
        },
        config: { // Size list config
            list: {
                marker: {
                    fillColor: "yellow",
                    strokeColor: "red",
                    strokeWidth: 2
                },
                label: {
                    fontSize: 13,
                    padding: 5
                }
            }
        },
        globalFont: {}
    }
     */var

    ListLegend = /*#__PURE__*/function (_BaseView3) {_inherits(ListLegend, _BaseView3);var _super9 = _createSuper(ListLegend);
      function ListLegend(spec, viewScaleComponent) {var _this28;_classCallCheck(this, ListLegend);
        _this28 = _super9.call(this, spec);
        _this28.viewScaleComponent = viewScaleComponent || EMPTY_RETURN_FUNCTION;return _this28;
      }_createClass(ListLegend, [{ key: "create", value:

        function create() {
          return this.encode = ListLegendParser(this.spec, this.viewScaleComponent(), this);
        } }]);return ListLegend;}(BaseView);

    Registry.setComponent('listLegend', ListLegend);

    //

    function getVisibleItemRenderCount(instance) {
      var spec = instance.spec;
      var config = spec.config,bound = spec.bound,
        borderConfig = config.border,titleConfig = config.title,listConfig = config.list,_listConfig$expandabl2 =
        listConfig.expandable,expandableConfig = _listConfig$expandabl2 === void 0 ? {} : _listConfig$expandabl2,
        borderWidth = borderConfig && borderConfig.show ? borderConfig.size : 0,
        maxWidth = bound.maxWidth,maxHeight = bound.maxHeight,
        align = getLegendAlignment(config),
        isHorizontal = align.layout === HORIZONTAL_ALIGN;

      if (!expandableConfig.show) {
        return;
      }

      var // Temp element
        tempEle = createElement('div', '.temp_list_view', [1], d3_selectAll('div.__baseZC_Container__')),
        maxW = maxWidth - 2 * borderWidth,
        maxH = maxHeight - 2 * borderWidth,
        i = 0,
        w = 0,
        h = 0,
        actualTitleShow = titleConfig.show,
        actualExpanded = expandableConfig._expanded;

      expandableConfig._expanded = false; // ZC2487
      if (isHorizontal && !titleConfig.keepAligned) {
        // If title is exceeds max-width, visibleItemCount is 1 always. So disabling title
        titleConfig.show = false;
      }

      var _viewSpec = _objectSpread(_objectSpread({}, spec), {}, { data: instance.viewScaleComponent().ticks }),
        _viewObj = new ListLegend(_viewSpec, instance.viewScaleComponent);

      while ((isHorizontal ? w < maxW : h < maxH) && ++i <= spec.data.length) {
        _viewSpec.visibleItemCount = i;

        _viewObj.create();
        _viewObj.draw(tempEle);
        var b = getBoundingRect(tempEle);

        if (isHorizontal) {
          w = b.width;
        } else {
          h = b.height;
        }
      }

      if (isHorizontal ? w >= maxW : h >= maxH) {
        i--;
      }

      titleConfig.show = actualTitleShow;
      expandableConfig._expanded = actualExpanded;

      tempEle.remove();

      return mathMax(i, 1);
    }

    //
    var
    ShapeLegendList = /*#__PURE__*/function (_BaseLegend2) {_inherits(ShapeLegendList, _BaseLegend2);var _super10 = _createSuper(ShapeLegendList);function ShapeLegendList() {_classCallCheck(this, ShapeLegendList);return _super10.apply(this, arguments);}_createClass(ShapeLegendList, [{ key: "create", value:
        function create() {
          var viewScaleComponent = this.viewScaleComponent();
          this.spec.data = viewScaleComponent.ticks;
          this.spec.visibleItemCount = getVisibleItemRenderCount(this);
          this.spec.scales = { shape: viewScaleComponent.scale };

          var mark = ListLegendParser(this.spec, viewScaleComponent, this); //TODO: remove 'this'
          this._parser = mark._helper;
          return this.encode = mark;
        } }, { key: "draw", value:
        function draw(parent) {
          parent.styles({
            display: 'block',
            position: 'absolute',
            left: NULL$1, //Reset left and top position. so that floating legend won't get trimmedon redraw (legend-03.json)
            top: NULL$1
          });
          _get(_getPrototypeOf(ShapeLegendList.prototype), "draw", this).call(this, parent);
        } }, { key: "resize", value:

        function resize(width, height) {
          if (!width && !height) {
            return;
          }

          var viewScaleComponent = this.viewScaleComponent();
          this.spec.visibleItemCount = getVisibleItemRenderCount(this);

          var _getMaxToResize2 = getMaxToResize(width, height, this.spec.bound),w = _getMaxToResize2.w,h = _getMaxToResize2.h;
          this.updateScale(w, h);
          _get(_getPrototypeOf(ShapeLegendList.prototype), "resize", this).call(this, w, h);
        } }]);return ShapeLegendList;}(BaseLegend);


    ShapeLegendList.encode = 'shape';
    ShapeLegendList.view = 'list';
    ShapeLegendList.domMode = 'html';
    Registry.setComponent('shapeLegendList', ShapeLegendList);
    LegendRegistry.add(ShapeLegendList);

    var sizeListOptions = function sizeListOptions(userProp) {
      return {
        marker: {
          shape: 'circle',
          hAlign: CENTER_ALIGN,
          vAlign: CENTER_ALIGN,
          fillColor: TRANSPARENT,
          strokeColor: '#808080'
        },
        label: {
          fontSize: userProp.fontL1Size.l5,
          padding: 5,
          keepAligned: true
        }
      };
    };

    Registry.setComponent('sizeListOptions', sizeListOptions);

    defaultTheme.sizeLegend = function (userProp) {
      var nestedOptions = Registry.getComponent('sizeNestedOptions')(userProp),
        listOptions = Registry.getComponent('sizeListOptions')(userProp),
        sliderOptions = Registry.getComponent('sizeSliderOptions')(userProp);

      return {
        enabled: true,
        hAlign: RIGHT_ALIGN, //left, right, center
        vAlign: TOP_ALIGN, //top, center, bottom
        layout: VERTICAL_ALIGN,
        itemMargin: 3,
        marginTop: 10,
        marginRight: 10,
        marginBottom: 10,
        marginLeft: 10,
        title: {
          show: false,
          text: 'Legend',
          fontSize: userProp.fontL1Size.l4
        },
        background: {
          color: TRANSPARENT,
          alpha: 0
        },
        border: {
          show: true,
          size: 1,
          style: 'solid',
          radius: 0,
          color: TRANSPARENT
        },
        shadow: {
          show: false,
          color: 'rgba(0,0,0,0.3)',
          x: 2,
          y: 2,
          blur: 3,
          inset: false
        },
        highlightEffect: {
          selectedSeries: null,
          unselectedSeries: 'none'
        },
        list: listOptions,
        nested: nestedOptions,
        slider: sliderOptions,
        hoverOptions: {
          slider: {
            tooltip: {
              fontSize: userProp.fontL1Size.l5
            }
          }
        },
        filter: {
          enabled: true,
          slider: {
            track: {},
            tooltip: _objectSpread(_objectSpread({},
            brushTooltipOptions()), {}, {
              fontSize: userProp.fontL1Size.l5 })

          }
        }
      };
    };

    //
    var
    SizeLegend = /*#__PURE__*/function (_BaseLegend3) {_inherits(SizeLegend, _BaseLegend3);var _super11 = _createSuper(SizeLegend);function SizeLegend() {_classCallCheck(this, SizeLegend);return _super11.apply(this, arguments);}_createClass(SizeLegend, [{ key: "updateScale", value:
        function updateScale(width, height) {
          var spec = this.spec,
            encode = this.encode,key = this.key,
            config = spec.config,scaleComponent = spec.scaleComponent,_spec$callbackArgs3 = spec.callbackArgs,callbackArgs = _spec$callbackArgs3 === void 0 ? [] : _spec$callbackArgs3,
            d3_scale = scaleComponent.d3_scale,
            customMax = { maxWidth: width, maxHeight: height };

          scaleComponent.config.range.operators = ScaleRegistry.get('size.rangeParser')(encode, key, config, callbackArgs[0], customMax);
          d3_scale.range = scaleComponent._parseRange();
          scaleComponent.scale.range(d3_scale.range);
        } }]);return SizeLegend;}(BaseLegend);


    //

    function LegendTitleHtmlAdjustFactor(config, w, h, globalFont, align) {
      var isHorizontal = align.layout === HORIZONTAL_ALIGN,
        show = config.show,keepAligned = config.keepAligned,
        adjust = [0, 0];

      if (show && isHorizontal && keepAligned) {
        adjust[0] += w * 0.2;
      }

      return adjust;
    }

    //
    var
    SizeLegendList = /*#__PURE__*/function (_SizeLegend) {_inherits(SizeLegendList, _SizeLegend);var _super12 = _createSuper(SizeLegendList);function SizeLegendList() {_classCallCheck(this, SizeLegendList);return _super12.apply(this, arguments);}_createClass(SizeLegendList, [{ key: "create", value:
        function create() {
          var viewScaleComponent = this.viewScaleComponent();
          this.spec.data = viewScaleComponent.ticks;
          this.spec.scales = { size: viewScaleComponent.scale };
          this.spec.visibleItemCount = getVisibleItemRenderCount(this);

          var mark = ListLegendParser(this.spec, viewScaleComponent, this); //TODO: remove 'this'
          this._parser = mark._helper;
          return this.encode = mark;
        } }, { key: "draw", value:
        function draw(parent) {
          parent.styles({
            display: 'block',
            position: 'absolute',
            left: NULL$1, //Reset left and top position. so that floating legend won't get trimmedon redraw (legend-03.json)
            top: NULL$1
          });
          _get(_getPrototypeOf(SizeLegendList.prototype), "draw", this).call(this, parent);
        } }, { key: "resize", value:

        function resize(width, height) {
          if (!width && !height) {
            return;
          }

          var viewScaleComponent = this.viewScaleComponent();
          this.spec.visibleItemCount = getVisibleItemRenderCount(this);

          var _getMaxToResize3 = getMaxToResize(width, height, this.spec.bound),w = _getMaxToResize3.w,h = _getMaxToResize3.h;
          this.updateScale(w, h);
          _get(_getPrototypeOf(SizeLegendList.prototype), "resize", this).call(this, w, h);
        } }]);return SizeLegendList;}(SizeLegend);


    SizeLegendList.adjustFactor = function (config, w, h, globalFont) {
      var align = getLegendAlignment(config),
        maxWidth = config.maxWidth,maxHeight = config.maxHeight,titleConfig = config.title,listConfig = config.list,
        expandableConfig = listConfig.expandable,
        expandableAdjust = ExpandableAdjustFactor(expandableConfig, w, h, globalFont, align, config.itemMargin),
        titleAdjust = LegendTitleHtmlAdjustFactor(titleConfig, w, h, globalFont, align),
        scrollBarSize = 22,
        adjust = [0, 0];

      if (align.layout === HORIZONTAL_ALIGN) {
        adjust[1] += scrollBarSize;
      } else {
        adjust[0] += scrollBarSize;
      }

      if (!maxHeight) {
        adjust[1] += expandableAdjust[1] + titleAdjust[1];
      }

      if (!maxWidth) {
        adjust[0] += expandableAdjust[0] + titleAdjust[0];
      }

      return adjust;
    };

    SizeLegendList.encode = 'z';
    SizeLegendList.view = 'list';
    SizeLegendList.domMode = 'html';
    Registry.setComponent('sizeLegendList', SizeLegendList);
    LegendRegistry.add(SizeLegendList);

    function SizeListListener(d, index, ele, eventType) {
      var manager = this,
        event = d3_event(),
        mouse = getMousePosition(manager.tracker.node(), event);

      var data = manager.getData(eventType, mouse, [d, index]);

      manager.associateBehaviours(eventType, data, mouse, event);
    }

    function SizeListDataFinder(mouse, eventType, d, index) {
      var manager = this,
        options = manager.options,
        config = options.config,ticks = options.ticks,
        reversed = config.reversed;

      if (reversed) {
        return ticks.length - 1 - index;
      } else {
        return index;
      }
    }

    //

    function SizeReverseDataFinder(data, eventType) {
      return ReverseDataFinder.apply(this, arguments);
    }

    function SizeListReverseDataFinder() {
      return SizeReverseDataFinder.apply(this, arguments);
    }

    function HighlightItem$2(mouse, data) {
      var manager = this,
        options = manager.options,
        trackerElement = options.trackerElement,config = options.config,globalFont = options.globalFont,boxSize = options.boxSize,
        ranges = config.ranges,
        hoverOptions = getHoverOptions(config),
        point = getListIndex(data, options),
        highlightElement = getHighlightElement$1(trackerElement, point);

      if (isEmptyObject(hoverOptions)) {
        return;
      }

      if (ranges && ranges[data.point].disabled) {
        return;
      }

      var markerConfig = config.list.marker,
        labelConfig = hoverOptions.label,
        hoverMarkerConfig = hoverOptions.marker,
        mergedHoverMarkerConfig = isEmptyObject(hoverMarkerConfig) ? hoverMarkerConfig : mergeJSON$1(hoverMarkerConfig, markerConfig),
        //
        labelElement = highlightElement.selectAll('.zc-legend-legendlabel, .zc-legend-legendlabel *'),
        markerElement = highlightElement.selectAll('.zc-legend-legendfilterbox');

      highlightLI(highlightElement, hoverOptions);
      highlightLabel(labelElement, config, globalFont, labelConfig);
      highlightMarker(markerElement, boxSize, markerConfig, mergedHoverMarkerConfig);
    }

    function ResetHighlightItem$1(mouse, data, forced) {
      var manager = this,
        options = manager.options,
        trackerElement = options.trackerElement,config = options.config,globalFont = options.globalFont,boxSize = options.boxSize,
        ranges = config.ranges,
        hoverOptions = getHoverOptions(config),
        point = getListIndex(data, options),
        highlightElement = getHighlightElement$1(trackerElement, point);

      if (isEmptyObject(hoverOptions)) {
        return;
      }

      if (!forced && ranges && ranges[data.point].disabled) {
        return;
      }

      var markerConfig = config.list.marker,
        //
        labelElement = highlightElement.selectAll('.zc-legend-legendlabel'),
        markerElement = highlightElement.selectAll('.zc-legend-legendfilterbox');

      highlightLI(highlightElement, config);
      highlightLabel(labelElement, config, globalFont);
      highlightMarker(markerElement, boxSize, markerConfig);
    }

    function ApplyFilterOnPlot(mouse, data) {
      var manager = this,
        chart = manager.chart,options = manager.options,
        config = options.config,dataType = options.dataType,
        ranges = config.ranges,filter = config.filter,
        point = ranges[data.point];

      if (!filter.enabled || isAllDisabled(ranges) && !point.disabled) {
        return;
      }

      point.disabled = !point.disabled;
      var filtered = ranges.filter(function (range) {return !range.disabled;});

      if (dataType === ORDINAL_DATATYPE) {
        filtered = filtered.map(function (d) {return d[0];});
      }

      config.filter.range = filtered;
      chart.plot.renderer.draw(true);
    }

    function isAllDisabled(ranges) {
      var disabledEle = ranges.filter(function (range) {return range.disabled;});

      return disabledEle.length == ranges.length - 1;
    }

    function DisableItem(mouse, data) {
      var manager = this,
        options = manager.options,
        trackerElement = options.trackerElement,config = options.config,globalFont = options.globalFont,boxSize = options.boxSize,
        disabledOptions = getDisabledOptions(config),
        list = config.list,
        markerConfig = list.marker,
        labelFilterConfig = disabledOptions.label,markerFilterConfig = disabledOptions.marker,
        point = getListIndex(data, options),
        highlightElement = getHighlightElement$1(trackerElement, point);

      if (!isEmptyObject(labelFilterConfig)) {
        var labelElement = highlightElement.selectAll('.zc-legend-legendlabel, .zc-legend-legendlabel *');
        highlightLabel(labelElement, config, globalFont, labelFilterConfig);
      }

      if (!isEmptyObject(markerFilterConfig)) {
        var mergedMarkerConfig = mergeJSON$1(markerFilterConfig, markerConfig),
          markerElement = highlightElement.selectAll('.zc-legend-legendfilterbox');

        highlightMarker(markerElement, boxSize, markerConfig, mergedMarkerConfig);
      }
    }

    function PaintFilterItem(mouse, data) {
      var manager = this,
        options = manager.options,
        config = options.config,
        ranges = config.ranges,
        point = data.point,
        event = d3_event();

      if (ranges[point].disabled) {
        ResetHighlightItem$1.call.apply(ResetHighlightItem$1, [manager].concat(Array.prototype.slice.call(arguments), [true]));
        DisableItem.apply(manager, arguments);
      } else if (event) {
        if (event.touches) {
          ResetHighlightItem$1.call.apply(ResetHighlightItem$1, [manager].concat(Array.prototype.slice.call(arguments), [true]));
        } else {
          HighlightItem$2.apply(manager, arguments);
          HighlightSeries.call.apply(HighlightSeries, [manager].concat(Array.prototype.slice.call(arguments), [true]));
        }
      }
    }

    //

    function ScrollItemToView(mouse, data) {
      var manager = this,
        options = manager.options,
        scrollToItem = options.scrollToItem,
        point = getListIndex(data, options);

      if (!scrollToItem) {
        return;
      }

      var ulElement = scrollToItem.ulElement,liElement = scrollToItem.liElement,available = scrollToItem.available,isScrollable = scrollToItem.isScrollable,isHorizontal = scrollToItem.isHorizontal,
        scrollType = isHorizontal ? 'scrollLeft' : 'scrollTop',
        offsetType = isHorizontal ? 'offsetLeft' : 'offsetTop';

      // Scroll into view
      if (isScrollable) {
        ulElement[scrollType] = liElement[point][offsetType] - available / 2;
      }
    }

    //

    function ResetOldHighlight(mouse, data) {
      docTapFunction();
    }

    //

    var tempEventName = $Browser.PHANTOMJS ? { move: 'mousemove', out: 'mouseout' } : { move: 'mouseenter', out: 'mouseleave' };

    var _legendSizeListHandlers = {
      LISTENER: (_LISTENER = {}, _defineProperty(_LISTENER,
      tempEventName.move, SizeListListener), _defineProperty(_LISTENER,
      tempEventName.out, SizeListListener), _defineProperty(_LISTENER, "click",
      SizeListListener), _defineProperty(_LISTENER, "dblclick",
      SizeListListener), _defineProperty(_LISTENER, "taphold",

      SizeListListener), _defineProperty(_LISTENER, "tapholdend",
      SizeListListener), _defineProperty(_LISTENER, "tap",
      SizeListListener), _LISTENER),

      DATA_FINDER: (_DATA_FINDER = {}, _defineProperty(_DATA_FINDER,
      tempEventName.move, SizeListDataFinder), _defineProperty(_DATA_FINDER,
      tempEventName.out, SizeListDataFinder), _defineProperty(_DATA_FINDER, "click",
      SizeListDataFinder), _defineProperty(_DATA_FINDER, "dblclick",
      SizeListDataFinder), _defineProperty(_DATA_FINDER, "taphold",

      SizeListDataFinder), _defineProperty(_DATA_FINDER, "tapholdend",
      SizeListDataFinder), _defineProperty(_DATA_FINDER, "tap",
      SizeListDataFinder), _DATA_FINDER),

      BEHAVIOUR: (_BEHAVIOUR = {}, _defineProperty(_BEHAVIOUR,
      tempEventName.move, [showCursor, HighlightSeries, HighlightItem$2]), _defineProperty(_BEHAVIOUR,
      tempEventName.out, [hideCursor, ResetHighlightSeries, ResetHighlightItem$1]), _defineProperty(_BEHAVIOUR, "click",
      [ClearCache, ApplyFilterOnPlot, PaintFilterItem]), _defineProperty(_BEHAVIOUR, "dblclick",
      []), _defineProperty(_BEHAVIOUR, "taphold",

      [ResetOldHighlight, showCursor, HighlightSeries, HighlightItem$2]), _defineProperty(_BEHAVIOUR, "tapholdend",
      [hideCursor, ResetHighlightSeries, ResetHighlightItem$1]), _defineProperty(_BEHAVIOUR, "tap",
      [ResetOldHighlight, ClearCache, ApplyFilterOnPlot, PaintFilterItem]), _BEHAVIOUR),

      REVERSE_DATA_FINDER: {
        mousemove: SizeListReverseDataFinder
      },
      REVERSE_BEHAVIOUR: {
        mousemove: [HighlightItem$2, ScrollItemToView],
        mouseout: [ResetHighlightItem$1]
      },
      SUPPORTED: function SUPPORTED(chart, id) {
        return id === 'z-0' && getLegendView(chart.legends, id) === LIST_LEGEND_TYPE;
      }
    };
    Registry.setComponent('_legendSizeListHandlers', _legendSizeListHandlers);

    //

    /**
     *
     * @param chart
     * @return {Legend Event options}
     */
    function _legendSizeListEventArguments(chart, id) {
      var legendInstance = chart.legends.get(id),
        component = legendInstance.component,element = legendInstance.element,meta = legendInstance.meta,highlightManager = legendInstance.highlightManager,
        config = meta.config,globalFont = meta.globalFont,scaleComponent = meta.scaleComponent,
        eventsConfig = config.events,
        dataType = scaleComponent.schema.data.dataType,

        trackerElement = getTrackerElement$3(element),_component$viewScaleC =
        component.viewScaleComponent(),ticks = _component$viewScaleC.ticks,scale = _component$viewScaleC.scale,

        eventDisabled = eventsConfig && validateNullVal(eventsConfig.enabled, true) == false,
        enabled = legendInstance.enabled && !eventDisabled,

        scrollToItem,
        boxSize;

      if (enabled) {
        var _viewSpec2 = component._parser.viewSpec,
          listConfig = _viewSpec2.config.list,
          markerConfig = listConfig.marker,labelConfig = listConfig.label;
        boxSize = getBoxSize$1(markerConfig, labelConfig, _viewSpec2.align, _viewSpec2.scale, _viewSpec2.label.fontSize);

        scrollToItem = getScrollToItem(element, component);
      }

      return { enabled: enabled, trackerElement: trackerElement, highlightManager: highlightManager, config: config, globalFont: globalFont, dataType: dataType, legendInstance: legendInstance, scale: scale, ticks: ticks, boxSize: boxSize, scrollToItem: scrollToItem };
    }

    /**
     * Returns tracker element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getTrackerElement$3(container) {
      return container.selectAll("li.".concat(SERIES_LEGEND_CLASSNAME));
    }

    function getScrollToItem(container, component) {
      var ulElement = container && container.selectAll(".".concat(LEGSERIES_LEGEND_CLASSNAME)).node();

      if (ulElement) {
        var expandableMark = component.encode.children[2],
          liElement = ulElement ? ulElement.children : [],
          parser = expandableMark._parser,
          _expanded = parser.show ? expandableState(expandableMark) : true,
          isHorizontal = expandableMark._spec.isHorizontal,
          measure = isHorizontal ? 'Width' : 'Height';

        return {
          ulElement: ulElement,
          liElement: liElement,
          available: ulElement["client".concat(measure)],
          isScrollable: ulElement["scroll".concat(measure)] > ulElement["client".concat(measure)] && _expanded,
          isHorizontal: isHorizontal
        };
      }
    }
    Registry.setComponent('_legendSizeListEventArguments', _legendSizeListEventArguments);

    //

    var sizeNestedOptions = function sizeNestedOptions(userProp) {
      return {
        marker: {
          shape: 'circle',
          hAlign: CENTER_ALIGN,
          vAlign: BOTTOM_ALIGN,
          fillColor: TRANSPARENT,
          strokeColor: '#C0C2C4'
        },
        axis: {
          show: true,
          tickOrient: INNER_ALIGN,
          ticklabel: {
            fontSize: userProp.fontL1Size.l8
          },
          tickmark: {
            show: false,
            color: '#AAACAF',
            size: 10
          }
        }
      };
    };
    Registry.setComponent('sizeNestedOptions', sizeNestedOptions);

    //

    var CENTER_CENTER_ALIGN = 'center-center';

    // TODO: check
    function NestedAxisParser(spec) {
      var data = spec.data,config = spec.config,bound = spec.bound,scale = spec.scale,align = spec.align,format = spec.format,_spec$shape = spec.shape,shape = _spec$shape === void 0 ? 'square' : _spec$shape,availableBound = spec.availableBound,

        lableConfig = config.ticklabel,lineConfig = config.tickmark,show = config.show,
        outerOrient = isOuterTickOrient(config),

        tickMarkParser = show && outerOrient && parseTickMark(lineConfig, bound, scale, align, shape),
        tickLabelParser = show && parseTickLabel(lableConfig, bound, scale, align, format, lineConfig, shape, outerOrient),
        tickLabelEnd = function tickLabelEnd(labelEle, lineEle) {return handleTicklabels(labelEle, lineEle, availableBound, bound, tickLabelParser.config);};

      var groupMark = Mark('group', ".".concat(NESTED_AXIS_CLASSNAME));

      if (!show) {
        return groupMark;
      }

      // Tick mark
      var lineGroupMark = Mark('group', ".".concat(NESTED_AXIS_TICKMARK_CLASSNAME));
      if (tickMarkParser) {
        var lineMark = { mark: 'line', data: data, config: tickMarkParser.config };
        setPropVal(lineMark, 'properties.styles', tickMarkParser.styles);
        lineGroupMark.children = [lineMark];
      }

      // Tick label
      var labelGroupMark = Mark('group', ".".concat(NESTED_AXIS_TICKLABEL_CLASSNAME));
      if (labelGroupMark) {
        var labelMark = { mark: 'text', data: data, config: tickLabelParser.config };
        setPropVal(labelMark, 'properties.styles', tickLabelParser.styles);
        labelGroupMark.children = [labelMark];
        labelGroupMark.onEnd = function (ele) {return tickLabelEnd(ele.selectAll('text'), lineGroupMark.element.selectAll('line'));};
      }

      groupMark.children = [lineGroupMark, labelGroupMark];

      return groupMark;
    }

    function parseTickMark(config, bound, scale, align, shape) {
      var _getAxisAlignment = getAxisAlignment(align),hAlign = _getAxisAlignment.hAlign,vAlign = _getAxisAlignment.vAlign,
        color = config.color,_config$size = config.size,size = _config$size === void 0 ? 3 : _config$size,
        position = linePoints(bound, scale, hAlign, vAlign, size, shape);

      return {
        config: _objectSpread(_objectSpread({ strokeColor: color }, position), config),
        styles: { display: null, fillColor: 'none' }
      };
    }

    function parseTickLabel(config, bound, scale, align, format, tickMarkConfig, shape, outerOrient) {
      var _getAxisAlignment2 = getAxisAlignment(align),hAlign = _getAxisAlignment2.hAlign,vAlign = _getAxisAlignment2.vAlign,
        x,
        y,
        dy,
        anchor = null,
        margin = pick(config.margin, 2),
        isHorizontal = vAlign === CENTER_ALIGN;

      if (outerOrient) {
        var tickMarkSize = pick(tickMarkConfig.size, 3),
          newMargin = mergeShortHandValues(tickMarkSize, margin);var _linePoints =

        linePoints(bound, scale, hAlign, vAlign, newMargin, shape);x = _linePoints.x2;y = _linePoints.y2;
        dy = isHorizontal ? '1em' : '0.3em';
        anchor = isHorizontal ? MIDDLE_ALIGN : null;
      } else {var _startXY2 =
        startXY(bound, scale, hAlign, vAlign, margin, shape);var _startXY3 = _slicedToArray(_startXY2, 2);x = _startXY3[0];y = _startXY3[1];
        dy = _dy(vAlign);
        anchor = _anchor(hAlign);
      }

      return {
        config: _objectSpread({
          text: format,
          transform: function transform(d) {return translateString([x(d), y(d)]);},
          anchor: anchor,
          dy: dy },
        config),

        styles: { display: null }
      };
    }

    function _x(bound, scale, hAlign) {var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var parsedMargin = parseShortHandValue(margin),
        w = bound.width;

      switch (hAlign) {
        case LEFT_ALIGN:
          return function (d) {return scale(d) + parsedMargin.left;};
        case RIGHT_ALIGN:
          return function (d) {return w - scale(d) - parsedMargin.right;};
        default:
          return function () {return w / 2;};}

    }

    function _y(bound, scale, vAlign) {var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var parsedMargin = parseShortHandValue(margin),
        h = bound.height;

      switch (vAlign) {
        case TOP_ALIGN:
          return function (d) {return scale(d) + parsedMargin.top;};
        case BOTTOM_ALIGN:
          return function (d) {return h - scale(d) - parsedMargin.bottom;};
        case CENTER_CENTER_ALIGN:
          return function (d) {return (h - scale(d)) / 2 - parsedMargin.bottom;};
        default:
          return function () {return h / 2;};}

    }

    function _anchor(hAlign) {
      switch (hAlign) {
        case LEFT_ALIGN:
          return null;
        case RIGHT_ALIGN:
          return END_ALIGN;
        default:
          return MIDDLE_ALIGN;}

    }

    function _dy(vAlign) {
      switch (vAlign) {
        case TOP_ALIGN:
          return '1em';
        case BOTTOM_ALIGN:
        case CENTER_CENTER_ALIGN:
          return '-0.3em';
        default:
          return '0.3em';}

    }

    function startXY(bound, scale, hAlign, vAlign, margin, shape, outerOrient) {
      var x = _x(bound, scale, hAlign, margin),
        y = _y(bound, scale, vAlign, margin),
        startX = x,
        startY = y;

      if (shape === 'square') {
        if (outerOrient) {
          if (vAlign === CENTER_ALIGN) {
            startY = function startY(d) {return y(d) + scale(d) / 2;};
          } else if (hAlign === CENTER_ALIGN) {
            startX = function startX(d) {return x(d) + scale(d) / 2;};
          } else if (hAlign === RIGHT_ALIGN) {
            startX = function startX(d) {return x(d) + scale(d);};
          }
        }
      } else if (vAlign !== CENTER_ALIGN) {
        if (hAlign === LEFT_ALIGN) {
          startX = function startX(d) {return x(d) - scale(d) / 2;};
        } else if (hAlign === RIGHT_ALIGN) {
          startX = function startX(d) {return x(d) + scale(d) / 2;};
        }
      }

      return [startX, startY];
    }

    function linePoints(bound, scale, hAlign, vAlign, size, shape) {
      size = parseShortHandValue(size);

      var _startXY = startXY(bound, scale, hAlign, vAlign, 0, shape, true),
        x1 = _startXY[0],
        y1 = _startXY[1],
        x2 = function x2() {return bound.width + size.left;},
        y2 = function y2() {return bound.height + size.top;};

      if (vAlign === CENTER_ALIGN) {
        x2 = x1;
      } else {
        y2 = y1;
      }
      return { x1: x1, y1: y1, x2: x2, y2: y2 };
    }

    function getAxisAlignment(align) {
      var hAlign = align.hAlign,vAlign = align.vAlign;
      if (vAlign === CENTER_ALIGN && hAlign === CENTER_ALIGN) {
        vAlign = CENTER_CENTER_ALIGN;
      }

      return { vAlign: vAlign, hAlign: hAlign };
    }

    function mergeShortHandValues() {
      var values = toArray(arguments).slice(0),
        sides = { top: 0, right: 0, bottom: 0, left: 0 };

      values.map(function (_) {
        var parsed = parseShortHandValue(_);
        for (var side in sides) {
          sides[side] += parsed[side];
        }
      });

      return objectValues(sides).join(' ');
    }

    function isOuterTickOrient(config) {
      var tickOrient = config.tickOrient;
      return tickOrient === OUTER_ALIGN;
    }

    var NESTED_VIEW_CLASSNAME = 'zc-nested-view';

    //

    function NestedParser(spec) {
      var config = spec.config,bound = spec.bound,_spec$data2 = spec.data,data = _spec$data2 === void 0 ? [] : _spec$data2,_spec$scale = spec.scale,scale = _spec$scale === void 0 ? function (d) {return d;} : _spec$scale,
        x = _x$1(bound, scale, config.hAlign),
        y = _y$1(bound, scale, config.vAlign);

      var groupMark = Mark('group', ".".concat(NESTED_VIEW_CLASSNAME)),
        pointMark = Mark('point', null, data);

      pointMark.config = _objectSpread(_objectSpread({},
      config), {}, {
        size: {
          _type: 'encode',
          scale: scale
        },
        x: {
          _type: 'encode',
          scale: x
        },
        y: {
          _type: 'encode',
          scale: y
        } });


      groupMark.children = [pointMark];
      return groupMark;
    }

    NestedParser.x = _x$1;
    NestedParser.y = _y$1;

    function _x$1(bound, scale, hAlign) {
      var w = bound.width;

      switch (hAlign) {
        case LEFT_ALIGN:
          return function (d) {return scale(d) / 2;};
        case RIGHT_ALIGN:
          return function (d) {return w - scale(d) / 2;};
        default:
          return function () {return w / 2;};}

    }

    function _y$1(bound, scale, vAlign) {
      var h = bound.height;

      switch (vAlign) {
        case TOP_ALIGN:
          return function (d) {return scale(d) / 2;};
        case BOTTOM_ALIGN:
          return function (d) {return h - scale(d) / 2;};
        default:
          return function () {return h / 2;};}

    }

    //

    function SizeNestedParser(spec, viewScaleComponent) {
      var _helper$c = helper$c(spec, viewScaleComponent),titleSpec = _helper$c.titleSpec,viewSpec = _helper$c.viewSpec,axisSpec = _helper$c.axisSpec,backgroundSpec = _helper$c.backgroundSpec,axisEnd = _helper$c.axisEnd; // TODO: implement axisEnd

      var groupMark = Mark('group', '.legendgroup'),
        backgroundMark = _LegendBackgroundSvgParser(backgroundSpec),
        contentMark = LegendContentWrapParser();

      // Title
      var titleMark = LegendTitleSvgParser(titleSpec);
      setPropVal(titleMark, 'as.height', 'title_height');

      // Nested view
      var nestedMark = NestedParser(viewSpec);
      setPropVal(nestedMark, 'config.y', { _type: 'as', as: 'title_height' });

      // Axis
      var axisMark = NestedAxisParser(axisSpec);
      axisMark.onEnd = function () {return axisEnd(axisMark, nestedMark, titleMark);}; // TODO: Replace by 'as'

      contentMark.children = [titleMark, nestedMark, axisMark];
      groupMark.children = [backgroundMark, contentMark];

      return groupMark;
    }

    function helper$c(spec, viewScaleComponent) {
      var config = spec.config,bound = spec.bound,format = spec.format,
        viewScale = viewScaleComponent.scale,viewBound = viewScaleComponent.bound,ticks = viewScaleComponent.ticks,labels = viewScaleComponent.labels,

        nestedConfig = config.nested,
        markerConfig = nestedConfig.marker,
        axisConfig = nestedConfig.axis,
        padding = pick(nestedConfig.padding, 3),
        parsedPadding = parseShortHandValue(padding);

      var titleSpec = {
          data: [1],
          config: config.title,
          bound: bound
        },
        viewSpec = {
          bound: viewBound,
          data: d3_values(ticks).reverse(),
          scale: viewScale,
          config: markerConfig
        },
        axisSpec = {
          bound: viewBound,
          data: labels || ticks,
          scale: viewScale,
          config: axisConfig,
          align: { hAlign: markerConfig.hAlign, vAlign: markerConfig.vAlign },
          format: format,
          shape: markerConfig.shape,
          availableBound: {
            maxWidth: bound.maxWidth - parsedPadding.left - parsedPadding.right,
            maxHeight: bound.maxHeight - parsedPadding.top - parsedPadding.bottom
          }
        },
        backgroundSpec = {
          data: [1],
          config: config,
          margin: padding
        },
        axisEnd = function axisEnd(axisEncode, nestedEncode, titleEncode) {
          var axisBox = bbox(axisEncode.element),
            titleBox = bbox(titleEncode.element),
            y = mathMax(-axisBox.y, 0) + titleBox.height + padding;

          axisEncode.element.attr('transform', "translate(0,".concat(y, ")"));
          nestedEncode.element.attr('transform', "translate(0,".concat(y, ")"));
        };

      return { titleSpec: titleSpec, viewSpec: viewSpec, axisSpec: axisSpec, backgroundSpec: backgroundSpec, axisEnd: axisEnd };
    }

    //
    var
    SizeLegendNested = /*#__PURE__*/function (_SizeLegend2) {_inherits(SizeLegendNested, _SizeLegend2);var _super13 = _createSuper(SizeLegendNested);function SizeLegendNested() {_classCallCheck(this, SizeLegendNested);return _super13.apply(this, arguments);}_createClass(SizeLegendNested, [{ key: "create", value:
        function create() {
          this.encode = SizeNestedParser(this.spec, this.viewScaleComponent());
        } }, { key: "resize", value:

        function resize(width, height) {
          if (!width && !height) {
            return;
          }

          var _getMaxToResize4 = getMaxToResize(width, height, this.spec.bound),w = _getMaxToResize4.w,h = _getMaxToResize4.h,
            children = this.encode.children,

            backgroundBox = bbox(children[0].element),
            nestedBox = bbox(children[1].children[1].element);

          w -= width ? mathMax(backgroundBox.width - nestedBox.width, 0) : 0;
          h -= height ? mathMax(backgroundBox.height - nestedBox.height, 0) : 0;

          this.updateScale(w, h);
          _get(_getPrototypeOf(SizeLegendNested.prototype), "resize", this).call(this, width, height);
        } }, { key: "draw", value:

        function draw(element) {
          this.element = element;
          renderDom(this.encode, element);

          var _this$spec2 = this.spec,config = _this$spec2.config,bound = _this$spec2.bound,
            maxWidth = config.maxWidth,maxHeight = config.maxHeight,
            w = bound.maxWidth,
            h = bound.maxHeight,
            bb = bbox(element),
            bb_width = bb.width,
            bb_height = bb.height;

          //ZC2184, ZC2182
          // If user defined maxWidth or maxHeight is present adjust
          if ((maxWidth || maxHeight) && (bb_width - w > 1 || bb_height - h > 1)) {
            w -= maxWidth && bb_width > w ? bb_width - w : 0;
            h -= maxHeight && bb_height > h ? bb_height - h : 0;

            this.updateScale(w, h);
            this.create();
            renderDom(this.encode, element);
          }
        } }]);return SizeLegendNested;}(SizeLegend);


    SizeLegendNested.adjustFactor = function (config, w, h, globalFont) {
      var adjust = [0, 0],
        maxWidth = config.maxWidth,maxHeight = config.maxHeight,
        axisConfig = config.nested.axis;

      if (axisConfig.show) {
        if (!maxHeight) {
          adjust[1] += getTextHeight([axisConfig.ticklabel, globalFont, $ZCG]);
        }

        if (!maxWidth) {
          adjust[0] += w * (isOuterTickOrient(axisConfig) ? 0.3 : 0.2);
        }
      }

      return adjust;
    };

    SizeLegendNested.encode = 'z';
    SizeLegendNested.view = 'nested';
    SizeLegendNested.domMode = 'svg';
    Registry.setComponent('sizeLegendNested', SizeLegendNested);
    LegendRegistry.add(SizeLegendNested);

    function SizeNestedListener(d, index, ele, eventType) {
      var manager = this,
        event = d3_event(),
        node = event.srcElement || event.target,
        mouse = getMousePosition(node, event);

      var data = manager.getData(eventType, mouse, [d, index]);

      manager.associateBehaviours(eventType, data, mouse, event);
    }

    function closestToPolygon(polygonPoints, point) {
      var _point3 = _slicedToArray(point, 2),x = _point3[0],y = _point3[1],
        distances = polygonPoints.map(function (_) {return geometryUtils.dist({ x: _[0], y: _[1] }, { x: x, y: y });}),
        closet = d3_min(distances);

      return closet || 0;
    }

    Registry.setComponent('geometryUtils.polygon.closestToPolygon', closestToPolygon);

    //$Id$

    function SizeNestedDataFinder(mouse, eventType, d, index) {
      var manager = this,
        options = manager.options,
        ticks = options.ticks,config = options.config,scale = options.scale,viewBound = options.viewBound,polygonPoints = options.polygonPoints,
        ranges = config.ranges,nestedConfig = config.nested,_nestedConfig$marker =
        nestedConfig.marker,hAlign = _nestedConfig$marker.hAlign,vAlign = _nestedConfig$marker.vAlign,_nestedConfig$marker$ = _nestedConfig$marker.shape,shape = _nestedConfig$marker$ === void 0 ? 'circle' : _nestedConfig$marker$,
        hoverOptions = getHoverOptions(config),
        triggerOffset = mathMax(pick(hoverOptions.triggerOffset, 5), 0.1);

      var data = ticks.length - 1 - index; // as bigger value rendered first

      if (ranges && ranges.length) {
        return data;
      } else {
        var d2 = ticks[data],
          d1 = pick(ticks[data - 1], scale.domain()[0]),
          _x7 = NestedParser.x(viewBound, scale, hAlign),
          _y5 = NestedParser.y(viewBound, scale, vAlign),
          //
          c1 = [_x7(d1), _y5(d1)],
          c2 = [_x7(d2), _y5(d2)],
          p = [c2[0] + mouse[0], c2[1] + mouse[1]],
          //
          closest1,
          closest2;

        if (shape === 'circle') {
          closest1 = closestToCircle([].concat(c1, [scale(d1) / 2]), p);
          closest2 = closestToCircle([].concat(c2, [scale(d2) / 2]), p);
        } else {
          var polygonPoints1 = polygonPoints[index + 1] || [],
            polygonPoints2 = polygonPoints[index];

          closest1 = closestToPolygon(polygonPoints1.map(function (_) {return [_[0] + c1[0], _[1] + c1[1]];}), p);
          closest2 = closestToPolygon(polygonPoints2.map(function (_) {return [_[0] + c2[0], _[1] + c2[1]];}), p);
        }

        var _scale7 = d3_scaleLinear().
          domain([0, closest1 + closest2]).
          range([d1, d2]),
          point = _scale7(closest1);

        return invertMousePoint(scale(point), scale, { triggerOffset: triggerOffset, round: true });
      }
    }

    function SizeNestedReverseDataFinder() {
      return SizeReverseDataFinder.apply(this, arguments);
    }

    //

    /*
    spec = {
        bound: {
            width: 100,
            height: 100
        },
        data: [10, 20, 30],
        scale: d => d * 2,
        config: {
            shape: "circle",
            hAlign: "center",
            vAlign: "bottom",
            fillColor: "transparent",
            strokeColor: "#C0C2C4"
        }
    }
     */var

    NestedView = /*#__PURE__*/function (_BaseView4) {_inherits(NestedView, _BaseView4);var _super14 = _createSuper(NestedView);function NestedView() {_classCallCheck(this, NestedView);return _super14.apply(this, arguments);}return _createClass(NestedView);}(BaseView);
    NestedView.parser = NestedParser;
    Registry.setComponent('nestedView', NestedView);

    function HighlightItem$3(mouse, data) {
      var manager = this,
        options = manager.options,
        config = options.config,highlightElement = options.highlightElement,viewScale = options.viewScale,viewBound = options.viewBound,dataType = options.dataType,
        ranges = config.ranges,nestedConfig = config.nested,
        hoverOptions = getHoverOptions(config),
        markerConfig = nestedConfig.marker,
        hoverMarkerConfig = hoverOptions.marker,
        point = data.point;

      if (isEmptyObject(hoverMarkerConfig)) {
        return;
      }

      // Show highlight element
      highlightElement.style('opacity', null);

      var viewParser = {
        bound: viewBound,
        data: getHighlightData$2(point, ranges, dataType),
        scale: viewScale,
        config: mergeJSON$1(hoverMarkerConfig, markerConfig)
      };
      var viewObj = new NestedView(viewParser);
      viewObj.create();
      viewObj.draw(highlightElement);
    }

    function getHighlightData$2(point, ranges, dataType) {
      if (dataType === ORDINAL_DATATYPE) {
        return [ranges[point][0]];
      } else if (ranges && ranges.length) {
        return [ranges[point]];
      } else if (defined(point.data)) {
        return [point.data];
      } else {
        return [];
      }
    }

    function ResetHighlightItem$2() {
      var manager = this,
        options = manager.options,
        highlightElement = options.highlightElement;

      // Hide highlight element
      highlightElement.style('opacity', 0);
    }

    function ShowTooltip(mouse, data) {
      var manager = this,
        options = manager.options,
        tooltip = options.tooltip,format = options.format,config = options.config,highlightElement = options.highlightElement,dataType = options.dataType,
        userRanges = config.ranges,
        point = data.point,
        d = dataType === ORDINAL_DATATYPE ? userRanges[point][0] : userRanges && userRanges.length ? userRanges[point] : point[0];

      // Position
      var ele = highlightElement.selectAll("g.".concat(NESTED_VIEW_CLASSNAME)).selectAll(PATH_ELEMENT),
        position = getSVGTooltipPosition(ele, tooltip.config, undefined, getSvgTransform(ele).translate); // getSVGTooltipPosition should be called before tooltip.show

      // Content
      tooltip.show(format(d));

      tooltip.positionTooltip(position);
    }

    //

    var _legendSizeNestedHandlers = {
      LISTENER: {
        mousemove: SizeNestedListener,
        mouseout: SizeNestedListener,

        taphold: SizeNestedListener,
        tapholdend: SizeNestedListener
      },
      DATA_FINDER: {
        mousemove: SizeNestedDataFinder,
        mouseout: SizeNestedDataFinder,

        taphold: SizeNestedDataFinder,
        tapholdend: SizeNestedDataFinder
      },
      BEHAVIOUR: {
        mousemove: [showCursor, HighlightSeries, HighlightItem$3, ShowTooltip],
        mouseout: [hideCursor, hideTooltip$1, ResetHighlightSeries, ResetHighlightItem$2],

        taphold: [ResetOldHighlight, showCursor, HighlightSeries, HighlightItem$3, ShowTooltip],
        tapholdend: [hideCursor, hideTooltip$1, ResetHighlightSeries, ResetHighlightItem$2]
      },
      REVERSE_DATA_FINDER: {
        mousemove: SizeNestedReverseDataFinder
      },
      REVERSE_BEHAVIOUR: {
        mousemove: [HighlightItem$3, ShowTooltip],
        mouseout: [ForceHideTooltip$1, ResetHighlightItem$2]
      },
      SUPPORTED: isSupported(NESTED_LEGEND_TYPE)
    };
    Registry.setComponent('_legendSizeNestedHandlers', _legendSizeNestedHandlers);

    /**
     *
     * @param chart
     * @return {Legend Event options}
     */
    function _legendSizeNestedEventArguments(chart, id) {
      var legendInstance = chart.legends.get(id),
        component = legendInstance.component,meta = legendInstance.meta,element = legendInstance.element,highlightManager = legendInstance.highlightManager,

        config = meta.config,scaleComponent = meta.scaleComponent,format = meta.format,
        eventsConfig = config.events,nestedConfig = config.nested,
        shape = nestedConfig.marker.shape,
        dataType = scaleComponent.schema.data.dataType,
        scale = scaleComponent.getScale(),

        trackerElement = getTrackerElement$4(element),
        highlightElement = getHighlightElement$2(element),_component$viewScaleC2 =
        component.viewScaleComponent(),ticks = _component$viewScaleC2.ticks,viewScale = _component$viewScaleC2.scale,viewBound = _component$viewScaleC2.bound,

        eventDisabled = eventsConfig && validateNullVal(eventsConfig.enabled, true) == false,
        hoverOptions = getHoverOptions(config),
        hasHoverStyle = !isEmptyObject(hoverOptions.marker),
        polygonPoints = shape !== 'circle' ? getPolygonPoints$1(trackerElement) : null,
        enabled = legendInstance.enabled && !eventDisabled && hasHoverStyle,
        tooltip = getTooltip$1(chart, highlightElement, config);

      return {
        enabled: enabled,
        trackerElement: trackerElement,
        highlightElement: highlightElement,
        highlightManager: highlightManager,
        config: config,
        ticks: ticks,
        viewScale: viewScale,
        viewBound: viewBound,
        scale: scale,
        dataType: dataType,
        polygonPoints: polygonPoints,
        legendInstance: legendInstance,
        tooltip: tooltip,
        format: format
      };
    }

    /**
     * Returns tracker element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getTrackerElement$4(container) {
      return container.
      select("g.".concat(NESTED_VIEW_CLASSNAME)).
      selectAll(PATH_ELEMENT).
      style('pointer-events', 'all');
    }

    /**
     * Returns highlight element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getHighlightElement$2(container) {
      var nestedEle = container.select("g.".concat(NESTED_VIEW_CLASSNAME));

      return createElement('g', ".".concat(HIGHLIGHT_LEGEND_CLASSNAME), [1], container).
      style('display', null).
      style('opacity', 0).
      attr('transform', nestedEle.empty() ? null : nestedEle.attr('transform'));
    }

    function getTooltip$1(chart, element, config) {
      var hoverOptions = getHoverOptions(config),
        tooltipConfig = hoverOptions.tooltip,
        userOrient = tooltipConfig && tooltipConfig.orient,
        orient = userOrient ? getOppositeOrient(userOrient) : getDefaultTooltipOrient(config),
        tooltipOptions = {
          config: _objectSpread(_objectSpread({}, tooltipConfig), {}, { orient: orient }),
          orient: orient,
          element: element,
          chart: chart
        };

      return HighlightTooltip(tooltipOptions);
    }

    function getDefaultTooltipOrient(config) {
      var nestedConfig = config.nested,_nestedConfig$marker2 =
        nestedConfig.marker,hAlign = _nestedConfig$marker2.hAlign,vAlign = _nestedConfig$marker2.vAlign;

      if (vAlign !== CENTER_ALIGN) {
        return vAlign;
      } else if (hAlign !== CENTER_ALIGN) {
        return hAlign;
      } else {
        return BOTTOM_ALIGN;
      }
    }

    /**
     * Returns polygon points of element
     * @param  {D3Selectiion} element
     * @return {Array}
     */
    function getPolygonPoints$1(element) {
      var points = [];

      element.each(function () {
        points.push(elementToPolygonPoints(this));
      });

      return points;
    }

    Registry.setComponent('_legendSizeNestedEventArguments', _legendSizeNestedEventArguments);

    var sizeSliderOptions = function sizeSliderOptions(userProp) {
      return {
        marker: {
          shape: 'circle',
          hAlign: CENTER_ALIGN,
          vAlign: CENTER_ALIGN,
          fillColor: '#51545A',
          strokeColor: 'white'
        },
        track: {
          show: true,
          fillColor: '#F2F3F5'
        },
        connector: {
          show: true,
          strokeColor: '#51545A'
        },
        axis: {
          show: true,
          ticklabel: {
            fontSize: userProp.fontL1Size.l5
          },
          minmaxlabels: {
            padding: 2,
            align: 'center',
            fontSize: userProp.fontL1Size.l5
          },
          tickmark: {
            color: 'rgb(97, 97, 97)',
            size: 5
          },
          axisline: {
            show: true,
            color: 'rgb(97, 97, 97)'
          }
        }
      };
    };

    Registry.setComponent('sizeSliderOptions', sizeSliderOptions);

    //

    function SliderAxisAdjustFactor(config, w, h, globalFont, align) {
      var show = config.show,padding = config.padding,tickMarkconfig = config.tickmark,axisLineconfig = config.axisline,tickLabelConfig = config.ticklabel,
        isHorizontal = align.layout === HORIZONTAL_ALIGN,
        axisPadding = pick(padding, 3),
        tickMarkSize = pick(tickMarkconfig.size, 6),
        axisLineSize = axisLineconfig ? pick(axisLineconfig.strokeWidth, 1) : 0,
        tickLabelMargin = pick(tickLabelConfig.margin, 3),
        tickLabelSize = getTextHeight([tickLabelConfig, globalFont, $ZCG]),
        adjust = [0, 0];

      if (show) {
        if (isHorizontal) {
          adjust[1] += tickLabelSize + axisLineSize + tickMarkSize + axisPadding + tickLabelMargin;
        } else {
          adjust[0] += tickLabelSize + axisLineSize + tickMarkSize + axisPadding + tickLabelMargin + w * 0.2;
        }
      }

      return adjust;
    }

    //

    function MinmaxLabelAdjustFactor(config, w, h, globalFont, align) {
      var isHorizontal = align.layout === HORIZONTAL_ALIGN,
        padding = pick(config.padding, 2),
        labelHeight = getTextHeight([config, globalFont, $ZCG]),
        labelAlign = config.align,
        adjust = [0, 0];

      if (config.show) {
        if (isHorizontal && labelAlign !== CENTER_ALIGN || !isHorizontal && labelAlign === CENTER_ALIGN) {
          adjust[1] += (padding + labelHeight) * 2;
        } else {
          adjust[0] += padding + labelHeight + w * 0.2;
        }
      }

      return adjust;
    }
    Registry.setComponent('minmaxLabel.adjust', MinmaxLabelAdjustFactor);

    //
    var
    SizeLegendSlider = /*#__PURE__*/function (_SizeLegend3) {_inherits(SizeLegendSlider, _SizeLegend3);var _super15 = _createSuper(SizeLegendSlider);
      function SizeLegendSlider() {var _this29;_classCallCheck(this, SizeLegendSlider);
        _this29 = _super15.apply(this, arguments);
        _this29.brushOptions = _this29.getBrushOptions();return _this29;
      }_createClass(SizeLegendSlider, [{ key: "create", value:
        function create() {var _this30 = this;
          var viewScaleComponent = this.viewScaleComponent();
          this.viewScale = viewScaleComponent.scale;
          this.brushOptions = this.getBrushOptions();

          var obj = { spec: this.spec, brushOptions: this.brushOptions, viewScaleComponent: viewScaleComponent, align: function align() {return _this30.align(_this30);} };
          var mark = SizeSliderParser(obj);
          this._parser = mark._helper;
          return this.encode = mark;
        } }, { key: "resize", value:

        function resize(width, height) {
          if (!width && !height) {
            return;
          }

          // Element
          var trackerEle = getEle$2(this, 'Tracker'),
            backgroundEle = getEle$2(this, 'LegendBackgroundSvg'),

            trackerBox = bbox(trackerEle),
            backgroundBox = bbox(backgroundEle),_getMaxToResize5 =

            getMaxToResize(width, height, this.spec.bound),w = _getMaxToResize5.w,h = _getMaxToResize5.h;

          w -= width ? mathMax(backgroundBox.width - trackerBox.width, 0) : 0;
          h -= height ? mathMax(backgroundBox.height - trackerBox.height, 0) : 0;

          this.updateScale(w, h);
          _get(_getPrototypeOf(SizeLegendSlider.prototype), "resize", this).call(this, w, h);
        } }, { key: "align", value:

        function align(self) {
          var alignSpec = self._parser.alignSpec,
            isHorizontal = alignSpec.isHorizontal,padding = alignSpec.padding,axisPadding = alignSpec.axisPadding,axisOrient = alignSpec.axisOrient,markerSize = alignSpec.markerSize,

            titleEle = getEle$2(self, 'LegendTitleSvg'),
            trackerEle = getEle$2(self, 'Tracker'),
            sliderEle = getEle$2(self, 'SliderView'),
            axisEle = getEle$2(self, 'SliderAxis'),
            minmaxLabelEle = getEle$2(self, 'MinmaxLabel'),
            connectorEle = getEle$2(self, 'Connector'),
            selectionTrackerEle = getEle$2(self, 'SelectionTracker'),

            titleBox = bbox(titleEle),
            trackerBox = bbox(trackerEle),
            axisBox = bbox(axisEle),
            minmaxLabelsBox = bbox(minmaxLabelEle),

            radius0 = markerSize[0][0] / 2,
            x,
            y;

          if (isHorizontal) {
            if (axisOrient === TOP_ALIGN) {
              x = radius0 - mathMin(0, axisBox.x);
              y = titleBox.height + axisBox.height + padding;

              translate$1([x, y + axisPadding - trackerBox.y], trackerEle, sliderEle, connectorEle, selectionTrackerEle);
              translate$1([x, y], axisEle, minmaxLabelEle);
            } else {
              x = radius0;
              y = titleBox.height + padding;

              translate$1([x, y - trackerBox.y], trackerEle, sliderEle, connectorEle, selectionTrackerEle);
              translate$1([x, y + trackerBox.height + axisPadding], axisEle, minmaxLabelEle);
            }
          } else {
            if (axisOrient === LEFT_ALIGN) {
              x = axisBox.width;
              y = titleBox.height + padding + mathMax(-mathMin(0, minmaxLabelsBox.y), radius0);

              translate$1([x + axisPadding, y], trackerEle, sliderEle, connectorEle, selectionTrackerEle);
              translate$1([x + trackerBox.x, y], axisEle, minmaxLabelEle);
            } else {
              x = 0;
              y = titleBox.height + padding + mathMax(-mathMin(0, minmaxLabelsBox.y), radius0);

              translate$1([x, y], trackerEle, sliderEle, connectorEle, selectionTrackerEle);
              translate$1([trackerBox.width + trackerBox.x + axisPadding, y], axisEle);
              translate$1([trackerBox.width + trackerBox.x, y], minmaxLabelEle);
            }
          }

          var titleX = mathMin(0, minmaxLabelEle.node().getBoundingClientRect().left - titleEle.node().getBoundingClientRect().left);
          translate$1([titleX, 0], titleEle);
        } }, { key: "getSliderArea", value:

        function getSliderArea() {
          // TODO: consider maxWidth, maxHeight, axis, minmaxlabels
          var scale = this.viewScale,_this$spec3 =
            this.spec,config = _this$spec3.config,bound = _this$spec3.bound,area = _this$spec3.area,
            maxWidth = bound.maxWidth,maxHeight = bound.maxHeight,
            sliderConfig = config.slider,
            filterConfig = getDisabledOptions(config),
            scale_domain = scale.domain(),
            range = [scale(scale_domain[0]), scale(scale_domain[scale_domain.length - 1])],
            align = getLegendAlignment(config),
            isHorizontal = align.layout === HORIZONTAL_ALIGN,
            userWidth = filterConfig.type ? sliderConfig.width : isHorizontal ? sliderConfig.width : null,
            userHeight = filterConfig.type ? sliderConfig.height : isHorizontal ? null : sliderConfig.height,
            defaultWidth,
            defaultHeight,
            s1 = range[0] + range[range.length - 1],
            s2 = mathMax(range[0], range[range.length - 1]);

          if (isHorizontal) {
            defaultWidth = s1 * 1.5;
            defaultHeight = s2;
            maxWidth -= s1 / 2;
          } else {
            defaultWidth = s2;
            defaultHeight = s1 * 1.5;
            maxHeight -= s1 / 2;
          }

          var width = mathMin(perToPx(userWidth, area.width, defaultWidth), maxWidth),
            height = mathMin(perToPx(userHeight, area.height, defaultHeight), maxHeight);

          // let markerBound = getBoxSize(sliderConfig.marker, {}, align, scale, 0),
          //     d1 = [markerBound.width(scale_domain[0]), markerBound.height(scale_domain[0])],
          //     d2 = [markerBound.width(scale_domain[scale_domain.length - 1]), markerBound.height(scale_domain[scale_domain.length - 1])];
          //
          // if (isHorizontal) {
          //     width = mathMax(0, mathMin(width, maxWidth - d1[1] / 2 - d2[1] / 2));
          // } else {
          //     height = mathMax(0, mathMin(height, maxHeight - d1[1] / 2 - d2[1] / 2));
          // }

          return { width: width, height: height };
        } }, { key: "getBrushOptions", value:
        function getBrushOptions() {
          this.viewScale = this.viewScale || this.viewScaleComponent().scale; // If legend is enabled, this.viewScale is needed for event api

          var dim = this.getSliderArea(),
            scale = this.viewScale,_this$spec4 =
            this.spec,config = _this$spec4.config,format = _this$spec4.format,
            ranges = config.ranges,reversed = config.reversed,
            dataType = this.spec.scaleComponent.schema.data.dataType,

            align = getLegendAlignment(config),
            isHorizontal = align.layout === HORIZONTAL_ALIGN,

            _range = isHorizontal ? [0, dim.width] : [0, dim.height],
            range = reversed ? _range.reverse() : _range,

            brushScale = getBrushScale(config, dataType, scale, range),
            initialExtent = getInitialExtent(ranges, config.filter.range, scale, brushScale, dataType),

            brushOptions = {
              config: config,
              reversed: reversed,
              ranges: ranges,
              range: range,
              isHorizontal: isHorizontal,
              initialExtent: initialExtent,
              align: align,
              format: format,
              brushScale: brushScale,
              scale: brushScale,
              sizeScale: scale,
              datatype: dataType,
              type: isHorizontal ? 'x' : 'y',
              orient: isHorizontal ? BOTTOM_ALIGN : LEFT_ALIGN,
              dimension: [dim.width, dim.height],
              scale_domain: scale.domain(),
              singleDomainContinuous: brushScale.singleDomainContinuous,
              markerBound: getBoxSize(config.slider.marker, {}, align, scale, 0),
              encode: 'z'
            };

          brushOptions.handles = getHandleOptions$1(brushOptions);

          return brushOptions;
        } }]);return SizeLegendSlider;}(SizeLegend);


    SizeLegendSlider.adjustFactor = function (config, w, h, globalFont, size) {
      var maxWidth = config.maxWidth,maxHeight = config.maxHeight,sliderConfig = config.slider,
        axisConfig = sliderConfig.axis,
        minmaxLabelsConfig = axisConfig.minmaxlabels,
        align = getLegendAlignment(config),
        isHorizontal = align.layout === HORIZONTAL_ALIGN,

        axisAdjust = SliderAxisAdjustFactor(axisConfig, w, h, globalFont, align),
        minmaxLabelAdjust = MinmaxLabelAdjustFactor(minmaxLabelsConfig, w, h, globalFont, align),
        adjust = [0, 0];

      if (!maxHeight) {
        adjust[1] += axisAdjust[1] + minmaxLabelAdjust[1];

        if (!isHorizontal) {
          adjust[1] += size[0] / 2 + size[size.length - 1] / 2;
        }
      }

      if (!maxWidth) {
        adjust[0] += axisAdjust[0] + minmaxLabelAdjust[0];

        if (isHorizontal) {
          adjust[0] += size[0] / 2 + size[size.length - 1] / 2;
        }
      }

      return adjust;
    };

    function translate$1(xy) {
      var _translate = "translate(".concat(xy.join(' '), ")");for (var _len4 = arguments.length, elements = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {elements[_key5 - 1] = arguments[_key5];}
      each(elements, function (ele) {return ele.attr('transform', _translate);});
    }

    function getEle$2(self, view) {
      var order = {
        LegendTitleSvg: 0,
        Tracker: 1,
        SelectionTracker: 2,
        SliderAxis: 3,
        Connector: 4,
        SliderView: 5,
        MinmaxLabel: 6
      };

      if (view === 'LegendBackgroundSvg') {
        return self.encode.children[0].element;
      }
      return self.encode.children[1].children[order[view]].element;
    }

    function getHandleOptions$1(options) {
      var sizeScale = options.sizeScale,brushScale = options.brushScale,config = options.config,dimension = options.dimension,align = options.align,isHorizontal = options.isHorizontal,
        bound = { width: dimension[0], height: dimension[1] },
        sliderConfig = config.slider,
        filterConfig = getDisabledOptions(config),
        markerConfig = sliderConfig.marker,
        hoverOptions = getHoverOptions(config),
        handleType = filterConfig.type,
        handleSymbol = markerConfig.shape || 'circle',
        shape,
        _transform;

      if (hoverOptions.type) {
        var op = getDefaultSliderOptions(dimension, isHorizontal);
        config.hoverOptions.slider = mergeJSON$1(op, hoverOptions, true);
      }

      if (handleType) {
        var _op = getDefaultSliderOptions(dimension, isHorizontal);
        config.filter.slider = mergeJSON$1(_op, filterConfig, true);
      }

      if (!handleType) {
        var position = getSliderMarkerPosition(sizeScale, brushScale, markerConfig, bound, align);
        shape = getSVGsymbol(handleSymbol);

        if (align.layout === HORIZONTAL_ALIGN) {
          _transform = function _transform(d) {return [0, position.y(d)];};
        } else {
          _transform = function _transform(d) {return [position.x(d), 0];};
        }

        return {
          shape: shape,
          position: _transform,
          transform: function transform(d) {return "translate(".concat(_transform(d).join(' '), ") ");}
        };
      }
    }

    SizeLegendSlider.encode = 'z';
    SizeLegendSlider.view = 'slider';
    SizeLegendSlider.domMode = 'svg';
    Registry.setComponent('sizeLegendSlider', SizeLegendSlider);
    LegendRegistry.add(SizeLegendSlider);

    /**
     *
     * @param chart
     * @return {BrushD3Options}
     */
    function _getLegendSizeSliderBrushArguments(chart) {
      var legendInstance = chart.legends.get('z-0'),
        component = legendInstance.component,element = legendInstance.element,
        brushOptions = component.brushOptions,
        type = brushOptions.type,dimension = brushOptions.dimension,

        extent = getExtent(dimension, brushOptions),
        BrushD3Options = Registry.getComponent('BrushD3Options');

      return new BrushD3Options({
        type: type,
        extent: extent,
        component: component,
        behaviour: 'resizeToMouse',
        element: getTrackerElement$5(element),
        styles: {
          selection: {
            fillColor: TRANSPARENT,
            strokeColor: TRANSPARENT,
            fillOpacity: 1
          },
          track: {
            fillColor: TRANSPARENT
          }
        }
      });
    }

    /**
     * Returns tracker element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getTrackerElement$5(container) {
      return container.selectAll("g.".concat(SLIDER_VIEW_CLASSNAME));
    }

    function getExtent(dimension, options) {
      var _dimension4 = _slicedToArray(dimension, 2),width = _dimension4[0],height = _dimension4[1],
        brushScale = options.brushScale,isHorizontal = options.isHorizontal,ranges = options.ranges,
        bandWidth = ranges && ranges.length === 1 ? 0 : brushScale.bandwidth ? brushScale.bandwidth() : 0,
        bandWidthBy2 = bandWidth / 2;

      if (isHorizontal) {
        return [[bandWidthBy2, 0], [width - bandWidthBy2, height]];
      } else {
        return [[0, bandWidthBy2], [width, height - bandWidthBy2]];
      }
    }

    Registry.setComponent('_getLegendSizeSliderBrushArguments', _getLegendSizeSliderBrushArguments);

    /**
     *
     * @param instanceMap
     * @param event
     * @constructor
     */
    function LegendSizeSliderBrushListener(instanceMap, event) {
      var eventManager = this,
        type = event.type,selection = event.selection,
        data = eventManager.getData(instanceMap, type, selection);

      eventManager.associateBehaviours(instanceMap, type, data, selection, event);
    }

    function getHandles$1(behaviour) {
      var behaviourInstance = behaviour.instance,_behaviourInstance$op2 =
        behaviourInstance.options,component = _behaviourInstance$op2.component,extent = _behaviourInstance$op2.extent,
        brushOptions = component.brushOptions,
        type = brushOptions.type,config = brushOptions.config,markerBound = brushOptions.markerBound,handleOptions = brushOptions.handles,
        width = markerBound.width,height = markerBound.height,
        data = getHandleData(brushOptions),
        filterConfig = getDisabledOptions(config),
        hoverOptions = getHoverOptions(config),
        markerConfig = config.slider.marker,
        handleType = filterConfig.type,
        handleSymbol = markerConfig.shape || 'circle';

      if (handleType) {
        return getBrushHandle(type, handleType, extent, null, filterConfig[handleType] || {});
      } else {
        var _transform2 = handleOptions.transform,
          symbolPath = handleOptions.shape,
          _path = function _path(d) {return symbolPath(width(d), height(d));},
          op = {
            shape: defined(hoverOptions.type) ?
            [[_path(data[0]), _path(data[0])], [_path(data[1]), _path(data[1])]] :
            [[_path(data[0])], [_path(data[1])]],
            style: _objectSpread(_objectSpread({},
            propertiesToStyles(markerConfig)), {}, {
              transform: function transform(d) {return _transform2(data[d.i]);} })

          };

        setCustomBrushHandle("marker-".concat(handleSymbol), op);
        return getBrushHandle(type, "marker-".concat(handleSymbol), extent, null, markerConfig);
      }
    }

    function BrushClip(behaviour, chart) {
      var brushInstance = behaviour.instance,
        element = brushInstance.options.component.element,
        flashElement = element.selectAll("g.".concat(TRACK_LEGEND_CLASSNAME)).selectAll("".concat(PATH_ELEMENT, ".").concat(TRACK_FLASH_CLASSNAME)),
        desc = flashElement.attr('d') || '';

      var clipPath = CHART_BRUSH_HELPERS.CLIP_TRACK(brushInstance, [0, 0], chart, 'size_slider_brush', { desc: desc });
      brushInstance._selection.attr('clip-path', clipPath);
    }

    function styleHandles$1(behaviourEventInstance, selectionManager) {
      var _instance = behaviourEventInstance.instance,
        customHandles = _instance.customHandles;

      if (!customHandles) {
        return;
      }

      var handles = customHandles.selectAll("path.".concat(CUSTOM_HANDLE_PATH_CLASSNAME)),
        brushOptions = _instance.options.component.brushOptions,
        handleOptions = brushOptions.handles,markerBound = brushOptions.markerBound,
        width = markerBound.width,height = markerBound.height,

        point = selectionManager.point,
        data = getHandleData(brushOptions, point);

      if (!handleOptions) {
        return;
      }

      var shape = handleOptions.shape,_transform3 = handleOptions.transform;

      handles.attrs({
        d: function d(_d13) {return shape(width(data[_d13.i]), height(data[_d13.i]));},
        transform: function transform(d) {return _transform3(data[d.i]);}
      });
    }

    //$Id$

    var line$1 = d3_line();

    function styleConnector(behaviourEventInstance, selectionManager, selection) {
      var point = selectionManager.point,
        _instance = behaviourEventInstance.instance,
        options = _instance.options,
        component = options.component,
        element = component.element,brushOptions = component.brushOptions;

      var connectorEle = element.selectAll("".concat(PATH_ELEMENT, ".zc-connector-line")),
        data = getHandleData(brushOptions, point);

      connectorEle.attr('d', line$1(getPoints(component._parser.connectorSpec)(data, selection))); // TODO: check component._parser
    }

    function AddClipToHandles(behaviourEventInstance, selectionManager) {
      var _instance = behaviourEventInstance.instance,
        customHandles = _instance.customHandles,
        eventManager = this,
        chart = eventManager.chart;

      if (!customHandles) {
        return;
      }

      var brushOptions = _instance.options.component.brushOptions,
        isHorizontal = brushOptions.isHorizontal,handleOptions = brushOptions.handles;

      if (handleOptions) {
        customHandles.each(function (d, i) {
          var handleEle = d3_select(this).selectAll("".concat(PATH_ELEMENT, ".").concat(CUSTOM_HANDLE_PATH_CLASSNAME)),
            handleNodes = handleEle.nodes();

          if (!handleNodes[1]) {
            return;
          }

          var desc = clip4Handle(bbox(handleNodes[0]), i, isHorizontal),
            clipSrc = CHART_BRUSH_HELPERS.GET_CLIP(_instance, [0, 0], chart, "size_slider_brush_handle_".concat(i), { desc: desc });

          d3_select(handleNodes[1]).
          attr('clip-path', clipSrc).
          style('opacity', 0).
          classed(SLIDER_HANDLE_TRACK_CLASSNAME, true);
        });
      }
    }

    function clip4Handle(bb, i, isHorizontal) {
      var x = bb.x,y = bb.y,width = bb.width,height = bb.height,
        strokeWidth = 1,
        lineClosed = d3_line().curve(d3_curves('linear-closed')),
        points;

      if (isHorizontal) {
        if (i === 0) {
          points = [
          [0, y - strokeWidth],
          [x + width + strokeWidth, y - strokeWidth],
          [x + width + strokeWidth, y + height + strokeWidth],
          [0, y + height + strokeWidth]];

        } else {
          points = [
          [x - strokeWidth, y - strokeWidth],
          [0, y - strokeWidth],
          [0, y + height + strokeWidth],
          [x - strokeWidth, y + height + strokeWidth]];

        }
      } else {
        if (i === 0) {
          points = [
          [x - strokeWidth, 0],
          [x + width + strokeWidth, 0],
          [x + width + strokeWidth, y + height + strokeWidth],
          [x - strokeWidth, y + height + strokeWidth]];

        } else {
          points = [
          [x - strokeWidth, y - strokeWidth],
          [x + width + strokeWidth, y - strokeWidth],
          [x + width + strokeWidth, 0],
          [x - strokeWidth, 0]];

        }
      }

      return lineClosed(points);
    }

    //$Id$

    function StyleTrack$1(behaviourEventInstance, selectionManager, selection) {
      var eventManager = this,
        chart = eventManager.chart,
        point = selectionManager.point,
        _instance = behaviourEventInstance.instance,
        options = _instance.options,
        component = options.component,extent = options.extent,
        element = component.element,brushOptions = component.brushOptions,
        isHorizontal = brushOptions.isHorizontal,config = brushOptions.config,
        filterConfig = getDisabledOptions(config);

      if (!filterConfig.track.fillColor) {
        return;
      }

      var groupEle = element.selectAll("g.".concat(TRACK_LEGEND_CLASSNAME, "-selection")),
        trackEle = groupEle.selectAll("".concat(PATH_ELEMENT, ".").concat(TRACK_FLASH_CLASSNAME)),
        symbolEle = groupEle.selectAll("".concat(PATH_ELEMENT, ".").concat(TRACK_SYMBOL_CLASSNAME)),
        data = getHandleData(brushOptions, point);

      var _symbolConfig = pointMark(helper$4(component._parser.selectionTrackSpec).symbolSpec).config; // TODO: component._parser

      // Symbol
      symbolEle.attrs({
        d: function d(_d14, i) {return _symbolConfig.d(data[i]);},
        transform: function transform(d, i) {
          var _position = _symbolConfig.
          transform(data[i]).
          replace('translate(', '').
          replace(')', '').
          split(' ').
          map(function (_) {return +_;}); // TODO
          return translateString(isHorizontal ? [selection[i], _position[1]] : [_position[0], selection[i]]);
        }
      });

      // Flash
      var desc = clip4Track(selection, extent, isHorizontal),
        clipSrc = CHART_BRUSH_HELPERS.GET_CLIP(_instance, [0, 0], chart, "size_slider_brush_selection-track", { desc: desc });

      trackEle.attr('clip-path', clipSrc);
    }

    function clip4Track(selection, extent, isHorizontal) {
      var lineClosed = d3_line().curve(d3_curves('linear-closed')),
        points = isHorizontal ?
        [
        [selection[0], extent[0][1]],
        [selection[1], extent[0][1]],
        [selection[1], extent[1][1]],
        [selection[0], extent[1][1]]] :

        [
        [extent[0][0], selection[0]],
        [extent[1][0], selection[0]],
        [extent[1][0], selection[1]],
        [extent[0][0], selection[1]]];


      return lineClosed(points);
    }

    var _legendSizeSliderBrushHandlers = {
      LISTENER: {
        start: LegendSizeSliderBrushListener,
        brush: LegendSizeSliderBrushListener,
        end: LegendSizeSliderBrushListener
      },
      DATA_FINDER: {
        start: LegendBrushDataFinder,
        brush: LegendBrushDataFinder,
        end: LegendBrushDataFinder
      },
      BEHAVIOUR: {
        start: [PreventDefault],
        brush: [ForceHideTooltip, styleHandles$1, ApplyBrushSelectionOnPlot$1, showTooltip, HideHighlight, styleConnector, StyleTrack$1],
        end: [ClearCache, hideTooltip, SnapRange, AddClipToHandles]
      },
      LISTENER_TYPES: d3_set(['start', 'brush', 'end']),
      SUPPORTED: isSupported(SLIDER_LEGEND_TYPE),
      // UPDATE: function() {},
      INIT: function INIT(behaviour) {
        var behaviouralEvents = this,
          chart = behaviouralEvents.chart,
          behaviourInstance = behaviour.instance,
          legendComponent = behaviourInstance.options.component,_legendComponent$getB =
          legendComponent.getBrushOptions(),initialExtent = _legendComponent$getB.initialExtent,config = _legendComponent$getB.config,handleOptions = _legendComponent$getB.handles,
          handles = getHandles$1(behaviour),
          eventEnabled = isEventEnabled$1(config);

        behaviour.initialized = false;
        behaviourInstance.setSelection(initialExtent);
        var handleElement = behaviourInstance.addCustomHandle(handles);
        behaviourInstance.tooltip = brushTooltip(behaviour);

        // Shadow
        var filterConfig = getDisabledOptions(config);
        handleShadow(filterConfig, handles, handleElement, chart);

        // Clip
        BrushClip(behaviour, chart);
        AddClipToHandles.call(this, behaviour);
        // updateTrackerClip(brushOptions, behaviourInstance.parent_group, behaviourInstance, chart);

        // Visibility for custom handles
        // behaviourInstance.customHandles.style('visibility', eventEnabled || handleOptions ? null : 'hidden');

        if (!eventEnabled) {
          behaviourInstance.customHandles.attr('pointer-events', 'none');
          behaviourInstance.destroy();
        }

        behaviour.initialized = true;
      }
    };

    function isEventEnabled$1(config) {
      var eventsConfig = config.events,filter = config.filter,
        eventDisabled = eventsConfig && validateNullVal(eventsConfig.enabled, true) == false;

      return !eventDisabled && filter.enabled;
    }

    Registry.setComponent('_legendSizeSliderBrushHandlers', _legendSizeSliderBrushHandlers);

    function SizeSliderListener(_, i, ele, eventType) {
      var manager = this,
        event = d3_event(),
        mouse = getMousePosition(manager.tracker.node(), event);

      var data = manager.getData(eventType, mouse);

      manager.associateBehaviours(eventType, data, mouse, event);
    }

    function SizeSliderReverseDataFinder() {
      return SizeReverseDataFinder.apply(this, arguments);
    }

    var _legendSizeSliderHandlers = {
      LISTENER: {
        mousemove: SizeSliderListener,
        mouseout: SizeSliderListener
      },
      DATA_FINDER: {
        mousemove: SizeSliderDataFinder,
        mouseout: SizeSliderDataFinder
      },
      BEHAVIOUR: {
        mousemove: [hideBrushTooltip, showCursor, HighlightItem, HighlightSeries, showTooltip$1],
        mouseout: [hideCursor, _resetHighlightItem$1, ResetHighlightSeries, _hideTooltip$1]
      },
      REVERSE_DATA_FINDER: {
        mousemove: SizeSliderReverseDataFinder
      },
      REVERSE_BEHAVIOUR: {
        mousemove: [HighlightItem, showTooltip$1],
        mouseout: [ForceResetHighlightItem, ForceHideTooltip$1]
      },
      SUPPORTED: isSupported(SLIDER_LEGEND_TYPE)
    };

    function _resetHighlightItem$1() {
      var manager = this;

      if (isForced$1(manager)) {
        ForceResetHighlightItem.call.apply(ForceResetHighlightItem, [manager].concat(Array.prototype.slice.call(arguments), [true]));
      } else {
        ResetHighlightItem.call.apply(ResetHighlightItem, [manager].concat(Array.prototype.slice.call(arguments)));
      }
    }

    function _hideTooltip$1() {
      var manager = this;

      if (isForced$1(manager)) {
        ForceHideTooltip$1.call.apply(ForceHideTooltip$1, [manager].concat(Array.prototype.slice.call(arguments), [true]));
      } else {
        hideTooltip$1.call.apply(hideTooltip$1, [manager].concat(Array.prototype.slice.call(arguments)));
      }
    }

    function isForced$1(manager) {
      // If mouse moves to custom-handle-path, force reset should be done
      var targetEvent = manager.targetEvent,
        relatedTarget = targetEvent.relatedTarget;

      if (relatedTarget) {
        return d3_select(relatedTarget).classed(CUSTOM_HANDLE_PATH_CLASSNAME);
      }
    }

    Registry.setComponent('_legendSizeSliderHandlers', _legendSizeSliderHandlers);

    /**
     *
     * @param chart
     * @return {Legend Event options}
     */
    function _legendSizeSliderEventArguments(chart, id) {
      var legendInstance = chart.legends.get(id),

        component = legendInstance.component,meta = legendInstance.meta,element = legendInstance.element,highlightManager = legendInstance.highlightManager,
        scaleComponent = meta.scaleComponent,
        dataType = scaleComponent.schema.data.dataType,

        brushOptions = component.brushOptions,
        config = brushOptions.config,
        eventsConfig = config.events,
        hoverOptions = getHoverOptions(config),
        container = element.selectAll("g.".concat(SLIDER_VIEW_CLASSNAME)),
        trackerElement = getTrackerElement$6(element, config),
        highlightElement = getHighlightElement$3(container),
        tooltip = getTooltip$2(chart, highlightElement, legendInstance.meta.config),

        eventDisabled = eventsConfig && validateNullVal(eventsConfig.enabled, true) == false,
        enabled = legendInstance.enabled && !eventDisabled && defined(hoverOptions.type);

      return _objectSpread(_objectSpread({ enabled: enabled, trackerElement: trackerElement, highlightElement: highlightElement, highlightManager: highlightManager, tooltip: tooltip }, brushOptions), {}, { dataType: dataType, legendInstance: legendInstance });
    }

    /**
     * Returns tracker element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getTrackerElement$6(container, config) {
      var selector = config.filter.enabled ? ".selection,.".concat(
      SLIDER_HANDLE_TRACK_CLASSNAME) : ".".concat(
      TRACK_FLASH_CLASSNAME, ",.").concat(TRACK_SYMBOL_CLASSNAME);

      return container.selectAll(selector).style('pointer-events', 'all');
    }

    /**
     * Returns highlight element
     * @param  {D3Selectiion} container
     * @return {D3Selectiion}
     */
    function getHighlightElement$3(container) {
      return createElement('g', ".".concat(HIGHLIGHT_LEGEND_CLASSNAME), [1], container).
      style('pointer-events', 'none').
      style('display', null).
      style('opacity', 1);
    }

    function getTooltip$2(chart, element, config) {
      var hoverOptions = getHoverOptions(config),
        tooltipOptions = {
          config: hoverOptions.tooltip,
          orient: legend_helpers.getOrient(config),
          element: element,
          chart: chart
        };

      return HighlightTooltip(tooltipOptions);
    }

    Registry.setComponent('_legendSizeSliderEventArguments', _legendSizeSliderEventArguments);

    function Node(tree, row, column, level, tag, name) {
      this.value = name,
      this.depth = level,
      this.depthbyrow = row,
      this.depthbycolumn = column,
      this.childIndexbyrow = 0,
      this.childIndexbycolumn = 0,
      this.tag = tag,
      this.data = tree.data;
      this.node = tree;
    }

    function getDepth() {
      var node = this;
      var depth = node.tag == 'row' ? node.depthbyrow : node.depthbycolumn;
      return depth;
    }

    Node.prototype = {
      getDepth: getDepth
    };

    function eachNode(root, callback) {
      var node = root,
        current,
        next = [node],
        children,
        i;
      do {
        current = next;
        while (node = current.pop()) {
          callback(node), children = node.children;
          if (children) {
            for (i = children.length - 1; i >= 0; i--) {
              current.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function eachNodeBeforeAfter(root, callbackBefore, callbackAfter) {
      var node = root,
        current,
        next = [node],
        children,
        i;
      do {
        current = next;
        while (node = current.pop()) {
          callbackBefore(node), children = node.children;
          if (children) {
            for (i = children.length - 1; i >= 0; i--) {
              callbackAfter(node, children[i]);
              current.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function Branch() {
      this.datatype = 'ordinal';
      this.nodes = [];
      this.inodes = [];
      this.domain = [];
      this.range = null;
      this.index = -1;
      this.list = new ArrayList();
    }

    function Cluster() {
      this.datatype = 'numeric';
      this.nodes = new Array(0);
      this.domain = new Array(0);
      this.range = [];
      this.entries = d3_map();
      this.keys = [];
      this.index = 0;
      this.count = 0;
      this.list = new ArrayList();
    }

    /*
    To get the total no. of nodes in cluster.entries up to the given idx
     */
    function getPrevNodesCountBySetIdx(idx) {
      if (this.entries.get(idx).prevNodesCount) {
        return this.entries.get(idx).prevNodesCount;
      }
      var nodeCount = 0;
      for (var i = 0; i < idx; i++) {
        nodeCount += this.entries.has(i) ? this.entries.get(i).list.count : 0;
      }
      this.entries.get(idx).prevNodesCount = nodeCount;
      return nodeCount;
    }

    Cluster.prototype = {
      constructor: Cluster,
      getPrevNodesCountBySetIdx: getPrevNodesCountBySetIdx
    };

    /*
    clusterSet is subset of cluster. It is stored in cluster.entries
     */
    function ClusterSet() {
      this.list = new ArrayList();
      this.domain = new Array(0);
      this.nodes = new Array(0);
      this.prevNodesCount = null;
    }

    ClusterSet.prototype = {
      constructor: ClusterSet
    };

    function Pane() {
      this.data = [];
      this.index = -1;
      this.row = -1;
      this.column = -1;
    }

    function Leaf(name, depth, row, column) {
      this.value = name, this.depth = depth, this.depthbyrow = row, this.depthbycolumn = column, this.datatype = 'numeric';
      this.data = [];
      this.index = 0;
      this.count = 0;
      this.name = 'Leaf';
    }

    Leaf.prototype = {
      constructor: Leaf
    };

    function iNode(tree, name) {
      this.value = name;
      this.children = new Array(0);
      this.layerNames = new ArrayList();
      this.leafNames = new ArrayList();
      this.list = new ArrayList();
      this.node = tree;
    }

    function createiNode(node) {
      var i_node = new iNode(node, node.value);
      return i_node;
    }

    function addBranchToiNode(node, inode) {
      var tag = node.tag,
        isSingleBranch = tag == 'row' ? node.firstRow && node.lastRow : node.firstColumn && node.lastColumn,
        isFirstBranch = tag == 'row' ? node.firstRow : node.firstColumn,
        isLastBranch = tag == 'row' ? node.lastRow : node.lastColumn;
      if (!isLastBranch) {
        inode.children = node.children;
      }
    }

    function addLeavesToiNode(node, inode, leaf) {
      if (!node.rootLayer) {
        var parentName = node.parent.value,
          leafMapKey = "".concat(parentName, "_").concat(leaf.value);
        if (node.parent.tag == 'layer') {
          var layerNode;
          if (inode.layerNames.indexOf(parentName) == null) {
            layerNode = createiNode(node.parent);
            inode.layerNames.add(parentName);
            layerNode.children.push(leaf);
            inode.children.push(layerNode);
          } else {
            if (inode.leafNames.indexOf(leafMapKey) == null) {
              layerNode = inode.children[inode.layerNames.indexOf(parentName)];
              layerNode.children.push(leaf);
            }
          }
        } else {
          leafMapKey = "".concat(leaf.value);
          if (inode.leafNames.indexOf(leafMapKey) == null) {
            inode.children.push(node);
          }
        }
        inode.leafNames.add(leafMapKey);
      }
    }

    function pushToBranch(node) {
      var nodeList = this,
        type = node.tag,
        branchIdx = node.getDepth(),
        levelByTag = type == 'row' ? 'levelByRow' : 'levelByColumn',
        levelByTag_invert = type == 'row' ? 'levelByColumn' : 'levelByRow',
        branch;
      (branch = nodeList.branches[branchIdx]) || (branch = nodeList.branches[branchIdx] = new Branch()) && nodeList.count++;

      var nodeValue = node.mainTag == 'layer' ? '' : node.point || node.value,
        nodeIdx = branch.list.indexOf(nodeValue);

      if (branchIdx != 0 || !defined(nodeIdx)) {
        branch.list.add(node.value);
        branch.index++;
        branch.domain.push(nodeValue || '');
        branch.nodes.push(node);
        var branchNode = createiNode(node);
        addBranchToiNode(node, branchNode);
        branch.inodes.push(branchNode);
        node.index = branch.index;
      } else {
        node.index = nodeIdx;
      }
      node.level = "".concat(pick(node.parent && node.parent.level, '') + node.index, "_");
      node[levelByTag] = "".concat(pick(node.parent && node.parent[levelByTag], '') + node.index, "_");
      node[levelByTag_invert] = "".concat(pick(node.parent && node.parent[levelByTag_invert], ''));
    }

    function createDuplicateLayerNode(node) {
      var idx = node.tag == 'row' ? node.childIndexbyrow : node.childIndexbycolumn,
        layerName = node.mainTag == 'layer' ? node.value : "manual_".concat(idx),
        node_duplicate = new Node(node, node.depthbyrow, node.depthbycolumn, node.depth, 'layer', layerName);
      node_duplicate.node = node.node;
      node_duplicate.row = node.row;
      node_duplicate.column = node.column;
      node_duplicate.childIndexbyrow = node.childIndexbyrow, node_duplicate.childIndexbycolumn = node.childIndexbycolumn;
      this.noLayers = node.mainTag !== 'layer';
      return node_duplicate;
    }

    function pushToLayers(node, series) {
      var layerList = this,
        rowIdx = node.row,
        columnIdx = node.column,
        layerIdx,
        layer,
        panekey = "".concat(rowIdx, "_").concat(columnIdx),
        pane,
        hasLayerNode = node.layer;
      layerIdx = node.layer = node.layer && node.layer.length > 1 ? node.layer.indexOf(node.layer[node.childIndexbyrow]) : 0;

      (layer = layerList.groups[layerIdx]) || (layer = layerList.groups[layerIdx] = new ArrayList());
      (pane = layerList.panes[panekey]) || (pane = layerList.panes[panekey] = new Pane()) && layerList.count++;
      pane.index = layerList.count - 1;
      pane.row = rowIdx;
      pane.column = columnIdx;
      pane.layer = layerIdx;
      pane.data.push(node);
      layerList.domain.add(node.value);
      layer.add(node.value);
      layerList.isLayerNode = hasLayerNode;
      node.levelByColumn = "".concat(pick(node.parent && node.parent.levelByColumn, ''));
      node.levelByRow = "".concat(pick(node.parent && node.parent.levelByRow, ''));
      // node.level = `${pick(node.parent && node.parent.level, '') + node.index}_`;

      // this.createSeries(node, series);
    }

    function createCluster(node) {
      var nodeList = this,
        childIdx = node.childIndex,
        clusters = nodeList.clusters;
      var cluster;
      (cluster = clusters[childIdx]) || (cluster = clusters[childIdx] = new Cluster()) && nodeList.clustersCount++;

      var nodeIndex = this.clusterMap.indexOf("".concat(node[this.name], "_").concat(childIdx));

      if (isUndefined(nodeIndex)) {
        this.clusterMap.add("".concat(node[this.name], "_").concat(childIdx));
        node.index = this.leafCount++;
      } else {
        node.index = nodeIndex;
      }
    }

    function pushToDiscreteCluster(node) {
      if (node.isDefined) {
        var clusters = this.clusters,
          _attr9 = this.levelAttr,
          idx = pick(node.parent && node.parent[_attr9], ''),
          cluster;
        (cluster = clusters[0]) ||
        (cluster = clusters[0] = new Cluster()) && ++this.leafCount && ++this.clustersCount && (cluster.datatype = this.name == 'column' ? node.datatype._columns || 'ordinal' : 'ordinal'); //For ordinal datatype, using single column for for all leaves and also updae time datatype for time data layout
        var clusterSet,
          entries = cluster.entries;
        clusterSet = entries.has(idx) || entries.set(idx, new ClusterSet());
        clusterSet = entries.get(idx);
        var list = clusterSet.list,
          nodeidx = list.indexOf(node.value, true),
          leaf;
        if (isUndefined(nodeidx)) {
          //missing data check
          /*
          To check whether data is missed in any of the grid.
          actualNodeCount - refers total no. of nodes present till previous column (i.e from clsuter.entries[])
          list.count - refers node count for  current column or clusterSet
          cluster.count - refers overall node count in the cluster
           */
          if (!this.missedNodes) {
            var actualNodeCount = cluster.getPrevNodesCountBySetIdx(idx);
            this.missedNodes = actualNodeCount + list.count != cluster.count;
          }

          leaf = createLeaf(node);
          leaf.index = cluster.count;
          nodeidx = list.count;

          clusterSet.domain[nodeidx] = node.value;
          clusterSet.nodes[nodeidx] = leaf;
          clusterSet.list.add(node.value, cluster.count++);
          // cluster.nodes.push(node);
        } else {
          clusterSet.nodes[nodeidx].data.push(node.data);
        }
        var inode = this.branches[node.depthbycolumn] ? this.branches[node.depthbycolumn].inodes[node.column] : null;
        if (inode) {
          addLeavesToiNode(node, this.branches[node.depthbycolumn].inodes[node.column], clusterSet.nodes[nodeidx]);
        }

        if (isUndefined(cluster.list.indexOf(node.value))) {
          cluster.list.add(node.value);
          cluster.keys.push(node.value);
        }
        node.data.index = node.index = list.indexOf(node.value);
        node.data.level = "".concat(pick(node.parent && node.parent.level, '') + node.index, "_");
        node.data.levelByColumn = "".concat(pick(node.parent && node.parent.levelByColumn, '') + node.index, "_");
        node.data.levelByRow = "".concat(pick(node.parent && node.parent.levelByRow, '') + node.index, "_");

        if (leaf) {
          leaf.level = node.data.level;
          leaf.levelByColumn = node.data.levelByColumn;
          leaf.levelByRow = node.data.levelByRow;
        }
      }
    }

    function createLeaf(node) {
      var leaf = new Leaf(node.value, node.depth, node.depthbyrow, node.depthbycolumn);
      leaf.data = [node.data];
      leaf.node = node;
      leaf.parent = node.parent;
      return leaf;
    }

    function pushToContinuousCluster(node) {
      var clusters = this.clusters,
        idx = this.name == 'row' ? node.childIndexbyrow : node.childIndexbycolumn,
        cluster;
      (cluster = clusters[idx]) || (cluster = clusters[idx] = new Cluster()) && ++this.leafCount && ++this.clustersCount;

      if (this.name == 'column') {
        node.data.level = "".concat(pick(node.parent && node.parent.level, '') + node.index, "_");
        node.data.levelByColumn = "".concat(pick(node.parent && node.parent.levelByColumn, '') + node.index, "_");
        node.data.levelByRow = "".concat(pick(node.parent && node.parent.levelByRow, '') + node.index, "_");
      }
      cluster.nodes.push(node);
      // cluster.domain.push(node.value);
      clusters.count++;
    }

    function getNodelistCount() {
      return this.count;
    }

    function getBranchesCount() {
      return this.branches.length;
    }

    function getLeavesCount() {
      if (this.name == 'column' && !this.splitColumnLeaves) {
        return this.leafCount;
      }
      if (this.count) {
        return this.clustersCount * this.getDomainForBranch(0).length;
      }
      return this.leafCount;
    }

    function getClustersCount() {
      return this.clustersCount;
    }

    function hasMultiCluster() {
      return this.clustersCount > 1;
    }

    function getLayersCount() {
      return this.count;
    }

    function getPanesCount() {
      return this.getPanes().length;
    }

    function getDomainForBranch(index) {
      var branch = this.branches[index];
      if (branch) {
        return branch.domain;
      }
    }

    function getRangesForBranch(index) {
      var branch = this.branches[index];
      if (branch) {
        return branch.range;
      }
    }

    function getDomainForCluster(index) {
      var cluster = this.clusters[index],
        entries = cluster.entries;
      if (cluster) {
        if (entries.size()) {
          return d3_merge(
          entries.values().map(function (d) {
            return d.domain;
          }));

        } else {
          return cluster.domain;
        }
      }
    }

    function getDomainForClusterSet(index, subIndex) {
      var cluster = this.clusters[index];
      if (cluster) {
        return cluster.entries.values()[subIndex].domain;
      }
    }

    function getNodesForClusterSet(index, subIndex) {
      var cluster = this.clusters[index];
      if (cluster) {
        return cluster.entries.values()[subIndex].nodes;
      }
    }

    function getDynamicDomainForCluster(index) {
      var nodelist = this,
        cluster = this.clusters[index],
        entries = cluster.entries;
      if (cluster) {
        if (entries.size()) {
          return d3_merge(
          entries.values().map(function (d, i) {
            return nodelist.getDynamicDomainForClusterSet(index, i);
          }));

        } else {
          return cluster.domain;
        }
      }
    }

    function getDynamicDomainForClusterSet(index, subIndex) {
      var cluster = this.clusters[index];
      if (cluster) {
        var customDomain = cluster.entries.values()[subIndex].customDomain;
        if (customDomain) {
          var customDomain_values;
          customDomain.values().map(function (d) {
            customDomain_values = d.values;
          });
          return d3_merge([cluster.entries.values()[subIndex].domain, customDomain_values]);
        } else {
          return cluster.entries.values()[subIndex].domain;
        }
      }
    }

    function getMergedDomainForClusterSet(index, subIndex) {
      var cluster = this.clusters[index];
      if (cluster) {
        var domain = this.getDomainForClusterSet(index, subIndex),
          customDomain = this.getDynamicDomainForCluster(index, subIndex);
        return d3_merge([domain, customDomain]);
      }
    }

    function getUniqueDomainForCluster(index) {
      var cluster = this.clusters[index];
      if (cluster) {
        return cluster.keys;
      }
    }
    function getBranchNodes(index) {
      var branch = this.branches[index];
      if (branch) {
        return branch.nodes;
      }
    }

    function getClusterNodes(index) {
      var cluster = this.clusters[index],
        entries = cluster.entries;
      if (cluster) {
        if (entries.size()) {
          return d3_merge(
          entries.values().map(function (d) {
            return d.nodes;
          }));

        } else {
          return cluster.nodes;
        }
      }
    }

    function getPanes() {
      return objectValues(this.panes);
    }

    /**
     *
     * @param {Object} parent
     * @param {Array|*} array for recursion, need not to pass any
     * @returns {Array}
     */
    function getAllChildren(parent, array) {
      array = pick(array, []);
      if (parent.children) {
        parent.children.forEach(function (child) {
          if (child.tag == 'leaf' && child.isDefined) {
            array.push(child.data); // push to existing array
          } else {
            getAllChildren(child, array);
          }
        });
      } else {
        return parent.data;
      }
      return array;
    }

    function getNodesAtDepth(order) {
      //order refers axisorder
      var leavesCount = this.getLeavesCount();
      if (order > leavesCount - 1) {
        return this.getBranchNodes(order - leavesCount);
      } else {
        return this.getClusterNodes(0);
      }
    }

    function setNodeIndexForClusters() {
      var nodeList = this;
      nodeList.clusters.map(function (cluster, i) {
        var clusterNodes = nodeList.getClusterNodes(i);
        clusterNodes.map(function (node, i) {
          node.index = i;
          node.data.map(function (d) {
            //Remove the old index value and replaced with new index
            d.index = i;
            node.level = d.level = d.level.
            split('_').
            slice(0, -2).
            concat([d.index]).
            join('_');
            node.levelByColumn = d.levelByColumn = d.levelByColumn.
            split('_').
            slice(0, -2).
            concat([d.index]).
            join('_');
            node.levelByRow = d.levelByRow = d.levelByRow.
            split('_').
            slice(0, -2).
            concat([d.index]).
            join('_');
            // d.level = `${pick(node.parent && node.parent.levelByColumn, '') + d.index}_`;
            // d.levelByColumn = `${pick(node.parent && node.parent.levelByColumn, '') + d.index}_`;
            // d.levelByRow = `${pick(node.parent && node.parent.levelByRow, '') + d.index}_`;
          });
        });
      });
    }

    function getParentByIndex(itemIndex, parentDepthIndex) {
      var nodeList = this,
        clusters = nodeList.getClusterNodes(0), //default leaves index is 0 as there are single category leaf axis
        leaf = clusters[itemIndex],
        parent = null,
        count = nodeList.getCount() + 1;

      while (count--) {
        if (leaf.depth === parentDepthIndex) {
          parent = leaf;
          break;
        } else if (leaf.depth === 0) {
          break;
        }
        leaf = leaf.parent;
      }
      return parent;
    }

    function Row() {
      this.count = 0;
      this.clustersCount = 0;
      this.leafCount = 0;
      this.branches = [];
      this.clusters = [];
      this.name = 'row';
      this.levelAttr = 'levelByRow';
      this.clusterMap = new ArrayList();
    }

    Row.prototype = {
      constructor: Row,
      pushToBranch: pushToBranch,
      createCluster: createCluster,
      pushToDiscreteCluster: pushToDiscreteCluster,
      pushToContinuousCluster: pushToContinuousCluster,
      getCount: getNodelistCount,
      getBranchesCount: getBranchesCount,
      getLeavesCount: getLeavesCount,
      getClustersCount: getClustersCount,
      hasMultiCluster: hasMultiCluster,
      getDomainForBranch: getDomainForBranch,
      getRangesForBranch: getRangesForBranch,
      getDomainForCluster: getDomainForCluster,
      getDomainForClusterSet: getDomainForClusterSet,
      getNodesForClusterSet: getNodesForClusterSet,
      getClusterNodes: getClusterNodes,
      getBranchNodes: getBranchNodes,
      getNodesAtDepth: getNodesAtDepth,
      getParent: getParentByIndex,
      getAllChildren: getAllChildren
    };

    function Column() {
      this.count = 0;
      this.clustersCount = 0;
      this.leafCount = 0;
      this.branches = [];
      this.clusters = [];
      this.name = 'column';
      this.levelAttr = 'levelByColumn';
      this.leafNodeMap = new ArrayList();
    }

    Column.prototype = {
      constructor: Column,
      pushToBranch: pushToBranch,
      createCluster: createCluster,
      pushToDiscreteCluster: pushToDiscreteCluster,
      pushToContinuousCluster: pushToContinuousCluster,
      getCount: getNodelistCount,
      getBranchesCount: getBranchesCount,
      getLeavesCount: getLeavesCount,
      getClustersCount: getClustersCount,
      hasMultiCluster: hasMultiCluster,
      getDomainForBranch: getDomainForBranch,
      getRangesForBranch: getRangesForBranch,
      getDomainForCluster: getDomainForCluster,
      getUniqueDomainForCluster: getUniqueDomainForCluster,
      getDomainForClusterSet: getDomainForClusterSet,
      getNodesForClusterSet: getNodesForClusterSet,
      getDynamicDomainForClusterSet: getDynamicDomainForClusterSet,
      getMergedDomainForClusterSet: getMergedDomainForClusterSet,
      getDynamicDomainForCluster: getDynamicDomainForCluster,
      getClusterNodes: getClusterNodes,
      getBranchNodes: getBranchNodes,
      getNodesAtDepth: getNodesAtDepth,
      getParent: getParentByIndex,
      getAllChildren: getAllChildren,
      setNodeIndexForClusters: setNodeIndexForClusters
    };

    function createSeries(node, series) {
      var layers = this,
        data = node.node,
        domain = layers.splitClusters.count ? layers.splitClusters : layers.domain;

      if (!series[domain.indexOf(node.value)]) {
        var obj = {
          type: data.type,
          color: data.color,
          data: [[]],
          yaxiscolumnorder: data.yaxiscolumnorder,
          seriesname: data.seriesname,
          disabled: data.disabled,
          hideInLegend: data.hideInLegend,
          filtered: data.filtered
        };
        if (data.plotoptions) {
          obj.plotoptions = data.plotoptions;
        }

        series.push(obj);
      }
    }

    function pushToSeries(node, series) {
      var layers = this,
        domain = layers.splitClusters.count ? layers.splitClusters : layers.domain;
      var seriesIdx = domain.indexOf(getSeriesName(node, layers.splitClusters.count)) || 0;
      if (series[seriesIdx]) {
        series[seriesIdx].data[0].push(node.data);
      }
    }

    function getSeriesName(node, splitClusters) {
      var layername = node.seriesname;
      if (!layername) {
        if (node.parent.tag == 'layer') {
          layername = splitClusters ? node.parent.parent.value : node.parent.value;
        } else if (node.parent.datatype == 'numeric') {
          layername = node.parent.value;
        } else {
          var idx = node.parent.tag == 'row' ? node.childIndexbyrow : node.childIndexbycolumn;
          layername = "manual_".concat(idx);
        }
      }
      return layername;
    }

    function Layer() {
      this.count = 0;
      this.domain = new ArrayList();
      this.splitClusters = new ArrayList();
      this.groups = new Array(0);
      this.panes = {};
    }

    Layer.prototype = {
      constructor: Layer,
      pushToLayers: pushToLayers,
      createSeries: createSeries,
      pushToSeries: pushToSeries,
      getLayersCount: getLayersCount,
      getPanesCount: getPanesCount,
      getPanes: getPanes,
      createDuplicateLayerNode: createDuplicateLayerNode
    };

    function processChild(node) {
      if (node.isEmpty) {
        return;
      }
      var tag = node.tag;
      if (tag == 'row' || tag == 'column') {
        if (node.datatype == 'ordinal') {
          var rootNodeList = this.getRootNodeList(node.tag);
          rootNodeList.pushToBranch(node);
          tag == 'row' ? node.row = node.index : node.column = node.index;
          if (!node.hasInnerChild) {
            var node_duplicate_layer = this.layers.createDuplicateLayerNode(node);
            this.layers.pushToLayers(node_duplicate_layer, this.series);
            this.layers.createSeries(node_duplicate_layer, this.series);
          }
        } else {
          var _rootNodeList = this.getRootNodeList(node.tag);
          _rootNodeList.createCluster(node);
          tag == 'row' ? node.row = node.index : node.column = node.index;
          tag == 'row' ? node.childIndexbyrow = node.childIndex : node.childIndexbycolumn = node.childIndex;
          if (!node.hasInnerChild) {
            this.layers.pushToLayers(node, this.series);
          } else {
            node.levelByColumn = "".concat(pick(node.parent && node.parent.levelByColumn, ''));
            node.levelByRow = "".concat(pick(node.parent && node.parent.levelByRow, ''));
            this.layers.splitClusters.add(node.value);
          }
          this.layers.createSeries(node, this.series);
        }
      } else if (tag == 'layer') {
        this.layers.pushToLayers(node, this.series);
        if (!node.parent || node.parent.datatype == 'ordinal') {
          this.layers.createSeries(node, this.series);
        }
      } else if (tag == 'leaf') {
        var datatype = node.datatype,
          datatype_rows = datatype.rows,
          datatype_columns = datatype.columns;

        if (node.parent) {
          node.childIndexbyrow = node.parent.childIndexbyrow;
          node.childIndexbycolumn = node.parent.childIndexbycolumn;
        }

        //columns
        if (datatype_columns == 'ordinal' || datatype_columns == 'time') {
          this.columns.pushToDiscreteCluster(node);
        } else {
          this.columns.pushToContinuousCluster(node);
        }
        this.layers.pushToSeries(node, this.series);

        //rows
        if (datatype_rows == 'ordinal' || datatype_rows == 'time') {
          this.rows.pushToDiscreteCluster(node);
        } else {
          this.rows.pushToContinuousCluster(node);
        }
      }
    }

    function setRanges(tag, leafscaleUtil) {
      var mode = leafscaleUtil ? 'discrete' : 'continuous',
        nodeList = tag == 'row' ? this.rows : this.columns,
        leafscale,
        pointProperty,
        startRange,
        sign_correction = 1,
        splitLeavesColumn = tag == 'column' ? nodeList.splitColumnLeaves : null,
        uniformLeafScale;

      if (mode == 'discrete') {
        leafscaleUtil._padding(nodeList.getClusterNodes(0), nodeList.getDomainForCluster(0));
        nodeList.leafScale = leafscale = leafscaleUtil._scale; //TODO check whether this property need tor not
        if (splitLeavesColumn) {
          var rangeInfo = leafscaleUtil._rangeInfo();
          startRange = rangeInfo.startPos;
          sign_correction = rangeInfo.sign;
          uniformLeafScale = leafscaleUtil._haUniformLeafScale;
        }
        pointProperty = leafscaleUtil.pointProperty;
      }
      var count = nodeList.count;
      for (var i = 0; i < count; i++) {
        var domain = nodeList.branches[i].nodes,
          range = nodeList.branches[i].range = new Array(domain.length),
          inodes = nodeList.branches[i].inodes,
          endRange = startRange;
        domain.forEach(function (d, i) {
          if (d.children) {
            if (isFirstBranch(tag, d.children)) {
              var c = inodes[i].children,
                children = c && c.length ? c : d.children;

              d.rangeBand = getRangeBandForFirstBranch(nodeList, children, mode, i);
              var tempRange = mode == 'continuous' ? d.rangeBand * i : splitLeavesColumn ? endRange : getStartRange(children);
              endRange = tempRange + sign_correction * d.rangeBand;
              d.range = [tempRange, endRange];
            } else {
              d.rangeBand = d.children.reduce(sumLeaves, 0);
              var firstProperChild = getFirstFullData(d.children);
              d.range = firstProperChild ? [firstProperChild.range[0], d.rangeBand + firstProperChild.range[0]] : [];
            }
            range[i] = d.range;
          }
        });
      }

      function getStartRange(children) {
        var startRange;
        if (leafscale) {
          var firstDefinedData = isLeafChild(children) ? getFirstDefinedData(children) : getFirstDefinedData(children[0].children);
          startRange = leafscale(firstDefinedData[pointProperty]) - getSpan(firstDefinedData, true, true);
        }
        return startRange;
      }
      function getRangeBandForFirstBranch(nodeList, children, mode, childIndex) {
        if (mode == 'continuous' || splitLeavesColumn) {
          return getContinousRangeBandForFirstBranch(nodeList, childIndex);
        } else {
          return getDiscreteRangeBandForFirstBranch(nodeList, children);
        }
      }

      function getContinousRangeBandForFirstBranch(nodeList, childIndex) {
        if (!uniformLeafScale && nodeList.nonUniformLeafSize) {
          return nodeList.nonUniformLeafSize[childIndex] * nodeList.clustersCount;
        }
        return nodeList.leafSize * nodeList.clustersCount;
      }

      function getDiscreteRangeBandForFirstBranch(nodeList, children) {
        if (leafscaleUtil._rangebandForFirstBranch) {
          return leafscaleUtil._rangebandForFirstBranch(children);
        }
        if (isLeafChild(children)) {
          return children.reduce(sumLeaves, 0);
        }
        var mergedChildren = mergerLayerChildren(children);
        if (mode == 'discrete' && leafscaleUtil._hasDynamicLeafScale()) {
          leafscaleUtil._padding(nodeList.getClusterNodes(0), nodeList.getDomainForCluster(0), mergedChildren[0].index);
        }
        return mergedChildren.reduce(sumLeaves, 0);
      }

      function mergerLayerChildren(layers) {
        var children = d3_map();
        layers.map(function (d) {
          d.children.map(function (child) {
            if (!children.has(child.value)) {
              var node = child.rootLayer ? child : child.node || child;
              children.set(child.value, node);
            }
          });
        });
        return children.values();
      }

      function isLeafChild(children) {
        return defined(children[0]) && children[0].tag === 'leaf';
      }
      function isFirstBranch(tag, children) {
        return (
          children && defined(children[0]) && (children[0].tag != tag || children[0].tag === 'leaf' || children[0].datatype == 'numeric'));

      }

      function sumLeaves(a, point) {
        if (!point.isDefined || point.isEmpty) {
          return 0;
        }
        if (!point.rangeBand) {
          return a + leafscale.bandwidth(point.index) + getSpan(point, true, leafscale) + getSpan(point, false, leafscale);
        }
        return a + point.rangeBand;
      }

      function getSpan(point, startSide, useStaticPadding) {
        var node = point.name == 'Leaf' ? point.node : point;
        if (startSide && node === leafscale.firstPt || !startSide && node === leafscale.lastPt) {
          return useStaticPadding ? pick(leafscale._outerPadding, leafscale.outerPadding) : leafscale.outerPadding;
        } else {
          return useStaticPadding ? pick(leafscale._innerPadding, leafscale.innerPadding) : leafscale.innerPadding;
        }
      }

      function getFirstDefinedData(children) {
        var firstDefinedChild;
        children.some(function (d) {
          var node = d.name == 'Leaf' ? d.node : d;
          if (node.isDefined) {
            firstDefinedChild = d;
          }
          return node.isDefined;
        });
        return firstDefinedChild;
      }

      function getFirstFullData(children) {
        var firstDefinedChild;
        children.some(function (d) {
          if (!d.isEmpty) {
            firstDefinedChild = d;
          }
          return !d.isEmpty;
        });
        return firstDefinedChild;
      }
    }

    /*
    Ranges for non linear ordinal leaf scale
     */
    function setRangesForLeafScale(tag, leafScale) {
      var nodeList = tag == 'row' ? this.rows : this.columns,
        actualDomain = leafScale.domain(),
        bandwidth = leafScale.bandwidth(),
        categoriesCount_firstBranch = nodeList.count ? nodeList.branches[0].domain.length : 1,
        clusterSet = nodeList.clusters[0];
      var counter = 0,
        counter1 = 0;
      var range = new Array(0);
      for (var i = 0; i < categoriesCount_firstBranch; i++) {
        var dynamicDomain = clusterSet.entries.values()[i].customDomain,
          domain = nodeList.getDomainForClusterSet(0, i);
        domain.map(function (d, j) {
          var startCounter = counter,
            endCounter;

          if (dynamicDomain && dynamicDomain.get(0) && j == domain.length - 1) {
            //handled only for single data as children for category

            var noOfDummyCategories = dynamicDomain.get(0).count;
            // if (domain.length > 1) {
            //     if (!tempDynamicScale) {
            //         tempDynamicScale = d3_scaleOrdinal()
            //             .domain(d3_range(domain.length))
            //             .range([leafScale(startCounter), leafScale(startCounter + domain.length + noOfDummyCategories - 1)])
            //             .paddingOuter(0)
            //             .paddingInner(leafScale.paddingInner());
            //     }
            //     // var x = mathAbs(leafScale(0) - leafScale(noOfDummyCategories - 1)) / noOfDummyCategories;
            //     // range[counter1] = [leafScale(startCounter), leafScale(startCounter) + bandwidth + x];
            //
            //     range[counter1] = [tempDynamicScale(startCounter), tempDynamicScale(startCounter) + tempDynamicScale.bandwidth()];
            //     if (j == domain.length - 1) {
            //         counter = startCounter + noOfDummyCategories;
            //     }
            // } else {
            endCounter = startCounter + noOfDummyCategories;
            range[counter1] = [leafScale(startCounter), leafScale(endCounter) + bandwidth];
            counter = endCounter;
            // }
          } else {
            range[counter1] = [leafScale(startCounter), bandwidth + leafScale(startCounter)];
          }

          counter++;
          counter1++;
        });
      }
      return range;
    }

    function setLeafSize(customRowSize, customColumnSize) {
      setLeafSizeForNodelist(this.rows, customRowSize);
      setLeafSizeByNonUniformScale(this.columns, customColumnSize);
    }

    function setLeafSizeForNodelist(nodeList, customSize) {
      if (nodeList.count || nodeList.leafCount) {
        var defaultSize = 150,
          firstBranchCount = nodeList.count ? nodeList.branches[0].domain.length : 1;
        nodeList.leafSize = customSize ? customSize / (firstBranchCount * nodeList.clustersCount) : defaultSize;
      }
    }

    function setLeafSizeByNonUniformScale(nodeList, customSize) {
      if (nodeList.count || nodeList.leafCount) {
        var defaultSize = 150,
          categoriesCount_cluster = nodeList.getClusterNodes(0).length,
          eachCategorySize = customSize ? customSize / categoriesCount_cluster : defaultSize / categoriesCount_cluster,
          categoriesCount_firstBranch = nodeList.count ? nodeList.branches[0].domain.length : 1,
          datatype = nodeList.clusters[0].datatype;
        if (datatype == ORDINAL_DATATYPE) {
          nodeList.nonUniformLeafSize = new Array(0);
          for (var i = 0; i < categoriesCount_firstBranch; i++) {
            nodeList.nonUniformLeafSize[i] = eachCategorySize * nodeList.getDomainForClusterSet(0, i).length;
          }
        }

        nodeList.leafSize = customSize ? customSize / (categoriesCount_firstBranch * nodeList.clustersCount) : defaultSize;
      }
    }

    function deleteAllEmptyParents(node) {
      var parent = node.parent,
        entry = node,
        siblings_entry,
        children_entry = node.children;
      while (parent) {
        siblings_entry = parent.children;
        if (children_entry.length == 0) {
          var nodeIdxToRemove = searchNodeIdxByKey(siblings_entry, entry, 'value');
          removeNodeByIdx(siblings_entry, nodeIdxToRemove);
        }
        entry = parent;
        children_entry = entry.children;
        parent = parent.parent;
      }
    }

    function searchNodeIdxByKey(children, node, key) {
      var idx = -1;
      children.some(function (d, i) {
        if (d[key] == node[key]) {
          idx = i;
          return true;
        }
      });
      return idx;
    }
    function removeNodeByIdx(nodes, idx) {
      if (idx > -1) {
        nodes.splice(idx, 1);
      }
    }

    function PivotLayout(data, hooks) {
      var _this = this,
        root = new Node(data, -1, -1, -1, 'root', ''),
        child,
        childs,
        i,
        n,
        children = hooks.children || defaultChildren,
        nodetype = hooks.nodeType || defaultNodeType,
        datatype = hooks.dataType || defaultDataType,
        name = hooks.nodeName || defaultNodeName,
        nodedata = hooks.data,
        isDefined = hooks.isDefined,
        isEmpty = hooks.isEmpty,
        splitColumnLeaves = hooks.hasSplitLeavesColumns();

      this.rows = new Row(), this.columns = new Column(), this.layers = new Layer(), this.series = [];

      eachNode(root, function (node) {
        if (node.tag !== 'leaf' && (childs = children(node)) && (n = childs.length)) {
          node.children = new Array(0);
          var isAllChildEmpty = true;
          for (i = 0; i < n; i++) {
            child = new Node(childs[i]);
            child.parent = node;
            child.depth = node.depth + 1;
            child.row = node.row || 0;
            child.column = node.column || 0;
            child.tag = nodetype(child);
            child.datatype = datatype(child);
            child.depthbyrow = child.tag == 'row' ? node.depthbyrow + 1 : node.depthbyrow;
            child.depthbycolumn = child.tag == 'column' ? node.depthbycolumn + 1 : node.depthbycolumn;
            child.childIndex = node.children.length;
            child.childIndexbyrow = node.childIndexbyrow || 0;
            child.childIndexbycolumn = node.childIndexbycolumn || 0;
            // child.level = `${pick(node.level, '') + i}_`;
            child.isDefined = child.tag == 'leaf' ? isDefined(child.node) : true;
            child.value = name(child.node);
            child.data = nodedata(child.node);
            child.isEmpty = child.tag == 'leaf' ? !child.isDefined : isEmpty(child);
            isAllChildEmpty = isAllChildEmpty ? child.isEmpty : isAllChildEmpty;

            if (!child.isEmpty) {
              node.children.push(child);
            }
            // this.process(child);
          }
          node.isEmpty = isAllChildEmpty;
          if (node.isEmpty) {
            deleteAllEmptyParents(node);
          }
        }
      });

      this.columns.splitColumnLeaves = splitColumnLeaves;

      eachNodeBeforeAfter(
      root,
      function (node) {
        _this.process(node);
      },
      this.postProcess);


      this.rows.branches.reverse();
      this.columns.branches.reverse();

      if (this.columns.missedNodes) {
        this.columns.setNodeIndexForClusters();
      }
    }

    function postProcess(node, child) {
      var tag = node.tag;
      child.row = node.row || 0;
      child.column = node.column || 0;
      if (tag == 'row') {
        child.childIndexbyrow = node.childIndexbyrow;
      } else if (tag == 'column') {
        child.childIndexbycolumn = node.childIndexbycolumn;
      }
    }

    function defaultChildren(d) {
      return d.children;
    }

    function defaultNodeType(d) {}

    function defaultDataType(d) {}

    function defaultNodeName(d) {}

    function getRootNodeList(tag) {
      if (tag == 'row') {
        return this.rows;
      } else if (tag == 'column') {
        return this.columns;
      } else if (tag == 'layer') {
        return this.layers;
      }
    }

    PivotLayout.prototype = {
      row: Row,
      column: Column,
      layer: Layer,
      process: processChild,
      getRootNodeList: getRootNodeList,
      setRanges: setRanges,
      setRangesForLeaf: setRangesForLeafScale,
      leafSize: setLeafSize,
      postProcess: postProcess
    };

    Registry.setComponent('PivotLayout', PivotLayout);

    function LayerHierarchy(data, lastRoot, hooks) {
      var root = new Node(data, -1, -1, -1, 'root', ''),
        child,
        childs,
        i,
        n,
        children = hooks.children,
        nodetype = hooks.nodeType,
        datatype = hooks.dataType,
        name = hooks.nodeName,
        layerName = hooks.layerName(data),
        nodedata = hooks.data,
        isDefined = hooks.isDefined,
        isEmpty = hooks.isEmpty,
        main = lastRoot || new Node({}, -1, -1, -1, 'root', '');

      eachNode(root, function (node) {
        if (node.tag !== 'leaf' && (childs = children(node)) && (n = childs.length)) {
          var layerNode;

          var parent = node.main || main;
          if (!parent.children) {
            parent.children = [];
          }
          node.children = new Array(0);

          var objKey = keysObject(parent.children);
          var isAllChildEmpty = true;
          for (i = 0; i < n; i++) {
            child = new Node(childs[i]);
            child.parent = parent;
            child.row = parent.row || 0;
            child.column = parent.column || 0;
            child.depth = parent.depth + 1;
            child.tag = nodetype(child, child.depth + 1);
            child.datatype = datatype(child, child.depth + 1);
            child.depthbyrow = child.tag == 'row' ? parent.depthbyrow + 1 : parent.depthbyrow;
            child.depthbycolumn = child.tag == 'column' ? parent.depthbycolumn + 1 : parent.depthbycolumn;
            child.data = nodedata(childs[i]);
            child.childIndex = node.children.length;
            child.childIndexbyrow = parent.childIndexbyrow || 0;
            child.childIndexbycolumn = parent.childIndexbycolumn || 0;
            child.value = name(child.node);
            child.isDefined = child.tag == 'leaf' ? isDefined(child.node) : true;
            child.isEmpty = child.tag == 'leaf' ? !child.isDefined : isEmpty(child);
            isAllChildEmpty = isAllChildEmpty ? child.isEmpty : isAllChildEmpty;
            var childNode = new Node(childs[i]);
            childNode.value = child.value;

            if (child.tag == 'leaf') {
              var objKey1 = keysObject(parent.children);

              if (!objKey1[layerName] || !layerNode) {
                layerNode = new Node(data);
                layerNode.disabled = data.disabled;
                layerNode.value = layerName;
                parent.children.push(layerNode);
                layerNode.children = [child];
              } else {
                layerNode.children.push(child);
              }
              layerNode.isDefined = true;
              layerNode.tag = 'layer';
              child.seriesname = layerNode.value;
              child.rootLayer = true;
            } else {
              if (!objKey[child.value]) {
                parent.children.push(child);
                childNode.main = child;
              } else {
                childNode.main = objKey[child.value];
              }
            }
            childNode.parent = parent;
            if (!child.isEmpty) {
              node.children.push(childNode);
            }
          }
          node.isEmpty = parent.isEmpty = isAllChildEmpty;
          if (node.isEmpty) {
            deleteAllEmptyParents(node);
          }
        }
      });
      return main;
    }

    function keysObject(arr) {
      var t = {};
      if (arr && arr.length) {
        arr.forEach(function (el) {
          t[el.value] = el;
        });
      }
      return t;
    }

    LayerHierarchy.prototype = {};

    function LayerHierarchyLayout(data, hooks) {var _this31 = this;
      var root,
        _this = this;

      this.rows = new Row(), this.columns = new Column(), this.layers = new Layer();
      this.series = [];

      data.forEach(function (d, i) {
        /*
            Added Domain names initially to have missed series data
         */
        _this31.layers.createSeries({ node: d }, _this31.series);
        _this31.layers.domain.add(d.seriesname);
        /*
         */
        if (!d.disabled) {
          root = new LayerHierarchy(d, root, hooks);
        }
      });

      this.columns.splitColumnLeaves = hooks.hasSplitLeavesColumns();

      eachNodeBeforeAfter(
      root,
      function (node) {
        if (node.tag == 'layer') {
          node.data = [
          node.children.map(function (d) {
            return d.data;
          })];

        }
        _this.process(node);
      },
      this.postProcess);


      this.rows.branches.reverse();
      this.columns.branches.reverse();
    }

    function preProcess(node) {
      if (node.tag == 'layer') {
        node.data = [
        node.children.map(function (d) {
          return d.data;
        })];

      }
      this.process(node);
    }

    function postProcess$1(node, child) {
      child.row = node.row || 0;
      child.column = node.column || 0;
    }

    function getRootNodeList$1(tag) {
      if (tag == 'row') {
        return this.rows;
      } else if (tag == 'column') {
        return this.columns;
      } else if (tag == 'layer') {
        return this.layers;
      }
    }

    LayerHierarchyLayout.prototype = {
      row: Row,
      column: Column,
      layer: Layer,
      process: processChild,
      preProcess: preProcess,
      postProcess: postProcess$1,
      getRootNodeList: getRootNodeList$1,
      setRanges: setRanges,
      leafSize: setLeafSize,
      executor: LayerHierarchy
    };

    Registry.setComponent('LayerHierarchyLayout', LayerHierarchyLayout);

    function GroupByTimeDataLayout(data, hooks) {
      var _this = this;
      this.rows = new Row(), this.columns = new Column(), this.layers = new Layer(), this.series = [];

      var root = new Node(data, -1, -1, -1, 'root', '');

      root.children = data.data;

      eachNodeBeforeAfter(
      root,
      function (node) {
        if (node.type == 'layer') {
          node.data = [
          node.children.map(function (d) {
            return d.data;
          })];

        }
        _this.process(node);
      },
      this.postProcess);

      this.rows.branches.reverse();
      this.columns.branches.reverse();
    }

    function preProcess$1(node) {
      if (node.tag == 'layer') {
        node.data = [
        node.children.map(function (d) {
          return d.data;
        })];

      }
      this.process(node);
    }

    function postProcess$2(node, child) {
      child.row = node.row || 0;
      child.column = node.column || 0;
    }

    function getRootNodeList$2(tag) {
      var list = tag == 'row' ? this.rows : this.columns;
      return list;
    }

    GroupByTimeDataLayout.prototype = {
      process: processChild,
      preProcess: preProcess$1,
      postProcess: postProcess$2,
      getRootNodeList: getRootNodeList$2,
      setRanges: setRanges,
      leafSize: setLeafSize
    };

    Registry.setComponent('GroupByTimeDataLayout', GroupByTimeDataLayout);

    /**
     *
     * @param chart
     */
    function getOverViewUserData(chart) {
      var data = chart.systemConf.chart.scroll.overview.data;

      if (!data) {
        data = simpleClone(chart.userdata);

        setPropVal(data, 'chart.marginTop', 0);
        setPropVal(data, 'chart.marginBottom', 0);
        setPropVal(data, 'chart.marginLeft', 0);
        setPropVal(data, 'chart.marginRight', 0);

        // setPropVal(data, 'canvas.intelligence', {});
        setPropVal(data, 'canvas.title.show', false);
        setPropVal(data, 'canvas.subtitle.show', false);

        // disable border and shadow
        setPropVal(data, 'canvas.border.show', false);
        setPropVal(data, 'canvas.shadow.show', false);

        // disable axis
        var yAxes = data.metadata.axes.y || [];
        yAxes.forEach(function (axis, i) {
          setPropVal(data, "chart.axes.yaxis[".concat(i, "].show"), false);
        });

        // for time auto ticks we will show the axis
        var xAxisConfig = chart.dataset.getColumn('x', 0);
        setPropVal(
        data,
        'chart.axes.xaxis.show',
        xAxisConfig.datatype === TIME_DATATYPE && getPropVal(xAxisConfig, 'time.format.specifier') === 'auto');


        // disable the label
        setPropVal(data, 'chart.axes.xaxis.label.show', false);
      }
      var scrollOrient = chart.scroll.settings.orient,
        axisReversed = data.chart.axes.xaxis.reversed;
      //this check is made inorder to achieve racing - if scrollOrient is loft/right if reversed is true - it will work fine, thus even if reversed not given true in racing data, we set it to true here, also if rversed mentioned in racing data that data itself is taken
      if (scrollOrient === 'right' || scrollOrient === 'left') {
        setPropVal(data, 'chart.axes.xaxis.reversed', !isUndefined(axisReversed) && !chart.racing ? axisReversed : true);
      } else {
        // racing-bottom and top, and other overview cases
        setPropVal(data, 'chart.axes.xaxis.reversed', !isUndefined(axisReversed) && !chart.racing ? axisReversed : false);
      }

      setPropVal(data, '__$overview', true);
      setPropVal(data, 'chart.plot.renderer.mode', 'canvas');
      if (scrollOrient) {
        setPropVal(data, 'chart.axes.rotated', scrollOrient === 'left' || scrollOrient === 'right');
      } else {
        setPropVal(data, 'chart.axes.rotated', chart.axes.rotated);
      }

      setPropVal(data, 'chart.plot.datalabels.show', false);
      setPropVal(data, 'chart.plot.events.enabled', false);
      setPropVal(data, 'credits.show', false);
      // #ZC2126
      setPropVal(data, 'notes.enabled', false);
      setPropVal(data, 'chart.scroll.enabled', false);
      setPropVal(data, 'chart.axes.xaxis.ticklabel.textOverflow', 'none');
      setPropVal(data, 'chart.axes.animation.enabled', false);
      // #ZC2117
      setPropVal(data, 'metadata.axes.label', []);
      // #ZC2106
      setPropVal(data, 'legend.enabled', false);

      // get all the chart types
      var types = DataProcessor.helpers.getAllChartTypes(data, 'object');

      // disable the datalabels
      types.forEach(function (t) {
        setPropVal(data, "chart.plot.plotoptions.".concat(t.name, ".datalabels.show"), false);
        // #ZC2117
        setPropVal(data, "chart.plot.plotoptions.".concat(t.name, ".datalabels.stackLabels.show"), false);
        setPropVal(data, "chart.plot.plotoptions.".concat(t.name, ".animation.enabled"), false);
        // setPropVal(data, `chart.plot.plotoptions.${t.name}.outerPadding`, 0);
      });

      return data;
    }

    /**
     *
     * @param overviewChart
     * @param scrollBound
     * @return {CanvasRenderingContext2D}
     */
    function getOverlayCanvas(overviewChart, scrollBound) {
      scrollBound.width = mathRound(scrollBound.width);
      var height = getPlotSize(overviewChart, 'height'),
        width = getPlotSize(overviewChart, 'width');
      var canvas = createElement('canvas', '.overview-grayscale', [1], overviewChart.d3container.select('.canvas-component'), 'svg.static').
      attrs({
        width: width,
        height: height
      }).
      styles({
        position: 'absolute',
        left: "".concat(overviewChart.plotarea.left, "px"),
        top: "".concat(overviewChart.plotarea.top, "px"),
        width: "".concat(width, "px"),
        height: "".concat(height, "px")
      });

      return fixHDPI(canvas.node().getContext('2d'));
    }

    /**
     *
     * @param chartObj
     * @param scrollDimension
     * @param callback
     */function
    renderOverviewContext(_x8, _x9, _x10) {return _renderOverviewContext.apply(this, arguments);}



























    /**
     *
     * @param {ChartBrushScroll} scroll
     * @return {number}
     */function _renderOverviewContext() {_renderOverviewContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(chartObj, scrollDimension, callback) {var userdata, overviewContext;return _regeneratorRuntime().wrap(function _callee2$(_context2) {while (1) switch (_context2.prev = _context2.next) {case 0:userdata = getOverViewUserData(chartObj);overviewContext = chartObj.container.selectAll('div.zcoverview');overviewContext.styles({ position: 'absolute', 'pointer-events': NONE, 'box-sizing': 'border-box', width: "".concat(scrollDimension.width, "px"), height: "".concat(scrollDimension.height, "px"), left: "".concat(scrollDimension.left, "px"), top: "".concat(scrollDimension.top, "px") }); //inorder to manage redraw -the container will be considered as hidden if its display is set to none
              overviewContext.style("display", null);chartObj.staticPaneSVG.selectAll(".brush-scroll").style("display", null);chartObj.overview = charts(overviewContext.node(), userdata, scrollDimension);if (!chartObj.systemConf.chart.scroll.overview.show) {overviewContext.style("display", "none");chartObj.staticPaneSVG.selectAll(".brush-scroll").style("display", "none");}if (callback) {callback(chartObj.overview);}case 8:case "end":return _context2.stop();}}, _callee2);}));return _renderOverviewContext.apply(this, arguments);}function getHandleMarkerSize(scroll, extent) {
      var considerMarkerSize = d3_set(['lineCircle']),
        resizerSettings = scroll.settings.resizer || {},
        markerType = resizerSettings.type;

      if (resizerSettings.enabled && considerMarkerSize.has(markerType)) {
        var userStyles = resizerSettings[markerType] || {},
          _styles4 = getMergedHandleStyles('x', resizerSettings.type, extent, null, userStyles);

        return _styles4.size;
      }
      return 0;
    }

    /**
     *
     * @param chartObj
     * @return {{top: *, left: *, width: plotarea.width, height: plotarea.height}}
     */
    function getScrollBoundRect(chartObj, scroll) {
      var scrollSettings = scroll.settings,
        rotated = chartObj.axes.rotated,
        plotarea = chartObj.plotarea;
      if (scroll.settings.orient) {
        var width = scroll.settings.orient === 'left' || scroll.settings.orient === 'right' ? scrollSettings.height : plotarea.width,
          height = scroll.settings.orient === 'left' || scroll.settings.orient === 'right' ? plotarea.height : scrollSettings.height;
      } else {
        var width = rotated ? scrollSettings.height : plotarea.width,
          height = rotated ? plotarea.height : scrollSettings.height;
      }
      return {
        width: width,
        height: height,
        left: scroll.position.x,
        top: scroll.position.y
      };
    }

    /**
     *
     * @param overviewChart
     */
    function clipOverview(overviewChart) {
      var scroll = this,
        scrollDimension = scroll.dimension,
        scrollData = scroll.settings,
        extent = scroll.brushExtent,
        overviewSettings = scrollData.overview || {},
        axisRotated = overviewChart.axes.rotated,
        defaultSelection = scroll.scrollDomain,
        selectionArgs = {
          scrollType: this.type,
          brushInstance: this.brushInstance,
          scrollScale: this.settings.brushScale,
          chartObj: this.chart
        },
        selection = isArray$1(scroll.settings.selectionDomain) ?
        scroll.settings.selectionDomain :
        invokeFunction(scroll.settings.selectionDomain, selectionArgs) || defaultSelection;
      // update the scale with the overview chart scale
      if (overviewSettings.syncScale !== false) {
        scroll.brushScale = overviewChart.axes.x.scale;
      }

      if (overviewSettings.bindTo === 'plot') {
        extent = getBrushExtent(overviewChart, scrollData, true);
      }

      // scroll.initialSelection = domainToActualRange(overviewChart, selection, 0, 'x', true);

      var brushInstance = scroll.addEvent(extent, selection),
        context = getOverlayCanvas(overviewChart, scrollDimension),
        canvasData = copyCanvasData(overviewChart.context);

      colorizeImageData(canvasData, overviewSettings.unselectedEffect);

      var highlightSelected = function highlightSelected() {
        var selection = brushInstance.getSelection();
        var clip = getClipBound(selection, scrollData, axisRotated, overviewChart.plotarea);

        context.putImageData(canvasData, 0, 0);
        context.clearRect(clip.x, clip.y, clip.width, clip.height);

        // clip the track
        CHART_BRUSH_HELPERS.CLIP_TRACK(brushInstance, selection, scroll.chart, 'overview');
      };

      highlightSelected();
      brushInstance.addHook('brush.clipCanvas', highlightSelected);
    }

    /**
     *
     * @param chartObj
     * @param scrollData
     * @param withinOverViewPlot
     * @return {*[][]|(number[]|*[])[]}
     */
    function getBrushExtent(chartObj, scrollData, withinOverViewPlot) {
      var plotArea = chartObj.plotarea;
      if (withinOverViewPlot) {
        return [[plotArea.left, plotArea.top], [plotArea.width + plotArea.left, plotArea.height + plotArea.top]];
      } else {
        return [
        [0, 0],
        chartObj.axes.rotated ? [scrollData.height, chartObj.plotarea.height] : [chartObj.plotarea.width, scrollData.height]];

      }
    }

    /**
     *
     * @param selection
     * @param scrollData
     * @param axisRotated
     * @param plotArea
     * @return {{x: number, width: number, y: number, height: number}}
     */
    function getClipBound(selection, scrollData, axisRotated, plotArea) {
      var selectionDistance = selection[1] - selection[0];
      var x = axisRotated ? 0 : selection[0] - plotArea.left,
        y = axisRotated ? selection[0] - plotArea.top : 0,
        width = axisRotated ? scrollData.height : selectionDistance,
        height = axisRotated ? selectionDistance : scrollData.height;

      return { x: x, y: y, width: width, height: height };
    }

    var MINIMUM_VISIBLE_POINTS = 3;

    /**
     * Minimum size of the resize place to avoid same domain
     * @type {number}
     */
    var FREE_DRAG_MIN_SIZE = 2;

    /**
     *
     * @param chart
     * @param axisType
     * @param numberOfPointsInView
     * @return {number}
     */
    function getMinimumVisibleArea(chart, axisType, numberOfPointsInView) {
      var domain,
        maxArea,_getAxisObject =
        getAxisObject(chart, axisType, 0),baseScale = _getAxisObject.baseScale,
        minX,
        maxX;

      if (numberOfPointsInView === 0) {
        return FREE_DRAG_MIN_SIZE;
      }

      if (baseScale.bandwidth) {
        domain = baseScale.domain();
        // use second data instead of 1 if available
        // it will have proper padding
        var t = domain.length > 1 ? 1 : 0;
        domain = [domain[t], domain[t]];
      } else {
        domain = getConsecutiveAvailablePoint(chart, 2);var _chart$dataObject$get =
        chart.dataObject.getMinMaxX(0, false);var _chart$dataObject$get2 = _slicedToArray(_chart$dataObject$get, 2);minX = _chart$dataObject$get2[0];maxX = _chart$dataObject$get2[1];
      }

      maxArea = domainToActualRange(chart, domain, 0, 'x', true);
      var singlePointDistance = maxArea[1] - maxArea[0],
        range = baseScale.range(),
        totalRange = mathAbs(range[1] - range[0]);

      // single point domain
      if (maxArea[0] === maxArea[1]) {
        return totalRange;
      } else if (minX === domain[0] && maxX === domain[1]) {
        // in case of only w points, allow till the half points.
        singlePointDistance = singlePointDistance / 2;
      }

      return mathMin(totalRange, singlePointDistance * numberOfPointsInView);
    }

    /**
     *
     * @param chart
     * @param numberOfPoints
     * @param type
     * @param index
     * @return {null}
     */
    function getConsecutiveAvailablePoint(chart) {var numberOfPoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'x';var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var data = [],
        dataIndex = chart.dataset.getColumn(type, index).dataindex;

      chart.seriesdata.some(function (series) {
        return series.data.some(function (subSeries) {
          return subSeries.some(function (point) {
            var p = point[dataIndex];
            if (defined(p) && !arrayIncludes(data, p) && data.length !== numberOfPoints) {
              data.push(p);
              return data.length === numberOfPoints;
            }
          });
        });
      });
      return data;
    }

    /**
     *
     * @param behaviourEventInstance
     * @param selectionManager
     * @param selection
     * @constructor
     */
    function SCROLL_BRUSH_ACTION(behaviourEventInstance, selectionManager, selection, event) {
      var eventManager = this,
        scroll = behaviourEventInstance.instance,
        behaviours = eventManager.behaviours,
        chart = scroll.chart,
        domainInfo = selectionManager.point,
        domain = domainInfo.x.domain,
        plotBrushInstanceMap = behaviours.PLOT_BRUSH,
        plotZoomInstanceMap = behaviours.PLOT_ZOOM,
        range = scroll.brushScale.range(),
        chartXScale = chart.axes.x.scale;

      chart.viewPortExtent = domain;

      scroll.lastScroll = selection.map(scroll.scrollPositionScale.invert);
      // fix the outer padding
      // if (!scroll.isSmooth) {
      //     if (!scroll.isSingleDomain) {
      //         if (scroll.brushScale.bandwidth) {
      //             let factor = scroll.rotated || chart.axes.x.reverse ? -1 : -1;
      //             range = [range[0] - chartXScale.outerPaddingPx * factor, range[1] + chartXScale.outerPaddingPx * factor];
      //         } else {
      //             domain = applyPadding(domain, chartXScale.outerPadding, chartXScale.originalDomain, chartXScale.correctionOverBubbles);
      //         }
      //     }
      //      #FEATURES_SCROLL_6 extra padding
      //     // domainInfo.x.range = range;
      //     // domainInfo.x.domain = domain;
      // }

      // let selectionCache = chart.cache.scroll.selection,
      // isDuplicateScroll = selectionCache && selectionCache[0] === selection[0] && selectionCache[1] === selection[1];

      // save the selection
      chart.cache.scroll.selection = selection;
      chart.cache.scroll.domain = domain;

      // #ZC2455 $isDuplicateScroll
      // #[ZC2357] [line, $chart.scrolling]
      chart.scrolling_ = true;
      if (chart.zooming || chart.scrolling && !chart.scrollEnd) {//TOBE solve ZC3535
        // if (chart.zooming) {
        return;
      }
      if (chart.scrollEnd) {
        chart.scrollEnd = false;
      }
      chart.scroll.scrollDomain = domain;

      // #[ZC2357] disable the animation only while scroll by user
      chart.disableAnimation = !!event.sourceEvent;
      chart.scrolling = true;

      if (isArray$1(domain)) {
        if (plotZoomInstanceMap) {
          domain = [domain[0], domain[domain.length - 1]];
          var identity = getIdentity(chart, domain, 'x', 0, selection);
          plotZoomInstanceMap.instance.zoomToIdentity(identity, 0);
          // _ZoomToDomain(eventManager, domain, 'x', 0, chart.brushScale, 0);
        } else {
          if (scroll.settings.smooth === true) {
            smoothOrdinalScroll(domainInfo, selection, scroll, chart, range);
          } else {
            CHART_DOMAIN_HELPERS.FILTER_CHART(domainInfo, scroll.chart);
          }
        }

        if (plotBrushInstanceMap) {
          plotBrushInstanceMap.instance.updateExtent([
          [0, 0],
          [chart.plotarea.width, chart.plotarea.height]]);

        }
      }

      if (scroll.tooltip && event.sourceEvent) {
        scroll.tooltip.show();
      }

      clearTimeout(scroll.timer);
      scroll.timer = setTimeout(function () {return chart.scrolling = false, chart.disableAnimation = false;}, 50);
    }

    function applyPadding(domain, padding, calculatedPadding) {
      var isDate = domain[0] instanceof Date;
      if (isDate) {
        domain = domain.map(function (d) {return d.getTime();});
      }
      if (isArray$1(calculatedPadding)) {
        domain = [domain[0] - calculatedPadding[0], domain[1] + calculatedPadding[1]];
      } else {
        var correction = mathAbs(domain[1] - domain[0]) * padding;
        domain = [domain[0] - correction, domain[1] + correction];
      }

      if (isDate) {
        domain = domain.map(function (d) {return new Date(d);});
      }
      return domain;
    }
    /**
     *
     * @param domainInfo
     * @param selection
     * @param scroll
     * @param chart
     */
    function smoothOrdinalScroll(domainInfo, selection, scroll, chart, scrollRange) {
      var transform = getIdentity(chart, domainInfo.x.domain, 'x', 0, selection),
        type = 'x',_getAxisObject2 =
        getAxisObject(chart, type, 0),scale = _getAxisObject2.scale,orient = _getAxisObject2.orient,reversed = _getAxisObject2.reversed,
        axisInfo = { scale: scale, baseScale: scroll.brushScale, orient: orient, reversed: reversed },_updateScaleByTransfo2 =
        updateScaleByTransform(axisInfo, chart.axes.rotated ? 'y' : 'x', transform, scrollRange),range = _updateScaleByTransfo2.range,domain = _updateScaleByTransfo2.domain;

      scroll.transform = transform;
      domainInfo.x.range = range;
      domainInfo.x.domain = domain;

      CHART_DOMAIN_HELPERS.FILTER_CHART(domainInfo, chart);
    }

    //$Id$

    var BrushD3$3 = Registry.getComponent('BrushD3'),
      BrushD3Options$1 = Registry.getComponent('BrushD3Options');
    /**
     *
     */var
    ChartBrushScroll = /*#__PURE__*/function () {
      function ChartBrushScroll(chart, type) {_classCallCheck(this, ChartBrushScroll);
        this.chart = chart;
        this.rotated = this.chart.axes.rotated;
        this.settings = chart.systemConf.chart.scroll;
        this.type = type;
      }_createClass(ChartBrushScroll, [{ key: "initialize", value:

        function initialize() {
          var scroll = this,
            chart = scroll.chart,
            scrollSettings = scroll.settings,
            orient = scroll.rotated ? 'left' : 'bottom',
            hasPlotZoom = getPropVal(chart.systemConf, 'chart.zoom.enabled') === true,
            applySmoothEffect = hasPlotZoom || scrollSettings.smooth,
            brushScale = scroll.brushScale = scroll.getScale(chart, chart.plotarea, scroll.type, orient, !applySmoothEffect);
          var selectionArgs = {
            scrollType: this.type,
            scrollScale: brushScale,
            chartObj: chart
          };
          scrollSettings.height = invokeFunction(scrollSettings.height, scrollSettings, chart);
          var userSelection = isArray$1(scrollSettings.selectionRange) ?
            scrollSettings.selectionRange.slice().sort(d3_ascending) :
            invokeFunction(scrollSettings.selectionRange, selectionArgs) || null,
            resizerSettings = scrollSettings.resizer || {},
            sliderSettings = scrollSettings.slider || {},
            resizerEnabled = resizerSettings.enabled === true,
            initialDomain = brushScale.domain();

          if (!resizerEnabled && sliderSettings.enabled) {
            resizerEnabled = true;
            resizerSettings = sliderSettings;
            scroll.behaviour = 'slider';
          }

          scroll.updatePositionScale();

          scroll.minimumVisiblePoints = pick(scrollSettings.minimumVisiblePoints, MINIMUM_VISIBLE_POINTS);
          scroll.resizerSettings = resizerSettings;
          scroll.resizerEnabled = resizerEnabled;
          scroll.overviewEnabled = getPropVal(scrollSettings, 'overview.enabled') === true;
          scroll.isSmooth = applySmoothEffect;

          // since during zoom the padding is already there, no need to update the padding
          // #ZC2304 $minimumVisiblePoints
          if (!hasPlotZoom) {
            scroll.fixScaleOuterPadding();
          }

          var scrollSpace = chart.plotarea[scroll.rotated ? 'height' : 'width'],
            domain = scroll.getInitialDomain(),
            selection = userSelection || scroll.getScrollSelection(domain),
            scrollLength = mathAbs(selection[1] - selection[0]),
            // scroll should be visible if zoom or resize is enabled
            isScrollNeed = scroll.resizerEnabled || hasPlotZoom || scrollSpace - scrollLength >= 1;

          if (scroll.visible = isScrollNeed) {
            scroll.initialSelection = selection;
            scroll.scrollDomain = domain;

            if (!scroll.isSmooth && !scroll.resizerEnabled) {
              scroll.visiblePointCount = domain.length;
            }

            // initial rendering optimization
            if (!scroll.isSmooth) {
              // #ZC2455 Final
              chart.viewPortExtent = resizerEnabled ? initialDomain : domain;
            }

            scroll.updatePlotAreaByScroll();
          }
        } }, { key: "fixScaleOuterPadding", value:

        function fixScaleOuterPadding() {
          var self = this,
            brushScale = self.brushScale;

          if (!brushScale.bandwidth) {
            var domain = firstAndLastItem(self.getInitialDomain()),
              cType = self.chart.chartTypes[0].name,
              outerPadding = self.chart.systemConf.chart.plot.plotoptions[cType].outerPadding || 0.02,
              diff = (domain[1] - domain[0]) * outerPadding,
              currentDomain = self.brushScale.domain();

            currentDomain = applyPadding(currentDomain, null, [diff, diff]);
            brushScale.domain(currentDomain);
            brushScale.originalDomain = currentDomain;
          }
        } }, { key: "updatePositionScale", value:

        function updatePositionScale() {
          var self = this,
            chart = self.chart,
            range,
            _orient = chart.systemConf.chart.scroll.orient;

          if (_orient === 'right' || _orient === 'left') {
            range = [chart.plotarea.height, 0];
          } else {
            range = [0, chart.plotarea.width];
          }
          if (!_orient) {
            if (chart.axes.rotated) {
              range = [chart.plotarea.height, 0];
            } else {
              range = [0, chart.plotarea.width];
            }
          }

          self.scrollPositionScale = d3_scaleLinear().
          range(range).
          domain([0, 100]);
        } }, { key: "update", value:

        function update() {
          if (this.chart.phase === 'redraw') {
            this.settings = this.chart.systemConf.chart.scroll;
            this.rotated = this.chart.axes.rotated;
            return;
          }

          if (this.visible) {
            var scroll = this,
              chart = scroll.chart,
              xScale = chart.axes.x.scale,
              originalDomain = chart.axes.x.baseScale.domain();

            scroll.updatePositionScale();

            chart.cache.scroll.selection = null;

            if (xScale.bandwidth) {
              chart.viewPortExtent = null;
            }
            scroll.scrollDomain = chart.cache.scroll.domain ? chart.cache.scroll.domain : scroll.scrollDomain; // scrollDomain is undefined -when legend filter made in racing chart as chart.cache.scroll.domain is undefined, and error produced on end of brush for undefined scrollDomain,thus set scrollDomain to scrollDomain itself if cache scroll domain is undefined

            // overview chart re-render
            scroll.render();

            // update the domain
            // chart.axes.x.baseScale.range(xScale.range());
            if (!chart.racing) {
              scroll.brushScale.originalDomain = originalDomain;
              xScale.originalDomain = originalDomain;
            }
          }
        } }, { key: "render", value:

        function render() {
          var scroll = this,
            chart = scroll.chart,
            scrollSettings = scroll.settings,
            rotated = scroll.rotated,
            overviewSettings = scrollSettings.overview || {}; //TODO MOve to some other child class

          // #ZC2019
          scroll.parent = createElement('g', '.brush-scroll', scroll.visible ? [1] : [], chart.staticPaneSVG, 'g.legendarea');

          if (scroll.parent.empty()) {
            return;
          }
          var topBotOrient = this.settings.orient === 'bottom' || this.settings.orient === 'top';
          var leftRightOrient = this.settings.orient === 'right' || this.settings.orient === 'left';
          if (!this.settings.orient) {
            scroll.brushType = fixBrushDirection('x', rotated);
          } else {
            scroll.brushType = fixBrushDirection('x', rotated && !topBotOrient || !rotated && leftRightOrient);
          }
          scroll.brushExtent = getBrushExtent(chart, scrollSettings);
          scroll.position = scroll.getPosition();

          var position = scroll.position;
          scroll.dimension = getScrollBoundRect(chart, scroll);
          scroll.parent.attr('transform', "translate(".concat(position.x, ",").concat(position.y, ")"));

          // set it initial phase
          scroll.initialized = false;
          // create the overview
          if (overviewSettings.enabled) {
            renderOverviewContext(chart, scroll.dimension, function (overviewChart) {
              clipOverview.call(scroll, overviewChart);
            });
          } else {
            scroll.addEvent(scroll.brushExtent);
          }
          scroll.isRedraw = true;
        } }, { key: "getScrollSelection", value:

        function getScrollSelection(domain) {
          var scroll = this,
            chart = scroll.chart,
            behaviours = chart.behaviouralEvents && chart.behaviouralEvents.eventManager.behaviours || {},
            transform = scroll.transform || behaviours.PLOT_ZOOM && behaviours.PLOT_ZOOM.instance.getTransform(),
            selectArea;

          if (scroll.lastScroll) {
            selectArea = scroll.lastScroll.map(scroll.scrollPositionScale);
          } else {
            selectArea = _getScrollSelection(chart, domain, transform);
          }
          selectArea.sort(d3_ascending);

          // very first selection for normal scroll
          if (!scroll.isRedraw && !scroll.overviewEnabled && !scroll.resizerEnabled) {
            var reversed = chart.axes.x.reversed,
              _r = scroll.brushScale.bandwidth ? scroll.brushScale.origRange[0] : scroll.brushScale(scroll.brushScale.originalDomain[0]);
            if (scroll.rotated) {
              if (reversed) {
                selectArea[0] = _r;
              } else {
                selectArea[1] = _r;
              }
            } else {
              if (reversed) {
                selectArea[1] = _r;
              } else {
                selectArea[0] = _r;
              }
            }
          }

          return selectArea;
        } }, { key: "addEvent", value:

        function addEvent(extent, domain) {
          var scroll = this,
            chart = scroll.chart,
            scrollSettings = scroll.settings,
            resizerSettings = scroll.resizerSettings,
            resizerEnabled = scroll.resizerEnabled,
            trackerStyles = scrollSettings.tracker,
            thumbStyles = scrollSettings.thumb,
            scrollCache = chart.cache.scroll = chart.cache.scroll || {},
            fixRadius = function fixRadius(obj) {return obj.radius && (obj.rx = obj.ry = obj.radius);},
            overviewOffset = chart.overview && [chart.overview.plotarea.left, chart.overview.plotarea.top],
            selectionArgs = {
              scrollType: this.type,
              scrollScale: scrollSettings.brushScale,
              chartObj: chart
            },
            userSelection = isArray$1(scrollSettings.selectionRange) ?
            scrollSettings.selectionRange.slice().sort(d3_ascending) :
            invokeFunction(scrollSettings.selectionRange, selectionArgs) || null,
            selectArea = userSelection || scroll.getScrollSelection(scrollCache.domain || domain || scroll.scrollDomain);

          // fix radius
          fixRadius(thumbStyles);
          fixRadius(trackerStyles);

          var options = new BrushD3Options$1({
            type: scroll.brushType,
            behaviour: scroll.behaviour || 'scroll',
            extent: extent,
            resizer: resizerEnabled && resizerSettings.type === 'rectangle',
            styles: {
              track: trackerStyles,
              selection: thumbStyles,
              slider: scrollSettings.slider
            },
            brushSelection: scrollSettings.selectionDomain,
            brushScale: scrollSettings.brushScale
          });

          var brush = scroll.brushInstance = new BrushD3$3(options);

          //
          brush.bindTo(scroll.parent); //TODO add this to chartBrush

          // add the listeners after binding the brush
          each(scroll._hooks, function (action, type) {return scroll.brushInstance.addHook(type, action);});

          if (resizerEnabled) {
            var userStyles = resizerSettings[resizerSettings.type] || {};
            fixRadius(userStyles);
            var handles = getBrushHandle(scroll.brushType, resizerSettings.type, extent, null, userStyles, overviewOffset);
            brush.addCustomHandle(handles);
            scroll.enableTooltip(resizerSettings);
          }

          // set it to true
          scroll.initialized = true;

          scroll.constrain(brush);

          // set the initial scroll selection
          brush.setSelection(selectArea);

          return brush;
        } }, { key: "enableTooltip", value:

        function enableTooltip() {
          var self = this,
            resizerSettings = self.settings.resizer,
            tooltipOptions = resizerSettings.tooltip || {};

          if (tooltipOptions.enabled === true) {
            var chart = self.chart,
              columnInfo = chart.dataset.getColumn('x'),
              datatype = columnInfo.datatype,
              formatConf = columnInfo[datatype] || {},
              orient = self.rotated ? 'right' : 'bottom',
              dataFinder = function dataFinder(i) {
                var domain = [chart.viewPortExtent[0], chart.viewPortExtent[chart.viewPortExtent.length - 1]];
                if (columnInfo.datatype === TIME_DATATYPE) {
                  var specifier = getPropVal(formatConf, 'tooltipformat.specifier') || getPropVal(formatConf, 'format.specifier');
                  if (specifier === 'auto') {
                    var subs = getAutoTimeSubFunction(mathAbs(domain[1] - domain[0])),
                      auto = { YEAR: 'DATE', MONTH: 'DATE' };
                    formatConf = {
                      subfunction: auto[subs.subFunction] || 'DATETIME'
                    };
                  }
                }

                if (defined(tooltipOptions.content)) {
                  return invokeFunction(chart, domain[i], columnInfo);
                } else {
                  return getFormattedValue(formatConf, domain[i], datatype, chart, 'tooltip', UNDEFINED, '-');
                }
              };

            self.tooltip = new BrushComponentTooltip(tooltipOptions, self.brushInstance, orient, dataFinder, self.chart);
          }
        } }, { key: "on", value:

        function on(type, action) {
          // TODO remove this and find better approach
          this._hooks = this._hooks || {};
          this._hooks[type] = action;
        } }, { key: "getScale", value:

        function getScale(chartObj, plotarea, type, orient, noOuterPadding) {
          return chartObj.axes.x.scrollScale = scale.getScale(
          chartObj,
          chartObj.dataObject,
          plotarea,
          orient,
          0,
          chartObj.dataset,
          type,
          null,
          noOuterPadding,
          false);

        } }, { key: "constrain", value:

        function constrain(brush) {
          var self = this,
            chart = self.chart,
            minimumScrollSize = getMinimumVisibleArea(chart, 'x', self.minimumVisiblePoints);

          var start;
          brush.addHook('start', function (e) {
            start = e.selection;
            side = lastMin = null;
          });

          brush.addHook('brush', function (e) {
            if ((e.mode === 'resize' || e.mode === 'move') && !self.isSmooth) {
              self.visiblePointCount = null;
            }
          });

          brush.addHook('end', function (e) {
            if ((e.mode === 'resize' || e.mode === 'move') && !self.isSmooth) {
              self.visiblePointCount = self.scrollDomain.length;
            }
          });

          // update the scroll selection
          var lastMin = null,
            side = null;
          brush.snap('brush', function (event) {
            var selection = event.selection;

            if (event.mode === 'move') {
              return selection;
            }

            if (!side) {
              side = +selection[0] !== +start[0] ? 'left' : 'right';
            }

            if (side === 'left') {
              selection[1] = mathMin(start[1], selection[1]);
            } else {
              selection[0] = mathMax(start[0], selection[0]);
            }

            var width = toFixedNumber(mathAbs(selection[1] - selection[0]), 2);

            if (side === 'left' && lastMin) {
              if (selection[0] >= start[1] - minimumScrollSize) {
                return lastMin;
              }
            }

            if (side === 'right' && lastMin) {
              if (selection[1] <= start[0] + minimumScrollSize) {
                return lastMin;
              }
            }

            if (width < minimumScrollSize) {
              if (side === 'right') {
                return lastMin = [selection[0], selection[0] + minimumScrollSize];
              } else {
                return lastMin = [selection[1] - minimumScrollSize, selection[1]];
              }
            }

            return selection;
          });
        } }, { key: "getInitialDomain", value:

        function getInitialDomain() {
          return this.getCategoryPosScreen();
        } }, { key: "getInitialSelection", value:

        function getInitialSelection(domain) {
          var self = this,
            chart = self.chart;
          return domainToActualRange(chart, domain, 0, 'x', false, true, self.brushScale);
        } }, { key: "getCategoryPosScreen", value:

        function getCategoryPosScreen() {
          var self = this,
            chartObj = self.chart,
            scrollData = this.settings,
            plotarea = chartObj.plotarea;
          var defaultItemSize = 15;
          var numVisibleCategories = scrollData.visibleCategories;
          var cType = chartObj.chartTypes[0].name;
          var padding =
          cType == 'gantt' || cType == 'bullet' || cType == 'bar' ?
          chartObj.systemConf.chart.plot.plotoptions[cType].padding || 0.2 :
          0.2;
          var outerPadding = chartObj.systemConf.chart.plot.plotoptions[cType].outerPadding || 0.02;
          var categoryPosValue;

          if (self.resizerEnabled) {
            var xCat = chartObj.dataObject.getCategories('x', 0, false);
            xCat = xCat && xCat.length ? xCat : chartObj.dataObject.findXCategories();

            // single domain
            self.isSingleDomain = xCat.length === 1;

            return self.brushScale.domain();
          } else if (numVisibleCategories) {
            numVisibleCategories = mathMax(self.minimumVisiblePoints, scrollData.visibleCategories);
            categoryPosValue = this.getCategoryPosByCount(plotarea, padding, outerPadding, numVisibleCategories);
          } else {
            categoryPosValue = this.getCategoryPosByThickness(
            plotarea,
            padding,
            outerPadding,
            scrollData.categoryThickness || defaultItemSize);

          }
          return categoryPosValue;
        } }, { key: "getActualScreenValue", value:

        function getActualScreenValue(scrollScale, index, value) {
          if (scrollScale.bandwidth) {
            return scrollScale.ordinalRange[index];
          } else {
            return scrollScale(value);
          }
        } }, { key: "getScrollBarLength", value:

        function getScrollBarLength(scrollScale, categoryPos, userSelection) {
          var axisRotated = this.rotated;
          if (isArray$1(userSelection)) {
            return userSelection[1] - userSelection[0];
          }
          if (scrollScale.bandwidth) {
            if (axisRotated) {
              return scrollScale.range()[0] - categoryPos;
            } else {
              return categoryPos + scrollScale.bandwidth();
            }
          } else {
            if (axisRotated) {
              return scrollScale.range()[0] - categoryPos;
            } else {
              return categoryPos;
            }
          }
        } }, { key: "getCategoryPosByCount", value:

        function getCategoryPosByCount(plotarea, padding, outerPadding, numVisibleCategories) {
          var self = this,
            chart = self.chart,
            scrollScale = self.chart.axes.x.scrollScale,
            xCat = chart.dataObject.getCategories('x', 0, false),
            xCat = xCat && xCat.length ? xCat : chart.dataObject.findXCategories(),
            actNumCategories = xCat.length,
            filterByIndex = chart.dataObject.isWaterfallEnabled,
            visibleCategoriesCount = mathMin(numVisibleCategories, actNumCategories),
            behaviours = chart.behaviouralEvents && chart.behaviouralEvents.eventManager.behaviours,
            brushOptions = chart.systemConf.chart.brush;

          // make a indicator
          self.allCategoriesVisible = visibleCategoriesCount >= actNumCategories;

          // water fall domain
          if (filterByIndex) {
            xCat = scrollScale.domain();
          }

          // when all ticks are visible make return the actual domain
          if (self.allCategoriesVisible) {
            self.lastScroll = null;
            if (chart.cache.scroll) {
              chart.cache.scroll.domain = null;
            }

            if (scrollScale.bandwidth && !self.isSmooth && chart.phase === 'redraw') {
              chart.viewPortExtent = xCat;
            }

            return self.brushScale.domain();
          }

          // redraw same domain maintain
          if (self.chart.cache.scroll && self.chart.cache.scroll.domain) {
            // if the number of $visibleCategories changes maintain that
            var lastDomain = self.chart.cache.scroll.domain;
            if (scrollScale.bandwidth) {
              // #ZC2318 when brush is enabled use the last domain
              if (behaviours.PLOT_BRUSH && isArray$1(brushOptions.x)) {
                return lastDomain;
              }
              if (lastDomain.length !== visibleCategoriesCount) {
                // reset the last scroll and take from new domain
                self.lastScroll = null;
                chart.cache.scroll.domain = null;
                return getItemsFromArrayByCount(xCat, xCat.indexOf(lastDomain[0]), visibleCategoriesCount);
              }
            }
            return self.chart.cache.scroll.domain;
          }

          var visibleCategories = xCat.slice(0, visibleCategoriesCount);

          if (scrollScale.bandwidth) {
            return visibleCategories;
          } else {
            return firstAndLastItem(visibleCategories);
          }
        } }, { key: "getCategoryPosByThickness", value:

        function getCategoryPosByThickness(plotarea, padding, outerPadding, thickness) {
          var scrollScale = this.chart.axes.x.scrollScale,
            baseValue = this.rotated ? plotarea.height : plotarea.width;
          var step = getCategoryStep(thickness, padding);
          var numVisibleCategories = this.getVisibleNumCategories(this.chart, plotarea, outerPadding, step);

          if (scrollScale && scrollScale.bandwidth) {
            outerPadding = getOuterPaddingInPixel(scrollScale.range(), numVisibleCategories, padding, outerPadding, step);
          } else {
            outerPadding = 2 * (step * outerPadding);
          }
          var numVisibleCategories = this.getVisibleNumCategories(this.chart, plotarea, outerPadding, step);

          var categoryPosValue = this.getCategoryPosByCount(plotarea, padding, outerPadding, numVisibleCategories);
          return categoryPosValue;
        } }, { key: "getVisibleNumCategories", value:

        function getVisibleNumCategories(chartObj, plotarea, outerPadding, step) {
          return this.rotated ? mathFloor((plotarea.height - outerPadding) / step) : mathFloor((plotarea.width - outerPadding) / step);
        } }, { key: "updatePlotAreaByScroll", value:

        function updatePlotAreaByScroll() {var plotArea = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.chart.plotarea;
          var chartScroll = this,
            scrollData = chartScroll.settings,
            axisRotated = chartScroll.rotated,
            markerSize = getHandleMarkerSize(chartScroll, getBrushExtent(chartScroll.chart, scrollData)),
            scrollSpan = scrollData.height + markerSize;

          var left = plotArea.left,top = plotArea.top,
            margin = getMargin(scrollData, 0),
            scrollOrient = scrollData.orient;
          if (defined(scrollData.x) && defined(scrollData.y)) {
            left = invokeFunction(scrollData.x, chartScroll, this.chart);
            top = invokeFunction(scrollData.y, chartScroll, this.chart);
          } else if (scrollOrient) {
            if (scrollOrient === 'left') {
              plotArea.width -= scrollSpan + margin.left + margin.right;
              plotArea.left += scrollSpan + margin.left + margin.right;
              left += margin.left;
            } else if (scrollOrient === 'bottom') {
              plotArea.height -= scrollSpan + margin.top + margin.bottom;
              plotArea.bottom += scrollSpan + margin.top + margin.bottom;
              top += plotArea.height;
              top += margin.top;
            } else if (scrollOrient === 'right') {
              plotArea.width -= scrollSpan + margin.left + margin.right;
              left += plotArea.width;
              left += margin.left;
            } else if (scrollOrient === 'top') {
              plotArea.height -= scrollSpan + margin.top + margin.bottom;
              plotArea.bottom += scrollSpan + margin.top + margin.bottom;
              plotArea.top += scrollSpan + margin.top + margin.bottom;
              top += margin.top;
            }
          } else {
            if (axisRotated) {
              plotArea.width -= scrollSpan + margin.left + margin.right;
              left += plotArea.width;
              left += margin.left;
            } else {
              plotArea.height -= scrollSpan + margin.top + margin.bottom;
              plotArea.bottom += scrollSpan + margin.top + margin.bottom;
              top += plotArea.height;
              top += margin.top;
            }
          }
          //when strokeColor is there for thumb if height is 40, thumb's height exceeds 40 and gets cropped at bottom(if border is enabled false and marginbottom is not there)
          //inorder to prevent thumb from getting cropped due to strokeColor - 1px is subtracted from the y position of scroll
          top = scrollData.thumb.strokeColor ? top - 1 : top;
          chartScroll._position = { x: left, y: top };
        } }, { key: "getPosition", value:

        function getPosition() {
          var plotArea = this.chart.plotarea;
          var topBotOrient = this.settings.orient === 'bottom' || this.settings.orient === 'top';
          var leftRightOrient = this.settings.orient === 'right' || this.settings.orient === 'left';

          if (defined(this.settings.x) && defined(this.settings.y)) {
            return {
              x: this._position.x,
              y: this._position.y
            };
          } else if (this.settings.orient) {
            if (this.chart.axes.rotated && !topBotOrient || !this.chart.axes.rotated && leftRightOrient) {
              return {
                x: this._position.x,
                y: plotArea.top
              };
            } else {
              return {
                x: plotArea.left,
                y: this._position.y
              };
            }
          } else {
            if (this.chart.axes.rotated) {
              return {
                x: this._position.x,
                y: plotArea.top
              };
            } else {
              return {
                x: plotArea.left,
                y: this._position.y
              };
            }
          }
        } }, { key: "destroy", value:

        function destroy() {
          this.chart.overview && this.chart.overview.destroy();
          this.brushInstance && this.brushInstance.destroy();
          this.parent.remove();
        } }]);return ChartBrushScroll;}();


    /**
     *
     * @param array
     * @param fromIndex
     * @param itemCount
     * @return {*}
     */
    function getItemsFromArrayByCount(array, fromIndex, itemCount) {
      var rightAvailable = array.length - fromIndex;
      if (itemCount > rightAvailable) {
        var fromLeft = Math.max(fromIndex - (itemCount - rightAvailable), 0);
        return array.slice(fromLeft);
      } else {
        return array.slice(fromIndex, fromIndex + itemCount);
      }
    }

    Registry.setComponent('ChartBrushScroll', ChartBrushScroll);

    defaultTheme.scroll = function () {
      return {
        x: null,
        y: null,
        orient: null,
        enabled: true,
        categoryThickness: null,
        visibleCategories: null,
        height: 10,
        // marginTop: 5,
        // marginBottom: 5,
        // marginLeft: 5,
        // marginRight: 5,
        thumb: {
          fillColor: '#b3b6b7',
          fillOpacity: 0.3,
          strokeColor: 'black',
          strokeOpacity: 0.3,
          cursor: POINTER
        },
        resizer: {
          enabled: false,
          type: 'lever',
          tooltip: {
            backgroundColor: '#b3b6b7',
            borderColor: 'rgb(51, 51, 51)',
            fontSize: 14
          }
        },
        tracker: {
          fillColor: '#ECF0F1',
          cursor: POINTER
        },
        overview: {
          show: true
        }
      };
    };

    /**
     *
     * @param instanceMap
     * @param event
     * @constructor
     */
    function ZCChartScrollListener(instanceMap, event) {
      var eventManager = this,
        selection = event.selection,
        data = eventManager.getData(instanceMap, event.type, selection),
        last = eventManager.chart.cache.scroll.selection;

      // if (last && selection && selection[0] === last[0] && selection[1] === last[1]) {
      //     return;
      // }

      // if data fire
      eventManager.associateBehaviours(instanceMap, event.type, data, event.selection, event);
    }

    /**
     *
     * @param instanceMap
     * @param type
     * @param selection
     * @return {{x: {domain: *[], dataType: *, index: number}}}
     * @constructor
     */
    function BrushScrollDataFinder(instanceMap, type, selection) {
      var eventManager = this,
        scrollInstance = instanceMap.instance,
        chart = eventManager.chart.overview || eventManager.chart,
        dataType = chart.dataset.getDataType('x', 0),
        rotated = chart.axes.rotated,
        reversed = chart.axes.x.reversed,
        range = instanceMap.instance.brushScale.range(),
        s2 = fixOuterPadding(selection, range, rotated, reversed),
        domain = SelectionToDomain(s2, scrollInstance.brushScale, 'x', dataType, rotated, chart.axes.x.reversed);
      scrollInstance.actualScrollSelection = domain.slice(0);
      if (!domain.length) {
        var _d = eventManager.chart.emptySelectionDomain = getEmptyDomain(s2, chart.axes.x.scale, 'x', dataType, rotated, chart.axes.x.reversed, chart);
        eventManager.chart.emptySelectionDomain = _d ? _d : chart.emptySelectionDomain;
      }
      // in caseof more domain

      if (defined(scrollInstance.visiblePointCount) && domain.length > scrollInstance.visiblePointCount) {
        domain.length = scrollInstance.visiblePointCount;
      }

      // fix min and max range
      var _eventManager$chart$s = eventManager.chart.systemConf.chart.axes.xaxis,minRange = _eventManager$chart$s.minRange,maxRange = _eventManager$chart$s.maxRange,
        fixDate = function fixDate(r) {return domain[0] instanceof Date ? new Date(r) : r;};

      if (defined(maxRange) || defined(minRange)) {
        eventManager.chart.scrollView = domain.slice(0);
      }

      var index = domain[1] > domain[0] ? { max: 1, min: 0 } : { max: 0, min: 0 };
      if (defined(maxRange)) {
        domain[index.max] = fixDate(maxRange);
      }
      if (defined(minRange)) {
        domain[index.min] = fixDate(minRange);
      }

      return { x: { domain: domain, index: 0, dataType: dataType } };
    }

    /**
     *
     * @param {[number, number]} range
     * @param {[number, number]} selection
     * @return {*}
     */
    function fixOuterPadding(selection, range, axisrotated, axisreversed) {
      selection = selection.slice(0);

      // axes rotated
      if (range[0] > range[1]) {
        var _range5 = range,_range6 = _slicedToArray(_range5, 2),t0 = _range6[0],t1 = _range6[1];
        range = [t1, t0];
      }
      range = range.slice(0).sort(d3_ascending);
      var adjust1 = mathMin(selection[0] - range[0], 0),
        adjust2 = mathMax(selection[1] - range[1], 0);

      if (axisrotated && !axisreversed || !axisrotated && axisreversed) {
        selection[0] -= adjust1;
        selection[1] += adjust2;
      } else {
        selection[0] += adjust1;
        selection[1] -= adjust2;
      }

      return selection;
    }

    /**
     *
     * @param behaviourEventInstance
     * @param selectionManager
     * @param selection
     * @constructor
     */
    function hideScrollTooltip(behaviourEventInstance, selectionManager, selection, event) {
      var scroll = behaviourEventInstance.instance,
        chart = scroll.chart;
      if (!chart.racing) {
        //this part is avoid for racing
        //since only when filter chart gets called for each brush animation will be fine, when filter chart called only at end animationw as not fine.,
        chart.scrolling = false;
        if (chart.scrolling_) {
          chart.scrolling_ = false;
          chart.scrollEnd = true;
          SCROLL_BRUSH_ACTION.call(this, behaviourEventInstance, selectionManager, selection, event);
        }
      }
      if (behaviourEventInstance.instance.tooltip) {
        behaviourEventInstance.instance.tooltip.hide();
      }
    }

    var _chartScrollHandlers = {
      LISTENER: {
        start: ZCChartScrollListener,
        brush: ZCChartScrollListener,
        end: ZCChartScrollListener
      },
      DATA_FINDER: {
        start: BrushScrollDataFinder,
        brush: BrushScrollDataFinder,
        end: BrushScrollDataFinder
      },
      BEHAVIOUR: {
        // start: SCROLL_BRUSH_ACTION,
        brush: SCROLL_BRUSH_ACTION,
        end: [hideScrollTooltip, ShowBrushResetButton]
      },
      LISTENER_TYPES: d3_set(['start', 'brush', 'end']),
      SUPPORTED: function SUPPORTED(chart) {return chart.isAxisCategory && !chart.isPolarAxisCategory;}
    };

    Registry.setComponent('_chartScrollHandlers', _chartScrollHandlers);

    //$Id$

    axis.threshold = function (chartObj, update) {
      var threshold = {};

      var systemconf = chartObj.systemConf;
      var xaxisdata = systemconf.chart.axes.xaxis;
      var xaxis_userdata = isObjectPropDefined(chartObj.userdata, 'chart.axes.xaxis') ? chartObj.userdata.chart.axes.xaxis : {};
      //X- Threshold Line
      if (xaxis_userdata.threshold != null && xaxis_userdata.threshold.line != null) {
        drawThreshold(chartObj.axes.x, xaxisdata.threshold.line, 0, update, 'x', 'line', xaxis_userdata.threshold.line);
      }

      //X- Threshold range
      if (xaxis_userdata.threshold != null && xaxis_userdata.threshold.range != null) {
        drawThreshold(chartObj.axes.x, xaxisdata.threshold.range, 0, update, 'x', 'range', xaxis_userdata.threshold.range);
      }

      //Y- Threshold line
      var yaxesdata = systemconf.chart.axes.yaxis;
      var yaxes_userdata = isObjectPropDefined(chartObj.userdata, 'chart.axes.yaxis') ? chartObj.userdata.chart.axes.yaxis : {};
      for (var i = 0; i < chartObj.axes.y.count; i++) {
        if (
        yaxes_userdata != null &&
        yaxes_userdata[i] != null &&
        yaxes_userdata[i].threshold != null &&
        yaxes_userdata[i].threshold.line != null)
        {
          drawThreshold(
          getAxisObject(chartObj, 'y', i),
          yaxesdata[i].threshold.line,
          i,
          update,
          'y',
          'line',
          yaxes_userdata[i].threshold.line);

        }
        //Y-Threshold range
        if (
        yaxes_userdata != null &&
        yaxes_userdata[i] != null &&
        yaxes_userdata[i].threshold != null &&
        yaxes_userdata[i].threshold.range != null)
        {
          drawThreshold(
          getAxisObject(chartObj, 'y', i),
          yaxesdata[i].threshold.range,
          i,
          update,
          'y',
          'range',
          yaxes_userdata[i].threshold.range);

        }
      }

      function createthreshold(axisObj, data, index, category) {
        if (axisObj) {
          if (!axisObj.threshold) {
            axisObj.threshold = {};
          }
          axisObj.threshold[category] = data.show ? category == 'line' ? axis.threshold.line() : axis.threshold.range() : null;
          return axisObj.threshold[category];
        }
        return null;
      }

      function setThresholdProp(renderer, axisObj, index, type, category, userdata) {
        var values;
        threshold.axisObj = function (_) {
          if (!arguments.length) {
            return axisObj;
          }
          axisObj = _;
          return threshold;
        };
        threshold.thresholdIndex = function (_) {
          if (!arguments.length) {
            return index;
          }
          index = _;
          return threshold;
        };
        threshold.type = function (_) {
          if (!arguments.length) {
            return type;
          }
          type = _;
          return threshold;
        };
        threshold.values = function (_) {
          if (!arguments.length) {
            return values;
          }
          values = _;
          return threshold;
        };
        threshold.chartObj = function (_) {
          if (!arguments.length) {
            return chartObj;
          }
          chartObj = _;
          return threshold;
        };
        threshold.
        thresholdIndex(index).
        type(type).
        values(userdata.values).
        chartObj(chartObj);
        if (category == 'line') {
          threshold.axisObj(axisObj);
        }
        renderer.parentObj(threshold);
        return renderer;
      }

      function drawThreshold(axisObj, data, index, update, type, category, userdata) {
        var isUnderlayThreshold = userdata && userdata.underlay;
        var thresholdGroup = (isUnderlayThreshold ? chartObj.svg : chartObj.staticPaneSVG).selectAll('g.threshold');

        var axisWrap = chartObj.svg.selectAll("g.".concat(type, "-axis-").concat(index));
        var visibility = axisWrap != null && !axisWrap.empty() && axisWrap.style('display') !== 'none' ? 'visible' : 'hidden';
        var thWrap = appendEle(
        thresholdGroup,
        'g',
        userdata.show && visibility == 'visible' ? [data] : [],
        '.',
        'class', "threshold".concat(
        category, "-").concat(type, "-axis-").concat(index));

        // thWrap.style("visibility",visibility);

        if (axisObj != null && data.show) {
          var renderer =
          update && axisObj.threshold != null && axisObj.threshold[category] != null ?
          axisObj.threshold[category] :
          createthreshold(axisObj, data, index, category);
          renderer = setThresholdProp(renderer, axisObj, index, type, category, userdata);

          thWrap.call(renderer);
        }
      }
    };

    axis.threshold.textAlign = function (hAlign, type, plotarea, axesRotated, padding, orient) {
      var x;
      padding = padding || 0;
      if (hAlign == 'left') {
        if (axesRotated) {
          if (orient == 'left' || orient == 'bottom') {
            x = type == 'x' ? padding : plotarea.height - padding;
          } else {
            x = type == 'x' ? padding : plotarea.height - padding;
          }
        } else {
          if (orient == 'left' || orient == 'bottom') {
            x = type == 'x' ? plotarea.height - padding : padding;
          } else {
            x = type == 'x' ? padding : plotarea.width - padding;
          }
        }
      } else if (hAlign == 'center') {
        if (axesRotated) {
          if (orient === 'left' || orient === 'bottom') {
            x = type == 'x' ? (plotarea.width + padding) / 2 : (plotarea.height - padding) / 2;
          } else {
            x = type == 'x' ? (plotarea.width - padding) / 2 : (plotarea.height + padding) / 2;
          }
        } else {
          if (orient == 'left' || orient == 'bottom') {
            x = type == 'x' ? (plotarea.height - padding) / 2 : (plotarea.width + padding) / 2;
          } else {
            x = type == 'x' ? (plotarea.height + padding) / 2 : (plotarea.width - padding) / 2;
          }
        }
      } else if (hAlign == 'right') {
        if (axesRotated) {
          x = type == 'x' ? plotarea.width : 0;
        } else {
          if (orient == 'left' || orient == 'bottom') {
            x = type == 'x' ? 0 : plotarea.width;
          } else {
            x = type == 'x' ? plotarea.height : 0;
          }
        }
      }
      return x;
    };

    //$Id$

    axis.threshold.overlay = function (chartObj, category, type, overlayData) {
      var axisrotated = chartObj.axes.rotated;
      if (category == 'discrete') {
        var thvalues = overlayData.values.slice(0),
          overlayRange = overlayData.overlayRange || 'below',
          defaultColor = overlayData.defaultColor, //Use seriesColor for 'null' colors,
          axisObj = getAxisObject(chartObj, type, 0),
          scaleObj = axisObj.scale,
          domain = scaleObj.domain(),
          isDiscreteScale = scaleObj.bandwidth;

        // old code
        // var thvalues_sort = thvalues.sort(function(a, b) {
        //     return ((overlayRange == "below") || (overlayRange == "equalandbelow")) ? (a < b ? -1 : a > b ? 1 : 0) : (a > b ? -1 : a < b ? 1 : 0);
        // });
        //For discrete scale type, we need to sort the value by indices, not by string sorting #ZC1380
        if (isDiscreteScale) {
          thvalues = thvalues.map(function (d, i) {
            return domain.indexOf(d);
          });
        }
        var thvalues_unsort = d3_merge([thvalues]); //unsorted values to get the correct color value
        //For equal case, there is no need of sorting
        //For below or equalandbelow, ascending
        //For above or equalandabove, descending
        //testcase bubble7
        if (overlayRange == 'below' || overlayRange == 'equalandbelow') {
          thvalues.sort(d3_ascending);
        } else if (overlayRange !== 'equal') {
          thvalues.sort(d3_descending);
        }

        return function (data, type, yvalue, seriescolor) {
          var thColor = data.color,
            yvalue_index = isDiscreteScale ? domain.indexOf(yvalue) : yvalue;

          if (overlayData.values == null || overlayData.length == 0) {
            return seriescolor;
          }

          for (var i = 0; i < thvalues.length; i++) {
            var compare = thvalues[i];
            /*
             * For bottom oriented axis, if overlay range is below, yvalue should be lesser than thValue to have color overlay
             * For bottom oriented axis, if overlay range is above, yvalue should be greater than thValue to have color overlay
             *
             * For left/right oriented axis, if overlay range is below, yvalue should be greater than thValue to have color overlay
             * For left/right oriented axis, if overlay range is above, yvalue should be lesser than thValue to have color overlay
             */

            var toCompare;
            switch (overlayRange) {
              case 'equal':
                toCompare = yvalue_index === compare;
                break;
              case 'equalandbelow':
                toCompare = yvalue_index <= compare;
                break;
              case 'equalandabove':
                toCompare = yvalue_index >= compare;
                break;
              case 'below':
                toCompare = yvalue_index < compare;
                break;
              default:
                toCompare = yvalue_index > compare;}


            if (toCompare) {
              var index = thvalues_unsort.indexOf(compare);
              return thColor == null || thColor[index] == null ? defaultColor ? seriescolor : 'black' : thColor[index];
            }
          }
          return seriescolor;
        };
      } else if (category == 'continous') {
        return function (seriescolor, data, index, type) {
          /*
           * If type is x use Xaxis scale
           * If type is y use Yaxis scale
           */
          var axisObj = getAxisObject(chartObj, type, 0),
            scaleObj = axisObj.scale,
            temp = index;

          // var th = chartObj.axes.yaxis[0].threshold;
          var origValues = data.values;
          if (origValues == null || origValues.length == 0) {
            return seriescolor;
          }
          var thValues = origValues.slice();
          var negthClr = data.color;
          var overlayRange = data.overlayRange || 'below',
            defaultColor = data.defaultColor; //Use seriesColor for 'null' colors

          if (overlayRange) {
            overlayRange = overlayRange.replace('equaland', ''); //equalandabove = above, equalandbelow = below
          }
          // for time input format values
          var datatype = chartObj.dataset.getDataType(type, index);
          var formatConf;
          if (datatype == 'time') {
            var column = chartObj.dataset.getColumn(type, index);
            formatConf = column.time != null ? column.time : null;
          }
          thValues = thValues.map(function (d, i) {
            return datatype == 'time' ? generateDateVal(d, null, formatConf).getTime() : d;
          });
          /*
           * For bottom oriented axis sort ascending
           * For left/right oriented axis sort descending
           */
          if (type == 'x' && !axisrotated || type == 'y' && axisrotated) {
            thValues.sort(function (a, b) {
              return a < b ? -1 : a > b ? 1 : 0;
            });
          } else {
            thValues.sort(function (a, b) {
              return a > b ? -1 : a < b ? 1 : 0;
            });
          }

          var scaleDomainLength = scaleObj.domain().length;
          var range =
          type == 'x' && !axisrotated || type == 'y' && axisrotated ?
          scaleObj(scaleObj.domain()[scaleDomainLength - 1]) - scaleObj(scaleObj.domain()[0]) :
          scaleObj(scaleObj.domain()[0]) - scaleObj(scaleObj.domain()[scaleDomainLength - 1]);
          var percent = [];
          percent.push(0);
          for (var i = 0; i < thValues.length; i++) {
            var val = scaleObj(thValues[i]) + (scaleObj.bandwidth != null ? scaleObj.bandwidth() / 2 : 0); //Half of the range band is added for the category scale
            var per = val / range * 100;

            if (per < 100) {
              percent.push(per);
              percent.push(per);
            }
          }

          percent.push(100);

          var color = [];
          if (
          type == 'y' && overlayRange == 'below' && !axisrotated ||
          type == 'x' && overlayRange == 'above' && !axisrotated ||
          type == 'y' && overlayRange == 'above' && axisrotated ||
          type == 'x' && overlayRange == 'below' && axisrotated)
          {
            color.push(seriescolor);
          }

          for (var i = 0; i < thValues.length; i++) {
            var idx = origValues.indexOf(thValues[i]);
            color.push(negthClr == null || negthClr[idx] == null ? defaultColor ? seriescolor : 'black' : negthClr[idx]);
          }
          if (
          type == 'y' && overlayRange == 'above' && !axisrotated ||
          type == 'x' && overlayRange == 'below' && !axisrotated ||
          type == 'y' && overlayRange == 'below' && axisrotated ||
          type == 'x' && overlayRange == 'above' && axisrotated)
          {
            color.push(seriescolor);
          }
          var offset = [];

          for (var i = 0; i < percent.length; i++) {
            var obj = {};
            obj.offset = "".concat(percent[i], "%");
            obj.color = i % 2 == 0 ? color[i / 2] : color[(i - 1) / 2];
            offset.push(obj);
          }

          var thresholdProp = {};
          thresholdProp.type = 'thresholdLinear';
          thresholdProp.options = {};
          var options = thresholdProp.options;
          var axisObj_x = getAxisObject(chartObj, 'x', index),
            axisObj_y = getAxisObject(chartObj, 'y', index);
          var scale_x = !axisrotated ? axisObj_x.scale : axisObj_y.scale;
          var scale_y = !axisrotated ? axisObj_y.scale : axisObj_x.scale;
          var isHorizontal = type == 'x' && !axisrotated || type == 'y' && axisrotated;

          options.x1 = isHorizontal ? scale_x(scale_x.domain()[0]) : 0;
          options.x2 = isHorizontal ? scale_x(scale_x.domain()[scaleDomainLength - 1]) : 0;
          options.y1 = isHorizontal ? 0 : scale_y(scale_y.domain()[scaleDomainLength - 1]);
          options.y2 = isHorizontal ? 0 : scale_y(scale_y.domain()[0]);
          options.values = thValues;
          options.color = color;
          options.seriesclr = seriescolor;
          options.overlayRange = overlayRange;

          /*
           * Mandatory - The gradient ID should be changed whenever the scale domain is changing on scroll
           * test case : scroll-03.json
           */
          var domain = (isHorizontal ? scale_x : scale_y).domain();
          options.scale = "".concat(domain[0], "_").concat(domain[1]);

          /**
           * This bellow two lines for passing stroke or fill opacity for area and line chart
           */

          var rendererMode = chartObj.plot.renderer.mode,
            chartName = chartObj.chartTypes[temp].name,
            plotOptions = chartObj.systemConf.chart.plot.plotoptions[chartName],
            opacity = chartName === 'line' ? plotOptions.strokeOpacity : plotOptions.fillOpacity,
            gradientDim = [options.x1, options.x2, options.y1, options.y2],
            prop = getGradientProp(thresholdProp, gradientDim, color, opacity),
            args = { chartObj: chartObj, offset: offset, dimension: gradientDim, color: color };
          var gradientID =
          rendererMode == 'svg' ?
          effects.get(effects.svg_gradients, 'svgGradientFill', prop, args) :
          effects.get(effects.canvas_gradients, 'canvasGradientFill', prop, args);

          return rendererMode == 'svg' ? "url(".concat(chartObj.defsLocation, "#").concat(gradientID, ")") : gradientID;
        };
      }
    };

    var _thresholdOverlay = axis.threshold.overlay;

    //$Id$

    axis.threshold.line = function () {
      var index, plotarea, systemconf, chartObj, axesRotated, type, parentObj, axisObj, values;

      function chart(selection) {
        selection.each(function (data) {
          var container = d3_select(this);
          chart.update = function () {
            container.transition().call(chart);
          };

          chartObj = parentObj.chartObj();
          index = parentObj.thresholdIndex();
          type = parentObj.type();
          axisObj = parentObj.axisObj();
          values = parentObj.values();

          plotarea = chartObj.plotarea;
          var scaleObj = axisObj.scale;
          var range = scaleObj.range();
          range = range.slice(0, range.length);
          range.sort(function (a, b) {
            return a - b;
          });
          var bandwidth = scaleObj.bandwidth != null ? scaleObj.bandwidth() / 2 : 0;
          var label = data.label;
          label = overrideThresholdFonts(
          label,
          isObjectPropDefined(
          chartObj.userdata, "chart.axes.".concat(
          type, "axis").concat(type === 'x' ? '' : ".".concat(index), ".threshold.line.label"),
          true));


          var markerInfo = data.marker || {};
          var markerEnabled = pick(markerInfo.enabled, true);
          axesRotated = chartObj.axes.rotated;
          systemconf = chartObj.systemConf;
          var thval = [],
            thname = [],
            thclr = [];

          // var yAxisColumnOrder = chartObj.systemConf.metadata.axes[type];
          // var colInfo = chartObj.systemConf.metadata.columns[index];

          var labelPadding = {
            x: 2,
            y: 2
          };
          var xAxisLine = systemconf.chart.axes.xaxis.axisline,
            yAxisLine = systemconf.chart.axes.yaxis[index].axisline,
            effect = chartObj.filterEffectsID;

          if (defined(xAxisLine) && xAxisLine.show) {
            labelPadding.x += +xAxisLine.strokeWidth - 1;
          }

          if (defined(yAxisLine) && yAxisLine.show) {
            labelPadding.y += +yAxisLine.strokeWidth - 1;
          }

          var count = 0;

          var hAlign = [],
            strokeDashArray = [],
            strokeWidth = [],
            markerWidth = [],
            markerBBox = [],
            markerSize = [],
            fontSizes = [],
            fontFamilies = [];

          var datatype = chartObj.dataset.getDataType(type, index);
          var formatConf,
            eventDisabled = getPropVal(data.events, 'enabled') !== false;

          var colInfo = chartObj.dataset.getColumn(type, index),
            columnindex = chartObj.dataset.getColumnIdx(type, index);
          if (datatype == TIME_DATATYPE) {
            formatConf = getPropVal(colInfo, TIME_DATATYPE) || null;
          }

          var hierarchical = chartObj.dataObject.hierarchical,
            hasMultiCluster,
            rowCount,
            columnCount,
            grid;
          if (hierarchical) {
            var rowList = hierarchical.pivotLayout.getRootNodeList('row'),
              columnList = hierarchical.pivotLayout.getRootNodeList('column');
            rowCount = rowList.getCount(), columnCount = columnList.getCount(), hasMultiCluster = rowList.hasMultiCluster(), grid;
          }

          if (hasMultiCluster && !rowCount && !columnCount) {
            grid = "".concat(index, "_", 0);
          }

          values.map(function (d, i) {
            var d_scale =
            d != null && d != '' ? datatype == TIME_DATATYPE ? generateDateVal(d, null, formatConf).getTime() : d : null;
            if (
            d != null &&
            d !== '' &&
            scaleObj(d_scale) + bandwidth >= range[0] &&
            scaleObj(d_scale) + bandwidth <= range[range.length - 1])
            {
              thval[count] = d_scale;
              thname[count] = getCustomThresholdText(getPropVal(data, "label.text[".concat(i, "]")) || '', values, colInfo, chartObj);
              thclr[count] = (isArray$1(data.color) ? data.color[i] : data.color) || 'black';
              hAlign[count] = defined(data.label) ?
              (isArray$1(data.label.hAlign) ? data.label.hAlign[i] : data.label.hAlign) || 'center' :
              'center';
              strokeWidth[count] = (isArray$1(data.strokeWidth) ? data.strokeWidth[i] : data.strokeWidth) || 1;
              strokeDashArray[count] = isArray$1(data.dashStyle) ? data.dashStyle[i] : data.dashStyle;
              markerWidth[count] =
              defined(data.marker) && data.marker.enabled ?
              (isArray$1(data.marker.strokeWidth) ? data.marker.strokeWidth[i] : data.marker.strokeWidth) || 2 :
              null;
              markerSize[count] =
              data.marker && data.marker.enabled ?
              (isArray$1(data.marker.size) ? data.marker.size[i] : data.marker.size) || 1 :
              null;
              count++;
            }
          });
          var rect = chartObj.container.node().getBoundingClientRect(),
            bound = {
              left: rect.left + plotarea.left,
              top: rect.top + plotarea.top,
              width: plotarea.width,
              height: plotarea.height,
              right: rect.left + plotarea.left + plotarea.width,
              bottom: rect.top + plotarea.top + plotarea.height
            },
            boundLeft = bound.left,
            boundTop = bound.top,
            orient = axisObj.component.orient(),
            margin = {
              top: 0,
              left: 0,
              right: 0,
              bottom: 0
            },
            overFlow = '..',
            key = "threshold".concat(type).concat(index),
            thresholdPoints = chartObj.cache.thresholdCustomPoints = pick(chartObj.cache.thresholdCustomPoints, {}),
            thresholdEvents = thresholdPoints[key] = pick(thresholdPoints[key], []),
            thresholdTriggerOffset = pick(getThresholdTriggerOffset(data, chartObj), 10);
          thresholdEvents.superKey = 'threshold';
          thresholdEvents.triggerOffset = thresholdTriggerOffset;
          thresholdEvents.grid = grid;
          container.attr('transform', "translate(".concat(plotarea.left, ",").concat(plotarea.top, ")"));
          var wrap = appendEle(container, 'g', [data], '.', 'class', "thresline-".concat(index));
          //plotarea border size to include in markerbox width
          var plotareaBorderEle = chartObj.staticPaneSVG.selectAll('g.plotareaBorder-property').node();
          var plotareaBorder_bkp = plotareaBorderEle.border || plotareaBorderEle["border-".concat(orient)];
          // var plotareaBorder_Oppbkp = (orient == "left") ? (plotareaBorderEle["border"] || plotareaBorderEle["border-right"]) : (orient == "right") ? (plotareaBorderEle["border"] || plotareaBorderEle["border-left"]) : null; //For dual side axes, need to consider border size on both axes
          var plotareaBorder_Oppbkp = plotareaBorderEle.border || plotareaBorderEle["border-".concat(getOppositeOrient(orient))];
          var wid1 = plotareaBorder_bkp && plotareaBorder_bkp.clr !== TRANSPARENT ? plotareaBorder_bkp.size : 0;
          var wid2 = plotareaBorder_Oppbkp && plotareaBorder_Oppbkp.clr !== TRANSPARENT ? plotareaBorder_Oppbkp.size : 0;
          var plotareaBorderWid_bkp = wid1 + wid2;

          var marker = appendEle(wrap, 'path', markerInfo != null && markerEnabled ? thval : [], '.', 'class', 'marker');
          marker.
          attr('d', function (d, i) {
            return getSVGsymbol(isArray$1(markerInfo.symbol) ? markerInfo.symbol[i] : markerInfo.symbol)(markerSize[i] * 10);
          })
          // .attr("transform",function(d,i){return "translate("+((type == "x" && !axesRotated)||(type == "y" && axesRotated)? (scale(d)+bandwidth) : (0+(((markerWidth[i] || 1)*10)/2))) + "," + ((type == "x" && !axesRotated)||(type == "y" && axesRotated)? (plotarea.height-(((markerWidth[i] || 1)*10)/2)) :scale(d)+bandwidth)+")"})
          .style('stroke-width', function (d, i) {
            return markerWidth[i] || 2;
          }).
          style('stroke', function (d, i) {
            return (isArray$1(markerInfo.strokeColor) ? markerInfo.strokeColor[i] : markerInfo.strokeColor) || thclr[i];
          }).
          attr('fill', function (d, i) {
            var fillClr = isArray$1(markerInfo.fillColor) ? markerInfo.fillColor[i] : markerInfo.fillColor;
            return fillClr || (fillClr === null ? thclr[i] : 'white'); //If 'fillColor' is given as null explicitly by the user, use thclr
          });

          marker.attr('transform', function (d, i) {
            var mrkrWidth = markerWidth[i] / 2;
            var bbox_marker = bbox(this);
            markerBBox[i] = bbox_marker.width + wid1;
            var translateX =
              orient == 'bottom' || orient == 'top' ?
              scaleObj(d) + bandwidth :
              orient == 'left' ?
              mrkrWidth + wid1 + bbox_marker.width / 2 :
              plotarea.width - (mrkrWidth + wid1 + bbox_marker.width / 2),
              // translateY = (orient == "bottom") ? (plotarea.height - mrkrWidth - ((plotareaBorderWid_bkp + ((bbox.width) / 2)))) : (orient == "top") ? (mrkrWidth + plotareaBorderWid_bkp + ((bbox.height) / 2)) : (scale(d) + bandwidth);
              translateY =
              orient == 'bottom' ?
              plotarea.height - bbox_marker.width / 2 - wid1 - mrkrWidth :
              orient == 'top' ?
              mrkrWidth + bbox_marker.height / 2 + wid1 :
              scaleObj(d) + bandwidth;

            if (eventDisabled && events.customPoints) {
              var thresholdData = function thresholdData(chartObj, index) {
                return function () {
                  var cache = chartObj.cache.thresholdCustomPoints[key][index];

                  return {
                    _x: cache && cache._x,
                    _y: cache && cache._y,
                    _size: cache && cache._size,
                    _visible: true
                  };
                };
              };
              thresholdEvents.push({
                _data: thresholdData(chartObj, i), //yaxisIndex+itemindex
                _x: translateX,
                _y: translateY,
                _key: "threshold_".concat(chartObj.id, "_").concat(type, "_").concat(index, "_").concat(i),
                width: markerBBox[i],
                height: markerBBox[i],
                color: thclr[i],
                text: thname[i],
                type: 'threshold-marker',
                triggerOffset: thresholdTriggerOffset,
                _size: (markerSize[i] || markerWidth[i]) * 10 + markerWidth[i] / 2,
                _mSize: markerSize[i],
                marker: markerInfo,
                point: values[i],
                formattedValue: getFormattedValue(
                colInfo[colInfo.datatype],
                values[i],
                colInfo.datatype,
                chartObj,
                'threshold',
                false),

                // value : d,
                // columnindex : columnindex,
                thresholdType: type,
                columnIndex: columnindex,
                columnInfo: colInfo,
                yColumnIndex: index,
                itemIndex: i,
                events: data.events || {},
                disabled: function disabled() {
                  return container.__data__ != NULL$1 || !chartObj.cache.thresholdCustomPoints[key];
                },
                _defaultH: function _defaultH() {
                  return [
                  {
                    shape: 'marker',
                    path: function path() {
                      return chartObj.eventHandler.CustomPoints.hoverPoint(this);
                    },
                    context: function context() {
                      return HIGHLIGHT_CONTEXT.get('scatter').call(this, chartObj);
                    }
                  }];

                }
              });
            }
            return "translate(".concat(translateX, ",").concat(translateY, ")");
          });

          var line = appendEle(wrap, 'line', thval);
          line.attr('x1', function (d, i) {
            return orient == 'bottom' || orient == 'top' ?
            scaleObj(d) + bandwidth :
            orient == 'left' ?
            (markerBBox[i] || 0) + markerWidth[i] :
            wid2;
          }).
          attr('y1', function (d, i) {
            return orient == 'bottom' ? wid1 : orient == 'top' ? (markerBBox[i] || 0) + markerWidth[i] : scaleObj(d) + bandwidth;
          }).
          attr('x2', function (d, i) {
            var x2 =
            orient == 'bottom' || orient == 'top' ?
            scaleObj(d) + bandwidth :
            orient == 'left' ?
            plotarea.width - wid2 :
            plotarea.width - markerWidth[i] - (markerBBox[i] || 0);

            return effect ? x2 + 1 : x2;
          }).
          attr('y2', function (d, i) {
            var y2 =
            orient == 'bottom' ?
            plotarea.height - markerWidth[i] - (markerBBox[i] || 0) :
            orient == 'top' ?
            plotarea.height - wid2 :
            scaleObj(d) + bandwidth;
            return effect ? y2 + 1 : y2;
          }).
          attr('stroke', function (d, i) {
            return "    ".concat(thclr[i]);
          }).
          attr('stroke-width', function (d, i) {
            return "".concat(strokeWidth[i], "px");
          }).
          attr('shaperendering', 'crispedges').
          attr('stroke-dasharray', function (d, i) {
            return getDashArray(strokeDashArray[i], strokeWidth[i]);
          });

          var text = appendEle(wrap, 'text', label != null ? thval : []);
          text.text(function (d, i) {
            return decodeHTML(thname[i]);
          }).
          attr('x', function (d, i) {
            var textPadding = markerSize[i] * 10 + labelPadding[type] + (markerWidth[i] || 2);
            var x =
            type == 'x' && !axesRotated || type == 'y' && axesRotated ?
            -axis.threshold.textAlign(hAlign[i] || 'right', type, plotarea, axesRotated, textPadding, orient) :
            axis.threshold.textAlign(hAlign[i] || 'right', type, plotarea, axesRotated, textPadding, orient);
            return x;
          }).
          attr('y', function (d, i) {
            var y =
            type == 'x' && !axesRotated || type == 'y' && axesRotated ? scaleObj(d) + bandwidth : scaleObj(d) + bandwidth;
            return y - 5;
          }).

          attr('transform', type == 'x' && !axesRotated || type == 'y' && axesRotated ? 'rotate(-90)' : 'rotate(0)').
          styles({
            'font-family': function fontFamily(d, i) {
              fontFamilies[i] =
              (isArray$1(label.fontFamily) ? label.fontFamily[i] : label.fontFamily) ||
              systemconf.chart.fontFamily ||
              systemconf.canvas.fontFamily ||
              $ZCG.fontFamily;
              return fontFamilies[i];
            },
            'font-size': function fontSize(d, i) {
              fontSizes[i] = utils.getVal(
              (isFunction(label.fontSize) || isArray$1(label.fontSize) ? label.fontSize[i] : label.fontSize) ||
              systemconf.chart.fontSize ||
              systemconf.canvas.fontSize);

              return "".concat(fontSizes[i], "px");
            },
            fill: function fill(d, i) {
              return (
                (isArray$1(label.fontColor) ? label.fontColor[i] : label.fontColor) ||
                systemconf.chart.fontColor ||
                systemconf.canvas.fontColor ||
                $ZCG.fontColor);

            },
            'font-weight': function fontWeight(d, i) {
              return (
                (isArray$1(label.fontWeight) ? label.fontWeight[i] : label.fontWeight) ||
                systemconf.chart.fontWeight ||
                systemconf.canvas.fontWeight ||
                $ZCG.fontWeight);

            },
            'font-style': function fontStyle(d, i) {
              return (
                (isArray$1(label.fontStyle) ? label.fontStyle[i] : label.fontStyle) ||
                systemconf.chart.fontStyle ||
                systemconf.canvas.fontStyle ||
                $ZCG.fontStyle);

            },
            'text-Anchor': function textAnchor(d, i) {
              if (orient == 'left' || orient == 'bottom') {
                return hAlign[i] == 'center' ? 'middle' : hAlign[i] == 'right' ? 'end' : 'start';
              } else {
                return hAlign[i] == 'center' ? 'middle' : hAlign[i] == 'right' ? 'start' : 'end';
              }
            }
          }).
          each(function (d, i) {
            var text = decodeHTML(thname[i]);
            var actualMarkerSize = markerSize[i] * 10,
              textWidth = utils.fontUtils.getTextWidth(text, fontSizes[i], fontFamilies[i]) + actualMarkerSize,
              size = orient === 'top' || orient === 'bottom' ? plotarea.height : plotarea.width,
              adjustment;

            if (textWidth > size) {
              adjustment = mathMin(textWidth - size, actualMarkerSize) + plotareaBorderWid_bkp;
              bound.left = boundLeft + adjustment;
              bound.top = boundTop + adjustment;
              trimText(
              this,
              this.textContent,
              this.getBoundingClientRect(),
              bound,
              get_threshold_text_orient(orient),
              overFlow,
              margin);

            }
          });
        });
      }

      chart.parentObj = function (_) {
        if (!arguments.length) {
          return parentObj;
        }
        parentObj = _;
        return chart;
      };

      chart.getMetaInfo = function (point) {
        return {
          itemIndex: point.itemIndex,
          point: point.point,
          data: mergeJSON$1(chartObj.systemConf.metadata.columns[point.columnIndex], {
            columnindex: point.columnIndex
          })
        };
      };

      /**
       *
       * @param {Object} markerInfo
       * @param {Chart} chartInstance
       */
      function getThresholdTriggerOffset(markerInfo, chartInstance) {
        return pick(getPropVal(markerInfo, 'events.triggerOffset'), getTriggeringOffset(chartInstance, chartInstance.chartTypes[0].value));
      }

      // function align(hAlign,type,data){
      // 	var x;
      // 	if (hAlign == "left"){
      // 		if(axesRotated){
      // 			x = (type == "x")?0:plotarea.height;
      // 		}else{
      // 			x = (type == "x")?plotarea.height:0;
      // 		}
      // 	}else if(hAlign == "center"){
      // 		if(axesRotated){
      // 			x = (type == "x")?plotarea.width/2:plotarea.height/2;
      // 		}else{
      // 			x = (type == "x")?plotarea.height/2:plotarea.width/2;
      // 		}
      // 	}else if(hAlign == "right"){
      // 		if(axesRotated){
      // 			x= (type == "x")?plotarea.width:0;
      // 		}else{
      // 			x= (type == "x")?0:plotarea.width;
      // 		}
      // 	}
      // 	return x
      // }
      return chart;
    };

    var _thresholdLine = axis.threshold.line;

    //$Id$

    axis.threshold.range = function () {
      var index, chartObj, type, parentObj;

      function chart(selection) {
        selection.each(function (data) {
          var container = d3_select(this);

          chartObj = parentObj.chartObj();
          index = parentObj.thresholdIndex();
          type = parentObj.type();

          var systemconf = chartObj.systemConf;
          var label = data.label;
          label = overrideThresholdFonts(
          label,
          isObjectPropDefined(
          chartObj.userdata, "chart.axes.".concat(
          type, "axis").concat(type === 'x' ? '' : ".".concat(index), ".threshold.range.label"),
          true));


          var fillColor = [],
            _fillOpacity2 = [],
            strokeColor = [],
            strokeDashArray = [],
            lineCap = [],
            hAlign = [],
            thName = [],
            fontColor = [],
            _fontSize2 = [],
            _fontFamily2 = [],
            _fontWeight2 = [],
            _fontStyle2 = [];
          var rect = chartObj.container.node().getBoundingClientRect(),
            plotarea = chartObj.plotarea,
            bound = {
              left: rect.left + plotarea.left,
              top: rect.top + plotarea.top,
              width: plotarea.width,
              height: plotarea.height,
              right: rect.left + plotarea.left + plotarea.width,
              bottom: rect.top + plotarea.top + plotarea.height
            },
            orient = chartObj.axes[type].orient,
            actualOrient = parentObj.axisObj().component.orient(),
            margin = {
              top: 0,
              left: 0,
              right: 0,
              bottom: 0
            },
            overFlow = '..';

          var wrap = appendEle(container, 'g', data.show ? [data] : [], '.', 'class', "thresholdrangegroup-".concat(type));

          var axesRotated = chartObj.axes.rotated;

          if (data.show) {
            var datatype = chartObj.dataset.getDataType(type, index);
            var formatConf;
            var colInfo = chartObj.dataset.getColumn(type, index);
            if (datatype == TIME_DATATYPE) {
              formatConf = colInfo.time != null ? colInfo.time : null;
            }
            var values = [],
              arr = [];

            var labelPadding = {
              x: 2,
              y: 2
            };
            var xAxisLine = systemconf.chart.axes.xaxis.axisline,
              yAxisLine = systemconf.chart.axes.yaxis[index].axisline;

            if (defined(xAxisLine) && xAxisLine.show) {
              labelPadding.x += +xAxisLine.strokeWidth - 1;
            }

            if (defined(yAxisLine) && yAxisLine.show) {
              labelPadding.y += +yAxisLine.strokeWidth - 1;
            }
            var axisObj_x = getAxisObject(chartObj, 'x', index),
              axisObj_y = getAxisObject(chartObj, 'y', index);
            var scale_x = !axesRotated ? axisObj_x.scale : axisObj_y.scale;
            var scale_y = !axesRotated ? axisObj_y.scale : axisObj_x.scale;

            var isBarEnabled = chartObj.dataObject.noofBarEnabledSeries;
            var rangeBand_x = scale_x.bandwidth != null && isBarEnabled ? scale_x.bandwidth() : 0,
              rangeBand_y = scale_y.bandwidth != null && isBarEnabled ? scale_y.bandwidth() : 0,
              strangeBand_x = scale_x.bandwidth != null && !isBarEnabled ? scale_x.bandwidth() / 2 : 0,
              strangeBand_y = scale_y.bandwidth != null && !isBarEnabled ? scale_y.bandwidth() / 2 : 0;

            var count = 0;
            var domain = (type == 'x' && !axesRotated || type == 'y' && axesRotated ? scale_x : scale_y).domain();
            var domainLength = domain.length - 1;

            data.values.map(function (d, i) {
              arr =
              d != null && d != '' ?
              d.map(function (dt) {
                return datatype == TIME_DATATYPE ? generateDateVal(dt, null, formatConf).getTime() : dt;
              }) :
              null;
              var rangeCheck =
              datatype == ORDINAL_DATATYPE ?
              domain.indexOf(arr[0]) !== -1 && domain.indexOf(arr[1]) !== -1 :
              !(arr[0] > domain[domainLength] || arr[1] < domain[0]);
              if (arr && rangeCheck) {
                /*
                 * Range should be within plot domain
                 */
                if (datatype !== ORDINAL_DATATYPE) {
                  arr[0] = mathMax(arr[0], domain[0]);
                  arr[1] = mathMin(arr[1], domain[domainLength]);
                }
                values[count] = arr;

                // rangeBoxRect properties
                fillColor[count] = (isArray$1(data.fillColor) ? data.fillColor[i] : data.fillColor) || 'grey';
                _fillOpacity2[count] = validateNullVal(isArray$1(data.fillOpacity) ? data.fillOpacity[i] : data.fillOpacity, '0.2');

                strokeColor[count] = (isArray$1(data.strokeColor) ? data.strokeColor[i] : data.strokeColor) || 'black';
                strokeDashArray[count] = isArray$1(data.dashStyle) ? data.dashStyle[i] : data.dashStyle;
                lineCap[count] = isArray$1(data.lineCap) ? data.lineCap[i] : data.lineCap;

                // rangeBoxText properties
                hAlign[count] = (isArray$1(data.label.hAlign) ? data.label.hAlign[i] : data.label.hAlign) || 'center';
                thName[count] = getCustomThresholdText(getPropVal(data, "label.text[".concat(i, "]")) || '', data.values, colInfo, chartObj);

                fontColor[count] = isArray$1(label.fontColor) ? label.fontColor[i] : label.fontColor;
                _fontStyle2[count] = isArray$1(label.fontStyle) ? label.fontStyle[i] : label.fontStyle;
                _fontFamily2[count] = isArray$1(label.fontFamily) ? label.fontFamily[i] : label.fontFamily;
                _fontWeight2[count] = isArray$1(label.fontWeight) ? label.fontWeight[i] : label.fontWeight;
                _fontSize2[count] =
                label.fontSize instanceof Function || isArray$1(label.fontSize) ? label.fontSize[i] : label.fontSize;

                count++;
              }
            });

            var rangeBoxgroup = appendEle(wrap, 'g', values, '.', 'class', "rangebox-".concat(index));

            rangeBoxgroup.append('rect');
            rangeBoxgroup.append('text');

            var rangeBoxRect = rangeBoxgroup.select('rect');
            var rangeBoxText = rangeBoxgroup.select('text');

            rangeBoxRect.
            attrs({
              x: function x(d, i) {
                return type == 'x' && !axesRotated || type == 'y' && axesRotated ?
                scale_x(d[0]) + strangeBand_x + chartObj.plotarea.left :
                chartObj.plotarea.left + labelPadding[type];
              },
              y: function y(d, i) {
                return type == 'x' && !axesRotated || type == 'y' && axesRotated ?
                chartObj.plotarea.top :
                scale_y(d[1]) + strangeBand_y + chartObj.plotarea.top;
              },
              width: function width(d, i) {
                return type == 'x' && !axesRotated || type == 'y' && axesRotated ?
                scale_x(d[1]) - scale_x(d[0]) + rangeBand_x :
                chartObj.plotarea.width - labelPadding[type];
              },
              height: function height(d, i) {
                return type == 'x' && !axesRotated || type == 'y' && axesRotated ?
                chartObj.plotarea.height - labelPadding[type] :
                scale_y(d[0]) - scale_y(d[1]) + rangeBand_y;
              }
            }).
            styles({
              fill: function fill(d, i) {
                return fillColor[i];
              },
              'fill-opacity': function fillOpacity(d, i) {
                return _fillOpacity2[i];
              },
              stroke: function stroke(d, i) {
                return strokeColor[i];
              },
              'stroke-dasharray': function strokeDasharray(d, i) {
                return getDashArray(strokeDashArray[i]);
              },
              'stroke-linecap': function strokeLinecap(d, i) {
                return getLineCap(lineCap[i], strokeDashArray[i]);
              }
            });

            rangeBoxText.
            attrs({
              transform: function transform(d, i) {
                var box = bbox(rangeBoxRect.nodes()[i]);
                var transY = axis.threshold.textAlign(
                hAlign[i],
                type,
                chartObj.plotarea,
                axesRotated,
                labelPadding[type],
                orient);

                if (type == 'x' && !axesRotated || type == 'y' && axesRotated) {
                  return "translate(".concat(box.x + box.width / 2, ",").concat(transY + chartObj.plotarea.top, ") rotate(-90)");
                }
                return "translate(".concat(transY + chartObj.plotarea.left, ",").concat(box.y + box.height / 2, ")");
              },
              dy: '0.3em'
            }).
            styles({
              'font-family': function fontFamily(d, i) {
                return _fontFamily2[i] || systemconf.chart.fontFamily || systemconf.canvas.fontFamily || $ZCG.fontFamily;
              },
              'font-size': function fontSize(d, i) {
                return "".concat(utils.getVal(_fontSize2[i] || systemconf.chart.fontSize || systemconf.canvas.fontSize), "px");
              },
              fill: function fill(d, i) {
                return fontColor[i] || systemconf.chart.fontColor || systemconf.canvas.fontColor || $ZCG.fontColor;
              },
              'font-weight': function fontWeight(d, i) {
                return _fontWeight2[i] || systemconf.chart.fontWeight || systemconf.canvas.fontWeight || $ZCG.fontWeight;
              },
              'font-style': function fontStyle(d, i) {
                return _fontStyle2[i] || systemconf.chart.fontStyle || systemconf.canvas.fontStyle || $ZCG.fontStyle;
              },
              'text-Anchor': function textAnchor(d, i) {
                return hAlign[i] == 'center' ? 'middle' : hAlign[i] == 'right' ? 'end' : 'start';
              }
            }).
            text(function (d, i) {
              return decodeHTML(thName[i]);
            }).
            each(function () {
              trimText(
              this,
              this.textContent,
              this.getBoundingClientRect(),
              bound,
              get_threshold_text_orient(actualOrient),
              overFlow,
              margin);

            });
          }
        });
      }

      chart.parentObj = function (_) {
        if (!arguments.length) {
          return parentObj;
        }
        parentObj = _;
        return chart;
      };
      return chart;
    };

    var _thresholdRange = axis.threshold.range;

    //$Id$

    var $ZC_TOOLTIP_POSITION = {};
    $ZC_TOOLTIP_POSITION.relative = function (
    position,
    element,
    chartObj,
    hookHeight,
    dist,
    isWithinChart,
    hookBorderWidth,
    parsedBorderRadius,
    defaultMaxWidth,
    defaultMaxHeight)
    {
      element.selectAll('#tooltipcontent').styles({
        width: null, //"auto",
        height: null,
        'max-width': defaultMaxWidth + PX,
        'max-height': defaultMaxHeight + PX
      });

      var eleNode = element.node(),
        eleWidth = eleNode.offsetWidth,
        eleHeight = eleNode.offsetHeight,
        marginRight = 2,
        canvasarea = chartObj.canvasarea,
        chartarea = chartObj.chartarea,
        distance = dist + hookHeight + (position.distance || 0),
        dTop = position.dTop || 0,
        dLeft = position.dLeft || 0,
        tooltipConfig = chartObj.systemConf.tooltip,
        orient = (tooltipConfig.relative || {}).orient,
        borderTop = tooltipConfig.borderTop || 0,
        availableWidth = chartarea.width - chartarea.left + chartarea.right,
        availableHeight = chartarea.height,
        dim = tooltip_helpers.getSize(
        tooltipConfig,
        [availableWidth, availableHeight],
        [eleWidth, eleHeight],
        [defaultMaxWidth, defaultMaxHeight]),

        width = dim.w,
        height = dim.h,
        hookPosition = {
          left: 50,
          top: 100,
          rotation: 0
        },
        checkBounds = {
          left: mathAbs(mathMin(dLeft, 0)) + (chartObj.scrolledX || 0),
          top: mathAbs(mathMin(dTop, 0)) + (chartObj.scrolledY || 0),
          right: canvasarea.width - marginRight - mathMax(dLeft, 0) + mathAbs(mathMin(dLeft, 0)), // width + left
          bottom: canvasarea.height - mathMax(dTop, 0) + mathAbs(mathMin(dTop, 0)) // height + top
        },
        coordinate = {
          x: position.left - width / 2,
          y: position.top - height - distance,
          // w: width + PX,
          // h: (height - borderTop) + PX,
          maxw: defaultMaxWidth + PX,
          maxh: defaultMaxHeight + PX
        };

      if (!(!isWithinChart || chartObj.scrolledX || chartObj.scrolledY)) {
        var maxTop = position.top - height - distance,
          maxRight = position.left + width + distance,
          maxLeft = position.left - width - distance,
          maxBottom = position.top + height + distance;

        orient =
        orient || (
        maxTop > checkBounds.top ?
        TOP_ALIGN :
        maxRight < checkBounds.right ?
        RIGHT_ALIGN :
        maxLeft > checkBounds.left ?
        LEFT_ALIGN :
        maxBottom < checkBounds.bottom ?
        BOTTOM_ALIGN :
        null);
        if (orient == TOP_ALIGN) {
          // TOP
          positionHook(TOP_ALIGN);
          hookPosition.rotation = 0;
          hookPosition.top = 100;
        } else if (orient == RIGHT_ALIGN) {
          // RIGHT
          coordinate.x = position.left + distance;
          positionHook(RIGHT_ALIGN);
          hookPosition.rotation = 90;
          hookPosition.left = 0;
        } else if (orient == LEFT_ALIGN) {
          // LEFT
          coordinate.x = position.left - distance - width;
          positionHook(LEFT_ALIGN);
          hookPosition.rotation = -90;
          hookPosition.left = 100;
        } else if (orient == BOTTOM_ALIGN) {
          // BOTTOM
          positionHook(BOTTOM_ALIGN);
          coordinate.y = position.top + distance;
          hookPosition.rotation = 180;
          hookPosition.top = 0;
        }
      }
      coordinate.hookPosition = hookPosition;
      return coordinate;

      function positionHook(mode) {
        var rad;
        if (/(top|bottom)/.test(mode)) {
          if (position.left - width / 2 < checkBounds.left) {
            // Is within left?
            rad = getRad(mode == TOP_ALIGN ? 'blx' : 'tlx');
            coordinate.x = checkBounds.left;
            hookPosition.left = mathMax(rad, position.left - checkBounds.left) / width * 100;
          } else if (position.left + width / 2 > checkBounds.right) {
            // Is within right?
            rad = getRad(mode == TOP_ALIGN ? 'brx' : 'trx');
            coordinate.x = checkBounds.right - width;
            hookPosition.left = (1 - mathMax(rad, checkBounds.right - position.left) / width) * 100;
          } else {
            hookPosition.left = 50;
          }
        } else {
          if (position.top - height / 2 < checkBounds.top) {
            // Is within top?
            rad = getRad(mode == LEFT_ALIGN ? 'trY' : 'tly');
            coordinate.y = checkBounds.top;
            hookPosition.top = mathMax(rad, position.top - checkBounds.top) / height * 100;
          } else if (position.top + height / 2 > checkBounds.bottom) {
            // Is within bottom?
            rad = getRad(mode == LEFT_ALIGN ? 'bry' : 'bly');
            coordinate.y = checkBounds.bottom - height;
            hookPosition.top = (1 - mathMax(rad, checkBounds.bottom - position.top) / height) * 100;
          } else {
            coordinate.y = position.top - height / 2;
            hookPosition.top = 50;
          }
        }
      }

      function getRad(attr) {
        return hookHeight + parsedBorderRadius[attr] + mathSQRT(mathPow(hookBorderWidth, 2) + mathPow(hookBorderWidth, 2));
      }
    };

    $ZC_TOOLTIP_POSITION.fixed = function (position, element, chartObj) {
      element.selectAll('#tooltipcontent').styles({
        width: null, //"auto",
        height: null,
        'max-width': null,
        'max-height': null
      });
      element.style('border-width', 0);
      var elementNode = element.node();

      var eleWidth = elementNode.offsetWidth,
        eleHeight = elementNode.offsetHeight,
        canvasarea = chartObj.canvasarea,
        dTop = position.dTop || 0,
        dLeft = position.dLeft || 0,
        tooltipConfig = chartObj.systemConf.tooltip,
        orient = (tooltipConfig.fixed || {}).orient,
        borderTop = tooltipConfig.borderTop || 0,
        borderWidth = pick(tooltipConfig.borderWidth, 1),
        parsedBorderWidth = parseShortHandValue(borderWidth),
        borderWidthTop = parsedBorderWidth.top,
        borderWidthRight = parsedBorderWidth.right,
        borderWidthBottom = parsedBorderWidth.bottom,
        borderWidthLeft = parsedBorderWidth.left,
        availableWidth = canvasarea.width - borderWidthLeft - borderWidthRight,
        availableHeight = canvasarea.height - borderWidthTop - borderWidthBottom,
        dim = tooltip_helpers.getSize(tooltipConfig, [availableWidth, availableHeight], [eleWidth, eleHeight]),
        width = dim.w,
        height = dim.h,
        checkBounds = {
          left: 0,
          top: 0,
          right: window.innerWidth, // width + left
          bottom: window.innerHeight // height + top
        },
        coordinate = {
          x: mathAbs(mathMin(dLeft, 0)),
          y: mathAbs(mathMin(dTop, 0))
        },
        x = mathAbs(mathMin(dLeft, 0)),
        y = mathAbs(mathMin(dTop, 0)),
        w = width,
        h = height,
        maxh,
        maxTop = coordinate.y - height,
        maxRight = coordinate.x + canvasarea.width + width,
        maxLeft = coordinate.x - width,
        maxBottom = coordinate.y + canvasarea.height + height,
        hasEnoughHeightAfterScrollY = dTop <= 0 || dTop > 0 && canvasarea.height - dTop > height;

      if (!orient) {
        if (maxTop > checkBounds.top) {
          orient = TOP_ALIGN;
        } else if (maxRight < checkBounds.right && hasEnoughHeightAfterScrollY) {
          orient = RIGHT_ALIGN;
        } else if (maxLeft > checkBounds.left && hasEnoughHeightAfterScrollY) {
          orient = LEFT_ALIGN;
        } else if (maxBottom < checkBounds.bottom) {
          orient = BOTTOM_ALIGN;
        }
      }

      if (orient === TOP_ALIGN) {
        coordinate.y = y - height - borderWidthTop - borderWidthBottom;
        w = availableWidth - (dLeft > 0 ? dLeft : 0);
        maxh = '40%';
      } else if (orient === RIGHT_ALIGN) {
        coordinate.x = x + canvasarea.width;
        h = availableHeight - (dTop > 0 ? dTop : 0);
      } else if (orient === LEFT_ALIGN) {
        coordinate.x = x - width - borderWidthRight - borderWidthLeft;
        h = availableHeight - (dTop > 0 ? dTop : 0);
      } else if (orient === BOTTOM_ALIGN) {
        coordinate.y = y + canvasarea.height - (dTop > 0 ? dTop : 0);
        w = availableWidth - (dLeft > 0 ? dLeft : 0);
        maxh = '40%';
      } else {
        coordinate.y = y;
        w = availableWidth - (dLeft > 0 ? dLeft : 0);
        maxh = '40%';
      }

      dim = tooltip_helpers.getSize(tooltipConfig, [availableWidth, availableHeight], [w, h]);
      coordinate.w = dim.w + PX;
      coordinate.h = dim.h - borderTop + PX;
      coordinate.maxw = availableWidth - (dLeft > 0 ? dLeft : 0) + PX;
      coordinate.maxh =
      mathMin(
      availableHeight - (dTop > 0 ? dTop : 0),
      isUndefined(tooltipConfig.height) && isUndefined(tooltipConfig.maxHeight) && defined(maxh) ?
      perToPx(maxh, availableHeight) :
      Infinity) +
      PX;

      element.style('border-width', shorthand_px(borderWidth));
      return coordinate;
    };

    $ZC_TOOLTIP_POSITION.block = function (position, element, chartObj) {
      var chartarea = chartObj.chartarea,plotarea = chartObj.plotarea,
        tooltipConfig = chartObj.systemConf.tooltip,
        blockConfig = tooltipConfig.block || {},
        borderTop = tooltipConfig.borderTop || 0,
        borderWidth = pick(tooltipConfig.borderWidth, 1),
        parsedBorderWidth = parseShortHandValue(borderWidth),
        borderWidthTop = parsedBorderWidth.top,
        borderWidthRight = parsedBorderWidth.right,
        borderWidthLeft = parsedBorderWidth.left,
        vAlign = blockConfig.vAlign || TOP_ALIGN,
        hAlign = blockConfig.hAlign,
        dTop = position.dTop || 0,
        dLeft = position.dLeft || 0,
        availableWidth = chartarea.width - borderWidthLeft - borderWidthRight,
        availableHeight = chartarea.height,
        dim = tooltip_helpers.getSize(tooltipConfig, [availableWidth, availableHeight], ['100%', chartObj.tooltip.preCalculatedHeight]),
        w = dim.w,
        h = mathMin(dim.h, perToPx(tooltip_block_helpers.MAXHEIGHT_BLOCK, availableHeight)),
        coordinate = {
          x: mathAbs(mathMin(dLeft, 0)) - mathMax(dLeft, 0) + chartarea.left, //dLeft + chartarea.left
          y: mathAbs(mathMin(dTop, 0)) - mathMax(dTop, 0), //dTop
          w: w + PX,
          h: h - borderTop + PX,
          align: hAlign
        };

      if (hAlign === RIGHT_ALIGN) {
        coordinate.x += availableWidth - w;
      } else if (hAlign === CENTER_ALIGN) {
        coordinate.x += (availableWidth - w) / 2;
      }

      if (vAlign === BOTTOM_ALIGN) {
        coordinate.y +=
        plotarea.top + plotarea.height + (plotarea.bottom - mathMax(chartarea.bottom, 0) - h) - borderWidthTop - borderWidthRight;
      } else {
        coordinate.y += chartarea.top;
      }
      return coordinate;
    };

    //$Id$

    events.tooltip = function (element, data, chartObj) {
      var MAX_WIDTH = '40%',
        MAX_HEIGHT = '100%';

      var tooltip = {
          element: element
        },
        systemConf = chartObj.systemConf,
        dataset = chartObj.dataset,
        dataSplicer = chartObj.dataSplicer,
        metadata_axes = dataSplicer.getEncode(),
        metadata_columns = dataSplicer.getColumns(),
        tooltipIndices = metadata_axes.tooltip || d3_range(metadata_columns.length),
        tooltip_data = systemConf.tooltip,
        themeMaxWidth = null,
        tooltipPosition = tooltip_data.position || 'relative',
        hookEnabled = defined(tooltip_data.hook) ? tooltip_data.hook : tooltipPosition === 'relative',
        hookPosition = {
          left: 50,
          top: 100,
          rotation: 0
        };

      if (tooltip_data.theme && tooltip_data.theme !== '') {
        var theme = isObjectPropDefined(window.$ZC, 'tooltip.getTheme') && $ZC.tooltip.getTheme(tooltip_data.theme, chartObj);
        if (theme !== null) {
          tooltip_data = chartObj.systemConf.tooltip = mergeJSON$1(tooltip_data, theme.borderStyle, true, true);
          chartObj.tooltip.content = [theme.body];
          themeMaxWidth = theme.maxWidth;
        }
      }

      var hookHeight = validateNullVal(tooltip_data.hookHeight, 6),
        dist = validateNullVal(tooltip_data.outerPadding, 20),
        borderWidth = defined(tooltip_data.borderWidth) ? tooltip_data.borderWidth : 1,
        borderRadius = defined(tooltip_data.borderRadius) ? tooltip_data.borderRadius : 5,
        borderStyle = defined(tooltip_data.borderStyle) ? tooltip_data.borderStyle : 'solid',
        padding = defined(tooltip_data.padding) ? "".concat(tooltip_data.padding) : "".concat(5),
        isWithinChart = validateNullVal(tooltip_data.withinChart, true),
        hookBorderWidth = validateNullVal(tooltip_data.hookBorderWidth, / /g.test(borderWidth) ? 1 : +borderWidth),
        parsedBorderRadius = getBorderRadius(borderRadius);

      var maxWidth = perToPx(tooltip_data.maxWidth || themeMaxWidth || MAX_WIDTH, chartObj.chartarea.width),
        maxHeight = perToPx(tooltip_data.maxHeight || MAX_HEIGHT, chartObj.chartarea.height),
        minWidth = mathMax(chartObj.chartarea.width * 0.05, 2 * hookHeight);

      var headerContentFunc = tooltip_data.headerContent,
        footerContentFunc = tooltip_data.footerContent,
        crosshair_data = tooltip_data.crosshair;

      // Tooltip elements
      var arrowbefore, arrowafter, arrowBeforeNAfter, contentBox, backgroundElement, effectOnChild;

      tooltip.initialize = function () {
        var fontSize = getFontSizeByHierarchy(tooltip_data, chartObj),
          defaultLineHeight = +fontSize + +fontSize * 0.35,
          userdataCanvasFontColor = chartObj.userdata.canvas != null ? chartObj.userdata.canvas.fontColor : null,
          borderRadius_px = shorthand_px(borderRadius),
          filterDisabled = tooltip_data.useChartEffect === false, // enabled default
          filterEffect = null;
        effectOnChild = false;

        if (!filterDisabled && chartObj.filterEffectsID) {
          filterEffect = "url(#".concat(chartObj.filterEffectsID, ")");
          effectOnChild = chartObj.systemConf.chart.effects.choice !== 'dropShadow' && !$Browser.PHANTOMJS;
        }

        element.styles({
          width: 'auto',
          opacity: tooltip_data.opacity,
          'z-index': tooltip_data.zindex,
          '-webkit-transform-style': 'preserve-3d',
          '-moz-transform-style': 'preserve-3d',
          '-ms-transform-style': 'preserve-3d',
          '-o-transform-style': 'preserve-3d',
          'transform-style': 'preserve-3d',
          // "-webkit-backface-visibility": "hidden",
          // "-moz-backface-visibility": "hidden",
          // "-ms-backface-visibility": "hidden",
          // "-o-backface-visibility": "hidden",
          // "backface-visibility": "hidden",
          'pointer-events': tooltip_data.pointerEvents
          // "padding": shorthand_px(padding)
        });

        backgroundElement = appendEle(element, 'div', effectOnChild ? [1] : [], '.', 'class', 'zc-tooltip-background');

        if (effectOnChild) {
          element.styles({
            'box-shadow': null,
            background: null,
            border: 'none',
            filter: null
          });
          backgroundElement.
          styles({
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            'border-radius': borderRadius_px,
            'border-width': shorthand_px(borderWidth),
            'border-style': borderStyle,
            'box-shadow': tooltip_data.shadow,
            filter: filterEffect,
            'z-index': -1
          }).
          lower();
          element.selectAll('div#zctooltipbefore,div#zctooltipafter').remove();
        } else {
          element.styles({
            'box-shadow': tooltip_data.shadow,
            'border-radius': borderRadius_px,
            'border-width': shorthand_px(borderWidth),
            'border-style': borderStyle,
            filter: filterEffect
          });
        }

        var borderTopBox = appendEle(element, 'div', tooltip_data.borderTop ? [tooltip_data.borderTop] : [], '.', 'class', 'borderTop');
        borderTopBox.styles({
          height: "".concat(tooltip_data.borderTop, "px"),
          'border-radius': borderRadius_px,
          'border-bottom-left-radius': '1px',
          'border-bottom-right-radius': '1px'
        });

        contentBox = appendEle(element, 'div', [1], '#', 'id', 'tooltipcontent');
        contentBox.styles({
          'box-sizing': tooltipPosition === 'relative' ? null : 'border-box',
          'max-width': tooltipPosition === 'relative' ? "".concat(maxWidth, "px") : null,
          'min-width': tooltipPosition === 'relative' ? "".concat(minWidth, "px") : null,
          // "max-height" : maxHeight + "px", // Is it necessary?
          'line-height': "".concat(tooltip_data.lineHeight || defaultLineHeight, "px"),
          'word-wrap': 'break-word',
          'white-space': 'normal',
          'overflow-y': 'auto',
          padding: shorthand_px(padding)
          //		"border-top":"1px solid red"
        });
        applyFont(
        contentBox,
        [
        {
          fontColor:
          tooltip_data.fontColor == null && userdataCanvasFontColor == null ?
          'white' :
          tooltip_data.fontColor || userdataCanvasFontColor
        },
        tooltip_data,
        chartObj.systemConf.canvas,
        $ZCG],

        true);


        // arrow before
        arrowbefore = appendEle(effectOnChild ? backgroundElement : element, 'div', hookEnabled ? [1] : [], '#', 'id', 'zctooltipbefore');
        arrowbefore.styles({
          'margin-left': "".concat(-(hookHeight + 2 * hookBorderWidth), "px"),
          border: "".concat(hookHeight + 2 * hookBorderWidth, "px solid transparent"),
          filter: effectOnChild ? filterEffect : null
        });

        // arrow after
        arrowafter = appendEle(effectOnChild ? backgroundElement : element, 'div', hookEnabled ? [1] : [], '#', 'id', 'zctooltipafter');
        arrowafter.styles({
          'margin-left': "".concat(-hookHeight, "px"),
          border: "".concat(hookHeight, "px solid transparent"),
          filter: effectOnChild ? filterEffect : null
        });

        // Properties for arrow before and after
        arrowBeforeNAfter = element.selectAll('div#zctooltipbefore,div#zctooltipafter');
        arrowBeforeNAfter.styles({
          'border-color': TRANSPARENT,
          'border-top-color': 'white',
          position: 'absolute',
          top: '100%',
          left: '50%',
          width: 0,
          height: 0,
          content: ' '
        });
      };

      tooltip.show = function (chartObj, position, content, useDefault, defaultArgs) {
        element = chartObj.tooltip.element;
        arrowBeforeNAfter = element.selectAll('div#zctooltipbefore,div#zctooltipafter');
        if (!defined(defaultArgs)) {
          defaultArgs = {};
        }

        var color = defaultArgs.color,
          svgFillFunc = defaultArgs.svgFillFunc,
          seriesindex = defaultArgs.seriesindex,
          subseriespos = defaultArgs.subseriespos,
          subseriesLength = defaultArgs.subseriesLength,
          itempos = defaultArgs.itempos,
          paneid = defaultArgs.paneid,
          backgroundColor = defaultArgs.backgroundColor || tooltip_data.backgroundColor,
          borderColor = defaultArgs.borderColor || tooltip_data.borderColor,
          tooltipSharedInfo = defaultArgs.tooltipSharedInfo,
          tooltipShared = defaultArgs.tooltipShared,
          cType =
          seriesindex != null && getChartTypeByIndex(chartObj, paneid, seriesindex).name ||
          defaultArgs.chartType && defaultArgs.chartType.name,
          hasMultiColoring,
          renderTo = defaultArgs.renderTo || 'plot', //Bydefault renderTo is 'plot', for legend selectAllbox it is 'legendTitle'
          hideHook;
        useDefault = content == null && useDefault === true;

        // getting color
        if (useDefault || defaultArgs.inheritColors) {
          hasMultiColoring = isMultiColorChart(cType, chartObj);
        }
        var clr = color;
        // var legendOrder = chartObj.dataObject.pivot && paneid ? chartObj.dataObject.hierarchical.gridOptions[paneid].legendOrder || 0 : null;
        if (useDefault || defaultArgs.inheritColors) {
          var idx = hasMultiColoring ? itempos : seriesindex;
          var dataPoint = dataset.getDataPoint(chartObj, null, seriesindex, subseriespos, itempos, defaultArgs.d);
          clr = getRawColor(chartObj, idx, dataPoint, seriesindex, paneid, dataPoint && dataPoint.rendererIndex);
        } else if (isArray$1(clr)) {
          clr = clr[seriesindex % clr.length];
        }

        if (tooltipShared) {
          if (backgroundColor == 'inherit') {
            backgroundColor = defaultArgs.nearest ? clr : 'black';
          }
          if (borderColor == 'inherit') {
            borderColor = defaultArgs.nearest ? clr : 'black';
          }
          clr = 'black';
        } else {
          if (backgroundColor == 'inherit') {
            backgroundColor = clr;
          }
          if (borderColor == 'inherit') {
            borderColor = clr;
          }
        }
        borderColor = borderColor != null ? borderColor : clr;
        backgroundColor = backgroundColor != null ? backgroundColor : clr;

        element.style('visibility', 'visible');
        (effectOnChild ? backgroundElement : element).styles({
          'background-color': backgroundColor,
          'border-color': borderColor
        });
        var selectionManager = chartObj.eventHandler.eventManager.selectionManager,
          nearest = selectionManager.nearest;
        //For analytics renrendering image case
        //For boxplot custom tooltip indices case
        if (!nearest || nearest && nearest.selected != SELECTED_MERGED || typeof tooltipIndices == 'function' || typeof tooltipIndices == 'string') {
          //***** TOOLTIP INNERHTML
          var tooltipcontent = '',
            toUserInfo,
            headerContent = '',
            footerContent = '',
            temp,
            contentBoxNode = contentBox.node();

          //custom header content
          if (useDefault && headerContentFunc != null) {
            headerContent = invokeFunction(headerContentFunc, d3_event(), toUserInfo = getInfoToUser(), chartObj);
          }

          //content
          if (useDefault) {
            if (tooltip_data.content) {
              tooltipcontent += invokeFunction(
              tooltip_data.content,
              d3_event(),
              toUserInfo = toUserInfo || getInfoToUser(),
              chartObj);

            } else if (tooltipShared) {
              tooltipcontent += getTooltipSharedContent(
              seriesindex,
              subseriespos,
              itempos,
              defaultArgs.d,
              tooltipSharedInfo,
              color,
              hasMultiColoring,
              subseriesLength);

            } else {
              tooltipcontent += getDefaultContent(seriesindex, subseriespos, itempos, clr, defaultArgs.d);
            }
          } else {
            tooltipcontent += content;
          }

          //custom footer content
          if (useDefault && footerContentFunc != null) {
            footerContent = invokeFunction(footerContentFunc, d3_event(), toUserInfo = toUserInfo || getInfoToUser(), chartObj);
          }

          // add html first
          contentBox.html(tooltipcontent);

          if (!isHTMLElement(headerContent)) {
            temp = document.createElement('div');
            temp.innerHTML = headerContent;
            headerContent = temp;
          }

          // add add header first
          if (!isHTMLElement(footerContent)) {
            temp = document.createElement('div');
            temp.innerHTML = footerContent;
            footerContent = temp;
          }

          // add add header to the top
          contentBoxNode.insertBefore(headerContent, contentBoxNode.firstChild);
          contentBoxNode.appendChild(footerContent);

          // TOOLTIP INNERHTML *****
        }
        var elementNode = element.node(),
          eleWidth = elementNode.offsetWidth,
          eleHeight = elementNode.offsetHeight;

        if (renderTo == 'plot' && crosshair_data.type != NONE && chartObj.isAxisCategory) {
          showCrossshair(chartObj, position.actLeft || position.left, position.actTop || position.top, crosshair_data);
        }

        if (renderTo == 'plot' && position.helpers && !position.helpers.isWithinPlot) {
          hideHook = true;
        }

        element.interrupt().transition();

        element.transition().delay(0);

        var coordinate;
        if (tooltipPosition === 'relative') {
          var curx = parseFloat(elementNode.style.left),
            cury = parseFloat(elementNode.style.top);
          coordinate = $ZC_TOOLTIP_POSITION.relative(
          position,
          element,
          chartObj,
          hookHeight,
          mathAbs(dist),
          isWithinChart,
          hookBorderWidth,
          parsedBorderRadius,
          maxWidth,
          maxHeight);

          hookPosition = coordinate.hookPosition;

          if (!curx || isNaN(curx) || !cury || isNaN(cury)) {
            // Transition will start after ~4ms only. If the tooltip is called at the first time no transition
            element.styles({
              left: "".concat(coordinate.x, "px"),
              top: "".concat(coordinate.y, "px")
            });
          }

          curx = !curx || isNaN(curx) ? coordinate.x : (2 * curx + coordinate.x) / 3;
          cury = !cury || isNaN(cury) ? coordinate.y : (cury + coordinate.y) / 2;

          element.
          transition().
          duration(100).
          ease(d3_ease_linear).
          styleTween('left', positionTween(curx, coordinate.x)) //To avoid sub pixel rendering issue, d3.interpolateRound has been used
          .styleTween('top', positionTween(cury, coordinate.y));
        } else if (tooltipPosition === 'fixed') {
          coordinate = $ZC_TOOLTIP_POSITION.fixed(position, element, chartObj);
          element.styles({
            left: "".concat(coordinate.x, "px"),
            top: "".concat(coordinate.y, "px")
          });
        } else {
          coordinate = $ZC_TOOLTIP_POSITION.block(position, element, chartObj);
          element.
          styles({
            left: "".concat(coordinate.x, "px"),
            top: "".concat(coordinate.y, "px")
          }).
          attr('align', coordinate.align); // test in all browsers
        }

        contentBox.styles({
          width: coordinate.w,
          height: coordinate.h,
          'max-width': coordinate.maxw,
          'max-height': coordinate.maxh
        });

        //borderTop
        if (tooltip_data.borderTop) {
          var svgFillEle = svgFillFunc ?
          svgFillFunc(
          hasMultiColoring ? itempos : seriesindex,
          null,
          null,
          clr,
          null,
          null,
          { width: mathMin(+coordinate.w, +coordinate.maxw) },
          true) :

          borderColor;
          var svgFillUrl = _typeof(svgFillEle) === 'object' ? "url(".concat(getSVGImage(svgFillEle, true).url, ")") : svgFillEle;
          var borderTop = element.selectAll('div.borderTop');
          borderTop.styles({
            background: svgFillUrl
          });
        }

        // Tooltip arrow
        if (tooltipShared || hideHook) {
          arrowBeforeNAfter.style('display', NONE);
        } else {
          var arrowTransform = "rotate(".concat(hookPosition.rotation, "deg)"),
            arrowTransformOrigin = '50% 0%';

          arrowBeforeNAfter.styles({
            display: '',
            left: "".concat(hookPosition.left, "%"),
            top: "".concat(hookPosition.top, "%"),
            transform: arrowTransform,
            '-webkit-transform': arrowTransform,
            '-ms-transform': arrowTransform,
            'transform-origin': arrowTransformOrigin,
            '-webkit-transform-origin': arrowTransformOrigin,
            '-ms-transform-origin': arrowTransformOrigin
          });

          arrowbefore.style('border-top-color', borderColor);

          arrowafter.styles({
            'border-top-color': backgroundColor,
            opacity: 1
          });
        }

        function getInfoToUser() {
          if (tooltipShared) {
            return tooltipSharedInfo.keys().map(function (d) {
              var curSerpos = pInt(d),
                curItempos = pInt(tooltipSharedInfo.get(d)),
                clridx = dataset.getColumnIdx('clr');
              var yaxiscolumnorder = chartObj.seriesdata[curSerpos].yaxiscolumnorder || [0, 0];
              var validx = chartObj.ismultiy || clridx == null ? dataset.getColumnIdx('y', yaxiscolumnorder) : clridx;
              var dp = dataset.getDataPoint(chartObj, validx, curSerpos, subseriespos, curItempos);
              var metaInfoObj = dataset.getMetaInfoObj(chartObj, dp, curSerpos);
              return {
                actData: dp,
                metaInfo: metaInfoObj
              };
            });
          }
          var dp = dataset.getDataPoint(chartObj, null, seriesindex, subseriespos, itempos, defaultArgs.d); // why we are sending null column index
          var metaInfoObj = chartObj.dataset.getMetaInfoObj(chartObj, dp, seriesindex);
          return {
            actData: dp,
            metaInfo: metaInfoObj,
            seriesIndex: seriesindex,
            subseriesIndex: subseriespos,
            itemIndex: itempos
          };
        }
      };

      tooltip.hide = function (tooltipele) {
        tooltipele = tooltipele == null ? this.element : tooltipele;
        tooltipele.style('visibility', 'hidden');
        if (chartObj.systemConf.tooltip.crosshair.type != NONE) {
          chartObj.staticPaneSVG.selectAll('g.crosshair').style('visibility', 'hidden');
        }
      };

      tooltip.destroy = function () {
        this.element.remove();
      };

      tooltip.getTooltipContent = function () {
        /* arguments
         * 0 - seriesIndex
         * 1 - subseriesIndex
         * 2 - itemIndex
         */

        return getDefaultContent.apply(null, arguments);
      };

      function showCrossshair(chartObj, x, y, data) {
        chartObj.staticPaneSVG.selectAll('g.crosshair').style('visibility', 'visible');

        var type = data.type;
        if (type == 'x' || type == 'xy') {
          drawCrosshairLine(chartObj, x, y, data, 'x');
        }
        if (type == 'y' || type == 'xy') {
          drawCrosshairLine(chartObj, x, y, data, 'y');
        }
      }

      function drawCrosshairLine(chartObj, x, y, data, type) {
        var ele = chartObj.staticPaneSVG.selectAll("line.".concat(type, "-crosshair"));
        var isVerticalLine = type == 'x' && !chartObj.axes.rotated || type == 'y' && chartObj.axes.rotated;
        ele.attrs({
          x1: isVerticalLine ? x : chartObj.plotarea.left,
          y1: isVerticalLine ? chartObj.plotarea.top : y,
          x2: isVerticalLine ? x : chartObj.plotarea.left + chartObj.plotarea.width,
          y2: isVerticalLine ? chartObj.plotarea.height + chartObj.plotarea.top : y
        }).styles({
          'shape-rendering': 'crispEdges',
          stroke: data.color,
          'stroke-width': data.strokeWidth,
          'stroke-dasharray': getDashArray(data.dashStyle, data.strokeWidth),
          'pointer-events': NONE
        });
      }

      function getDefaultContent(seriesindex, subseriespos, itempos, color, d, customTooltipIndices) {
        if (isObjectPropDefined(window.$ZC, 'tooltip.getTheme') && defined(systemConf.tooltip.theme) && systemConf.tooltip.theme !== '') {
          if (defined(chartObj.tooltip.content)) {
            return dataset.getCustomizedVal(
            chartObj,
            chartObj.tooltip.content,
            seriesindex,
            subseriespos,
            itempos,
            d,
            'tooltip',
            color);

          }
        }

        var chartName = getChartTypeByIndex(chartObj, d && d.paneid, seriesindex).name,
          hasMultiColoring = isMultiColorChart(chartName, chartObj),
          dataPoint = dataset.getDataPoint(chartObj, null, seriesindex, subseriespos, itempos, d),
          clr = getRawColor(chartObj, hasMultiColoring ? itempos : seriesindex, dataPoint, seriesindex),
          indices_ = invokeFunction(customTooltipIndices || tooltipIndices, null, dataPoint, chartObj),
          indices = indices_.filter(function (idx) {
            return !(metadata_columns[idx] && isUndefined(dataset.getDataPoint(chartObj, idx, seriesindex, subseriespos, itempos, d))); // dataPoint is null for the current idx
          }),
          isSankeyNode = chartName === SANKEY_CHARTNAME && d._type === 'node',
          template;

        // if((chartName == BAR_CHARTNAME || chartName == BARRANGE_CHARTNAME) && chartObj.dataObject.hasWhiskers){
        //
        // }

        if (isSankeyNode) {
          var xIndex = chartObj.dataset.getColumnIdx('x'),
            zIndex = chartObj.dataset.getColumnIdx('z');
          template = "{{col(".concat(xIndex, ")}} : {{val(").concat(xIndex, ")}}<br>{{col(").concat(zIndex, ")}} : {{val(").concat(zIndex, ")}}");
        } else {
          template = tooltip_content.getContentTemplate(chartObj, NULL$1, indices);
        }

        return dataset.getCustomizedVal(chartObj, template, seriesindex, subseriespos, itempos, d, 'tooltip', clr);
      }

      function getTooltipSharedContent(seriesindex, subseriespos, itempos, d, tooltipSharedInfo, color, hasMultiColoring, subseriesLength) {
        var clridx = dataset.getColumnIdx('clr'),
          yaxiscolumnorder_series = chartObj.seriesdata[seriesindex].yaxiscolumnorder || [0, 0], //yaxiscolumnorder is not mandatory
          repeatIndex =
          chartObj.dataObject.pieWithAxis && !chartObj.dataObject.isCombinationalChart ?
          tooltip_helpers.getPieColumnIndex(chartObj) :
          dataset.getColumnIdx('y', yaxiscolumnorder_series),
          sharedKeys = tooltipSharedInfo.keys(),
          y_pattern = tooltipSharedInfo.y_val_pattern,
          indices_ = invokeFunction(tooltipIndices || tooltipIndices, null, d),
          meta_tooltip = tooltip_content.getRawSharedContent(chartObj, tooltipSharedInfo, indices_),
          i = 0,
          updatePattern = function updatePattern(pattern, curSerpos, subseriespos, curItempos, clr, copy_y_pattern) {
            if (chartObj.ismultiy || clridx == null) {
              var seriesName = encodeHTML(chartObj.seriesdata[curSerpos].seriesname) || copy_y_pattern.replace(/val/gi, 'col');
              pattern = pattern.replace('{{val(null)}}', seriesName);
            }
            return dataset.getCustomizedVal(
            chartObj,
            pattern,
            curSerpos,
            subseriespos,
            curItempos,
            NULL$1, //Doubt for unsorted seriesdataafterupdate
            'tooltip',
            clr,
            NULL$1,
            subseriesLength && subseriesLength > 1 ? subseriesLength : NULL$1);

          },
          removeIndices = [];

        meta_tooltip.forEach(function (pattern, patternIndex) {
          var hasRepeatPattern = (isArray$1(pattern) ? pattern : [pattern]).some(function (cur) {
            return (
              typeof cur === 'string' && (
              cur.indexOf("{{val(".concat(repeatIndex, ")}}")) != -1 || cur.indexOf("{{per(".concat(repeatIndex, ")}}")) != -1));

          });

          if (isArray$1(pattern) || hasRepeatPattern) {
            i = i % chartObj.seriesdata.length; //#ZC1248
            var curKey = sharedKeys[i];

            if (hasRepeatPattern) {
              i++;
            }

            //y-values
            if (isUndefined(curKey)) {
              // If datapoint is not available
              removeIndices.push(patternIndex);
              return;
            }
            var curSerpos = pInt(curKey),
              curItempos = pInt(tooltipSharedInfo.get(curKey)),
              copy_y_pattern = y_pattern,
              clr = color;

            if (isArray$1(clr)) {
              var dataPoint = dataset.getDataPoint(chartObj, null, curSerpos, subseriespos, curItempos, d);
              clr = getRawColor(chartObj, hasMultiColoring ? curItempos : curSerpos, dataPoint, curSerpos);
            }

            if (isArray$1(pattern)) {
              pattern.forEach(function (cur, j) {
                pattern[j] = updatePattern(pattern[j], curSerpos, subseriespos, curItempos, clr, copy_y_pattern);
              });
            } else {
              meta_tooltip[patternIndex] = updatePattern(
              meta_tooltip[patternIndex],
              curSerpos,
              subseriespos,
              curItempos,
              clr,
              copy_y_pattern);

            }
          } else {
            //Custom text with non y-values
            var curKey = sharedKeys[0],
              curSerpos,
              curItempos;

            if (defined(curKey)) {
              curSerpos = pInt(curKey);
              curItempos = pInt(tooltipSharedInfo.get(curKey));
            } else {
              curSerpos = seriesindex;
              curItempos = itempos;
            }
            meta_tooltip[patternIndex] = dataset.getCustomizedVal(
            chartObj,
            pattern,
            curSerpos,
            subseriespos,
            curItempos,
            d,
            'tooltip',
            color,
            NULL$1);

          }
        });

        // If datapoint is not available
        meta_tooltip = meta_tooltip.filter(function (d, i) {
          return removeIndices.indexOf(i) == -1;
        });

        return tooltip_content.getContentTemplate(chartObj, meta_tooltip);
      }

      function positionTween(start, end) {
        return function (d, i) {
          var interpolate = d3_interpolateRound(parseInt(start), parseInt(end));
          return function (t) {
            return "".concat(interpolate(t), "px");
          };
        };
      }

      return tooltip;
    };

    var _chartTooltip = events.tooltip;
    Registry.setComponent('tooltip', _chartTooltip);

    /**
     *
     * @param instanceMap
     * @param type
     */
    function ChartZoomDataFinder(instanceMap, type) {
      var eventManager = this,
        chart = eventManager.chart,
        plotZoom = instanceMap.instance,
        transform = plotZoom.getTransform(),
        zoomType = chart.systemConf.chart.zoom.type,
        zoomTypes = instanceMap.types = instanceMap.types || { x: stringIncludes(zoomType, 'x'), y: stringIncludes(zoomType, 'y') };

      return getDomainInfoFromZoomTransform(transform, zoomTypes, chart);
    }

    /**
     *
     * @param transform
     * @param types
     * @param chart
     * @return {{}}
     */
    function getDomainInfoFromZoomTransform(transform, types, chart) {
      var domainInfo = {},
        axisLength = { x: 1, y: chart.axes.y.groups.length };

      each(types, function (enabled, type) {
        if (enabled === true) {
          for (var i = 0; i < axisLength[type]; i++) {
            var axisInfo = getAxisObject(chart, type, i);
            if (!axisInfo.disabled) {
              var _updateScaleByTransfo4 = updateScaleByTransform(axisInfo, fixBrushDirection(type, chart.axes.rotated), transform),domain = _updateScaleByTransfo4.domain,range = _updateScaleByTransfo4.range;

              var store = domainInfo[type] = domainInfo[type] || [];
              store.push({ domain: domain, range: range, index: axisInfo.index });

              axisInfo.domain = domain;
              axisInfo.range = range;
            }
          }
        }
      });
      return domainInfo;
    }

    /**
     *
     * @param instanceMap
     * @param selectionManager
     */
    function filterChart_C(instanceMap, selectionManager) {
      var eventManager = this,
        chart = eventManager.chart;

      chart.zooming = true;

      var domainInfo = selectionManager.point;

      chart.disableAnimation = true;

      if (domainInfo.x && domainInfo.x[0].domain) {
        chart.viewPortExtent = domainInfo.x && domainInfo.x[0].domain;
      }

      CHART_DOMAIN_HELPERS.FILTER_CHART(domainInfo, chart);
    }

    /**
     *
     * @param instanceMap
     * @param event
     * @constructor
     */
    function ChartZoomListener(instanceMap, event) {
      var eventManager = this;
      var data = eventManager.getData(instanceMap, event.type, event.transform);

      // if data fire
      eventManager.associateBehaviours(instanceMap, event.type, data, event.transform, event);
    }

    /**
     * #ZC2260
     * @param behaviour
     */
    function updateChartZoomTransform(behaviour) {
      var eventManager = this,
        chart = eventManager.chart,
        existingScale = behaviour.instance.getTransform(),
        types = behaviour.types || {};

      var x, y;
      if (types.x) {
        x = chart.axes.x;
      }
      if (types.y) {
        y = chart.axes.y.groups[0];
      }

      if (chart.axes.rotated) {var _ref20 =
        [y, x];x = _ref20[0];y = _ref20[1];
      }

      var transform = getZoomTransformFromAxis(existingScale.k, x, y, chart);

      // just update the zoom transform in the context
      behaviour.instance.zoomToIdentity(transform, 0, false);
    }

    var zoom_start_listeners = [];
    if (!$Browser.isTouchDevice) {
      zoom_start_listeners = [ClearOldInfo_C];
    }

    var _chartZoomHandlers = {
      LISTENER: {
        start: ChartZoomListener,
        zoom: ChartZoomListener,
        end: ChartZoomListener
      },
      DATA_FINDER: {
        start: ChartZoomDataFinder,
        zoom: ChartZoomDataFinder,
        end: ChartZoomDataFinder
      },
      BEHAVIOUR: {
        start: zoom_start_listeners,
        zoom: [ClearOldInfo_C, filterChart_C, UPDATE_SCROLL_BY_DOMAIN],
        end: [UpdateViewportArea_C, ShowBrushResetButton]
      },
      LISTENER_TYPES: d3_set(['start', 'zoom', 'end']),
      SUPPORTED: function SUPPORTED(chart) {return chart.isAxisCategory && !chart.isPolarAxisCategory;},
      UPDATE: updateChartZoomTransform
    };

    Registry.setComponent('_chartZoomHandlers', _chartZoomHandlers);

    defaultTheme.zoom = function (userProp) {
      return {
        enabled: false,
        type: 'xy', // x, y, xy
        minZoom: 1,
        wheelZoom: true,
        pan: true,
        transitionDuration: 1000
      };
    };

    var DEFAULT_MAX_ZOOM = 25;

    /**
     *
     * @param chart
     * @return {ZoomD3Options}
     */
    function _getPlotZoomArguments(chart) {
      var options = chart.systemConf.chart.zoom,
        plotarea = chart.plotarea,
        translateExtent = [
        [0, 0],
        [plotarea.width, plotarea.height]],

        ZoomD3Options = Registry.getComponent('ZoomD3Options'),
        zoomType = chart.isGeoMap ? 'xy' : options.type,
        maxZoom = options.maxZoom || getMaxZoom(chart, pick(options.minimumVisiblePoints, MINIMUM_VISIBLE_POINTS), zoomType);

      return new ZoomD3Options({
        type: zoomType,
        scaleExtent: [options.minZoom, maxZoom],
        translateExtent: translateExtent,
        extent: translateExtent,
        wheelZoom: options.wheelZoom !== false,
        pan: options.pan !== false,
        transitionDuration: options.transitionDuration,
        element: chart.eventHandler.trackerGroup,
        metaKey: options.metaKey,
        filter: function filter() {
          // #ZC2560
          if ($Browser.isTouchDevice) {
            var event = d3_event();
            return event.touches.length > 1 || event.changedTouches.length > 1;
          }
          return true;
        }
      });
    }

    /**
     *
     * @param chart
     * @param numberOfPointsInView
     * @param zoomType
     */
    function getMaxZoom(chart) {var numberOfPointsInView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;var zoomType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'xy';
      if (zoomType === 'xy') {
        return DEFAULT_MAX_ZOOM;
      }

      var scale = getAxisObject(chart, zoomType, 0).scale,
        side = chart.axes.rotated ? 'height' : 'width';

      if (zoomType === 'x' || zoomType === 'y' && scale.bandwidth) {
        return mathMax(1, chart.plotarea[side] / getMinimumVisibleArea(chart, zoomType, numberOfPointsInView));
      }

      return DEFAULT_MAX_ZOOM;
    }

    Registry.setComponent('_getPlotZoomArguments', _getPlotZoomArguments);

    /**
     *
     * @type {boolean}
     * @private
     */

    var __META_KEY_INITIALIZED = false;
    var __META_EVENT = null;
    var __HOOKS = d3_map();
    var __HOOK_ID = 0;

    /**
     *
     */var
    KEYBOARD_EVENT_HANDLER = /*#__PURE__*/function () {function KEYBOARD_EVENT_HANDLER() {_classCallCheck(this, KEYBOARD_EVENT_HANDLER);}_createClass(KEYBOARD_EVENT_HANDLER, null, [{ key: "__INIT_EVENT", value:
        /**
         *
         * @private
         */
        function __INIT_EVENT() {
          if (!__META_KEY_INITIALIZED) {
            var WIN = d3_select(window);
            WIN.on("keydown.__META_KEY_ZC", function () {
              __META_EVENT = d3_event();

              __HOOKS.each(function (hook, key) {
                var hookKey = key.split('.').shift();
                if (KEYBOARD_EVENT_HANDLER.TEST_KEY(hookKey)) {
                  hook(true); // active
                }
              });
            });

            WIN.on("keyup.__META_KEY_ZC", function () {
              __HOOKS.each(function (hook, key) {
                var hookKey = key.split('.').shift();
                if (KEYBOARD_EVENT_HANDLER.TEST_KEY(hookKey)) {
                  hook(false); // not active
                }
              });
              __META_EVENT = null;
            });
            __META_KEY_INITIALIZED = true;
          }
        }

        /**
         *
         * @param key
         * @return {boolean}
         */ }, { key: "TEST_KEY", value:
        function TEST_KEY(key) {
          // init only once
          KEYBOARD_EVENT_HANDLER.__INIT_EVENT();

          if (!__META_EVENT) {
            return false;
          }
          return !!__META_EVENT[key];
        } }, { key: "ADD_HOOK", value:

        function ADD_HOOK(keyName, hook) {
          // init only once
          KEYBOARD_EVENT_HANDLER.__INIT_EVENT();
          __HOOK_ID++;

          var hook_id = "".concat(keyName, ".").concat(__HOOK_ID);
          __HOOKS.set(hook_id, hook);
          return hook_id;
        }

        /**
         *
         * @param HOOK_ID
         */ }, { key: "REMOVE_HOOK", value:
        function REMOVE_HOOK(HOOK_ID) {
          __HOOKS.remove(HOOK_ID);
        } }]);return KEYBOARD_EVENT_HANDLER;}();


    /**
     *
     * @param options
     * @constructor
     */

    var defaultOptions$2 = {
      // * For wheel zoom
      wheelZoom: true,
      // * for touch zoom feature
      doubleClickZoom: false,
      // * Panning behaviour
      pan: true,
      // * min and max zoom
      scaleExtent: [1, 8],
      extent: [[0, 0], [0, 0]],
      translateExtent: [[0, 0], [0, 0]],
      // meta key for mouse zoom
      metaKey: null,

      transitionDuration: 750
    };

    /**
     * This is used as a interface for zoom position
     */var
    ZoomD3Options = /*#__PURE__*/_createClass(
    function ZoomD3Options(options) {_classCallCheck(this, ZoomD3Options);
      this.settings = _objectSpread(_objectSpread({}, defaultOptions$2), options);
    });var


    ZoomD3 = /*#__PURE__*/function () {
      /**
       *
       * @param {ZoomD3Options} zoomD3Options
       */
      function ZoomD3(zoomD3Options) {_classCallCheck(this, ZoomD3);
        this.options = zoomD3Options.settings;
        this.initialize();
        this.hookCount = 0;
      }_createClass(ZoomD3, [{ key: "initialize", value:

        function initialize() {
          var zoom = this,
            options = zoom.options;

          zoom._maxZoom = mathMax.apply(void 0, _toConsumableArray(options.scaleExtent));
          zoom._minZoom = mathMin.apply(void 0, _toConsumableArray(options.scaleExtent));
          /**
           *
           * @type {ZoomBehavior}
           */
          zoom.d3_zoom = d3_zoom().scaleExtent([zoom._minZoom, zoom._maxZoom]);

          // create the signals for callback
          zoom._signal = d3_dispatch('start', 'zoom', 'end');

          zoom.enableSignals();

          if (options.filter) {
            zoom.d3_zoom.filter(options.filter);
          }

          if (options.element && options.element.isD3Selection) {
            zoom.bindTo(options.element);
          }
        }

        /**
         *
         */ }, { key: "enableSignals", value:
        function enableSignals() {
          var zoom = this,
            d3_zoom = zoom.d3_zoom,
            signal = zoom._signal;

          d3_zoom.on('start', function () {
            if (zoom.__notify !== false) {
              signal.call('start', zoom, d3_event());
            }
          });

          d3_zoom.on('zoom', function () {
            if (zoom.__notify !== false) {
              signal.call('zoom', zoom, d3_event());
            }
          });

          d3_zoom.on('end', function () {
            if (zoom.__notify !== false) {
              signal.call('end', zoom, d3_event());
            }
            zoom.__notify = true;
          });
        }

        /**
         *
         * @return {{}}
         */ }, { key: "getSignals", value:
        function getSignals() {
          return this._signal;
        }

        /**
         *
         * @param type
         * @param hook
         * @return {string}
         */ }, { key: "addHook", value:
        function addHook(type, hook) {
          this.hookCount++;
          var currentHookID = "".concat(type, ".").concat(this.hookCount);
          this._signal.on(currentHookID, hook);
          return currentHookID;
        }

        /**
         *
         * @param currentHookID
         */ }, { key: "removeHook", value:
        function removeHook(currentHookID) {
          this._signal.on(currentHookID, null);
        }

        /**
         *
         * @param {HTMLElement} element
         */ }, { key: "bindTo", value:
        function bindTo(element) {
          var zoom = this,
            d3_zoom = this.d3_zoom,
            options = this.options;

          zoom._element = element;
          zoom._elementNode = element.node();

          // set the extent
          d3_zoom.extent(zoom.__getExtent());
          d3_zoom.translateExtent(zoom.__getTranslateExtent());

          if (options.metaKey) {
            KEYBOARD_EVENT_HANDLER.ADD_HOOK(options.metaKey, function (active) {
              if (active) {
                element.call(d3_zoom);
                zoom.constrainEvent();
              } else {
                element.on('.zoom', null);
              }
            });
          } else {
            element.call(d3_zoom);
            zoom.constrainEvent();
          }
        }

        // should be called only after binding the event.
      }, { key: "constrainEvent", value: function constrainEvent() {
          var options = this.options,
            element = this._element;

          if (options.doubleClickZoom === false) {
            element.on('dblclick.zoom', null);
          }

          if (options.wheelZoom === false) {
            element.on('wheel.zoom', null);
          }

          if (options.pan === false) {
            element.on('mousedown.zoom', null);
          }

          if (options.touchZoom === false) {
            element.on('touchstart.zoom', null);
          }
        }

        /**
         *
         * @return {d3.event.transform|*}
         */ }, { key: "getTransform", value:
        function getTransform() {
          return d3_event() && d3_event().transform || this._element && d3_zoomTransform(this._element.node()) || d3_zoomIdentity;
        } }, { key: "step", value:

        function step(stepSize, transitionDuration) {
          stepSize = stepSize <= 0 ? 1 / -stepSize : stepSize;
          this.d3_zoom.scaleBy(this.__getZoomTransition(transitionDuration), stepSize);
        }

        /**
         *
         * @param scale
         * @param bounds
         */ }, { key: "zoomToBounds", value:
        function zoomToBounds(bounds, scale, transitionDuration) {
          this.zoomToRect(boundToRect(bounds), scale, transitionDuration);
        }

        /**
         *
         * @param scale
         * @param rect
         */ }, { key: "zoomToRect", value:
        function zoomToRect(rect, scale, transitionDuration) {
          this.zoomToPoint(ZoomD3.centroid(rect), pick(scale, this.__getConstrainedScale(rect)), transitionDuration);
        }

        /**
         *
         * @param point
         * @param scale
         * @param transitionDuration
         */ }, { key: "zoomToPoint", value:
        function zoomToPoint(point, scale, transitionDuration) {
          var zoom = this;

          scale = zoom.__limitScale(pick(scale, zoom._maxZoom));
          point = zoom.__constrainPoint(point, scale);
          zoom.interpolateZoom(point, scale, transitionDuration);
        }

        /**
         *
         * @param translate
         * @param scale
         * @param transitionDuration
         */ }, { key: "interpolateZoom", value:
        function interpolateZoom(translate, scale, transitionDuration) {
          this.zoomToIdentity(ZoomD3.getIdentity(translate, scale), transitionDuration);
        } }, { key: "zoomToIdentity", value:

        function zoomToIdentity(identity, transitionDuration) {var notify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var zoom = this;
          zoom.__notify = notify;
          zoom.__getZoomTransition(transitionDuration).call(zoom.d3_zoom.transform, identity);
        }

        /**
         * reset the zoom
         */ }, { key: "reset", value:
        function reset() {
          this._element.
          transition().
          duration(this.options.transitionDuration).
          call(this.d3_zoom.transform, d3_zoomIdentity);
        }

        /**
         *
         * @param xy
         * @return {*}
         */ }, { key: "invert", value:
        function invert(xy) {
          return this.getTransform().invert(xy);
        } }, { key: "update", value:

        function update(option) {
          var zoom = this,
            options = zoom.options = mergeJSON$1(zoom.options, option, true, true);

          zoom.d3_zoom.scaleExtent(options.scaleExtent).translateExtent(zoom.__getTranslateExtent());
        } }, { key: "updateExtent", value:

        function updateExtent(extent) {
          if (isArray$1(extent) && isArray$1(extent[0]) && isArray$1(extent[1])) {
            this.options.extent = extent;
            this.d3_zoom.extent(extent);

            this.options.translateExtent = extent;
            this.d3_zoom.translateExtent(extent);

            if (this._element) {
              this._element.call(this.d3_zoom);
              // after call we should constrain the event
              this.constrainEvent();
            }
          }
        }

        /**
         *
         * @param translate
         * @param scale
         * @return {Transform}
         */ }, { key: "__getExtent", value:




        /**
         *
         * @return {[[number, number], [number, number]]}
         * @private
         */
        function __getExtent() {
          return this.options.extent || [[0, 0], [this._elementNode.clientWidth, this._elementNode.clientHeight]];
        } }, { key: "destroy", value:

        function destroy() {
          var zoom = this;
          zoom._signal = null;
          // #ZC2766
          zoom._element && zoom._element.on('.zoom', null);
          each(zoom, function (value, key) {
            zoom[key] = null;
            delete zoom[key];
          });
        }

        /**
         *
         * @return {[[number, number], [number, number]]}
         * @private
         */ }, { key: "__getTranslateExtent", value:
        function __getTranslateExtent() {
          return this.options.translateExtent || this.__getExtent();
        }

        /**
         *
         * @return {Transition}
         * @private
         */ }, { key: "__getZoomTransition", value:
        function __getZoomTransition(transitionDuration) {
          return this._element.transition().duration(pick(transitionDuration, this.options.transitionDuration));
        }

        /**
         *
         * @param boundRect
         * @return {number}
         * @private
         */ }, { key: "__getConstrainedScale", value:
        function __getConstrainedScale(boundRect) {
          var zoom = this,
            translateExtentRect = boundToRect(zoom.__getTranslateExtent());

          return mathMax(
          1,
          mathMin(zoom._maxZoom, 1 / mathMax(boundRect.width / translateExtentRect.width, boundRect.height / translateExtentRect.height)));

        }

        /**
         *
         * @param point
         * @param scale
         * @return {number[]}
         * @private
         */ }, { key: "__constrainPoint", value:
        function __constrainPoint(point, scale) {
          var translateExtentRect = boundToRect(this.__getTranslateExtent());
          return [
          mathMin(
          translateExtentRect.x,
          mathMax(translateExtentRect.width / 2 - scale * point[0], translateExtentRect.width - translateExtentRect.width * scale)),

          mathMin(
          translateExtentRect.y,
          mathMax(translateExtentRect.height / 2 - scale * point[1], translateExtentRect.height - translateExtentRect.height * scale))];


        } }, { key: "__limitScale", value:

        function __limitScale(scale) {
          return mathMax(this._minZoom, mathMin(scale, this._maxZoom));
        }

        /**
         *
         * @param {{x: number, y: number, width: number, height: number}} rect
         * @return {number[]}
         */ }], [{ key: "getIdentity", value: function getIdentity(translate, scale) {return d3_zoomIdentity.translate(translate[0], translate[1]).scale(scale);} }, { key: "centroid", value:
        function centroid(rect) {
          return [+rect.x + +rect.width / 2, +rect.y + +rect.height / 2];
        } }]);return ZoomD3;}();


    ZoomD3.prototype.on = ZoomD3.prototype.addHook;

    Registry.setComponent('ZoomD3', ZoomD3);
    Registry.setComponent('ZoomD3Options', ZoomD3Options);

    /**
     *
     * @param instanceMap
     * @param event
     * @constructor
     */
    function MapZoomListener(instanceMap, event) {
      var eventManager = this;

      eventManager.associateBehaviours(instanceMap, event.type, {}, event.transform, event);
    }

    //GeoUtils.js

    var GeoUtils = {
      /**
       *
       * @param feature
       * @param geoPath
       * @return {*|{x: number, y: number, width: number, height: number}}
       */
      getGeoBBox: function getGeoBBox(feature, geoPath) {
        return this.geoBoundToRect(geoPath.bounds(feature));
      },

      /**
       *
       * @param {number[]}bound
       * @return {{x: number, y: number, width: number, height: number}}
       */
      geoBoundToRect: function geoBoundToRect(bound) {
        return {
          x: bound[0][0],
          y: bound[0][1],
          width: Math.abs(bound[1][0] - bound[0][0]),
          height: Math.abs(bound[1][1] - bound[0][1])
        };
      },

      /**
       *
       * @param feature
       * @param type
       * @param geoPath
       * @return {*|*|{x: number, y: number, width: number, height: number}}
       */
      getFeatureGradientBBox: function getFeatureGradientBBox(feature, type, geoPath) {
        return this.getGeoBBox(feature, geoPath);
        // var bbox = this.getGeoBBox(feature, geoPath);
        // if (type === "radial") {
        //     bbox.x = bbox.x + bbox.width / 2;
        //     bbox.y = bbox.y + bbox.height / 2;
        // }
        // return bbox;
      },

      /**
       *
       * @param {GeoMap} geoMap
       * @param {number} x
       * @param {number} y
       * @return {number[]}
       */
      toLatLong: function toLatLong(geoMap, x, y) {
        var utils_geo = geoMap.geo.utils,
          xy = [x, y];

        // first get if any transformation is applied to the map and invert it
        // then invert the xy on transformed container
        // var transform = geoMap.getTransform();
        // xy = transform.invert(xy);

        // finally convert and return
        return utils_geo.projection.invert(xy);
      },

      /**
       *
       * @param {GeoMap}geoMap
       * @param {number} x
       * @param {number} y
       * @return {number[]}
       */
      toXY: function toXY(geoMap, x, y) {
        // fix the globe
        // https://stackoverflow.com/questions/48161441/
        var projectionConf = geoMap.systemConf.map.projection || {};

        if (projectionConf.name === 'geoOrthographic') {
          var rotate = geoMap.geo.utils.projection.rotate(),
            centerPos = [-rotate[0], -rotate[1]];
          var distance = d3_geoDistance([x, y], centerPos);
          if (distance > Math.PI / 2) {
            return [null, null];
          }
        }
        return geoMap.geo.utils.projection([x, y]) || [null, null];
      },

      clearContext: function clearContext(context) {
        if (context && context.clearRect) {
          context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        }
      },

      /**
       *
       */
      applyTransform: function applyTransform(transform, context) {
        if (context.canvas) {
          context.translate(transform.x, transform.y);
          context.scale(transform.k, transform.k);
        } else {
          context.attr('transform', transform);
        }
      },

      round: function round(value, precision) {
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(value * multiplier) / multiplier;
      }
    };

    /**
     *
     * @type {{DRAG: (function(*, *=): *), START: (function(*=, *=): {quaternion: *, cartesian})}}
     */
    var VERSOR_DRAG = {
      START: function START(rotation, space3d) {
        return {
          cartesian: versor.cartesian(space3d),
          quaternion: versor(rotation)
        };
      },
      DRAG: function DRAG(start, space3d) {
        var v1 = versor.cartesian(space3d),
          q1 = versor.multiply(start.quaternion, versor.delta(start.cartesian, v1));
        return versor.rotation(q1);
      }
    };

    /**
     *
     * @param geoMap
     * @return {{scale: number, translate: [number, number]}}
     * @private
     */
    function __getBaseProjectionTransform(geoMap) {
      var baseProjection = geoMap.baseProjection = geoMap.baseProjection = geoMap.getProjection(geoMap.geo.renderedLayer);
      return {
        scale: baseProjection.scale(),
        translate: baseProjection.translate()
      };
    }

    /**
     *
     * @param instanceMap
     * @param selectionManager
     * @param transform
     * @constructor
     */
    function ApplyZoomOnMap(instanceMap, selectionManager, transform) {
      var eventManager = this,
        geoMap = eventManager.chart;

      if (geoMap.geo.isGlobeMap) {
        applyZoomOnGlobeMap(geoMap, transform, instanceMap);
      } else {
        applyZoomOnFlatMap(geoMap, transform, instanceMap);
      }
      __updateMap(geoMap);
    }

    /**
     *
     * @param geoMap
     * @param transform
     * @param instanceMap
     */
    function applyZoomOnFlatMap(geoMap, transform, instanceMap) {
      var baseTransform = __getBaseProjectionTransform(geoMap),
        geoUtils = geoMap.geo.utils;

      geoUtils.projection.translate([
      transform.x + baseTransform.translate[0] * transform.k,
      transform.y + baseTransform.translate[1] * transform.k]);

      geoUtils.projection.scale(baseTransform.scale * transform.k);
    }

    /**
     *
     * @param geoMap
     * @param transform
     * @param instanceMap
     */
    function applyZoomOnGlobeMap(geoMap, transform, instanceMap) {
      var geoUtils = geoMap.geo.utils,
        baseTransform = __getBaseProjectionTransform(geoMap);

      geoUtils.projection.scale(baseTransform.scale * transform.k);
      geoUtils.projection.rotate(instanceMap._baseRotate);
      // get the current mouse lat-long
      var mouse = d3_mouse(geoMap.eventHandler.trackerElement.node()),
        mouse_latLong = GeoUtils.toLatLong(geoMap, mouse[0], mouse[1]),
        rotation = VERSOR_DRAG.DRAG(instanceMap._basePosition, mouse_latLong);

      geoUtils.projection.rotate(rotation);
    }

    /**
     *
     * @param {GeoMap} geoMap
     * @private
     */
    function __updateMap(geoMap) {
      geoMap.eventHandler.mapEvents.handleMouseOut();
      geoMap.eventHandler.tooltipElement.hide();
      geoMap.addRemoveSeries();
    }

    /**
     *
     * @param instanceMap
     * @param selectionManager
     * @param transform
     * @constructor
     */
    function UpdateMapOutLine(instanceMap, selectionManager, transform) {
      var mapEvents = this.chart.eventHandler.mapEvents;
      mapEvents.outLine = mapEvents.getOutLine();
    }

    /**
     *
     * @constructor
     */
    function SaveGlobeMapState(instanceMap, selectionManager, transform) {
      var eventManager = this,
        geoMap = eventManager.chart;

      if (geoMap.geo.isGlobeMap) {
        var mouse = d3_mouse(geoMap.eventHandler.trackerElement.node()),
          mouse_latLong = GeoUtils.toLatLong(geoMap, mouse[0], mouse[1]);

        instanceMap._baseRotate = geoMap.geo.utils.projection.rotate();
        instanceMap._basePosition = VERSOR_DRAG.START(instanceMap._baseRotate, mouse_latLong);
      }
    }

    var _mapZoomHandlers = {
      LISTENER: {
        start: MapZoomListener,
        zoom: MapZoomListener,
        end: MapZoomListener
      },
      DATA_FINDER: {},
      BEHAVIOUR: {
        start: SaveGlobeMapState,
        zoom: ApplyZoomOnMap,
        end: UpdateMapOutLine
      },
      LISTENER_TYPES: d3_set(['start', 'zoom', 'end']),
      SUPPORTED: function SUPPORTED(chart) {return chart.isGeoMap;}
    };

    Registry.setComponent('_mapZoomHandlers', _mapZoomHandlers);

    //$Id$

    function getAreaLayout(rp, shiftDiff, shiftInfo, serData, subseriesIndex, paneid) {
      var chartObj = rp.chartObj,
        xscale = rp.xscale,
        yscale = rp.yscale,
        stacked = rp.stacked,
        index = rp.datasetIndex,
        axisrotated = rp.axisrotated,
        commonPlotOptions = rp.commonPlotOptions,
        hasNegValue = rp.hasNegValue,
        yaxiscolumnorder = rp.yaxiscolumnorder,
        dataset = rp.dataset,
        systemconf = chartObj.systemConf,
        dataObject = chartObj.dataObject,
        yReversed = systemconf.chart.axes.yaxis[yaxiscolumnorder].reversed,
        plotoptions = (chartObj.seriesdata[index] || chartObj.seriesdata[0]).plotoptions,
        gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions),
        interpolation = gvp('mode'),
        layout;

      if (dataObject.isPolarAxisCategory) {
        var polarBaseIdx = yReversed && !stacked ? rp.yscale.domain().length - 1 : 0,
          dataProcessorHelpers = DataProcessor.helpers,
          isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
          isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder),
          innerRadiusFunc = function innerRadiusFunc(d, j) {
            var innerRadius;
            if (stacked) {
              innerRadius = d.y0 == 0 ? mathMin(rp.yscale.range()[0], rp.yscale(hasNegValue), d.y0) : rp.yscale(d.y0); //Test_763.json
            } else {
              innerRadius =
              rp.yscale(rp.yscale.domain()[polarBaseIdx]) + (rp.yscale.bandwidth != null ? rp.yscale.bandwidth() / 2 : 0);
            }
            return mathMax(innerRadius, rp.yscale.range()[polarBaseIdx]);
          },
          outerRadiusFunc = function outerRadiusFunc(d, j) {
            if (d.isDummy) {
              return innerRadiusFunc.apply(null, arguments); //Test_829.json
            }
            var outerRadius = stacked ?
            rp.yscale(d.y0 + d.y) :
            rp.yscale(dataset.getY(d, yaxiscolumnorder)) + (rp.yscale.bandwidth != null ? rp.yscale.bandwidth() / 2 : 0);
            return mathMax(outerRadius, rp.yscale.range()[polarBaseIdx]);
          };

        layout = d3_areaRadial().
        angle(function (d, j) {
          return xscale(dataset.getX(d));
        }).
        outerRadius(outerRadiusFunc).
        innerRadius(innerRadiusFunc).
        curve(d3_curves(interpolation));
        layout._defined = function (d, j) {
          return !isCatNullY(dataset.getY(d, yaxiscolumnorder)) && !isCatNullX(dataset.getX(d));
        };
      } else {
        var cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
          cType = cType_Obj.name,
          isRangeChart = cType === AREARANGE_CHARTNAME,
          yrangePos = isRangeChart ? 1 : null,
          dataProcessorHelpers = DataProcessor.helpers,
          isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
          isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder);

        layout = d3_area().
        defined(function (d, j) {
          if (stacked) {
            return !isCatNullX(dataset.getX(d));
          }
          return !isCatNullY(dataset.getY(d, yaxiscolumnorder)) && !isCatNullX(dataset.getX(d));
        }).
        curve(d3_curves(interpolation, rp.axisrotated, commonPlotOptions.tension));

        if (axisrotated) {
          layout.
          x0(function (d, j) {
            if (stacked) {
              return index == 0 && subseriesIndex == 0 && j == 0 ?
              mathMax(rp.yscale.range()[0], rp.yscale(hasNegValue)) :
              rp.yscale(d.y0);
            } else {
              if (isRangeChart) {
                return dataObject.getXYvalue(
                rp.axisrotated,
                rp.stacked,
                rp.xscale,
                rp.yscale,
                rp.yaxiscolumnorder,
                d,
                'x',
                null,
                0);

              } else {
                return rp.yscale.bandwidth != null ?
                rp.yscale.origRange[0] + rp.yscale.bandwidth() :
                mathMax(rp.yscale.range()[0], rp.yscale(hasNegValue));
              }
            }
          }).
          x1(function (d, j) {
            var x = dataObject.getXYvalue(
            rp.axisrotated,
            rp.stacked,
            rp.xscale,
            rp.yscale,
            rp.yaxiscolumnorder,
            d,
            'x',
            null,
            yrangePos);

            if (isNaN(x) && shiftInfo != null) {
              x =
              dataObject.getXYvalue(
              rp.axisrotated,
              rp.stacked,
              rp.xscale,
              rp.yscale,
              rp.yaxiscolumnorder,
              serData[serData.length - 1],
              'x',
              null,
              yrangePos) +
              shiftDiff;
            }
            return x;
          }).
          y(function (d, j) {
            return dataObject.getXYvalue(
            rp.axisrotated,
            rp.stacked,
            rp.xscale,
            rp.yscale,
            rp.yaxiscolumnorder,
            d,
            'y',
            null,
            yrangePos);

          });
        } else {
          layout.
          x(function (d, j) {
            var x = chartObj.dataObject.getXYvalue(
            rp.axisrotated,
            rp.stacked,
            rp.xscale,
            rp.yscale,
            rp.yaxiscolumnorder,
            d,
            'x',
            null,
            yrangePos);

            if (shiftInfo != null) {
              var transX = Math.abs(
              chartObj.dataObject.getXYvalue(
              rp.axisrotated,
              rp.stacked,
              chartObj.renderer[index].oldXscale,
              rp.yscale,
              rp.yaxiscolumnorder,
              serData[0],
              'x',
              null,
              yrangePos) -

              chartObj.dataObject.getXYvalue(
              rp.axisrotated,
              rp.stacked,
              rp.xscale,
              rp.yscale,
              rp.yaxiscolumnorder,
              serData[0],
              'x',
              null,
              yrangePos));


              x = x + transX;
            }
            return x;
          }).
          y0(function (d, j) {
            if (stacked) {
              return index == 0 && subseriesIndex == 0 && j == 0 ?
              mathMin(rp.yscale.range()[0], rp.yscale(hasNegValue)) :
              rp.yscale(d.y0);
            } else {
              if (isRangeChart) {
                return dataObject.getXYvalue(
                rp.axisrotated,
                rp.stacked,
                rp.xscale,
                rp.yscale,
                rp.yaxiscolumnorder,
                d,
                'y',
                null,
                0);

              } else {
                return rp.yscale.bandwidth != null ?
                rp.yscale.origRange[0] + rp.yscale.bandwidth() :
                mathMin(rp.yscale.range()[0], rp.yscale(hasNegValue));
              }
            }
          }).
          y1(function (d, j) {
            var s = rp.yscale;
            return dataObject.getXYvalue(
            rp.axisrotated,
            rp.stacked,
            rp.xscale,
            rp.yscale,
            rp.yaxiscolumnorder,
            d,
            'y',
            null,
            yrangePos);

          });
        }
      }
      return layout;
    }

    function WebHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    inherit(WebHighlighter, ScatterHighlighter);

    var proto$9 = WebHighlighter.prototype;

    proto$9._defaultH = function () {var _this32 = this;
      return [
      {
        shape: 'marker',
        path: _super(this).path,
        data: _super(this).data,
        context: _super(this).renderingContext,
        translate: this.translateContext
      },
      {
        shape: 'poly',
        path: this.path,
        data: this.data,
        context: this.renderingContext,
        translate: this.translateContext,
        styles: function styles(point) {
          return patternFillEffect.call(_this32, point, 'inherit');
        }
      }];

    };

    proto$9.data = function (point) {
      var rp = this.renderer.commonRendererProp().params;
      var chart = this.chart,
        renderer = this.renderer,
        layout = renderer.layout[point.subSeriesIndex],
        y0 = layout.innerRadius(),
        isDefined = layout._defined;

      point._polydata = this.poly(point);

      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key];
        cache._x = point._x =
        cache._x ||
        chart.dataObject.getXYvalue(rp.axisrotated, rp.stacked, rp.xscale, rp.yscale, rp.yaxiscolumnorder, point, 'x') + rp.bound.x;
        cache._y = point._y =
        cache._y ||
        chart.dataObject.getXYvalue(rp.axisrotated, rp.stacked, rp.xscale, rp.yscale, rp.yaxiscolumnorder, point, 'y') + rp.bound.y;
        cache._y0 = point._y0 = cache._y0 || y0(point, point.itemIndex);
        cache._uid = point._uid = chart.dataset.getX(point);
        cache._defined = point._defined = defined(cache._defined) ? cache._defined : isDefined(point);
        cache._visible = point._visible = isPointVisible(chart, point);
        cache._point = point;
        return point;
      };
    };

    proto$9.poly = function (point) {
      var chart = this.chart,
        renderer = this.renderer;
      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key];
        if (!cache._poly) {
          var flatten = renderer.seriesdataAfterUpdate[point.subSeriesIndex],
            poly = getPolygonPoints(flatten, point),
            polypoints = getAbstractPolyPoints(flatten);
          poly.points = polypoints;
          cache._poly = point._poly = poly;
        }

        return point._poly;
      };
    };

    proto$9.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('area').call(this, this.chart);
    };

    proto$9.translateContext = function () {
      return [this.chart.plotarea.left + this.chart.plotarea_approx.x, this.chart.plotarea.top + this.chart.plotarea_approx.y];
    };

    proto$9.options = function (point) {
      var rp = this.renderer.commonRendererProp().params,
        commonOptions = _super(this).commonOptions.call(this, point),
        symbol = commonOptions.symbol,
        size = commonOptions._size || rp.gvp('strokeWidth'),
        interpolation = rp.gvp('mode'),
        fillopacity = rp.hoverOptions.fillOpacity || 0.2;

      commonOptions.size = {
        outer: size * 0.7,
        inner: size * 0.35
      };
      commonOptions.fillopacity = fillopacity;
      commonOptions.interpolation = interpolation;

      return commonOptions;
    };

    proto$9.path = function (point, model) {
      var options = this.options(point),
        context = model.context.call(this),
        translate = model.translate.call(this),
        pathContext,
        rp = this.renderer.commonRendererProp().params,
        area = this.renderer.layout[point.subSeriesIndex];
      area.context(NULL$1);
      context.style('display', '').attr('transform', "translate(".concat(translate[0] + rp.bound.x, ",").concat(translate[1] + rp.bound.y, ")"));

      pathContext = appendEle(context, 'path', [1], '.', 'class', "highlight".concat(point.seriesIndex));
      pathContext.
      datum(this.renderer.seriesdataAfterUpdate[point.subSeriesIndex]).
      attr('d', area).
      attr('stroke', '').
      styles({
        'fill-opacity': options.fillopacity,
        display: ''
      });

      return pathContext;
    };

    //$Id$

    canvas_plot_renderer.area = function () {
      var commonRendererProp,
        shiftInfo,
        shiftDiff,
        line = canvas_plot_renderer.line();

      function chart(context, seriesdata, pattern, filterIndex) {
        var rp = commonRendererProp.params,
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          yscale = rp.yscale,
          stacked = rp.stacked,
          index = rp.datasetIndex,
          legendOrder = rp.legendOrderIndex,
          rendererIndex = rp.rendererIndex,
          axisrotated = rp.axisrotated,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          labelQueue = rp.labelQueue,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          mainSeries = seriesdata;

        seriesdata = chartObj.dataObject.categoryHierarchy ? seriesdata[index] : chartObj.seriesdata[index];
        var plotoptions = seriesdata.plotoptions;
        var paneid = isFacet(chartObj) ? "".concat(seriesdata.row, "_").concat(seriesdata.column) : null;
        var gvp = commonRendererProp.params.gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions);
        var fillOpacity = gvp('fillOpacity'),
          strokeWidth = gvp('strokeWidth'),
          strokeColor = gvp('strokeColor'),
          markeroptions = commonRendererProp.params.markerOptions =
          plotoptions && plotoptions.marker ?
          mergeJSON$1(commonPlotOptions.marker, plotoptions.marker, true) :
          commonPlotOptions.marker,
          hoverOptions = commonRendererProp.params.hoverOptions =
          plotoptions && plotoptions.hoveroptions ?
          mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
          commonPlotOptions.hoveroptions,
          markerEnabled = markeroptions.enabled,
          borderEnabled =
          defined(strokeWidth) && strokeWidth != '' && pInt(strokeWidth) != 0 ||
          defined(strokeColor) && strokeColor != '' ||
          markerEnabled,
          datatypeX = chartObj.dataset.getDataType('x'),
          datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
          xCategories = datatypeX == ORDINAL_DATATYPE ? xscale.domain() : null,
          yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
          cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
          cType = cType_Obj.name,
          isRangeChart = rp.isRangeChart = cType == 'arearange',
          gradientDim = gradient_helpers.getDimension(chartObj, index),
          fillStyle = chart.fillColorFunc = getFillColor(chartObj, legendOrder, paneid, gradientDim, null, null, null, rp),
          strokeColor = getStrokeColor(chartObj, legendOrder);

        if (defined(pattern)) {
          fillStyle = pattern;

          if (defined(filterIndex)) {
            markerEnabled = true;
            fillOpacity = 0.00000001;
          }
        }
        chart.layout = [];

        chart.seriesdataAfterUpdate = [];
        seriesdata.data.forEach(function (d, i) {
          var serData;
          if (datatypeX == ORDINAL_DATATYPE || datatypeY == ORDINAL_DATATYPE) {
            serData = chartObj.dataObject.updateSeriesdatabyCategories(d3_values(d), xCategories, yCategories, yaxiscolumnorder);
          } else {
            serData = d;
          }
          if (chartObj.renderVisiblePointsOnly || shiftInfo != null) {
            //for pushdatapoint allow filter for highlight
            serData = DataProcessor.helpers.filterPointsInViewport(chartObj, serData, 'area', 'x', index);
          }

          chart.seriesdataAfterUpdate[i] = serData;
          shiftDiff =
          shiftInfo != null ?
          shiftDiff == null || shiftDiff == 0 ?
          chartObj.dataObject.getXYvalue(
          axisrotated,
          stacked,
          xscale,
          yscale,
          yaxiscolumnorder,
          serData[serData.length - 1],
          'x') -

          chartObj.dataObject.getXYvalue(
          axisrotated,
          stacked,
          xscale,
          yscale,
          yaxiscolumnorder,
          serData[serData.length - 2],
          'x') :

          shiftDiff :
          0;
          var area = getAreaLayout(rp, shiftDiff, shiftInfo, serData, i, paneid);
          chart.layout[i] = area;
          if (!seriesdata.disabled) {
            var drawAreaFunction = function drawAreaFunction(context, fillStyle) {
              context.beginPath();
              context.fillStyle = fillStyle;
              area.context(context)(d);
              context.fill();
              context.restore();
            };

            if (chartObj.imagePallete) {
              effects.canvas_patterns.imageFill(
              {
                context: context,
                name: getImageByIndex(chartObj, legendOrder, paneid)
              },
              drawAreaFunction);

            } else {
              var fillStyle =
              defined(pattern) && isUndefined(filterIndex) ?
              pattern :
              chart.fillColorFunc(
              legendOrder,
              null,
              null,
              gvp('fillColor') || color,
              fillOpacity,
              gradientDim,
              null,
              false,
              i);

              drawAreaFunction(context, fillStyle);
            }
          }
        });
        if (!seriesdata.disabled) {
          if ((borderEnabled || markerEnabled) && !seriesdata.disabled) {
            line.chartRendered = false;
            line.commonRendererProp(commonRendererProp).shiftInfo(shiftInfo);
            line(context, mainSeries, pattern, filterIndex);
          }
        }

        if (defined(labelRenderer) && !(borderEnabled || markerEnabled)) {
          if (isRangeChart) {
            labelQueue.push({
              renderer: chart,
              charttype: 'scatter',
              chartObj: chartObj,
              rendererIndex: rendererIndex,
              paneid: paneid,
              args: [seriesdata, index, 0, 1]
            });
            labelQueue.push({
              renderer: chart,
              charttype: 'scatter',
              chartObj: chartObj,
              rendererIndex: rendererIndex,
              paneid: paneid,
              args: [seriesdata, index, 0, 0]
            });
          } else {
            labelQueue.push({
              renderer: chart,
              charttype: 'scatter',
              chartObj: chartObj,
              rendererIndex: rendererIndex,
              paneid: paneid,
              args: [seriesdata, index, 0, null]
            });
          }
        }
        chart.chartRendered = true;
        return chart;
      }

      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          chart.highlighter = chartObj.dataObject.isPolarAxisCategory ?
          new WebHighlighter(chartObj, chart) :
          new AreaHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };
      return chart;
    };

    defaultTheme.area = function () {
      return {
        strokeOpacity: 0.5,
        outerPadding: 0.02,
        fillOpacity: 0.4,
        mode: 'linear', //linear,stepBefore,stepAfter,cardinal
        stacked: {
          enabled: false,
          showAs: 'values' //values,percent
        },
        marker: {
          enabled: false,
          outerFillColor: 'transparent',
          outerStrokeOpacity: 0.5,
          size: 1, //1,2....
          useSVGMarkers: true
        },
        hoveroptions: {
          innerStrokeWidth: 2,
          outerFillOpacity: 0.5,
          outerStrokeOpacity: 0.1
        },
        datalabels: {
          showAs: 'y' //x,y,percent
        },
        gradients: {
          // linear || none
          options: {
            linear: {
              x2: 50
            }
          }
        },
        animation: {
          type: 'vertPathTweenAll', //horiPathTween || vertPathTween || vertPathTweenAll || pointTween
          marquee: {
            enabled: false,
            duration: 300
          },
          blink: {
            enabled: false,
            type: 'twinkle', //twinkle | fade
            duration: 800
          }
        }
      };
    };

    defaultTheme.arearange = function () {
      return {
        strokeOpacity: 0.5,
        outerPadding: 0.02,
        fillOpacity: 0.4,
        mode: 'linear', //linear,stepBefore,stepAfter,cardinal
        stacked: {
          enabled: false,
          showAs: 'values' //values,percent
        },
        marker: {
          enabled: false,
          outerFillColor: 'transparent',
          outerStrokeOpacity: 0.5,
          size: 1 //1,2....
        },
        hoveroptions: {
          innerStrokeWidth: 2,
          outerFillOpacity: 0.5,
          outerStrokeOpacity: 0.1
        },
        datalabels: {
          showAs: 'y' //x,y,percent
        },
        gradients: {
          // linear || none
          options: {
            linear: {
              x2: 50
            }
          }
        },
        animation: {
          type: 'vertPathTweenAll', //horiPathTween || vertPathTween || vertPathTweenAll || pointTween
          marquee: {
            enabled: false,
            duration: 300
          },
          blink: {
            enabled: false,
            type: 'twinkle', //twinkle | fade
            duration: 800
          }
        }
      };
    };

    defaultTheme.web = function () {
      return {
        fillOpacity: 0.5,
        strokeWidth: 2,
        mode: 'linearClosed', //linearClosed || cardinalClosed
        outerPadding: 10,
        stacked: {
          enabled: false,
          showAs: 'values' //values,percent
        },
        marker: {
          enabled: true,
          innerStrokeOpacity: 1,
          outerFillColor: 'white'
        },
        hoveroptions: {
          innerStrokeWidth: 2,
          innerStrokeOpacity: 1,
          outerFillColor: 'white'
        },
        datalabels: {
          showAs: 'y' //x,y,percent
        },
        animation: {
          type: 'strokeTween', //strokeTween , pathTween , pointbypointTween , fade
          marquee: {
            enabled: false,
            duration: 300
          },
          blink: {
            enabled: false,
            type: 'twinkle', //twinkle | fade
            duration: 800
          }
        },
        gradients: {
          // radial || linear || none
          options: {
            linear: {
              x2: 15,
              spreadMethod: 'repeat', // pad || repeat || reflect
              gradientUnits: 'userSpaceOnUse' //objectBoundingBox || userSpaceOnUse
            },
            radial: {
              radius: 90,
              x: 0,
              y: 0
            }
          }
        }
      };
    };

    //$Id$

    /**
     *
     * @returns {chart} area and arearange renderer.
     */
    svg_plot_renderer.area = function () {
      var commonRendererProp,
        xscale,
        yscale,
        dataset,
        yaxiscolumnorder,
        index = 0,
        stacked = false,
        axisrotated = false,
        redraw = false,
        line = svg_plot_renderer.line();
      var area = [],
        color,
        labelQueue,
        commonPlotOptions,
        systemconf,
        hasNegValue,
        chartObj,
        transitionDuration;
      var shiftInfo,
        shiftDiff;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          yscale = rp.yscale,
          stacked = rp.stacked,
          index = rp.datasetIndex,
          axisrotated = rp.axisrotated,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          labelQueue = rp.labelQueue,
          hasNegValue = rp.hasNegValue,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset,
          systemconf = chartObj.systemConf;
          var renderingOrder = rp.renderingOrderIndex,
            legendOrder = rp.legendOrderIndex,
            rendererIndex = rp.rendererIndex;

          var defsLocation = chartObj.defsLocation,
            isPolar = chartObj.dataObject.isPolarAxisCategory;

          var currentdata = data[index];
          var data_bind = { data: currentdata, index: renderingOrder };
          var plotoptions = currentdata.plotoptions;
          var currentseriesdata = currentdata.data;
          var paneid = "".concat(currentdata.row, "_").concat(currentdata.column);
          var cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
            cType = cType_Obj.name;

          var gvp = commonRendererProp.params.gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions);
          var fillOpacity = gvp('fillOpacity'),
            strokeWidth = gvp('strokeWidth'),
            strokeColor = gvp('strokeColor'),
            hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
            markeroptions = commonRendererProp.params.markerOptions =
            plotoptions && plotoptions.marker ?
            mergeJSON$1(commonPlotOptions.marker, plotoptions.marker, true) :
            commonPlotOptions.marker,
            hoverOptions = commonRendererProp.params.hoverOptions =
            plotoptions && plotoptions.hoveroptions ?
            mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
            commonPlotOptions.hoveroptions,
            markerEnabled = hasColorScale || markeroptions.enabled;
          var borderEnabled =
          strokeWidth != null && strokeWidth != '' && pInt(strokeWidth) != 0 ||
          strokeColor != null && strokeColor != '' ||
          markerEnabled;

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, cType);
          var isAnimationEnable = animationOptions.enabled,
            easingType = animationOptions.easingType,
            animationType = animationOptions.type;
          transitionDuration = animationOptions.duration;
          animationType = animationType == VERTPATHTWEENALL_ANIMATION ? VERTPATHTWEEN_ANIMATION : animationType;

          var datatypeX = chartObj.dataset.getDataType('x'),
            datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
            xCategories = datatypeX == ORDINAL_DATATYPE ? xscale.domain() : null,
            yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
            categories =
            datatypeX == ORDINAL_DATATYPE && !defined(chartObj.dataObject.hierarchical) ?
            xCategories :
            chartObj.dataObject.getCategories('x');

          var yReversed = systemconf.chart.axes.yaxis[yaxiscolumnorder].reversed;
          if (datatypeX != ORDINAL_DATATYPE && categories.length == 0 && isAnimationEnable && animationType == POINTTWEEN_ANIMATION) {
            categories = chartObj.dataObject.findXCategories();
          }

          var isRangeChart = rp.isRangeChart = cType == 'arearange';
          var yrangePos = isRangeChart ? 1 : null;

          chart.seriesdataAfterUpdate = [];
          chart.layout = [];
          currentseriesdata.forEach(function (d, i) {
            var serData;
            if (datatypeX == ORDINAL_DATATYPE || datatypeY == ORDINAL_DATATYPE) {
              serData = chartObj.dataObject.updateSeriesdatabyCategories(d3_values(d), xCategories, yCategories, yaxiscolumnorder);
            } else {
              serData = d;
            }

            if (chartObj.renderVisiblePointsOnly || shiftInfo != null) {
              //for pushdatapoint allow filter for highlight
              serData = DataProcessor.helpers.filterPointsInViewport(chartObj, serData, cType, 'x', index);
            }

            chart.seriesdataAfterUpdate[i] = serData;
            if (chartObj.systemConf.chart.axes.xaxis.reversed) {
              serData = serData.slice(0).reverse();
            }
            shiftDiff =
            shiftInfo != null ?
            shiftDiff == null || shiftDiff == 0 ?
            chartObj.dataObject.getXYvalue(
            axisrotated,
            stacked,
            xscale,
            yscale,
            yaxiscolumnorder,
            serData[serData.length - 1],
            'x') -

            chartObj.dataObject.getXYvalue(
            axisrotated,
            stacked,
            xscale,
            yscale,
            yaxiscolumnorder,
            serData[serData.length - 2],
            'x') :

            shiftDiff :
            0;

            area[i] = getAreaLayout(rp, shiftDiff, shiftInfo, serData, i, paneid);
            chart.layout[i] = area[i];
          });

          var container = d3_select(this);
          chart.update = function () {
            container.transition().call(chart);
          };
          var dynamicPosition = rp.dynamicSeriesPosition;
          if (dynamicPosition === undefined) {
            dynamicPosition = index;
          }
          var series;
          if (isPolar) {
            index = dynamicPosition;
            series = container.selectAll("g.areaseries_".concat(index)).data([data_bind]);
            series.
            enter().
            insert('g', ':first-child').
            merge(series).
            attr('class', "areaseries_".concat(index));
            series = container.selectAll("g.areaseries_".concat(index));
          } else {
            series = appendEle(container, 'g', [data_bind], '.', 'class', "areaseries_".concat(dynamicPosition));
          }

          if (borderEnabled || markerEnabled) {
            line.commonRendererProp(commonRendererProp).shiftInfo(shiftInfo);
            line.chartRendered = false;

            if (isRangeChart) {
              line.yrangePos(1);
              var baseLine = svg_plot_renderer.
              line().
              commonRendererProp(commonRendererProp).
              shiftInfo(shiftInfo).
              yrangePos(0);
              baseLine.chartRendered = false;
              container.call(baseLine);
            }
            container.call(line);
          } else {
            container.selectAll("g.lineseries_".concat(dynamicPosition, ",g.scatterseries_").concat(dynamicPosition)).remove();
          }

          currentseriesdata.forEach(function (d, i) {
            var serData = chart.seriesdataAfterUpdate[i];
            var baseData = serData;
            var basedataShift,
              dummyDataLength = 0;

            if (isAnimationEnable) {
              if (animationType == POINTTWEEN_ANIMATION) {
                baseData = serData.map(function (d, i) {
                  return Object.create(serData[0]);
                });
              } else {
                var idx = animationType == HORIPATHTWEEN_ANIMATION ? dataset.xidx : dataset.yidx(yaxiscolumnorder);
                var scaleObj = animationType == HORIPATHTWEEN_ANIMATION ? xscale : yscale;
                var baseIdx = isPolar && yReversed && !stacked ? scaleObj.domain().length - 1 : 0;
                baseData = serData.map(function (d, i) {
                  var s = Object.create(d);
                  if (d.isDummy) {
                    dummyDataLength++;
                  }
                  if (stacked && animationType != HORIPATHTWEEN_ANIMATION) {
                    s.y0 = isPolar && animationType === STROKETWEEN_ANIMATION ? mathMin(0, scaleObj.domain()[0]) : 0;
                    s.y =
                    !isPolar && hasNegValue != null && scaleObj(hasNegValue) != null ?
                    mathMax(hasNegValue, scaleObj.domain()[0]) :
                    scaleObj.domain()[0];
                  } else {
                    if (isRangeChart && animationType == VERTPATHTWEEN_ANIMATION) {
                      var yArr = new Array(2);
                      var y0 = chartObj.dataset.getY(d, yaxiscolumnorder, 0);
                      yArr[0] = y0;
                      yArr[1] =
                      s[idx] == null ?
                      null :
                      hasNegValue != null && scaleObj(hasNegValue) != null ?
                      mathMax(hasNegValue, y0) :
                      y0;
                      s[idx] = yArr;
                    } else {
                      s[idx] =
                      s[idx] == null ?
                      null :
                      !isPolar && hasNegValue != null && scaleObj(hasNegValue) != null ?
                      mathMax(hasNegValue, scaleObj.domain()[0]) :
                      scaleObj.domain()[baseIdx];
                    }
                  }
                  return s;
                });
              }
              basedataShift = d3_values(baseData);
            }

            var ishideable = currentdata.disabled;
            var subseries = appendEle(
            series,
            'g',
            function (d) {
              return ishideable ? [] : [d];
            },
            '.',
            'class', "subseries_".concat(
            i));

            var path = subseries.selectAll('path.area').data(function (d) {
              return ishideable ? [] : [d];
            });

            var pathEnter = path.
            enter().
            append('path').
            datum(baseData, function (d) {
              return dataset.getX(d);
            }).
            attr('class', 'area').
            style('opacity', fillOpacity).
            style('fill', color).
            attr('d', area[i]);

            if (isAnimationEnable) {
              if (animationType == POINTBYPOINT_ANIMATION || animationType == POINTTWEEN_ANIMATION) {
                interTween(
                baseData,
                basedataShift,
                serData,
                categories,
                animationType,
                easingType,
                transitionDuration,
                rp,
                function (d) {
                  return {
                    d: area[i](d)
                  };
                },
                pathEnter);

              } else if (pathEnter.node() != null && animationType == STROKETWEEN_ANIMATION) {
                //For stacked chart, check again
                pathEnter.
                transition().
                duration(0).
                delay(transitionDuration).
                attr('d', function (d) {
                  return area[i](d);
                });
              } else {
                var isEmpty = !serData.length || serData.length == 1 && !serData[0].length;
                isEmpty = stacked ? serData.length == dummyDataLength : isEmpty;
                if (isEmpty) {
                  pathEnter.attr('d', function (d) {
                    return area[i]([]);
                  });
                } else {
                  pathEnter.
                  transition().
                  duration(transitionDuration).
                  ease(easingType).
                  attrTween('d', pathTween);
                }
              }
            }

            function pathTween() {
              var interpolate = d3_interpolate(area[i](baseData), area[i](serData));
              return function (t) {
                return interpolate(t);
              };
            }
            var gradientDim = gradient_helpers.getDimension(chartObj, index);
            var fillColor = chart.fillColorFunc = getFillColor(chartObj, index, paneid, gradientDim, null, null, null, rp);

            // var ShiftedData = d3_values(serData);
            // var ShiftedData_bef = [];
            if (shiftInfo != null) {
              // ShiftedData = d3_values(serData);
              // var co = shiftInfo.count;
              // for (var k = 0; k <= co; k++) {
              //     ShiftedData.splice(k, 0, shiftInfo.point)
              // }
              //
              // for (var h = 0; h < serData.length; h++) {
              //     ShiftedData_bef[h] = []
              //     ShiftedData_bef[h][0] = serData[h][0]
              //     ShiftedData_bef[h][1] = (h == 0) ? shiftInfo.point[1] : serData[h - 1][1]
              // }
              // ShiftedData_bef.push(["dummmy", serData[serData.length - 1][1]])

              if (redraw) {
                // var markerWidth = (chartObj.dataObject.totalnoofdatas <= maxLimit) && markerEnabled
                var clipX = xscale(serData[0][0]) + (xscale.bandwidth != null ? xscale.bandwidth() / 2 : 0);
                var clipWid =
                chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                serData[serData.length - 1],
                'x') -
                chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, serData[0], 'x');

                var properties = {
                    name: 'rect',
                    id: chartObj.id,
                    x: clipX,
                    y: 0,
                    width: clipWid,
                    height: chartObj.plotarea.height
                  },
                  args = {
                    chartObj: chartObj
                  };
                var clipID = effects.get(effects.svg_clips, 'rect', properties, args);
                series.attr('clip-path', "url(".concat(defsLocation, "#").concat(clipID, ")"));
              }
            }

            var dataUpdate = serData;
            var pathUpdate = pathEnter.
            merge(path).
            datum(serData, function (d) {
              return dataset.getX(d);
            }).
            styles({
              opacity: fillOpacity,
              fill: fillColor(legendOrder, null, null, gvp('fillColor') || color, NULL$1, NULL$1, NULL$1, NULL$1, i)
            });

            if (shiftInfo != null) {
              var transX =
              shiftInfo != null ?
              Math.abs(
              chartObj.dataObject.getXYvalue(
              axisrotated,
              stacked,
              chart.oldXscale,
              yscale,
              yaxiscolumnorder,
              serData[0],
              'x',
              null,
              yrangePos) -

              chartObj.dataObject.getXYvalue(
              axisrotated,
              stacked,
              xscale,
              yscale,
              yaxiscolumnorder,
              serData[0],
              'x',
              null,
              yrangePos)) :


              null;
              path.datum(dataUpdate).
              attr('d', area[i]).
              attr('transform', null).
              transition().
              duration(transitionDuration).
              ease(easingType).
              attr('transform', function () {
                return transX == null ? null : "translate(-".concat(transX, ",0)");
              });
            } else {
              var race_syncTrans = chartObj.racing && chartObj.racing.syncTransition;
              if (pathEnter.node() != null && animationType == STROKETWEEN_ANIMATION) {
                if (race_syncTrans) {
                  pathUpdate.
                  datum(dataUpdate).
                  style('fill-opacity', 0).
                  transition(race_syncTrans).
                  attr('d', area[i]).
                  style('fill-opacity', null);
                } else {
                  pathUpdate.
                  datum(dataUpdate).
                  style('fill-opacity', 0).
                  transition().
                  duration(0).
                  delay(transitionDuration).
                  attr('d', area[i]).
                  style('fill-opacity', null);
                }
              } else {
                if (race_syncTrans) {
                  pathUpdate.
                  datum(dataUpdate).
                  style('fill-opacity', null).
                  transition(race_syncTrans).
                  attr('d', area[i]);
                } else {
                  pathUpdate.
                  datum(dataUpdate).
                  style('fill-opacity', null).
                  transition().
                  delay(
                  (animationType == POINTBYPOINT_ANIMATION || animationType == POINTTWEEN_ANIMATION) &&
                  pathEnter.node() != null ?
                  transitionDuration :
                  0).

                  duration(transitionDuration).
                  ease(easingType).
                  attr('d', area[i]);
                }
              }
            }
            setOpacityForTickFilterElements(pathUpdate, chartObj, cType);

            if (chartObj.dataObject.hierarchical) {
              pathUpdate.attr('levelbycolumn', function (d, i) {
                return d[0] && d[0].levelByColumn;
              });
              if (chartObj.dataObject.pivot) {
                pathUpdate.attr('levelbyrow', function (d, i) {
                  return d[0] && d[0].levelByRow;
                });
              }
            }
            path.exit().remove();
          });

          chart.getSymbolSize = line.getSymbolSize;
          if (!(borderEnabled || markerEnabled)) {
            if (isRangeChart) {
              labelQueue.push({
                renderer: chart,
                charttype: 'scatter',
                chartObj: chartObj,
                paneid: paneid,
                args: [currentdata, legendOrder, 0, 1]
              });
              labelQueue.push({
                renderer: chart,
                charttype: 'scatter',
                chartObj: chartObj,
                paneid: paneid,
                args: [currentdata, legendOrder, 0, 0]
              }); //last argument in args for yrangePos
            } else {
              labelQueue.push({
                renderer: chart,
                charttype: 'scatter',
                chartObj: chartObj,
                rendererIndex: rendererIndex,
                paneid: paneid,
                args: [currentdata, legendOrder, 0]
              });
            }
          }
        });
        var chartInstance = commonRendererProp.params.chartObj;
        chartInstance.timerObj[chartInstance.timerObj.length] = chart.renderedTimer = setTimeout(function () {
          chart.chartRendered = true;
          redraw = true;
        }, transitionDuration);
        chart.oldXscale = xscale;
        return chart;
      }
      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          chart.highlighter = chartObj.dataObject.isPolarAxisCategory ?
          new WebHighlighter(chartObj, chart) :
          new AreaHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };

      return chart;
    };

    //$Id$

    function evalMarkerCorrection(_) {
      var _scale = this,
        data = _.data,size = _.size,position = _.position,scale = _.scale;
      // TODO: check this
      scale = invokeFunction(scale, _scale) || function (d) {return d;};
      var domain = invokeFunction(scale.domain),
        bandwidth = invokeFunction(scale.bandwidth) || 0,
        range = isFunction(position) ? [scale(domain[0]), scale(domain[domain.length - 1]) + bandwidth] : [0, 0],
        bbs = MeasureMarker(data, { size: size, position: position, scale: scale, _this: _scale });

      var bound = d3_extent(d3_merge([d3_extent(bbs, function (bb) {return bb.x;}), d3_extent(bbs, function (bb) {return +(bb.x + bb.width).toFixed(12);}), [0]]));

      if (!_modularized.scaleCorrection) {
        var c = bubbleCorrection(scale, bound, _scale);
        if (c) {
          return c;
        }
      }

      return [mathMax(range[0] - bound[0], 0), mathMax(bound[1] - range[1], 0)];
    }

    function MeasureMarker(data, _args) {
      var scale = _args.scale,size = _args.size,position = _args.position,_this = _args._this,
        bandwidth = invokeFunction(scale.bandwidth) || 0;
      return data.map(function (d) {
        var s = splat(size).reduce(function (prev, cur) {return prev + invokeFunction(cur, d);}, 0),
          _position = invokeFunction(true, position, _this, d, scale),
          p = isObject(_position) ? _position.value : scale(_position) + bandwidth / 2; // TODO: enhance

        return {
          x: p - s / 2,
          y: p - s / 2,
          width: s,
          height: s
        };
      });
    }

    ScaleRegistry.add('marker-correction-evaluator', evalMarkerCorrection);

    //stack-layout.js

    /**
     * @param  {Array} data          [description]
     * @param  {Function} keyAccessor   [description]
     * @param  {Function} valueAccessor [description]
     */
    var StackLayout = function StackLayout(data, keyAccessor, valueAccessor) {
      var base = this._base = 0;
      this._extent = [];
      this._data = [];
      this._list = d3_map();

      if (data) {
        this.add.apply(this, arguments);
      }
    };

    var proto$a = StackLayout.prototype;

    /**
     * Converts and adds the data to the layout[description]
     * @param  {Array} data          [description]
     * @param  {Function} keyAccessor   [description]
     * @param  {Function} valueAccessor [description]
     */
    proto$a.add = function (data, keyAccessor, valueAccessor) {
      var layout = this,
        list = layout._list,
        extent = layout._extent,
        base = layout._base;

      data.forEach(function (d) {
        var key = keyAccessor(d),
          value = valueAccessor(d) || base,
          isRangeVal = value instanceof Array,
          sign = +(value >= base),
          entry;

        var y0, y1;

        //Initialize y0-list
        if (!list.has(key)) {
          entry = [UNDEFINED, UNDEFINED];
          entry.key = key; //saving the key is mandatory as 1 is saved in list as "1"
          entry.values = [d];
          list.set(key, entry);
        } else {
          entry = list.get(key);
          entry.values.push(d);
        }


        if (isRangeVal) {//range chart
          y0 = value[0];
          y1 = value[1];
          base = y0;
          value = value[1] - value[0];
        } else {
          y0 = entry[sign] || base,
          y1 = y0 + value;
        }


        //Save y0, y values
        d.y0 = y0;
        d.y = value;
        entry[sign] = y1;

        //Find extent
        extent = d3_extent([].concat(_toConsumableArray(extent), [y1, base]));
      });

      layout._extent = extent;
      layout._data = layout._data.concat(data);
    };

    proto$a.sort = function (keyAccessor, valueAccessor, sortAccessor) {
      var layout = this,
        list = layout._list,
        list_n = sortAccessor.call(null, layout);
      layout._list = d3_map();
      layout.add(list_n, keyAccessor, valueAccessor);
    };

    /**
     * Read the extent
     * @return {Array} [description]
     */
    proto$a.getExtent = function () {
      return this._extent;
    };

    Registry.setComponent('stackLayout', StackLayout);

    //stack-extent.js

    var proto$b = StackLayout.prototype;

    /**
     * @return {Boolean} [description]
     */
    proto$b.getAllExtents = function () {
      var layout = this;

      if (layout._keyExtents) {
        return layout._keyExtents;
      }

      var list = layout._list,
        extents = [],
        getObj = function getObj(val, d) {
          var _ = [val.key, d];
          _.sum = (val[0] || 0) + (val[1] || 0);
          return _;
        };

      list.each(function (val) {
        // Positive
        if (val[1] >= 0) {
          extents.push(getObj(val, val[1]));
        }

        // Negative
        if (val[0] < 0) {
          extents.push(getObj(val, val[0]));
        }
      });
      return layout._keyExtents = extents;
    };

    //stack-percent.js

    var proto$c = StackLayout.prototype;

    /**
     * Convert the stack data to 100% stack data
     * @param  {Array} data        [description]
     * @param  {Function} keyAccessor [description]
     */
    proto$c.toPercent = function (data, keyAccessor) {
      var layout = this,
        list = layout._list;

      data.forEach(function (d) {
        var key = keyAccessor(d),
          entry = list.get(key),
          max = entry && entry[1]; //FEATURES_BAR_19 entry is null

        if (!isNaN(max) && max != null && max != 0) {
          d.y0 /= max / 100;
          d.y /= max / 100;
        }
      });
    };

    /*
        columnData: {
            nodes:[[]],
            count: '#'
        }
         return {
            [[]]
        }
     */


    function ZC_getColumnSize(columnData, leafScale, chartObj) {
      /*
          option to get custom size columns involved
       */
      var customLeafSizeColumns = chartObj.systemConf.facets.config.columns.customLeafSizeColumns;
      var allowedColumns = customLeafSizeColumns ? d3_set(customLeafSizeColumns) : d3_set([1]),
        output = new Array(columnData.count);
      for (var i = 0; i < columnData.count; i++) {
        if (allowedColumns.has(i)) {
          var data = columnData.nodes[i],
            paneid = "0_".concat(i);

          var cType = getChartTypeByIndex(chartObj, paneid, 0),
            plotoptions = DataProcessor.helpers.getSeriesdata(chartObj, paneid, 0).plotoptions,
            commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions[cType.name],
            dataLabelsConf = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, 0, paneid),
            textContent_func = dataLabelTextContent(chartObj, null, dataLabelsConf, 'datalabels', null, 0, null, "".concat(i, "_0"));

          //find maxsize of label
          var maxSizes = data.map(function (leaf) {
              var bounds = MeasureDataLabel(leaf.data, { config: dataLabelsConf, accessor: textContent_func, chartObj: chartObj });
              return d3_max(bounds, function (_) {return _.width;});
            }),
            maxSize = d3_max(maxSizes);
          output[i] = maxSize > 0 ? maxSize : null;
        } else {
          output[i] = 'auto';
        }
      }

      return output;
    }

    //hierarchy-data-adapter.js

    function HierarchicalDataAdapter(chartInstance) {
      this.chart = chartInstance;
      this.originalSeries = chartInstance.seriesdata;
      this.initialize();
    }

    HierarchicalDataAdapter.prototype = {
      initialize: function initialize() {
        var layout = this;

        layout.hierarchyLayout = true;
        layout.dataCount = 0;
        layout.globalChartType = layout.originalSeries.type;
      },

      getCategories: function getCategories() {
        return this.categories;
      },

      getPivotLayout: function getPivotLayout() {
        return this.pivotLayout;
      }
    };

    /* ********************************** Static Functions ****************************/

    /**
     *
     * @param arr
     * @return {boolean}
     */

    HierarchicalDataAdapter.is3D = function (arr) {
      return isArray$1(arr) && isArray$1(arr[0]);
    };

    /**
     *
     * @param series
     * @return {boolean|*}
     */

    HierarchicalDataAdapter.isArrayOfSeries = function (series) {
      return HierarchicalDataAdapter.is3D(series.data) && defined(series.seriesname);
    };

    /**
     *
     * @param arr
     * @return {{}}
     */

    HierarchicalDataAdapter.keysObject = function (arr) {
      var t = {};
      if (arr && arr.length) {
        arr.forEach(function (el) {
          t[el.value] = el;
        });
      }
      return t;
    };

    DataProcessor.HierarchicalDataAdapter = HierarchicalDataAdapter;
    // $ZC.HierarchicalDataAdapter = HierarchicalDataAdapter;

    // (function() {

    function HierarchicalOrdinalDataAdapter(chartInstance) {
      DataProcessor.HierarchicalDataAdapter.call(this, chartInstance);
      this.dataType = ORDINAL_DATATYPE;
      this.categoryTree = true;
      this.gridOptions = {};
      this.legendOptions = {};
      this.update(true);
    }

    /**
     *
     * @type {{process: process, getSeries: getSeries, searchHierarchy: searchHierarchy}}
     */

    var hierarchicalOrdinalDataAdapter = {
      calculatePivotLayout: function calculatePivotLayout() {
        var helpers = this.pivotHelpers(),
          component = this.pivot ? Registry.getComponent('PivotLayout') : new Registry.getComponent('LayerHierarchyLayout'),
          pivot = this.pivot ?
          new component({ seriesname: 'root', data: this.originalSeries }, helpers) :
          new component(this.originalSeries, helpers);

        this.pivotLayout = pivot;
      },
      hasRows: function hasRows() {
        var rowList = this.pivotLayout.getRootNodeList('row'),
          rowCount = rowList.getCount(),
          hasMultiCluster = rowList.hasMultiCluster();

        return rowCount || hasMultiCluster;
      },
      /*
      @param scale
      hooks for setting ranges for column with leafscale
       */
      setScaleForRange: function setScaleForRange(leafscale) {
        var _this = this,
          chart = this.chart;
        return {
          _padding: function _padding(nodes, points, index) {
            var scale_copy = leafscale.copy(),
              firstPt = nodes[0].node,
              lastPt = nodes[nodes.length - 1].node,
              isOrdinal = leafscale.bandwidth,
              rangeBand = isOrdinal ? scale._getDiscreteRangeBand(leafscale, index) : scale.getContinuousRangeBand(leafscale, points),
              innerPadding = isOrdinal ? rangeBand.rangeBand : rangeBand.rangeBand / 2,
              outerPadding = rangeBand.outerPaddingInPixel;

            leafscale.firstPt = firstPt;
            leafscale.lastPt = lastPt;
            leafscale.innerPadding = innerPadding;
            leafscale.outerPadding = outerPadding;
            leafscale.span = isOrdinal ? leafscale.bandwidth() : null;

            if (!defined(index)) {
              leafscale._innerPadding = innerPadding;
              leafscale._outerPadding = outerPadding;
            }
          },

          _scale: leafscale,
          pointProperty: leafscale.bandwidth ? 'index' : 'point',
          _rangeInfo: function _rangeInfo() {
            var isHorizontal = chart.axes.x.orient == 'top' || chart.axes.x.orient == 'bottom',
              startPos = isHorizontal ? 0 : chart.plotarea.height,
              sign = isHorizontal ? 1 : -1;
            return {
              sign: sign,
              startPos: startPos
            };
          },
          _hasDynamicLeafScale: function _hasDynamicLeafScale() {
            return _this.dynamicLeafScale;
          },
          _haUniformLeafScale: chart.systemConf.chart.axes.xaxis.uniformLeafScale
        };
      },
      setGridOptions: function setGridOptions() {
        var hierarchical = this,
          chartObj = hierarchical.chart,
          gridOptions = hierarchical.gridOptions,
          legendOptions = hierarchical.legendOptions,
          pivotLayout = hierarchical.pivotLayout,
          layers = pivotLayout.layers,
          hasMultiLayers = layers.isLayerNode,
          rowList = hierarchical.pivotLayout.getRootNodeList('row'),
          hasMultiCluster = rowList.hasMultiCluster(),
          panes = layers.panes,
          gridlist = objectValues(panes),
          globalChartType = hierarchical.chart.seriesdata && hierarchical.chart.userdata.seriesdata.type,
          nonAxisSingleSeries = !(chartObj.dataObject.isAxisCategory || chartObj.dataObject.isNonAxisMultiSeriesCategory);
        gridlist.forEach(function (grid, gridIdx) {
          var colors = new Array(0),
            chartTypes = new Array(0),
            legendIndices = new Array(0);
          var paneid = "".concat(grid.row, "_").concat(grid.column);
          var legendNewConfig = chartObj.systemConf.legend.color && chartObj.systemConf.legend.color[grid.layer],
            legendColors = legendNewConfig && legendNewConfig.colors || [];
          var layerIdx = grid.layer,
            layers = hierarchical.pivotLayout.layers.groups[layerIdx];
          var data = grid.data;
          data.forEach(function (d, i) {
            var legendIdx = layers.indexOf(d.value);
            var idx = hasMultiCluster ? hasMultiLayers ? legendIdx : gridIdx : legendIdx;
            colors.push(
            d.node.color || legendColors[i] || hierarchical.chart.mainSeriesColor[idx % hierarchical.chart.mainSeriesColor.length]);

            var defaultType = hierarchical.chart.chartTypes[i] ? hierarchical.chart.chartTypes[i].value : globalChartType;
            chartTypes.push(DataProcessor.helpers.getChartType(pick(d.node.type, globalChartType), 'object'));
            legendIndices.push(idx);
          });
          gridOptions[paneid] = gridOptions[paneid] || {};
          gridOptions[paneid].renderer = new Array(0);
          gridOptions[paneid].colors = colors;
          gridOptions[paneid].chartTypes = chartTypes;
          gridOptions[paneid].legendOrder = grid.layer;
          gridOptions[paneid].legendIndices = legendIndices;
          if (!legendOptions[grid.layer]) {
            legendOptions[grid.layer] = {
              colors: colors
            };
          }
        });
      },
      setDummyDomainForClusters: function setDummyDomainForClusters(columnSizeInfo, leafScale) {
        var hierarchical = this,
          chartObj = hierarchical.chart,
          pivotLayout = hierarchical.pivotLayout,
          nodeList = pivotLayout.getRootNodeList('column'),
          totalCustomLeafSize = 0,
          customCount = 0;

        //Find total leaf size generated
        columnSizeInfo.map(function (d) {
          if (d && d !== 'auto') {
            totalCustomLeafSize += d;
            customCount++;
          }
        });
        //Find available plot size
        var scaleRange = leafScale.range();
        var plotSize = mathAbs(scaleRange[1] - scaleRange[0]),
          newPlotSize = plotSize - totalCustomLeafSize;

        var tempScale = d3_scaleOrdinal().
        domain(d3_range(leafScale.domain().length - customCount)).
        range([0, newPlotSize]);
        // var newCSize = (newPlotSize / (leafScale.domain().length - customCount));
        var bw = tempScale.bandwidth();
        columnSizeInfo.map(function (d, i) {
          if (d && d !== 'auto') {
            var childCount = nodeList.getNodesForClusterSet(0, i).length;
            var newCSize = bw * childCount;
            hierarchical.dynamicLeafScale = true;
            var extendedCategoriesCount = 0,
              maxColumnSize = d;
            if (maxColumnSize > newCSize) {
              extendedCategoriesCount = mathMin(mathCeil(maxColumnSize / newCSize), 5);
            }

            //add dummy category in pivot entries
            if (extendedCategoriesCount) {
              var clusterSet = nodeList.clusters[0].entries.get("".concat(i, "_"));
              clusterSet.customDomain = d3_map();
              var customDomain = new Array(extendedCategoriesCount);
              var mapObj = {
                count: extendedCategoriesCount,
                values: customDomain
              };
              for (var i = 0; i < extendedCategoriesCount; i++) {
                customDomain[i] = "domain_".concat(i);
              }
              clusterSet.customDomain.set(0, mapObj);
            }
          }
        });
      },
      getDynamicColumnSize: function getDynamicColumnSize(leafScale, customSize) {
        var hierarchical = this,
          chartObj = hierarchical.chart,
          pivotLayout = hierarchical.pivotLayout,
          nodeList = pivotLayout.getRootNodeList('column'),
          leafSizeCallback = chartObj.systemConf.facets.config.columns.leafSize,
          columnInfo;
        //TOdo
        customSize = chartObj.plotarea.width;

        if (nodeList.count || nodeList.leafCount) {
          //start
          var datatype = nodeList.clusters[0].datatype;
          if (datatype == ORDINAL_DATATYPE) {
            if (nodeList.count) {
              var nodeData = nodeList.branches[0].domain.map(function (d, i) {
                return nodeList.getNodesForClusterSet(0, i);
              });
              var info = {
                nodes: nodeData,
                count: nodeData.length
              };
              if (leafSizeCallback == 'default') {
                columnInfo = ZC_getColumnSize(info, leafScale, chartObj);
              } else {
                columnInfo = invokeFunction(leafSizeCallback, info, leafScale, chartObj);
              }
              this.setDummyDomainForClusters(columnInfo, leafScale);
            }
            //end
            return;
          }
        }
      },
      getNodeValueByColumnIdx: function getNodeValueByColumnIdx(point, colidx, levelindex) {
        var chart = this.chart,
          facets = chart.userdata.facets,
          rowIndices = chart.dataset.rowIndices,
          columnIndices = chart.dataset.columnIndices;
        var tag, depth, inverseDepth, nodeIdx;
        if (chart.dataObject.pivot) {
          var rowDepth = rowIndices.indexOf(colidx);
          if (rowDepth != -1) {
            tag = 'row';
            depth = rowDepth;
            inverseDepth = rowIndices.length - 1 - rowDepth;
            nodeIdx = point.levelByRow.split('_')[depth];
          } else {
            var columnDepth = columnIndices.indexOf(colidx);
            tag = 'column';
            depth = columnDepth;
            inverseDepth = columnIndices.length - 1 - columnDepth;
            nodeIdx = point.levelByColumn.split('_')[depth];
          }
        } else {
          tag = 'column';
          depth = levelindex - 1;
          inverseDepth = chart.axes.x.count - 1 - levelindex;
          nodeIdx = point.levelByColumn.split('_')[depth];
        }
        var nodeList = chart.dataObject.hierarchical.pivotLayout.getRootNodeList(tag),
          domainList = nodeList.getDomainForBranch(inverseDepth),
          nodeValue = domainList[nodeIdx];

        return nodeValue;
      },
      /*
      Hooks used for both pivot and layer hierarchy model
       */
      pivotHelpers: function pivotHelpers() {
        var _this = this,
          chart = this.chart,
          allDistinctSeriesTypes_val = chart.distinctChartTypes || getDistinct(getAllSeriesTypes(chart.userdata)),
          allChartTypes_num = allDistinctSeriesTypes_val.map(function (_) {return charttype[_];});
        var helpers = {};

        helpers.children = function (node) {
          var hasChildren = PreProcessor.helpers.hasInnerSeries(node);
          if (hasChildren) {
            return node.data;
          } else if (node.data) {
            var is3d = DataProcessor.helpers.is3D(node.data),
              is1d = !is3d && node.data.length && node.data[0].constructor !== Array,
              nodeData = is3d ? d3_merge(node.data) : is1d ? [node.data] : node.data,
              hasSomeDefinedData = nodeData.length ?
              nodeData.some(function (d) {
                return helpers.isDefined(d);
              }) :
              true,
              isEmpty = !nodeData.length || nodeData.length == 1 && !nodeData[0].length || !hasSomeDefinedData;

            return isEmpty ? null : nodeData;
          }
          return null;
        };
        helpers.nodeType = function (node, depth1) {
          var depth = node ? pick(depth1, node.depth) : depth1,
            axes = chart.userdata.metadata.axes,
            yindices = d3_merge(axes.y),
            columns = chart.userdata.metadata.columns,
            facets = chart.userdata.facets,
            mappedIndices = mapColumnIndexToLevelIndex(facets, columns),
            rowIndices = facets ?
            chart.dataset.rowIndices ||
            facets.rows.filter(function (d) {
              return yindices.indexOf(d) == -1;
            }) :
            mappedIndices.rows,
            columnIndices = facets ?
            chart.dataset.columnIndices ||
            facets.columns.filter(function (d) {
              return axes.x.indexOf(d) == -1;
            }) :
            mappedIndices.columns,
            columnIdx = mappedIndices.columns.indexOf(depth),
            rowIdx = mappedIndices.rows.indexOf(depth),
            layerIdx = mappedIndices.color.indexOf(depth),
            isColumn = columnIdx != -1,
            isRow = rowIdx != -1,
            isLayer = layerIdx != -1; //TODO alt for indexof

          chart.dataset.rowIndices = rowIndices;
          chart.dataset.columnIndices = columnIndices;

          var hasChildren = node ? node.node.data : true; //PreProcessor.helpers.hasInnerSeries(tree);

          if (node) {
            /*
                    In pivot model, if row/column datatype is ordinal and has no child, we need to process
                    separately by pushing to leaves.
                 */
            var hasGrandNode = PreProcessor.helpers.hasInnerSeries(node);
            node.hasInnerChild = true;
            if (_this.pivot) {
              node.hasInnerChild = hasGrandNode;
            }
          }

          if (isColumn && hasChildren) {
            var isFirstColumn = columnIdx == 0,
              isLastColumn = columnIdx == columnIndices.length - 1;
            if (node && isFirstColumn) {
              node.firstColumn = isFirstColumn;
            }
            if (node && isLastColumn) {
              node.lastColumn = isLastColumn;
            }

            return 'column';
          } else if (isRow && hasChildren) {
            var isFirstRow = rowIdx == 0,
              isLastRow = rowIdx == rowIndices.length - 1;
            if (node && isFirstRow) {
              node.firstRow = isFirstRow;
            }
            if (node && isLastRow) {
              node.lastRow = isLastRow;
            }

            if (node && !node.hasInnerChild && mappedIndices.color.length) {
              node.mainTag = 'layer';
            }
            return 'row';
          } else if (isLayer && hasChildren) {
            if (node) {
              node.layer = facets && facets.color;
            }
            return 'layer';
          } else {
            return 'leaf';
          }
        },
        helpers.data = function (node) {
          var hasChildren = PreProcessor.helpers.hasInnerSeries(node);
          if (hasChildren) {
            return node.data;
          } else if (node.data) {
            var is3d = DataProcessor.helpers.is3D(node.data),
              is1d = !is3d && node.data.length && node.data[0].constructor !== Array,
              nodeData = is3d ? node.data : is1d ? [[node.data]] : [node.data];
            node.data = nodeData;
            return nodeData;
          } else {
            return node;
          }
        },
        helpers.isEmpty = function (node) {
          var hasChildren = helpers.children(node);
          return !hasChildren;
        },
        helpers.dataType = function (node, depth1) {
          var type = node.tag,
            depth = pick(depth1, node.depth),
            axes = chart.userdata.metadata.axes,
            columns = chart.userdata.metadata.columns,
            facets = chart.userdata.facets,
            mappedIndices = mapLevelIndexToColumnIndex(facets, columns, axes),
            columnindex = mappedIndices.get(depth),
            datatype = columns[columnindex || 0].datatype,
            isBarType = allChartTypes_num.every(function (chartType) {return arrayIncludes(chartcategory.discrete, chartType);});
          if (type == 'leaf') {
            var columnInfo_rows = columns[axes.y[0][0]],
              columnInfo_columns = columns[axes.x[0]];
            datatype = {
              rows: columnInfo_rows.useDiscrete ? ORDINAL_DATATYPE : columnInfo_rows.datatype,
              columns: columnInfo_columns.useDiscrete || isBarType ? ORDINAL_DATATYPE : columnInfo_columns.datatype
            };
          }

          return datatype;
        },
        helpers.nodeName = function (node) {
          return node.seriesname || node[0];
          // if(node.seriesname){
          //     return node.seriesname;
          // }else{
          //     let column = pick(chart.dataset.getColumn('x'), {}),
          //         dataType = column.datatype,
          //         dataIndex = pick(column.dataindex, 0),
          //         hasNullFormatter = defined(column[dataType]) && defined(column[dataType].nullformatting),
          //         nullFormatter = hasNullFormatter ? column[dataType].nullformatting : null,
          //         value = node[dataIndex] || nullFormatter;
          //     return value;
          // }
        },
        helpers.layerName = function (node) {
          return node.seriesname;
        },
        helpers.isDisabledSeries = function (series) {
          return series.disabled;
        },
        helpers.isDefined = function (data) {
          var column = pick(chart.dataset.getColumn('x'), {}),
            dataType = column.datatype,
            dataIndex = pick(column.dataindex, 0),
            hasNullFormatter = defined(column[dataType]) && defined(column[dataType].nullformatting);
          return hasNullFormatter || defined(data[dataIndex]);
        },
        helpers.hasSplitLeavesColumns = function () {
          if (chart.systemConf) {
            return chart.systemConf.chart.axes.xaxis.splitLeaves;
          }
          return getPropVal(chart.userdata, 'chart.axes.xaxis.splitLeaves');
        };

        return helpers;
      },
      update: function update(init) {
        if (!init) {
          this.initialize();
        }
        this.pivot = this.isPivotModel(this.originalSeries);
        this.facetRendering = this.renderByFacet();
        this.calculatePivotLayout();
      },
      /*
      To check whether data model is pivot or of layer hierarchy
       */
      isPivotModel: function isPivotModel(root) {
        return this.pivotHelpers().nodeType(null, 0) != 'layer';
      },
      /*
      To check whether plot need to render by facet columns
       */
      renderByFacet: function renderByFacet() {
        return this.pivot || this.chart.userdata.facets && this.chart.userdata.facets.renderByFacet;
      },
      getSeries: function getSeries(seriesIndex) {
        return defined(seriesIndex) ? this.pivotLayout.series[seriesIndex] : this.pivotLayout.series;
      }
    };

    /**
     *
     * @param {facets, columns}
     * @Generate map column indices to hierarchical depth of the data
     */
    function mapColumnIndexToLevelIndex(facets, columns) {
      var mappedIndices = {
          rows: [],
          columns: [],
          color: []
        },
        arr = ['rows', 'columns', 'color'];
      if (facets) {
        arr.map(function (d) {
          if (facets[d]) {
            facets[d].map(function (i) {
              mappedIndices[d].push(columns[i].levelindex);
            });
          }
        });
      } else {
        mappedIndices.color.push(0); //default 0 for color indices;
        columns.map(function (d) {
          if (d.levelindex) {
            mappedIndices.columns.push(d.levelindex);
          }
        });
      }

      return mappedIndices;
    }
    /**
     *
     * @param {facets, columns}
     * @Generate map hierarchical depth to column indices
     */
    function mapLevelIndexToColumnIndex(facets, columns, axes) {
      var mappedIndices = d3_map(),
        arr = ['rows', 'columns', 'color'];
      if (facets) {
        arr.map(function (d) {
          if (facets[d]) {
            facets[d].map(function (i) {
              mappedIndices.set(columns[i].levelindex, i);
            });
          }
        });
      } else {
        mappedIndices.set(0, axes.clr[0]);
        columns.map(function (d, i) {
          if (d.levelindex) {
            mappedIndices.set(d.levelindex, i);
          }
        });
      }

      return mappedIndices;
    }

    // inherit from HierarchicalDataAdapter
    inherit(HierarchicalOrdinalDataAdapter, DataProcessor.HierarchicalDataAdapter);

    // extend all the functions
    extend(HierarchicalOrdinalDataAdapter.prototype, hierarchicalOrdinalDataAdapter);
    DataProcessor.HierarchicalOrdinalDataAdapter = HierarchicalOrdinalDataAdapter;

    Registry.setComponent('_hierarchyOrdinal', DataProcessor.HierarchicalOrdinalDataAdapter);

    // (function() {

    function HierarchicalTimeDataAdapter(chartInstance, tickValues, groupOrder, isDiscrete, columnInfo) {
      DataProcessor.HierarchicalDataAdapter.call(this, chartInstance);

      this.dataType = TIME_DATATYPE;
      this.chart = chartInstance;
      this.columnInfo = columnInfo;

      if (isDiscrete) {
        this.groupByDiscreteTime = true;
      } else {
        this.groupByContinuousTime = true;
      }

      if (isArray$1(groupOrder)) {
        this.groupOrder = groupOrder.slice(0).reverse();
      } else if (groupOrder === 'AUTO') {
        this.groupOrder = HierarchicalTimeDataAdapter.getAutoGroupOrder(columnInfo.time.subfunction);
      }

      this.groupByTime = true; // common

      this.update(tickValues);
    }

    var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      defaultGroupOrder = ['YEAR', 'QUARTER', 'MONTH', 'WEEK', 'DAY'],
      formattingFunctions = {
        YEAR: 'YEAR',
        ABSQUARTER: 'QUARTER',
        QUARTER: 'QUARTER',
        MONTH: 'MONTH',
        ABSMONTH: 'MONTH',
        WEEK: 'WEEK',
        ABSWEEK: 'WEEK',
        ABSDAY: 'DAY'
      };

    /**
     *
     * @param {Date} d
     * @returns {string}
     */

    function getMonth(d) {
      return months[d.getMonth()];
    }

    /**
     *
     * @param {Date} d
     * @returns {string}
     */
    function getDay(d) {
      return days[d.getDay()];
    }

    /**
     *
     * @param {Date} d
     * @returns {number}
     */
    function getWeek(d) {
      var firstJanuary = new Date(d.getFullYear(), 0, 1);
      return mathCeil(((d - firstJanuary) / 86400000 + firstJanuary.getDay() + 1) / 7);
    }

    /**
     *
     * @param array
     * @param callback
     * @returns {*}
     */

    function groupBy$1(array, callback) {
      var key = null;
      return array.reduce(function (r, a) {
        key = callback.call(null, a);
        r[key] = r[key] || [];
        r[key].push(a);
        return r;
      }, {});
    }

    /**
     *
     * @param tickValues
     * @param columnInfo
     */
    function getDateFromTickValues(tickValues, columnInfo) {
      return tickValues.map(function (d) {
        return generateDateVal(d, null, columnInfo);
      });
    }

    /**
     *
     * @param data
     */

    function convertDateToObject(data) {
      var converter = function converter(point) {
        return {
          YEAR: point.getFullYear(),
          QUARTER: getQuarter(point),
          MONTH: getMonth(point),
          WEEK: getWeek(point),
          DAY: getDay(point),
          timestamps: point.getTime(),
          data: point
        };
      };
      return data.map(converter);
    }

    /**
     *
     * @param object
     * @param leaf
     * @param depth
     * @param isDiscreteTime
     * @returns {Array}
     */

    function toHierarchy(object, leaf, depth, isDiscreteTime) {
      var tree = [];
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          var entry = new Node(object[key], depth, depth, depth);

          tree.push(entry);

          if (leaf) {
            entry.leaf = true;
            entry.value = isDiscreteTime ? object[key].data.getTime() : object[key].data;
            entry.point = object[key].data.getTime();
            entry.tag = entry.leaf ? 'leaf' : 'column';
            entry.datatype = {
              rows: 'numeric',
              columns: isDiscreteTime ? 'ordinal' : 'time',
              _columns: 'time'
            };
            entry.seriesname = 'manual';
            entry.isDefined = true;
          } else {
            entry.value = key;
            entry.point = object[key][0].data;
            entry.children = object[key];
            entry.tag = entry.leaf ? 'leaf' : 'column';
            entry.datatype = 'ordinal';
            entry.depthbyrow = entry.tag == 'row' ? entry.depthbyrow + 1 : entry.depthbyrow;
            entry.depthbycolumn = entry.tag == 'column' ? depth : depth;
            entry.seriesname = 'manual';
            entry.isDefined = true;
          }
        }
      }
      return tree;
    }

    /**
     *
     * @type {{update: update, process: process, getPossibleGroupBy: getPossibleGroupBy}}
     */

    var timeAxisGroup = {
      setScaleForRange: function setScaleForRange(leafscale) {
        var _this = this;
        return {
          _padding: function _padding(nodes, points) {
            var scale_copy = leafscale.copy(),
              firstPt = nodes[0].node,
              lastPt = nodes[nodes.length - 1].node,
              isOrdinal = leafscale.bandwidth,
              rangeBand = isOrdinal ? scale._getDiscreteRangeBand(leafscale) : scale.getContinuousRangeBand(leafscale, points),
              innerPadding = isOrdinal ? rangeBand.rangeBand : rangeBand.rangeBand / 2,
              outerPadding = rangeBand.outerPaddingInPixel;

            leafscale.firstPt = firstPt;
            leafscale.lastPt = lastPt;
            leafscale.innerPadding = innerPadding;
            leafscale.outerPadding = outerPadding;
          },
          _rangebandForFirstBranch: function _rangebandForFirstBranch(nodes) {
            var start = nodes[0],
              end = nodes[nodes.length - 1],
              pointProperty = 'point',
              barWidth = leafscale.bandwidth ? leafscale.bandwidth() : null;

            if (_this.groupByContinuousTime) {
              barWidth = 0;

              if (defined(_this.tickValues[start.index + 1])) {
                var startTick = _this.tickValues[start.index],
                  nextTick = _this.tickValues[start.index + 1],
                  index = start.index == 0 ? start.index : start.index - 1,
                  rangeBand = scale.getContinuousRangeBand(leafscale, _this.tickValues, index),
                  innerPadding = rangeBand.rangeBand;
                // r = leafscale(nextTick) - leafscale(startTick);

                leafscale.innerPadding = innerPadding;
              }
            } else {
              pointProperty = 'index';
            }

            return (
              leafscale(end[pointProperty]) -
              leafscale(start[pointProperty]) +
              this.getSpan(start, true) +
              this.getSpan(end) +
              barWidth);

          },
          getSpan: function getSpan(point, startSide) {
            if (startSide && point === leafscale.firstPt || !startSide && point === leafscale.lastPt) {
              return leafscale.outerPadding;
            } else {
              return leafscale.innerPadding;
            }
          },
          _scale: leafscale,
          pointProperty: leafscale.bandwidth ? 'index' : 'point'
        };
      },
      update: function update(tickValues) {
        var layout = this;

        if (layout.groupByDiscreteTime) {
          tickValues = pick(layout.chart.dataObject.findXCategories(), tickValues);
        }

        layout.dataCount = 0;
        layout.tickValues = getDateFromTickValues(tickValues, layout.columnInfo);
        layout.process();

        // if (!this.pivotLayout) {
        // TODO check for the need of recalculation
        var component = new Registry.getComponent('GroupByTimeDataLayout');
        this.pivotLayout = new component({ data: this.categories });
        // }
      },

      process: function process() {
        var layout = this,
          data = layout.tickValues,
          index = 0,
          groupOrder = pick(layout.groupOrder, defaultGroupOrder),
          isDiscreteTime = layout.groupByDiscreteTime;

        var object = convertDateToObject(data, index),
          order = groupOrder.slice(0),
          key = order.shift(),
          yearlyGrouped = groupBy$1(object, function (date) {
            return date[key];
          }),
          currentDepth = 0,
          storage = toHierarchy(yearlyGrouped, false, currentDepth, isDiscreteTime);

        function group(currentObj, keys, depth) {
          var key = keys.shift(),
            grouped;
          currentObj.forEach(function (d) {
            if (key) {
              grouped = groupBy$1(d.children, function (data) {
                return data[key];
              });

              d.children = toHierarchy(grouped, false, depth, isDiscreteTime);
              group(d.children, keys.slice(0), depth + 1);
            } else {
              d.children = toHierarchy(d.children, true, depth, isDiscreteTime);
            }
          });

          return currentObj;
        }

        layout.categories = group(storage, order.slice(0), currentDepth + 1);
      },

      /**
       *
       * @param {[Date]} data array of dates
       * @param {array} groupOrder
       * @returns {string}
       */

      getPossibleGroupBy: function getPossibleGroupBy(data, groupOrder) {
        var startTime = data[0],
          endTime = data[data.length - 1],
          isSameYear = startTime.getFullYear() === endTime.getFullYear(),
          groupByObject = groupOrder[0];

        var timeDiff = data[data.length - 1] - data[0];
        var absoluteTime = millisecondToAbsoluteTime(timeDiff);

        for (var property in absoluteTime) {
          if (absoluteTime.hasOwnProperty(property)) {
            if (absoluteTime[property] > 1 || property === 'YEAR' && !isSameYear) {
              groupByObject = property;
              break;
            }
          }
        }
        return groupByObject;
      }
    };

    /**
     *
     * @param {String} formattingFunction
     * @returns {Array.<string>}
     */
    HierarchicalTimeDataAdapter.getAutoGroupOrder = function (formattingFunction) {
      var index = defaultGroupOrder.indexOf(formattingFunctions[formattingFunction]);
      return defaultGroupOrder.slice(0, index);
    };

    // inherit from HierarchicalDataAdapter
    inherit(HierarchicalTimeDataAdapter, DataProcessor.HierarchicalDataAdapter);

    // extend timeAxisGroup
    extend(HierarchicalTimeDataAdapter.prototype, timeAxisGroup);

    DataProcessor.HierarchicalTimeDataAdapter = HierarchicalTimeDataAdapter;

    /**
     *
     * @param correctionFactor
     * @returns {[number,number]}
     */

    DataProcessor.prototype.getMinMaxX = function (correctionFactor) {var applyZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var systemconf = this.chartObj.systemConf,
        columnInfo = this.dataset.getColumn('x'),
        rangeOperators = {};
      var orient = getAxisOrient('x', this.chartObj.axes.rotated);
      rangeOperators.plotBound = {
        dimension: orient == BOTTOM_ALIGN || orient == TOP_ALIGN ? 'width' : 'height',
        customPlotBound: this.chartObj.systemConf.chart,
        plotSize: this.chartObj.plotarea,
        defaultPlotSize: this.chartObj.plotarea,
        boundExtreme: 0
      };
      var domainOperators = numericAxisParser('x', index, this.chartObj, correctionFactor, null, applyZoom, true);
      var parser = {
        type: 'numeric',
        field: columnInfo,
        scaleType: columnInfo.scaleType,
        reverse: this.xaxisData.reversed,
        data: [],
        domain: {
          operators: domainOperators,
          evaluator: expressionEvalDomainForLinear
        },
        range: {
          operators: rangeOperators,
          evaluator: expressionEvalRangeForLinear
        },
        outerPadding: correctionFactor
      };
      if (this.chartObj.viewFlow && this.chartObj.viewFlow.scales[columnInfo.id]) {
        extendScaleParser(parser, this.chartObj.viewFlow.scales[columnInfo.id].conf);
      }
      // if (systemconf.viewParser) {
      //     if (systemconf.viewParser.scale && systemconf.viewParser.scale[columnInfo.name]) {
      //         extendScaleParser(parser, systemconf.viewParser.scale[columnInfo.name]);
      //     }
      // }
      var newScale = new Scale('x', index, parser, this.chartObj);
      var domain = newScale._parseDomain();
      if (!this.xRange) {
        this.xRange = newScale.config.tempDomain;
      }
      // this.hasNegativeValue[index] = newScale.config.hasNegativeValue && newScale.config.hasNegativeValue[index];

      return domain;

      /*
      SCALE PARSER
       */
      var processor = this,
        xAxisConfig = processor.xaxisData,
        seriesData = processor.processedseriesData,
        chart = processor.chartObj,
        dataSet = processor.dataset,
        customMin = xAxisConfig.minRange,
        customMax = xAxisConfig.maxRange,
        dataType = dataSet.getDataType('x'),
        temp,
        extendX = processor.xRange,
        axisObj = getAxisObject(chart, 'x'),
        columnInfo = dataSet.getColumn('x');

      correctionFactor = pick(correctionFactor, 0.05);

      if (columnInfo.scaleType === LOG) {
        correctionFactor = 0;
        if (defined(axisObj.logDomain)) {
          return axisObj.logDomain;
        }
      }

      // [**MIGRATION**] zoom --> brush
      // if zoom range is defined, use it by default.
      // #ZC2016 $index
      if (isObjectPropDefined(chart.systemConf, "chart.brush.x[".concat(index, "]")) && applyZoom) {
        var xRange = chart.systemConf.chart.brush.x[index];
        return [xRange.minRange, xRange.maxRange];
      }

      if (!defined(extendX)) {
        temp = seriesData.map(function (d) {
          return d.data.map(function (d) {
            return d3_extent(d, function (d) {
              return dataSet.getX(d);
            });
          });
        });

        var xAxis = pick(getPropVal(chart.userdata, 'chart.axes.xaxis'), {});
        extendX = processor.xRange = d3_extent(d3_merge(d3_merge(temp)).concat(getThresholdValues(xAxis)));
      }

      if (processor.isBubbleEnabled && dataType !== TIME_DATATYPE && !defined(customMin) && !defined(customMax)) {
        temp = processor.overBubbles(extendX, 'x');
        extendX = [extendX[0] - temp[0], extendX[1] + temp[1]];
      }

      if (DataProcessor.helpers.hasMarkerCorrection() && dataType !== TIME_DATATYPE) {
        temp = processor.overMarker(extendX, 'x', correctionFactor);
        extendX = [extendX[0] - temp[0], extendX[1] + temp[1]];
      }

      var correctionOverDatalabels = 0,
        diff,
        correction;

      // no need to find correction datalabel,if correction factor is 0
      if (dataType !== TIME_DATATYPE && correctionFactor !== 0) {
        //TODO mismatch with minmaxy
        correctionOverDatalabels = processor.getCorrectionOverDataLabels(extendX, 'x');
      }

      diff = extendX[1] - extendX[0];

      if (diff === 0) {
        diff = 1;
      }

      correction = diff * correctionFactor + correctionOverDatalabels;
      return [pick(customMin, extendX[0] - correction, 0), pick(customMax, extendX[1] + correction, 0)];
    };

    /**
     *
     * @param {String} type chart type
     * @param {number} index series index
     */

    DataProcessor.prototype.getCategories = function (type, index) {var applyZoom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var filterIndexes = arguments.length > 3 ? arguments[3] : undefined;
      var processor = this,
        chart = processor.chartObj,
        hierarchical = processor.hierarchical,
        categoriesStore = processor.categoriesStore,
        categories,
        filterByIndex =
        defined(hierarchical) && hierarchical.categoryTree && type === 'x' && index === 0 || chart.dataObject.isWaterfallEnabled,
        systemconf = chart.systemConf;

      index = index || 0;
      // #ZC2016 $index
      if (applyZoom && isObjectPropDefined(systemconf, "chart.brush.".concat(type, "[").concat(index, "].categories"))) {
        filterIndexes = systemconf.chart.brush[type][index].categories;
        if (!filterByIndex) {
          return filterIndexes;
        }
      }
      if (systemconf.viewParser && systemconf.viewParser.scales) {
        var metaData = systemconf.metadata,
          column_id = metaData.columns[metaData.axes[type][index]].id,
          customScaleParser;
        systemconf.viewParser.scales.map(function (scale) {
          if (scale.id === column_id) {
            customScaleParser = scale;
          }
        });
        var customExtremes_parser =
        isObjectPropDefined(customScaleParser, 'domain.operators.extremes') && customScaleParser.domain.operators.extremes;

        if (customExtremes_parser && isArray$1(customExtremes_parser[0])) {
          return simpleClone(customExtremes_parser[0]);
        }
      }
      if (!(processor.isAxisCategory || processor.isPolarAxisCategory || chart._isAxisCategory())) {
        //TODO: remove
        return [];
      }

      var rowList, columnList;

      if (hierarchical) {
        rowList = hierarchical.pivotLayout.getRootNodeList('row');
        columnList = hierarchical.pivotLayout.getRootNodeList('column');
      }
      if (type === 'x') {
        if (defined(hierarchical) && hierarchical.groupByTime) {
          // for time group
          if (index > 0) {
            categories = columnList.getDomainForBranch(index - 1);
          } else {
            // for time grouped bar chart in leaf category return the original categories.
            // #ZC1253 && #ZC1257
            categories = hierarchical.groupByDiscreteTime ?
            pick(processor.xaxisData.categories, categoriesStore.x.sort(d3_ascending)) :
            columnList.getDomainForCluster(0);
          }
        } else if (hierarchical) {
          // normal multi level axis.
          var leavesCount = columnList.getLeavesCount(),
            columnCount = columnList.getCount();
          var uniformLeafScale = systemconf.chart.axes.xaxis.uniformLeafScale;
          categories =
          index > leavesCount - 1 ?
          columnList.getDomainForBranch(index - leavesCount) :
          leavesCount > 1 ?
          uniformLeafScale ?
          columnList.getUniqueDomainForCluster(0) :
          columnList.getDomainForClusterSet(0, index) :
          columnCount //check  axis.categories only for data with no columns
          ? columnList.getDomainForCluster(0) :
          processor.xaxisData.categories || columnList.getDomainForCluster(0);
        } else {
          categories = processor.xaxisData.categories;
        }
        index = ''; // this will save a condition. see id=1
      } else {
        if (defined(hierarchical) && (rowList.getCount() || rowList.hasMultiCluster())) {
          // normal multi level axis.
          //CHECK for ordinal category case!!!!
          categories =
          rowList.getCount() && index > rowList.getLeavesCount() - 1 ?
          rowList.getDomainForBranch(index - rowList.getLeavesCount()) :
          rowList.getDomainForCluster(0);
        } else {
          categories = processor.yaxesData[index].categories;
        }
      }

      if (!defined(categories) || categories.length === 0) {
        categories = categoriesStore[type + index]; // id=1
      }

      if (type === 'y' && !hierarchical && !categoriesStore["y".concat(index)].enabled) {
        categories = ['NoData', 'NoData']; // Axis is filtered
      }

      // #ZC2027
      if (filterByIndex && isArray$1(filterIndexes)) {
        categories = filterIndexes.map(function (i) {return categories[i];});
      }

      return categories;
    };

    function getSizeFromPoint(d, dataSet, chartObj) {
      var val = dataSet.getZ(d),
        scaleComponent = arrayFind(chartObj.scales, function (_) {return _.id === 'z-0';}),
        scale = scaleComponent.scale,config = scaleComponent.config,schema = scaleComponent.schema,
        dataType = schema.data.dataType,
        nullAs = config.nullAs;

      if (isUndefined(val)) {
        if (defined(nullAs)) {
          var nullAsOptions = { config: config, scale: scale, columnKey: chartObj.dataset.getColumnIdx('z') };
          return scale(convertNull(val, nullAsOptions));
        } else if (dataType === ORDINAL_DATATYPE) {
          return scale(val);
        } else {
          return scale(scale.domain()[0]);
        }
      }

      return scale(val);
    }

    /**
     *
     * @param axisrotated
     * @param stacked
     * @param xscale
     * @param yscale
     * @param yaxiscolumnorder
     * @param d
     * @param type
     * @param zscale
     * @param yrangePos
     * @returns {*}
     */

    DataProcessor.prototype.getXYvalue = function (axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, type, zscale, yrangePos) {
      var model = this,
        yaxesData = this.yaxesData,
        dataset = this.dataset,
        chartObj = this.chartObj;

      if (model.isPolarAxisCategory) {
        var baseIdx = yaxesData[yaxiscolumnorder].reversed && !stacked ? yscale.domain().length - 1 : 0;
        var a = xscale(dataset.getX(d)),
          r = stacked ?
          yscale(d.y + d.y0) :
          yscale(dataset.getY(d, yaxiscolumnorder)) + (yscale.bandwidth != null ? yscale.bandwidth() / 2 : 0);
        r = mathMax(r, yscale.range()[baseIdx]);
        var xy = polarToXY(r, a);
        return type === 'x' ? xy[0] : xy[1];
      } else if (model.isFlowChartCategory) {
        var centroid = d._centroid;
        if (!d._centroid || chartObj.phase === 'legendFilter') {
          var polygon = this.chartObj.renderer[0].highlighter.getPolygon(d);
          centroid = polygon.length > 1 ? d._centroid = d3_polygonCentroid(polygon) : polygon[0];
        }
        return type === 'x' ? centroid[0] : centroid[1];
      }
      switch (type) {
        case 'x':
          if (axisrotated) {
            return stacked ?
            yscale(d.y + d.y0) :
            yscale(dataset.getY(d, yaxiscolumnorder, yrangePos)) + (yscale.bandwidth != null ? yscale.bandwidth() / 2 : 0);
          }
          var xval = dataset.getX(d);
          return xscale(xval) + (xscale.bandwidth != null ? xscale.bandwidth(xval) / 2 : 0);
        case 'y':
          if (axisrotated) {
            var _xval = dataset.getX(d);
            return xscale(_xval) + (xscale.bandwidth != null ? xscale.bandwidth(_xval) / 2 : 0);
          }
          return stacked ?
          yscale(d.y + d.y0) :
          yscale(dataset.getY(d, yaxiscolumnorder, yrangePos)) + (yscale.bandwidth != null ? yscale.bandwidth() / 2 : 0);
        case 'z':{
            return getSizeFromPoint(d, dataset, chartObj);
          }}

    };

    /**
     *
     * @param param
     * @param d
     * @param i
     * @param j
     * @param cp
     * @param radius
     * @param yrangePos
     * @returns {*}
     */

    DataProcessor.prototype.getTransRectValue = function (param, d, i, j, cp, radius, yrangePos) {
      var dataset = this.dataset,
        yscale = cp && cp.yscale,
        bandWidthBy2 = cp && cp.addRangeBand(yscale),
        isWaterfall = cp && cp.charttype == 'waterfall',
        hasBaseY0 = cp && cp.stacked || isWaterfall;

      var isYRange = cp && dataset.getY(d, cp.yaxiscolumnorder) instanceof Array;
      var minRange = cp && (yscale.bandwidth ? yscale.ordinalRange[0] + bandWidthBy2 : yscale.range()[0]),
        maxRange = cp && yscale.range()[1];
      this.dataset.yAccessor = this.isPercentChart ?
      function (d) {
        return d.y;
      } :
      this.dataset.getY;
      switch (param) {
        case 'x':
          if (cp.axisrotated) {
            var y = dataset.getY(d, cp.yaxiscolumnorder);
            yrangePos = yrangePos != null ? yrangePos : isYRange ? y[0] < y[1] ? 0 : 1 : null; //yrange ngeative data
            // yrangePos = isYRange ? 0 : null;
            var curY = this.dataset.yAccessor(d, cp.yaxiscolumnorder, yrangePos);
            return yscale.bandwidth ?
            yscale.origRange[0] :
            hasBaseY0 ?
            yscale(mathMin(d.y0, d.y + d.y0)) :
            yrangePos != null || isYRange ?
            yscale(curY) :
            yscale(cp.hasNegValue != null ? curY < cp.hasNegValue ? curY : cp.hasNegValue : mathMin(curY, yscale.domain()[0])); //ZC1718
          }

          var v = dataset.getX(d);
          return (
            (cp.stacked ?
            cp.bandwidth1(v) + cp.bandwidth2(cp.stackGroupIndex) :
            cp.bandwidth1(v) + cp.bandwidth2(cp.barDatasetIndex + i)) + cp.padding);

        case 'y':
          if (cp.axisrotated) {
            var v = dataset.getX(d);
            return (
              (cp.stacked ?
              cp.bandwidth1(v) + cp.bandwidth2(cp.stackGroupIndex) :
              cp.bandwidth1(v) + cp.bandwidth2(cp.barDatasetIndex + i)) + cp.padding);

          }
          var y = dataset.getY(d, cp.yaxiscolumnorder);
          yrangePos = yrangePos != null ? yrangePos : isYRange ? y[0] > y[1] ? 0 : 1 : null; //yrange ngeative data
          var curY = this.dataset.yAccessor(d, cp.yaxiscolumnorder, yrangePos);
          // var curY = isYRange ? d3_max(dataset.getY(d, cp.yaxiscolumnorder)) : this.dataset.yAccessor(d, cp.yaxiscolumnorder, yrangePos);
          return hasBaseY0 ?
          yscale(mathMax(d.y0, d.y + d.y0)) + bandWidthBy2 :
          yscale(yscale.bandwidth == null && !isYRange ? mathMax(cp.hasNegValue || 0, curY) : curY) + bandWidthBy2;
        case 'width':
          if (cp.axisrotated) {
            var curY = isYRange ?
            d3_max(dataset.getY(d, cp.yaxiscolumnorder)) :
            this.dataset.yAccessor(d, cp.yaxiscolumnorder, yrangePos);
            curY = yscale(curY);
            var basevalue =
            cp.hasNegValue == null ?
            isYRange ?
            yscale(this.dataset.yAccessor(d, cp.yaxiscolumnorder, 0)) :
            minRange :
            isYRange ?
            yscale(d3_min(dataset.getY(d, cp.yaxiscolumnorder))) :
            yscale(cp.hasNegValue);
            yrangePos = isYRange ? 1 : null;

            return yscale.bandwidth ?
            curY + bandWidthBy2 :
            hasBaseY0 ?
            mathAbs(yscale(d.y + d.y0) - yscale(d.y0)) + bandWidthBy2 :
            (mathAbs(maxRange - basevalue - (maxRange - curY)) || 0) + bandWidthBy2;
          }
          return cp.barWidth;
        case 'height':
          if (cp.axisrotated) {
            return cp.barWidth;
          }
          var curY = isYRange ? d3_max(dataset.getY(d, cp.yaxiscolumnorder)) : this.dataset.yAccessor(d, cp.yaxiscolumnorder, yrangePos);
          curY = yscale(curY) + bandWidthBy2;
          var basevalue =
          cp.hasNegValue != null && !isYRange ?
          yscale(cp.hasNegValue) :
          isYRange && !hasBaseY0 ?
          yscale(d3_min(dataset.getY(d, cp.yaxiscolumnorder))) :
          minRange;
          yrangePos = isYRange ? 1 : null;

          if (yscale.bandwidth) {
            return mathAbs(yscale.origRange[0] - curY);
          }

          return hasBaseY0 ?
          mathAbs(basevalue - yscale(d.y + d.y0) - (basevalue - yscale(d.y0))) + bandWidthBy2 :
          mathAbs(basevalue - curY);
        case 'radius':{
            return getBorderRadius(radius);
          }}

    };

    /**
     *
     * @param includeDisabled
     */

    DataProcessor.prototype.findXCategories = function (includeDisabled) {
      var processor = this,
        categoriesStore = processor.categoriesStore,
        processedseriesData = processor.processedseriesData,
        dataset = processor.dataset;

      var XCat = categoriesStore.x;

      processedseriesData.forEach(function (d, i) {
        var disabled = d.disabled && !includeDisabled,
          curdata = d.data;
        if (!disabled && curdata != null && curdata.constructor == Array) {
          curdata.map(function (subgroup, j) {
            if (subgroup != null && subgroup.constructor == Array) {
              return subgroup.map(function (dataPoint) {
                var xVal = dataset.getX(dataPoint);
                xVal != null && XCat.indexOf(xVal) == -1 ? XCat.push(xVal) : null;
              });
            }
          });
        }
      });
      return XCat;
    };

    //storeCategories.js

    DataProcessor.prototype.storeCategories = function (
    curdata,
    stacked,
    groupbyDataIndices,
    cType,
    actXdatatype,
    yDatatype,
    yaxiscolumnorder,
    needDuplicateCategories)
    {
      var processor = this,
        dataset = processor.dataset,
        categoriesStore = processor.categoriesStore,
        XCat = categoriesStore.x,
        yCat = categoriesStore["y".concat(yaxiscolumnorder)],
        helpers = DataProcessor.helpers;

      var isCatNullX = helpers.isCatNull(dataset, 'x'),
        isCatNullY = helpers.isCatNull(dataset, 'y', yaxiscolumnorder);

      if (stacked) {
        curdata.map(function (subgroup, j) {
          if (!curdata.disabled && isArray$1(subgroup)) {
            return subgroup.map(function (dataPoint) {
              var xVal = dataset.getActualX(dataPoint);
              var groupByVal = groupbyDataIndices.length > 0 ? dataset.getGroupByValues(dataPoint, groupbyDataIndices) : null;

              if (xVal > processor.lastCategoryValue && !processor.needXCategoriesSorting) {
                processor.lastCategoryValue = xVal;
              } else if (!processor.needXCategoriesSorting && XCat.indexOf(xVal) == -1) {
                processor.needXCategoriesSorting = true;
              }

              !isCatNullX(xVal) && (XCat.indexOf(xVal) == -1 || needDuplicateCategories) ? XCat.push(xVal) : null;

              if (groupByVal != null) {
                subgroup.groupByVal = groupByVal;
                dataPoint.groupByVal = groupByVal;
                categoriesStore.subseries.indexOf(groupByVal) == -1 ? categoriesStore.subseries.push(groupByVal) : null;
              }
            });
          }
        });
      } else if (actXdatatype === ORDINAL_DATATYPE || yDatatype === ORDINAL_DATATYPE) {
        curdata.map(function (subgroup, j) {
          if (!curdata.disabled && isArray$1(subgroup)) {
            return subgroup.map(function (dataPoint) {
              var xVal = dataset.getActualX(dataPoint),
                yVal = dataset.getY(dataPoint, yaxiscolumnorder);
              if (actXdatatype === ORDINAL_DATATYPE && !isCatNullX(xVal)) {
                needDuplicateCategories || XCat.indexOf(xVal) === -1 ? XCat.push(xVal) : null;
              }
              if (yDatatype === ORDINAL_DATATYPE) {
                if (cType === charttype.arearange || cType === charttype.gantt) {
                  defined(yVal) && yCat.indexOf(yVal[0]) === -1 ? yCat.push(yVal[0]) : null;
                  defined(yVal) && yCat.indexOf(yVal[1]) === -1 ? yCat.push(yVal[1]) : null;
                } else {
                  !isCatNullY(yVal) && yCat.indexOf(yVal) === -1 ? yCat.push(yVal) : null;
                }
              }
            });
          }
        });
      }
    };

    //stack-check.js

    /**
     *
     * @param cType
     * @returns {boolean}
     */
    DataProcessor.prototype.isstacked = function (cType) {
      var data = this.data,
        plotoptions = data.chart.plot.plotoptions,
        stackedChart = this.stackedChart,
        helpers = DataProcessor.helpers;

      if (defined(cType)) {
        var numType = helpers.getChartType(cType, NUMERIC_DATATYPE);
        cType = helpers.getChartType(cType, 'string');
        plotoptions = plotoptions[cType];

        //TODO: remove stkdbar, stkdarea chartTypes
        return (
          numType === charttype.stkdarea ||
          numType === charttype.stkdbar ||
          arrayIncludes(chartcategory.stacked, numType) && getPropVal(plotoptions, 'stacked.enabled'));

      }

      if (isUndefined(stackedChart)) {
        var allChartTypes = this.allChartTypes || helpers.getAllChartTypes(data),
          self = this;

        this.stackedChart = stackedChart = allChartTypes.some(function (chartType) {return self.isstacked.call(self, chartType);});
      }

      return stackedChart;
    };

    //stack-percent-check.js

    /**
     *
     * @returns {boolean}
     */
    DataProcessor.prototype.isStackedPercent = function () {
      var processor = this,
        seriesTypes = processor.dataset.seriesTypes,
        plotOptions = processor.data.chart.plot.plotoptions,
        checkStackedPercent = function checkStackedPercent(chartType) {return (
            seriesTypes.has(chartType) && plotOptions[charttypenames.get(chartType)].stacked.showAs === PERCENT_SHOWAS);};

      return chartcategory.stackedPercent.some(checkStackedPercent);
    };

    DataProcessor.prototype.isStackedSort = function () {
      var processor = this,
        seriesTypes = processor.dataset.seriesTypes,
        plotOptions = processor.data.chart.plot.plotoptions,
        sortAccesor,
        checkStackedSort = function checkStackedSort(chartType) {
          if (seriesTypes.has(chartType) && plotOptions[charttypenames.get(chartType)].stacked.sort) {
            sortAccesor = plotOptions[charttypenames.get(chartType)].stacked.sort;
            return true;
          }
        };

      if (chartcategory.stacked.some(checkStackedSort)) {
        return sortAccesor;
      }
      return null;
    };

    // stack-group-list

    var proto$d = DataProcessor.prototype;

    proto$d.getStackGroup = function () {
      var processor = this;

      // Non stack chart
      if (!processor.isstacked()) {
        return NULL$1;
      }

      // Serve from cache
      var cache = processor.cache;
      if (cache.stackGroup) {
        return cache.stackGroup;
      }

      // Find stack group and add to the cache
      return cache.stackGroup = processor._createStackGroup();
    };

    proto$d._createStackGroup = function () {
      var processor = this;

      var data = processor.chartObj.seriesdata,
        globalChartType = processor.globalChartType,
        helpers = DataProcessor.helpers,
        stackGroup = {},
        pushToStack = function pushToStack(key, value) {var _stackGroup$key;
          value = splat(value);
          stackGroup[key] = stackGroup[key] || [];
          (_stackGroup$key = stackGroup[key]).push.apply(_stackGroup$key, _toConsumableArray(value));
        };

      // User defined stck group
      // ZC1937
      var customStackGroup = processor.data.seriesdata.stackGroup,
        mergedCustomStackGroup;

      if (customStackGroup) {
        mergedCustomStackGroup = d3_merge(customStackGroup);
        customStackGroup.forEach(function (val, i) {
          pushToStack("user_".concat(i), val);
        });
      }

      data.forEach(function (series, seriesIndex) {
        var chartType = helpers.getChartType(series.type || globalChartType, NUMERIC_DATATYPE);

        if (processor.isstacked(chartType) && !(mergedCustomStackGroup && arrayIncludes(mergedCustomStackGroup, seriesIndex))) {
          var yaxiscolumnorder = helpers.getParsedYAxisOrder(series.yaxiscolumnorder),
            key = "".concat(yaxiscolumnorder, "_").concat(chartType);

          pushToStack(key, seriesIndex);
        }
      });

      return objectValues(stackGroup);
    };

    //cartesian-data-processor.js

    Registry.setComponent('cartesianDataProcessor', CartesianDataProcessor);
    function CartesianDataProcessor(data, dataSet, chartInstance) {
      // support variables
      this.values = [];
      this.minmaxY = [];
      this.stackeddata = [];
      this.stackedChart = null;
      this.hasNegativeValue = [];
      this.baseline = [];
      this.xRange = null;
      this.yRange = [];
      this.domainCorrections = {
        plotHeight: null,
        byDatalabels: {},
        forBubbles: {}
      };
      this.rangeCorrections = {
        datalabels: {}
      };
      this.xaxisData = data.chart.axes.xaxis;
      this.yaxesData = data.chart.axes.yaxis;
      this.qualitativeRanges = null;
      this.groupedByStack = d3_map();
      this.categoriesStore = null;

      this.hierarchical = chartInstance.preProcessor.hierarchical;
      this.categoryHierarchy = this.hierarchical && this.hierarchical.categoryTree;
      this.pivot = this.categoryHierarchy && this.hierarchical.pivot;
      this.isHierarchy = chartInstance.preProcessor.isHierarchy;

      // Super data-processor
      this.initialize = extendFunction(DataProcessor.prototype.initialize, initialize);
      DataProcessor.apply(this, arguments);
    }
    inherit(CartesianDataProcessor, DataProcessor);

    var initialize = function initialize(state) {
      var processor = this,
        domainCorrections = processor.domainCorrections,
        yaxesData = processor.yaxesData,
        allChartTypes = processor.allChartTypes,
        data = processor.data,
        chartObj = processor.chartObj,
        globalChartType = processor.globalChartType,
        dataSplicer = chartObj.dataSplicer,
        metadata_axes = dataSplicer.getEncode(),
        metadata_columns = dataSplicer.getColumns(),
        noofYaxis = metadata_axes.y.length,
        metadata = data.metadata,
        axes = metadata_axes,
        plotOptions = data.chart.plot.plotoptions,
        stacked = processor.isstacked(),
        dataset = processor.dataset,
        categoriesStore = processor.categoriesStore = {},
        processedseriesData = processor.processedseriesData,
        helpers = DataProcessor.helpers;

      if (processor.hierarchical && !processor.hierarchical.groupByTime && defined(state)) {
        processor.hierarchical.update();
        processor.chartObj.seriesdata = processor.hierarchical.getSeries();
      }

      processor.xRange = null;
      processor.yRange = [];
      processor.qualitativeRanges = null;
      processor.cache = {};

      domainCorrections.plotHeight = null;
      domainCorrections.forBubbles = {};

      processor.lastCategoryValue = 0;
      processor.isBubbleEnabled = false;
      processor.noofBarEnabledSeries = 0;
      processor.noofAreaEnabledSeries = 0;
      processor.noofAreaRangeEnabledSeries = 0;
      processor.noofBoxplotEnabledSeries = 0;
      processor.noofBarRangeEnabledSeries = 0;
      processor.noofGanttEnabledSeries = 0;
      processor.isContinousChart = true;
      processor.isPercentChart = false;

      categoriesStore.x = [];
      categoriesStore.z = [[0]];

      categoriesStore.subseries = [];
      dataset.hasNullFormatter = {};
      processor.seriesExtermes = []; // finding series extremes for each series

      processor.seriesAssist = [];

      var yaxesGroups = chartObj.axes.y.groups;
      var yaxesleafScales = chartObj.axes.y.leaves;

      // TODO check legend filter
      //Reset cache for data
      chartObj.cache.data = {};
      chartObj.cache.search = {};
      chartObj.cache.customPoints = {};
      chartObj.cache.correction = {};

      for (var i = 0; i < noofYaxis; i++) {
        categoriesStore["y".concat(i)] = [];
        processor.seriesExtermes[i] = [];
        !defined(yaxesData[i]) ? yaxesData[i] = {} : null;

        // Create yaxis group and mark the axis is disabled initially
        yaxesGroups[i] = yaxesGroups[i] || {};
        yaxesGroups[i].disabled = true;

        // Create yaxis group and mark the axis is disabled initially
        yaxesleafScales[i] = yaxesleafScales[i] || {};
        yaxesleafScales[i].disabled = false;
      }

      if (isArray$1(processedseriesData)) {
        var xColumn = axes.x ? dataset.getColumn('x') : null,
          xDatatype = xColumn ? xColumn.datatype : null,
          isZenabled = defined(axes.z),
          groupbyDataIndices = helpers.groupByDataIndices(metadata, chartObj),
          check = function check(d) {return arrayIncludes(allChartTypes, d);};

        //sorting of data
        var xColPos = metadata_axes.x;
        var datatype_x = metadata_columns[xColPos].datatype;

        processor.hasZaxis = defined(dataset.zidx) && chartcategory.zaxis.some(check);
        processor.isFlowChartCategory = chartcategory.flow.some(check);
        processor.needXCategoriesSorting = false;
        var needDuplicateCategories, isPercentChart;

        var gridlist = processor.pivot ? getGridList(processor) : [{ data: processedseriesData }];
        gridlist.forEach(function (grid) {
          grid.data.forEach(function (d) {
            var disabled = d.disabled,
              chartType_num = helpers.getChartType(d.node && d.node.type || d.type || globalChartType, NUMERIC_DATATYPE);

            processor.isBubbleEnabled = processor.isBubbleEnabled || !disabled && isBubbleChartType$1(chartType_num);
            processor.isWaterfallEnabled = processor.isWaterfallEnabled || !disabled && isWaterfallChartType(chartType_num);
            processor.pieWithAxis = processor.pieWithAxis || !disabled && chartType_num == charttype.bubblepie;
            processor.noofBarEnabledSeries += isBarChartType(chartType_num) && !disabled ? 1 : 0;
            processor.noofAreaEnabledSeries +=
            (chartType_num == charttype.area || chartType_num == charttype.stkdarea) && !disabled ? 1 : 0;
            processor.noofAreaRangeEnabledSeries += chartType_num == charttype.arearange && !disabled ? 1 : 0;
            processor.noofBoxplotEnabledSeries += chartType_num == charttype.boxplot && !disabled ? 1 : 0;
            processor.noofBarRangeEnabledSeries += chartType_num == charttype.barrange && !disabled ? 1 : 0;
            processor.noofGanttEnabledSeries += chartType_num == charttype.gantt && !disabled ? 1 : 0;

            processor.isContinousChart =
            processor.isContinousChart && (
            chartType_num == charttype.line || isAreaChartType(chartType_num) || isPointChartType(chartType_num));
          });
        });

        // var hooks = [];

        processedseriesData.forEach(function (d, i) {
          var disabled = d.disabled,
            curdata = d.data;
          var chartType_num = helpers.getChartType(d.type || globalChartType, NUMERIC_DATATYPE);
          var yaxiscolumnorder = helpers.getParsedYAxisOrder(d.yaxiscolumnorder);
          var yDatatype = dataset.getDataType('y', yaxiscolumnorder);

          /*
           * All size values are should be saved to encode eventhough they are disabled
           * Case: Combinational bubble chart, if all the bubble series are disabled, redraw is called, enable any bubble chart. sizeScale is not updated
           * DEMOEVENTS_BUBBLEPIE_4
           */
          if (isArray$1(curdata)) {
            if (defined(dataset.zidx) && arrayIncludes(chartcategory.zaxis, chartType_num)) {
              processor.saveEncode('z', 0, i);
            }
          }

          if (!disabled && isArray$1(curdata)) {
            categoriesStore["y".concat(yaxiscolumnorder)].enabled = true;
            yaxesGroups[yaxiscolumnorder].disabled = false;
            needDuplicateCategories = chartType_num === charttype.waterfall && needDuplicateCategories == null;
            processor.seriesAssist[i] = {};

            var actXdatatype = dataset.getDataType('x', null, allChartTypes),
              yColumn = dataset.getColumn('y', yaxiscolumnorder);

            // debugger
            if (!defined(dataset.hasNullFormatter.x)) {
              dataset.hasNullFormatter.x = !(actXdatatype === ORDINAL_DATATYPE ?
              !isObjectPropDefined(xColumn[xDatatype], 'nullformatting') :
              true);
            }

            if (!defined(dataset.hasNullFormatter["y".concat(yaxiscolumnorder)])) {
              dataset.hasNullFormatter["y".concat(yaxiscolumnorder)] = !(yDatatype === ORDINAL_DATATYPE ?
              !isObjectPropDefined(yColumn[yColumn.datatype], 'nullformatting') :
              true);
            }

            processor.saveEncode('x', 0, i);
            processor.saveEncode('y', yaxiscolumnorder, i);

            if (colorscale_helpers.isQuantileColorScale(chartObj)) {
              processor.saveEncode('color', 0, i);
            }

            var _stacked = processor.isstacked(chartType_num),
              _percent = seriesIs(charttypenames.get(chartType_num), BAR_CHARTNAME) && plotOptions.bar.showAs;

            if (_stacked || _percent) {
              var stackIndex;
              if (!processor.pivot) {
                stackIndex = getStackGroupIndex(processor.getStackGroup(), i);
                processor.saveEncode('stack', stackIndex, i);
                processor.seriesAssist[i].layout = ['stack'];
                processor.seriesAssist[i].stackIndex = stackIndex;

                var stackTransform = processor.getEncode('stack', stackIndex),
                  stackLayout = Registry.getComponent('stackLayout');

                stackTransform.layout = stackTransform.layout || new stackLayout();

                //TODO: remove
                saveStackInfo(processor, curdata, i, stackIndex, chartType_num);
              }
            }

            isPercentChart = isPercentChart || _percent;

            //For stacked data need to iterate each data for collecting X and groupbyval
            //Categories store update
            processor.storeCategories(
            curdata,
            stacked,
            groupbyDataIndices,
            chartType_num,
            actXdatatype,
            yDatatype,
            yaxiscolumnorder,
            needDuplicateCategories);


            //Numeric store extremes update
            processor.setExtremes(curdata, stacked, yDatatype, chartType_num, isZenabled, yaxiscolumnorder);
          }
        });

        var userCategories = getPropVal(chartObj.userdata, 'chart.axes.xaxis.categories');

        if (
        processor.isAxisCategory &&
        datatype_x !== ORDINAL_DATATYPE &&
        processor.needXCategoriesSorting && (
        !defined(userCategories) || defined(userCategories) && userCategories.length === 0))
        {
          categoriesStore.x.sort(d3_ascending);
        }

        processor.isCombinationalChart = processor.pivot ?
        getUniqueChartTypes(chartObj).values().length > 1 :
        getDistinct(allChartTypes, function (d) {return charttypenames.get(d);}).length > 1;
        processor.isStackedPercentChart = stacked && processor.isStackedPercent();
        processor.isPercentChart = processor.isStackedPercentChart || isPercentChart;

        if (processor.pieWithAxis) {
          processor.bubblepieData = processor.processBubblePieData();
        } else if (processor.isFlowChartCategory) {
          processor.processSankeyData();
        }

        if ((stacked || processor.isPercentChart) && !processor.isWaterfallEnabled) {
          if (processor.pivot) {
            var pivotLayout = processor.hierarchical.pivotLayout,
              rowList = pivotLayout.getRootNodeList('row'),
              columnList = pivotLayout.getRootNodeList('column'),
              layers = pivotLayout.getRootNodeList('layer'),
              panes = layers.panes,
              hasMultiCluster = rowList.hasMultiCluster(),
              firstColumnCategoryCount = columnList.getBranchesCount(0) || 1,
              firstRowCategoryCount = rowList.getBranchesCount(0) || 1,
              gridlist = objectValues(panes);
            gridlist.forEach(function (d, i) {
              d.data.forEach(function (s, j) {
                var stackIndex = "".concat(d.row, "_").concat(d.column),
                  seriesIndex = i + j;
                processor.saveEncode('stack', stackIndex, i, s.node);
                processor.seriesAssist[seriesIndex] = processor.seriesAssist[seriesIndex] || {};
                processor.seriesAssist[seriesIndex].layout = ['stack'];
                processor.seriesAssist[seriesIndex].stackIndex = stackIndex;

                var stackTransform = processor.getEncode('stack', stackIndex),
                  stackLayout = Registry.getComponent('stackLayout');

                stackTransform.layout = stackTransform.layout || new stackLayout();

                //TODO: remove
                var chartType_num = helpers.getChartType(d.data.type || globalChartType, NUMERIC_DATATYPE);
                saveStackInfo(processor, d.data, seriesIndex, stackIndex, chartType_num);
              });

              prepareStackData(d.data, dataset, processor); //TODO: revamp function
              AddDataToStackLayout(d.data, dataset, processor);
            });
          } else {
            prepareStackData(processedseriesData, dataset, processor); //TODO: revamp function
            AddDataToStackLayout(processedseriesData, dataset, processor);
          }
        }

        if (processor.isPercentChart) {
          var stackedData = processor.getEncode('stack');
          convertToStackPercent(stackedData, dataset);
        }
      }
    };

    var CartesianDataProcessorProto = CartesianDataProcessor.prototype;

    /**
     *
     * @return {Array}
     */

    CartesianDataProcessorProto.getSeriesData = function () {
      var processor = this,
        chart = this.chartObj;

      if (defined(processor.hierarchical) && processor.hierarchical.categories) {
        // should be updated in the chartObj.seriesdata;
        var temp = processor.hierarchical.getSeries(); //FEATURESEVENTS_SUBSERIES_1 throws error on legend filter
        chart.seriesdata = temp;
        return temp;
      }
      return chart.seriesdata;
    };

    /**
     *
     * @param {Number} index
     * @returns {*}
     */

    CartesianDataProcessorProto.containsNegativeData = function (index) {
      return this.hasNegativeValue[index];
    };

    /**
     * @param  {Number} index  [description]
     * @param  {Array} extent [description]
     */
    CartesianDataProcessorProto.saveBaseLine = function (index, extent, userDefinedMinRange, rangeCheck) {
      var processor = this,
        dataType = processor.dataset.getDataType('y', index),
        temp = NULL$1;

      if (dataType === NUMERIC_DATATYPE) {
        var baseLineValue = processor.baseline[index],
          stacked = processor.isstacked() || processor.isPercentChart;

        temp =
        defined(baseLineValue) && !stacked && (!rangeCheck || isWithinRange$1(baseLineValue, extent)) //On zooming only, isWithinRange should be considered
        ? baseLineValue :
        userDefinedMinRange < 0 || extent[0] < 0 ?
        0 :
        NULL$1;
      }

      processor.hasNegativeValue[index] = temp;
    };

    /**
     * @returns {Array}
     */

    CartesianDataProcessorProto.getMinMaxZ = function () {
      return d3_extent(d3_merge(this.categoriesStore.z));
    };

    /**
     *
     * @param {Array} seriesdata series points
     * @param {Array} xCategories
     * @param {Array|null} yCategories
     * @param {Number} yaxiscolumnorder
     * @param {Boolean} removeDuplicateX if true, will remove all duplicate X categories will be ignored.
     * @return {Array}
     */
    CartesianDataProcessorProto.updateSeriesdatabyCategories = function (
    seriesdata,
    xCategories,
    yCategories,
    yaxiscolumnorder,
    removeDuplicateX,
    subseriesIdx)
    {
      var dataSet = this.dataset,
        chart = this.chartObj,
        helpers = DataProcessor.helpers,
        isCatNullX = helpers.isCatNull(dataSet, 'x'),
        isCatNullY = helpers.isCatNull(dataSet, 'y', yaxiscolumnorder),
        tempSet = d3_set(),
        counter = 0,
        chartName = chart.chartTypes[0].name,
        // for gantt chart allow by default
        isGantt = chartName === 'gantt',
        allowDuplicateCategories = pick(chart.systemConf.chart.plot.allowDuplicateCategories, isGantt);

      // DO NOT FILTER BY CATEGORIES
      if (allowDuplicateCategories) {
        return seriesdata;
      }

      seriesdata = seriesdata.filter(function (d) {
        var show = true,
          x = dataSet.getX(d);

        if (xCategories) {
          show = show && !isCatNullX(x) && xCategories.indexOf(x) > -1;
        }

        if (yCategories) {
          var y = dataSet.getY(d, yaxiscolumnorder);
          show = show && !isCatNullY(y) && yCategories.indexOf(y) > -1;
        }

        //duplicate keys remove
        if (xCategories && removeDuplicateX && show) {
          if (!tempSet.has(x)) {
            // add the X value if does not exist
            tempSet.add(x);
          } else {
            // if the data is already in the X category, ignoring that.
            show = false;
          }
        }

        if (show) {
          d._filter = false;
          d.counter = counter++;
        } else {
          d._filter = true;
        }
        d.subseriesIdx = subseriesIdx || 0;
        return show;
      });
      return seriesdata;
    };

    /**
     *
     * @param curdata
     * @param stacked
     * @param yDatatype
     * @param chartType
     * @param isZenabled
     * @param yaxiscolumnorder
     */

    CartesianDataProcessorProto.setExtremes = function (curdata, stacked, yDatatype, cType, isZenabled, yaxiscolumnorder) {
      var processor = this,
        dataset = processor.dataset,
        zCat = processor.categoriesStore.z;

      if ((yDatatype === NUMERIC_DATATYPE || yDatatype === TIME_DATATYPE) && !stacked || isZenabled) {
        if (!curdata.disabled && isArray$1(curdata)) {
          var mergedSubgroup = d3_merge(curdata);
          if (isZenabled) {
            var zExtremes = d3_extent(mergedSubgroup, function (d) {
              return dataset.getZ(d);
            });
            zCat.push(zExtremes);
          }
          if (yDatatype === NUMERIC_DATATYPE || yDatatype === TIME_DATATYPE) {
            var yExtremes;
            if (chartcategory.rangePlot.has(cType)) {
              if (mergedSubgroup) {
                var mergedYValues = mergedSubgroup.map(function (d) {
                  return dataset.getY(d, yaxiscolumnorder);
                });
                var mergedYranges = mergedYValues.length && mergedYValues[0] ? d3_merge(mergedYValues) : [];
                yExtremes = d3_extent(mergedYranges);
              } else {
                yExtremes = d3_extent([]);
              }
            } else {
              yExtremes = d3_extent(mergedSubgroup, function (d) {
                return dataset.getY(d, yaxiscolumnorder);
              });
            }
            processor.seriesExtermes[yaxiscolumnorder].push(yExtremes);
          }
        }
      }
    };

    /**
     *
     * @param {Array} categories
     * @param {Boolean} leaf
     * @return {*}
     */

    CartesianDataProcessorProto.getDomain = function (categories, type, leaf) {
      // var isHierarchicalMultiAxis = type == 'x' ? this.hierarchical && this.hierarchical.columns.count  : this.hierarchical && this.hierarchical.rows.count;
      var rowCount, columnCount;
      if (this.hierarchical) {
        rowCount = this.hierarchical.pivotLayout.getRootNodeList('row').getCount();
        columnCount = this.hierarchical.pivotLayout.getRootNodeList('column').getCount();
      }
      var isHierarchicalMultiAxis = type == 'x' ? columnCount : rowCount;
      if (this.hierarchical && isHierarchicalMultiAxis && !(this.hierarchical.groupByDiscreteTime && leaf) || this.isWaterfallEnabled) {
        //TODO waterfall
        return d3_range(categories.length);
      } else {
        return categories;
      }
    };

    /**
     *
     * @param domain
     * @param range
     * @param systemconf
     * @param padding
     * @param outerpadding
     * @param type
     * @param index
     * @returns {number}
     */

    DataProcessor.prototype.extendOuterpadding = function (domain, range, systemconf, padding, outerpadding, type, index) {
      var processor = this,
        chartObj = processor.chartObj;
      range = d3_extent(range); // if (range[0] > range[1]) { range = [range[1], range[0]]; }

      var scaleObj = d3_scaleOrdinal().
      domain(domain).
      range(range).
      paddingInner(padding).
      paddingOuter(outerpadding);

      var corrections = Object.keys(correctionParserMap).map(function (_) {return chartObj.cache.correction[_ + '-' + type + '-' + index] || [0, 0];}),
        totalCorrection = d3_max(d3_merge(corrections));

      if (!totalCorrection) {
        return 0;
      }
      return totalCorrection - (scaleObj(scaleObj.domain()[0]) - scaleObj.range()[0]);
    };

    function BarHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    var proto$e = BarHighlighter.prototype;

    proto$e._defaultH = function () {
      return [
      {
        shape: RECT_ELEMENT,
        path: this.path,
        data: this.data,
        context: this.renderingContext,
        translate: this.translateContext,
        styles: patternFillEffect
      }];

    };

    proto$e.data = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params;
      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key],
          transPoint;
        if (!defined(cache._x)) {
          var x = chart.dataObject.getTransRectValue('x', point, point.subSeriesIndex, 0, renderer.commonOption),
            y = chart.dataObject.getTransRectValue('y', point, point.subSeriesIndex, 0, renderer.commonOption),
            w = chart.dataObject.getTransRectValue('width', point, point.subSeriesIndex, 0, renderer.commonOption),
            h = chart.dataObject.getTransRectValue('height', point, point.subSeriesIndex, 0, renderer.commonOption);
          transPoint = getCorrectedRectParams(x, y, w, h, null, rp.yaxisreversed, rp.axisrotated);

          cache._x = point._x = cache._x || transPoint.x1;
          cache._y = point._y = cache._y || transPoint.y1;
          cache._width = point._width = cache._width || w;
          cache._height = point._height = cache._height || h;
          cache._widthT = point._widthT = cache._widthT || transPoint.x2; //Translated screen x2, y2 value needed for roundedRect Function, but absolute width, height needed for barSelection. In future need to change roundedrect x2, y2
          cache._heightT = point._heightT = cache._heightT || transPoint.y2;
          cache._uid = point._uid = chart.dataset.getX(point);
          cache._point = point;
        }
        cache._visible = point._visible = isPointVisible(chart, point);
        return point;
      };
    };

    proto$e.options = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        border = rp.gvp('border') || {},
        radius = border.show ? border.radius : 0,
        color = getRawColor(
        this.chart,
        isMultiColoring(rp.commonPlotOptions, this.chart) ? pick(point.categoryIndex, point.sortedItemIndex) : point.seriesIndex,
        point,
        point.seriesIndex);

      return {
        radius: chart.dataObject.getTransRectValue('radius', null, null, null, renderer.commonOption, radius),
        color: color
      };
    };

    proto$e.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('bar').call(this, this.chart);
    };

    proto$e.translateContext = function () {
      return [this.chart.plotarea.left, this.chart.plotarea.top];
    };

    proto$e.path = function (point, model) {
      var yaxisReversed = this.chart.systemConf.chart.axes.yaxis[point.yaxisOrder || 0].reversed;
      point = point._data();
      var rect = roundedRect(
      point._x,
      point._y,
      point._widthT,
      point._heightT,
      this.options(point).radius,
      yaxisReversed,
      this.chart.axes.rotated,
      true);

      var context = model.context.call(this),
        pathContext = appendEle(context, 'path', [1], '.', 'class', "highlight".concat(point.paneid).concat(point.seriesIndex).concat(point.subSeriesIndex).concat(point.itemIndex));
      context.style('display', '');
      pathContext.
      style('display', '').
      attr('d', rect).
      attr('transform', "translate(".concat(this.chart.plotarea.left, ",").concat(this.chart.plotarea.top, ")"));
      return pathContext;
    };

    function BulletHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
      extend(BulletHighlighter.prototype, BarHighlighter.prototype);
    }

    var proto$f = BulletHighlighter.prototype;

    proto$f.levelmarker = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        bulletEvents = chart.eventHandler.bulletEvents;

      if (!events.BulletEvent) {
        return [];
      }

      if (!bulletEvents) {
        var rp = this.renderer.commonRendererProp().params;
        chart.eventHandler.bulletEvents = new events.BulletEvent(chart, renderer.commonOption, rp.xscale, rp.yscale);
      }
      // return function () {
      var collections = chart.eventHandler.bulletEvents.getCurrentRectangles(point);
      collections.map(function (d, i) {
        d._uid = chart.dataset.getActualX(point);
        d._data = function () {
          var rect = chart.eventHandler.bulletEvents.getCurrentRectangles(point)[i];
          rect._uid = d._uid;
          return rect;
        };
      });
      collections.disabled = function () {
        return chart.seriesdata[point.seriesIndex].disabled;
      };
      return collections;
      // }
    };

    function GanttHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    inherit(GanttHighlighter, BarHighlighter);

    var proto$g = GanttHighlighter.prototype;
    proto$g._defaultH = function () {var _this33 = this;
      return [
      {
        shape: 'rect',
        path: _super(this).path,
        data: _super(this).data,
        context: _super(this).renderingContext,
        translate: _super(this).translateContext,
        styles: patternFillEffect
      },
      {
        shape: 'rect',
        path: this.levelMarker,
        context: this.renderingContext,
        translate: _super(this).translateContext,
        styles: function styles(point) {
          return _this33.getStylesForLevelMarker.call(_this33, point);
        }
      },
      {
        shape: 'marker',
        path: this.markerPath,
        context: this.markerContext,
        translate: _super(this).translateContext,
        type: 'start'
      },
      {
        shape: 'marker',
        path: this.markerPath,
        context: this.markerContext,
        translate: _super(this).translateContext,
        type: 'end'
      }];

    };

    proto$g.levelMarker = function (point, model) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        levelMarker = rp.levelMarker || {};
      var p = this.renderer.getBarLevelMarkerProp(point, point.subSeriesIndex, point.itemIndex, this.renderer, this.renderer.commonOption);

      var rect = roundedRect(
      p.x,
      p.y,
      p.width,
      p.height,
      this.chart.dataObject.getTransRectValue('radius', null, null, null, 0),
      NULL$1,
      this.chart.axes.rotated);


      var context = model.context.call(this),
        pathContext = appendEle(context, 'path', levelMarker.enabled ? [1] : [], '.', 'id', "levelMarkerpath");
      context.style('display', '');
      pathContext.
      style('display', '').
      attr('d', rect).
      attr('transform', "translate(".concat(this.chart.plotarea.left, ",").concat(this.chart.plotarea.top, ")"));
      return pathContext;
    };

    proto$g.markerPosition = function (point, model) {
      var renderer = this.renderer,
        align = model.type,
        isHorizontal = this.chart.axes.rotated,
        orient = getMarkerOrient(align, isHorizontal),
        x,
        y;
      switch (orient) {
        case 'left':
          x = point._x;
          y = point._y + point._height / 2;
          break;
        case 'right':
          x = point._x + point._width;
          y = point._y + point._height / 2;
          break;
        case 'top':
          x = point._x + point._width / 2;
          y = point._y;
          break;
        case 'bottom':
          x = point._x + point._width / 2;
          y = point._y + point._height;
          break;}


      return {
        x: x,
        y: y
      };
    };

    proto$g.markerPath = function (point, model) {
      var _options = this.markerOptions(point, model.type),
        _hoveroptions = _options.options,
        p1 = this.markerPosition(point, model);
      if (!_options.enabled) {
        return;
      }
      var context = model.context.call(this),
        translate = model.translate.call(this),
        pathContext = appendEle(context, 'g', [1], '.', 'class', "yrangePos".concat(model.type));
      addSVGmarker(
      pathContext,
      null,
      _hoveroptions,
      {
        color: _options.color,
        symbolSize: {
          inner: _options.size.inner,
          outer: _options.size.outer
        },
        transform: [p1.x, p1.y],
        imageSize: 15
      },
      this.chart);

      context.attr('transform', "translate(".concat(translate[0], ",").concat(translate[1], ")"));
      return pathContext;
    };

    proto$g.markerOptions = function (point, type) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        cpo = rp.commonPlotOptions.hoveroptions[type],
        spo = this.chart.seriesdata[point.seriesIndex].plotoptions,
        spo = spo && spo.hoveroptions ? spo.hoveroptions[type] : {},
        _options = mergeJSON$1(cpo, spo, true),
        cpo_marker = rp.commonPlotOptions.marker[type],
        spo_marker = spo && spo.marker ? spo.marker[type] : {},
        _options_marker = mergeJSON$1(cpo_marker, spo_marker, true),
        _options = mergeJSON$1(_options_marker, _options, true);

      return {
        enabled: rp.commonPlotOptions.marker && rp.commonPlotOptions.marker.enabled,
        options: _options,
        symbol: _options.symbol,
        _size: _options.size,
        color: this.options(point).color,
        size: {
          outer: _options.size * 2,
          inner: _options.size * 1
        }
      };
    };
    proto$g.markerContext = function () {
      return HIGHLIGHT_CONTEXT.get('scatter').call(this, this.chart);
    };
    proto$g.getStylesForLevelMarker = function (point) {
      var renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        levelMarker = rp.levelMarker || {},
        options = this.options(point);

      return {
        fill: levelMarker.color || options.color
      };
    };

    /*
    Consider four sided rectangle
    Need to place the marker at any of the centre of four sides
    For vertical rectangle - > marker should be placed on top and bottom
    For horizontal rectangle - > marker should be placed on left and right
     */
    function getMarkerOrient(align, isHorizontal) {
      if (isHorizontal) {
        return align == 'start' ? 'left' : 'right';
      } else {
        return align == 'start' ? 'top' : 'bottom';
      }
    }

    function BoxplotHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    inherit(BoxplotHighlighter, BarHighlighter);

    var proto$h = BoxplotHighlighter.prototype;

    proto$h._defaultH = function (point) {
      return [
      {
        shape: 'whisker',
        data: proto$h.data,
        segments: proto$h.segments,
        path: this.whiskerPath,
        context: this.renderingContext,
        translate: this.translateContext
      },
      {
        shape: 'median',
        data: proto$h.data,
        segments: proto$h.segments,
        path: this.medianPath,
        context: this.renderingContext,
        translate: this.translateContext
      },
      {
        shape: RECT_ELEMENT,
        path: _super(this).path,
        data: _super(this).data,
        context: _super(this).renderingContext,
        translate: _super(this).translateContext,
        styles: patternFillEffect
      }];

    };

    proto$h.whiskerPath = function (point, model) {
      var whisker = MarksRegistry.get('boxplot.whisker').call(this.renderer.commonRendererProp().parser, { data: [point] }, "highlight", true);
      renderDom(whisker, model.context.call(this));
    };
    proto$h.medianPath = function (point, model) {
      var median = MarksRegistry.get('boxplot.median').call(this.renderer.commonRendererProp().parser, { data: [point] }, "highlight", true);
      renderDom(median, model.context.call(this));
    };
    proto$h.renderingContext = function () {
      var renderingContext = HIGHLIGHT_CONTEXT.get('scatter').call(this, this.chart);
      renderingContext.node().setAttribute("transform", "translate(0,0)");
      return renderingContext;
    };
    proto$h.box = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = this.renderer.commonRendererProp().params,
        dataset = this.chart.dataset,
        x = dataset.getX(point),
        y = dataset.getY(point, point.yaxisOrder),
        min = isArray$1(y) ? y[0] : rp.yscale.domain()[0],
        max = isArray$1(y) ? y[1] : y,
        whiskers = rp.whiskers,
        accessor = chart.dataObject.getTransRectValue,
        option = renderer.commonOption,
        whisker0,
        whisker1;

      if (whiskers.enabled) {
        whisker0 = point[whiskers.dataindex][0];
        whisker1 = point[whiskers.dataindex][1];
        min = min < whisker0 ? min : whisker0;
        max = max > whisker1 ? max : whisker1;
      }

      if (!chart.cache.data[point._key]) {
        chart.cache.data[point._key] = {};
      }
      var cache = chart.cache.data[point._key];
      cache._box = point._box =
      cache._box || (
      whiskers.enabled ?
      getRectForlevels(chart, option, rp, constructPoint(point, [min, max], dataset), point) :
      getRectForlevels(chart, option, rp, point, point));
      return point._box;
    };
    proto$h.levels = function (point, needAllLevels) {
      //needAllLevels - for automation purpose
      var chart = this.chart,
        renderer = this.renderer,
        rp = this.renderer.commonRendererProp().params,
        median = rp.median,
        whiskers = rp.whiskers,
        dataset = this.chart.dataset,
        x = dataset.getX(point),
        y = dataset.getY(point, point.yaxisOrder),
        medianVal = point[median.dataindex],
        whisker0 = whiskers.enabled && point[whiskers.dataindex][0],
        whisker1 = whiskers.enabled && point[whiskers.dataindex][1],
        medianT = rp.yscale(medianVal),
        t = whiskers.strokeWidth * 5, //medianThickness
        k = rp.axisrotated ? -1 : 1, //multiply factor
        accessor = chart.dataObject.getTransRectValue,
        option = renderer.commonOption,
        p1 = constructPoint,
        inv = rp.yscale.invert; //To find the differentiate of median, we are using invert function; Need to check for ordinal datatype

      if (!chart.cache.data[point._key]) {
        chart.cache.data[point._key] = {};
      }
      var cache = chart.cache.data[point._key];
      if (!cache._levels) {
        if (!whiskers.enabled && !median.enabled) {
          cache._levels = point._levels = null;
          return point._levels;
        }
        var w0,
          w1,
          q0,
          q1,
          m,
          _levels = [];

        q0 = getRectForlevels(chart, option, rp, p1(point, [y[0], inv(medianT + t * k)], dataset), point, 'high');
        q1 = getRectForlevels(chart, option, rp, p1(point, [inv(medianT - t * k), y[1]], dataset), point, 'low');

        _levels.push(q0, q1);

        if (whiskers.enabled || needAllLevels) {
          w0 = getRectForlevels(chart, option, rp, p1(point, [whisker0, y[0]], dataset), point, 'whisker0');
          w1 = getRectForlevels(chart, option, rp, p1(point, [y[1], whisker1], dataset), point, 'whisker1');

          _levels.push(w0, w1);
        }
        if (median.enabled || needAllLevels) {
          m = getRectForlevels(chart, option, rp, p1(point, [inv(medianT + t * k), inv(medianT - t * k)], dataset), point, 'median');

          _levels.push(m);
        }

        cache._levels = point._levels = _levels;
      }

      return point._levels;
    };

    function getRectForlevels(chart, option, rp, point, point0, type) {
      var x = chart.dataObject.getTransRectValue('x', point, 0, 0, option),
        y = chart.dataObject.getTransRectValue('y', point, 0, 0, option),
        w = chart.dataObject.getTransRectValue('width', point, 0, 0, option),
        h = chart.dataObject.getTransRectValue('height', point, 0, 0, option),
        transPoint = getCorrectedRectParams(x, y, w, h, null, rp.yaxisreversed, rp.axisrotated);

      return {
        _data: function _data() {
          return {
            _x: transPoint.x1,
            _y: transPoint.y1,
            _width: w,
            _height: h,
            _widthT: transPoint.x2,
            _heightT: transPoint.y2,
            _point: point0,
            type: type,
            _uid: point._uid
          };
        }
      };
    }

    function constructPoint(point, newY, dataset) {
      var p1 = [],
        xidx = dataset.xidx,
        yidx = dataset.yidx(point.yaxisOrder),
        x = dataset.getX(point);
      p1[xidx] = x, p1[yidx] = newY;
      p1.index = point.index;
      return p1;
    }

    BarHighlighter.prototype.box = proto$h.box;
    BarHighlighter.prototype.levels = proto$h.levels;

    //$Id$

    canvas_plot_renderer.bar = function () {
      var commonRendererProp,
        bandwidth1,
        bandwidth2,
        yscale,
        barDatasetIndex,
        shiftInfo;

      function chart(context, seriesdata, effect, filterIndex) {
        var rp = commonRendererProp.params,
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          stacked = rp.stacked,
          index = rp.datasetIndex,
          axisrotated = rp.axisrotated,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          paneColor = rp.paneColor,
          labelQueue = rp.labelQueue,
          hasNegValue = rp.hasNegValue,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset,
          legendOrder = rp.legendOrderIndex,
          rendererIndex = rp.rendererIndex,
          systemconf = chartObj.systemConf,
          plotarea = chartObj.plotarea,
          dataObject = chartObj.dataObject,
          dataProcessorHelpers = DataProcessor.helpers;

        // categories = xscale.domain();
        // categories = chartObj.dataObject.getCategories("x");
        seriesdata = chartObj.dataObject.categoryHierarchy ? seriesdata[index] : chartObj.seriesdata[index];

        var paneid = isFacet(chartObj) ? "".concat(seriesdata.row, "_").concat(seriesdata.column) : null,
          cType_Obj = getChartTypeByIndex(chartObj, paneid, index);
        if (!bandwidth1 || !bandwidth2) {
          chart.chartRendered = true;
          return;
        }

        yscale = rp.yscale;
        var datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
          xCategories = xscale.domain(),
          yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
          categories = defined(dataObject.hierarchical) ? dataObject.getCategories('x') : xCategories;

        var cType = cType_Obj.name;
        var gradientDim = null; //[w,h];
        var yAxisReversed = rp.yaxisreversed = chartObj.systemConf.chart.axes.yaxis[yaxiscolumnorder || 0].reversed,
          xAxisReversed = rp.xaxisreversed = chartObj.systemConf.chart.axes.xaxis.reversed;

        var plotoptions = seriesdata.plotoptions;
        var gvp = rp.gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions),
          isBullet = cType_Obj.value === charttype.bullet;

        var targetMarker = fillOpacity = gvp('targetMarker') || {};

        var levelMarker =
          plotoptions && plotoptions.levelMarker ?
          mergeJSON$1(commonPlotOptions.levelMarker, plotoptions.levelMarker, true) :
          commonPlotOptions.levelMarker,
          borderOptions =
          plotoptions && plotoptions.border ?
          mergeJSON$1(commonPlotOptions.border, plotoptions.border, true) :
          commonPlotOptions.border;
        var multiColoring = isMultiColoring(commonPlotOptions, chartObj),
          hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj);

        var fillStyle = chart.fillColorFunc = getFillColor(chartObj, legendOrder, paneid, gradientDim, null, null, null, rp),
          strokeColor = getStrokeColor(chartObj, index, paneid, null, rp);

        var fillOpacity = gvp('fillOpacity'),
          getParamValue = chart.getParamValue = function () {
            return chartObj.dataObject.getTransRectValue.apply(chartObj.dataObject, toArray(arguments));
          };

        var commonOption = getBarCommonOption(chartObj.rendererConf[rendererIndex], rendererIndex, legendOrder);
        var levelMarkerWidth = commonOption.levelMarkerWidth;
        levelMarker.overlayRange = 'below';
        var levelMarkerColor = levelMarker.color; //Saving the levelMarker colors, helps in multi categories bullet if each categories dont have same no of levels

        var borderRadius = {
          tlx: 0,
          tly: 0,
          trx: 0,
          trY: 0,
          brx: 0,
          bry: 0,
          blx: 0,
          bly: 0
        };
        var borderSize = 0,
          borderColor = null,
          borderStyle = null,
          radius = 0;
        if (defined(borderOptions) && isTrue(borderOptions.show)) {
          borderSize = defined(borderOptions.size) ? borderOptions.size : 1;
          borderColor = borderOptions.color;
          borderStyle = borderOptions.style;
          radius = borderOptions.radius;
          borderRadius = getParamValue('radius', null, null, null, commonOption, radius);
        }

        var dashStyle = getDashArray(borderStyle, borderSize == null ? 2 : borderSize);

        var legend_data = systemconf.legend;
        var rounded = isRounded(borderRadius),
          patternName = legend_data.patternPallete,
          patternPallete = legend_data.patternPallete;

        var size = pick(targetMarker.size, levelMarkerWidth - 2 * pick(targetMarker.padding, commonOption.padding / 2)),
          bandwidth = isBullet ? xscale.bandwidth() : levelMarkerWidth,
          customMarkerSize = targetMarker.size;

        targetMarker.size = size = defined(customMarkerSize) ? isBullet ? mathMin(size, bandwidth / 10) : size : size / 10;

        //STACKED BAR : for which series the level marker should be drawn
        var isLevelMarkerIndex;
        if (stacked && levelMarker.enabled && !defined(effect)) {
          var actualStackGroupIndex = getStackGroupIndex(dataObject.getStackGroup(), index),
            stackEncode = chartObj.dataObject.getEncode('stack', actualStackGroupIndex);

          isLevelMarkerIndex = stackEncode && stackEncode.seriesIndices[0] === index;
        }

        if (!seriesdata.disabled) {
          chart.seriesdataAfterUpdate = [];
          seriesdata.data.forEach(function (data, i) {
            var dataUpdate = chartObj.dataObject.updateSeriesdatabyCategories(
            d3_values(data),
            xCategories,
            yCategories,
            yaxiscolumnorder,
            true);


            if (hasColorScale && defined(filterIndex)) {
              dataUpdate = legend_helpers.filterSelectionByColor(dataUpdate, true, filterIndex, chartObj);
            }
            if (chartObj.renderVisiblePointsOnly) {
              dataUpdate = dataProcessorHelpers.filterPointsInViewport(chartObj, dataUpdate, 'bar', 'x', index, i);
            }
            chart.seriesdataAfterUpdate[i] = dataUpdate;

            if (chartObj.systemConf.chart.axes.xaxis.reversed) {
              dataUpdate = dataUpdate.slice(0).reverse();
            }

            if (stacked && levelMarker.enabled && !defined(effect) && xCategories.length != dataUpdate.length) {
              plot.render.bulletHelpers.addDummyDataForLevelmarker(dataUpdate, xCategories, dataset, yaxiscolumnorder);
            }

            dataUpdate.forEach(function (d, j) {
              var x,
                y,
                w,
                h,
                fillColor = getRawColor(chartObj, multiColoring ? j : legendOrder, d, index, paneid);

              if (levelMarker.enabled && !defined(effect)) {
                if (stacked && isLevelMarkerIndex && i === 0 || !stacked) {
                  var rect = plot.render.bulletHelpers.ZC_BAR_getLevelMarkerRect(
                    d,
                    levelMarker,
                    chartObj,
                    commonOption,
                    rp,
                    i,
                    index),

                    x = axisrotated ? rect.y : rect.x,
                    y = axisrotated ? rect.x : rect.y,
                    w = rect.width,
                    h = rect.height;

                  context.save();
                  context.beginPath();
                  context.fillStyle =
                  plot.render.bulletHelpers.getBulletLevelMarkerGradient(
                  d,
                  levelMarker,
                  chartObj,
                  fillColor,
                  levelMarkerColor) ||

                  rgba_canvas(
                  (isArray$1(levelMarker.color) ? levelMarker.color[0] : levelMarker.color) || fillColor,
                  levelMarker.fillOpacity);

                  canvasUtils.roundedRect(context, x, y, w, h, borderRadius, yAxisReversed, axisrotated);
                  context.fill();
                  context.closePath();
                  context.restore();
                }
              }

              x = getParamValue('x', d, i, j, commonOption);
              y = getParamValue('y', d, i, j, commonOption);
              w = getParamValue('width', d, i, j, commonOption);
              h = getParamValue('height', d, i, j, commonOption);

              if (yAxisReversed) {
                if (axisrotated) {
                  x = x - w;
                } else {
                  y = y - h;
                }
              }
              gradientDim = [w, h];

              var drawBarFunction = function drawBarFunction(context, fillStyle) {
                context.save();
                context.translate(x, y);
                context.strokeStyle = rgba_canvas(fillColor, fillOpacity);
                context.fillStyle = fillStyle;
                if (rounded) {
                  context.beginPath();
                  canvasUtils.roundedRect(context, 0, 0, w, h, borderRadius);
                  context.fill();
                } else {
                  context.beginPath();
                  context.rect(0, 0, w, h);
                  context.fill();
                }
                setBorder(context, borderSize, borderColor || fillColor, dashStyle);
                context.closePath();
                context.restore();
              };

              if (chartObj.imagePallete) {
                var imageUrl = getImageByIndex(chartObj, multiColoring ? j : legendOrder, paneid);
                effects.canvas_patterns.imageFill({ x: x, y: y, context: context, name: imageUrl }, drawBarFunction);
              } else {
                var fillStyle = defined(effect) ?
                effect :
                chart.fillColorFunc(
                multiColoring ? j : legendOrder,
                d,
                null,
                paneColor,
                fillOpacity,
                gradientDim,
                { x: x, y: y, width: w, height: h, context: context },
                false);

                drawBarFunction(context, fillStyle);
              }

              // draw target marker
              if (isBullet && targetMarker.enabled === true && !d.isDummy) {
                x = bandwidth1(dataset.getX(d)) + bandwidth / 2;
                y = yscale(d[targetMarker.dataindex]);
                drawTargetMarker(context, targetMarker, size, x, y, axisrotated);
              }
            });
          });
        }
        targetMarker.size = customMarkerSize;
        labelQueue.push({
          renderer: chart,
          charttype: 'bar',
          chartObj: chartObj,
          rendererIndex: rendererIndex,
          paneid: paneid,
          args: [seriesdata, legendOrder, null, null, null, rendererIndex]
        });

        chart.chartRendered = true;
        return chart;
      }
      chart.getHighlighter = function (chartObj, index, chartName) {
        if (chart.highlighter) {
          return chart.highlighter;
        }
        var cType = chartName || getChartTypeByIndex(chartObj, null, index).name,
          isBullet = cType == 'bullet',
          isGantt = cType == 'gantt',
          isBoxplot = cType == 'boxplot';
        chart.highlighter = isBullet ?
        new BulletHighlighter(chartObj, chart) :
        isGantt ?
        new GanttHighlighter(chartObj, chart) :
        isBoxplot ?
        new BoxplotHighlighter(chartObj, chart) :
        new BarHighlighter(chartObj, chart);
        return chart.highlighter;
      };

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      chart.bandwidth1 = function (_) {
        if (!arguments.length) {
          return bandwidth1;
        }
        bandwidth1 = _;
        return chart;
      };
      chart.bandwidth2 = function (_) {
        if (!arguments.length) {
          return bandwidth2;
        }
        bandwidth2 = _;
        return chart;
      };
      chart.barDatasetIndex = function (_) {
        if (!arguments.length) {
          return barDatasetIndex;
        }
        barDatasetIndex = _;
        return chart;
      };

      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };

      function isRounded(radius) {
        for (var l in radius) {
          if (radius.hasOwnProperty(l)) {
            return !!radius[l];
          }
        }
        return false;
      }

      /**
       *
       * @param context
       * @param marker
       * @param size
       * @param x
       * @param y
       * @param axisRotated
       */

      function drawTargetMarker(context, marker, size, x, y, axisRotated) {
        var outerSize = size * 5,
          outerStrokeWidth = pick(marker.outerStrokeWidth, 1),
          innerStrokeWidth = pick(marker.innerStrokeWidth, 1),
          outerStrokeColor = marker.outerStrokeColor,
          innerStrokeColor = marker.innerStrokeColor,
          outerFillColor = marker.outerFillColor,
          innerFillColor = marker.innerFillColor;

        if (defined(marker.outerFillOpacity) && outerFillColor) {
          outerFillColor = rgba_canvas(outerFillColor, marker.outerFillOpacity);
        }
        if (defined(marker.outerStrokeOpacity) && outerStrokeColor) {
          outerStrokeColor = rgba_canvas(outerStrokeColor, marker.outerStrokeOpacity);
        }
        if (defined(marker.innerFillOpacity) && innerFillColor) {
          innerFillColor = rgba_canvas(innerFillColor, marker.innerFillOpacity);
        }
        if (defined(marker.innerStrokeOpacity) && innerStrokeColor) {
          innerStrokeColor = rgba_canvas(innerStrokeColor, marker.innerStrokeOpacity);
        }

        // fix the dash style
        if (defined(marker.dashStyle)) {
          marker.outerDashStyle = marker.innerDashStyle = marker.dashStyle;
        }

        // using scatter marker
        var cache = canvas_plot_renderer.scatter.getCache(
        marker.symbol,
        outerSize,
        outerStrokeColor,
        outerStrokeWidth,
        outerFillColor,
        innerStrokeColor,
        innerStrokeWidth,
        innerFillColor,
        marker);

        var adjust = cache.adjustPosition,
          cacheCanvas = cache.canvas,
          drawWidth = cache.width,
          centered = outerSize + outerStrokeWidth / 2 + adjust;

        context.save();
        // rotate by 90 degree if the axis rotated
        if (axisRotated) {
          context.translate(y, x);
          context.rotate(deg2rad * 90); // rotate 90 deg
        } else {
          context.translate(x, y);
        }

        context.drawImage(cacheCanvas, -centered, -centered, drawWidth, drawWidth);
        context.restore();
      }

      function setBorder(context, size, color, dashStyle) {
        if (size > 0) {
          context.lineWidth = size;
          if (isArray$1(dashStyle) && dashStyle.length && defined(context.setLineDash)) {
            context.setLineDash(dashStyle);
          }
          context.strokeStyle = color;
          context.stroke();
        }
      }
      return chart;
    };

    defaultTheme.bar = function () {
      return {
        outerPadding: 0.04,
        fillOpacity: 0.9,
        maxBandWidth: 200,
        multiColoring: false,
        border: {
          show: false,
          size: null,
          style: 'solid',
          radius: 0,
          color: null
        },
        stacked: {
          enabled: false,
          showAs: 'values' //values,percent
        },
        levelMarker: {
          enabled: false,
          color: ['#d8d8d8'],
          fillOpacity: 0.9
        },
        datalabels: {
          animation: {
            enabled: false
          },
          showAs: 'y', //x,y,percent
          stackLabels: {
            show: false,
            showAs: 'y' //y,percent
          }
        },
        animation: {
          type: 'verticalAll' //verticalAll || vertical
        },
        gradients: {
          //linear || none
          options: {
            linear: {
              y2: 50
            }
          }
        },
        whiskers: {
          enabled: false,
          columnindex: 3,
          dataindex: 2,
          size: '50%',
          color: '#d8d8d8',
          opacity: 0.9,
          strokeWidth: 1,
          showOn: 'overlay', //'overlay'
          events: {
            enabled: true
          },
          hoveroptions: {
            strokeWidth: 2,
            opacity: 0.9,
            color: '#d8d8d8'
          }
        }
      };
    };

    //$Id$

    plot.render.bulletHelpers = function () {};
    plot.render.bulletHelpers.getLevelMarkerParams = function (d, i, j, renderer, cp) {
      var rp = renderer.commonRendererProp().params,
        chartObj = rp.chartObj,
        yaxiscolumnorder = rp.yaxiscolumnorder,
        axisrotated = rp.axisrotated,
        dataset = rp.dataset,
        maxRange = cp && cp.yscale.range()[1];

      var percentComplete = d[cp.levelMarker.dataindex],
        yVal = dataset.getY(d, yaxiscolumnorder),
        startVal = yVal[0],
        endVal = yVal[1],
        diff = endVal - startVal,
        marginIncrease = diff * percentComplete / 100,
        finalVal = cp.yscale(startVal + marginIncrease),
        xPadding = axisrotated ? 0 : cp.levelMarkerPadding,
        yPadding = axisrotated ? cp.levelMarkerPadding : 0;

      var x, y, wid, hei;
      x = chartObj.dataObject.getTransRectValue('x', d, i, j, cp) + xPadding;
      var basevalue = cp.hasNegValue == null ? cp.yscale(dataset.getY(d, cp.yaxiscolumnorder, 0)) : cp.yscale(cp.hasNegValue);
      if (cp.axisrotated) {
        y = renderer.getParamValue('y', d, i, j, cp) + yPadding;
        wid = cp.stacked ?
        mathAbs(cp.yscale(d.y + d.y0) - cp.yscale(d.y0)) + cp.addRangeBand(cp.yscale) :
        (mathAbs(maxRange - basevalue - (maxRange - finalVal)) || 0) + cp.addRangeBand(cp.yscale);
        hei = cp.levelMarkerWidth || cp.barWidth;
      } else {
        y = finalVal;
        wid = cp.levelMarkerWidth || cp.barWidth;
        hei = cp.stacked ?
        mathAbs(basevalue - cp.yscale(d.y + d.y0) - (basevalue - cp.yscale(d.y0))) + cp.addRangeBand(cp.yscale) :
        mathAbs(basevalue - finalVal) + cp.addRangeBand(cp.yscale);
      }
      return {
        x: x,
        y: y,
        width: wid,
        height: hei
      };
    };
    plot.render.bulletHelpers.getBulletLevelMarkerGradient = function (d, levelMarker, chartObj, baseClr, levelMarkerColor) {
      var level = d[levelMarker.dataindex] || [];
      if (level != null && !(level instanceof Array)) {
        //If level marker is a single value and in non-array format, make it as array
        return null;
      }

      if (!level.length) {
        return null;
      }

      var levelMarkerColor_old = levelMarker.color;
      if (!levelMarkerColor) {
        //If colors are not specified, create monochrome colors
        levelMarker.color = [];
        var colorGamma = levelMarker.colorGamma || [0.3, 0.9];
        var domain = [0, level.length - 1],
          range = [+colorGamma[0], +colorGamma[1]];
        var monoClrGen = getMonochromeColor(baseClr, domain, range);
        levelMarker.color = level.map(function (d, i) {
          return monoClrGen(i);
        });
      } else if (levelMarkerColor.constructor != Array) {
        levelMarker.color = [levelMarkerColor];
      }

      var neg = level.filter(function (d) {
        return d < 0;
      });

      var thValues;
      if (neg.length > 0) {
        // If negative values are present, add 0
        thValues = level.slice();
        var zeroIndex = thValues.indexOf(0);
        if (zeroIndex > -1) {
          thValues.splice(zeroIndex, 1);
        }

        var negthClr = levelMarker.color;
        thValues = thValues.sort(d3_descending);
        var color = [];

        for (var i = 0; i < thValues.length; i++) {
          var index = level.indexOf(thValues[i]);
          color.push(negthClr[index]);
        }
        levelMarker.color = color;
        thValues.splice(thValues.length - neg.length, 0, 0);
        level = thValues;
      }
      levelMarker.values = level;
      var thOverlay = axis.threshold.overlay(chartObj, 'continous')(TRANSPARENT, levelMarker, 0, 'y');
      if (neg.length > 0) {
        level = thValues;
      }

      levelMarker.color = levelMarkerColor_old;

      return thOverlay;
    };

    plot.render.bulletHelpers.ZC_BAR_getLevelMarkerRect = function (d, levelMarker, chartObj, cp, rp, i, index) {
      var level = d[levelMarker.dataindex] || [],
        hasLevels = defined(levelMarker.dataindex),
        hasFixedPosDatalabels = chartObj.datalabels.hasFixedPosition,
        yaxisReversed = chartObj.systemConf.chart.axes.yaxis[rp.yaxiscolumnorder || 0].reversed,
        actualStackGroupIndex = cp.stackGroupIndex,
        plotarea = chartObj.plotarea,
        stacked = rp.stacked,
        axisrotated = rp.axisrotated,
        hasNegValue = rp.hasNegValue,
        yaxiscolumnorder = rp.yaxiscolumnorder,
        dataset = rp.dataset,
        yscale = rp.yscale,
        min,
        max;

      if (chartObj.eventHandler && !chartObj.eventHandler.bulletEvents && events.BulletEvent) {
        chartObj.eventHandler.bulletEvents = new events.BulletEvent(chartObj, cp, rp.xscale, rp.yscale);
      }

      if (level != null && !(level instanceof Array)) {
        //If level marker is a single value and in non-array format, make it as array
        level = [level];
      }
      if (hasLevels && !level.length) {
        min = max = 0;
      } else {
        min = d3_min(level);
        max = d3_max(level);
      }
      var v = dataset.getX(d);
      var x =
      (stacked ?
      cp.bandwidth1(v) + (cp.bandwidth2(actualStackGroupIndex) || 0) :
      cp.bandwidth1(v) + cp.bandwidth2(cp.barDatasetIndex + i)) + cp.levelMarkerPadding;
      var y = hasLevels ?
        axisrotated ?
        yscale(mathMin(0, min)) :
        yscale(mathMax(0, max)) :
        axisrotated && hasNegValue != null ?
        yscale(hasNegValue) :
        0,
        wid = axisrotated ?
        hasLevels ?
        mathAbs(yscale(mathMax(0, max)) - yscale(mathMin(0, min))) :
        hasNegValue != null ?
        mathAbs(plotarea.width - yscale(hasNegValue)) :
        plotarea.width :
        cp.levelMarkerWidth,
        hei = axisrotated ?
        cp.levelMarkerWidth :
        hasLevels ?
        mathAbs(yscale(mathMin(0, min)) - yscale(mathMax(0, max))) :
        hasNegValue != null ?
        yscale(hasNegValue) :
        plotarea.height;
      if (!hasLevels) {
        if (yscale.bandwidth) {
          var ordinalRange = yscale.ordinalRange,
            bandWidthBy2 = yscale.bandwidth() / 2;
          if (axisrotated) {
            y = yscale.origRange[0];
            wid = ordinalRange[yaxisReversed ? 0 : ordinalRange.length - 1] + bandWidthBy2;
          } else {
            y = ordinalRange[ordinalRange.length - 1] + bandWidthBy2;
            hei = ordinalRange[yaxisReversed ? ordinalRange.length - 1 : 0] + bandWidthBy2;
          }
        } else {
          var actualMin, actualMax, curY;
          curY = dataset.getY(d, cp.yaxiscolumnorder);
          if (hasFixedPosDatalabels) {
            var yRange = chartObj.dataObject.ZC_BAR_getRangeY(yaxiscolumnorder);
            actualMin = yRange[0];
            actualMax = yRange[1];
          } else {
            actualMin = yscale.domain()[0];
            actualMax = yscale.domain()[1];
          }
          var minmax = [yscale(actualMax), yscale(defined(hasNegValue) ? hasNegValue : actualMin)];

          if (curY < 0) {
            minmax = [yscale(defined(hasNegValue) ? hasNegValue : actualMax), yscale(actualMin)];
          }

          if (axisrotated) {
            minmax.reverse();
            y = minmax[0];
            wid = mathAbs(minmax[1] - minmax[0]);
          } else {
            y = minmax[0];
            hei = mathAbs(minmax[1] - minmax[0]);
          }
        }
      }
      return {
        x: x,
        y: y,
        width: wid,
        height: hei
      };
    };

    plot.render.bulletHelpers.addDummyDataForLevelmarker = function (dataUpdate, xCategories, dataset, yaxiscolumnorder) {
      var xMappingFunction = function xMappingFunction(d) {
        return dataset.getX(d);
      };
      var currentkeys = dataUpdate.map(xMappingFunction);
      xCategories.forEach(function (d, i) {
        var key = d;
        var haveKey = currentkeys.indexOf(key);
        if (haveKey < 0) {
          var duplicate = [];
          duplicate.splice(dataset.xidx, 0, key);
          duplicate.splice(dataset.yidx(yaxiscolumnorder), 0, 0); //dummy data add as 0
          duplicate.isDummy = true;
          duplicate.y = 0, duplicate.y0 = 0;
          duplicate.index = i;
          dataUpdate.splice(i, 0, duplicate);
        }
      });
    };

    var _levelmarkerHelpers = plot.render.bulletHelpers;

    /**
     *
     * @param extentY
     * @returns {*}
     */

    DataProcessor.prototype.overLevelMarker = function (index) {
      var context = this;

      if (!context.qualitativeRanges) {
        context.qualitativeRanges = [];
      }

      var helpers = DataProcessor.helpers,
        qualitativeRanges = context.qualitativeRanges[index],
        processedseriesData = context.getEncode('y', index).seriesData,
        chartName = helpers.getChartType(processedseriesData[0].type || context.globalChartType, 'string'),
        conf = context.data.chart.plot.plotoptions[chartName],
        levelMarker = conf.levelMarker,
        targetMarker = conf.targetMarker,
        whiskers = conf.whiskers,
        levelMarkerIndex,
        targetMarkerIndex,
        whiskersIndex;

      if (!qualitativeRanges) {
        qualitativeRanges = context.qualitativeRanges[index] = [];

        processedseriesData.forEach(function (series) {
          var plotOptions = series.plotoptions || {};

          levelMarker = mergeJSON$1(levelMarker, plotOptions.levelMarker);
          targetMarker = mergeJSON$1(targetMarker, plotOptions.targetMarker);
          whiskers = mergeJSON$1(whiskers, plotOptions.whiskers);

          levelMarkerIndex = levelMarker.dataindex;
          targetMarkerIndex = targetMarker.dataindex;
          whiskersIndex = whiskers.dataindex;

          if (levelMarker.enabled || targetMarker.enabled || whiskers.enabled) {
            if (levelMarkerIndex || targetMarkerIndex || whiskersIndex) {
              series.data.forEach(function (subSeries) {
                subSeries.forEach(function (point) {
                  if (targetMarker.enabled && defined(point[targetMarkerIndex])) {
                    qualitativeRanges.push(point[targetMarkerIndex]);
                  }

                  if (levelMarker.enabled && defined(point[levelMarkerIndex])) {
                    // in bullet chart data comes in array
                    if (isArray$1(point[levelMarkerIndex])) {
                      qualitativeRanges = qualitativeRanges.concat(point[levelMarkerIndex]);
                    } else {
                      qualitativeRanges.push(point[levelMarkerIndex]);
                    }
                  }

                  if (whiskers.enabled && defined(point[whiskersIndex])) {
                    qualitativeRanges = qualitativeRanges.concat(point[whiskersIndex]);
                  }
                });
              });
            } else if (levelMarker.enabled) {
              if (isArray$1(levelMarker.ranges)) {
                qualitativeRanges = d3_merge(levelMarker.ranges);
              } else if (defined(levelMarker.values)) {
                qualitativeRanges = qualitativeRanges.concat(levelMarker.values);
              }
            }
          }
        });
      }

      if (whiskers.enabled) {
        context.hasWhiskers = true;
      }
      if (!qualitativeRanges.length && !context.hasLevelMarker) {
        return [];
      }

      return d3_extent([].concat(_toConsumableArray(qualitativeRanges), [0]));
    };

    DataProcessor.prototype.getLevelMarkerIndices = function (index) {
      var context = this;

      if (!context.qualitativeRanges) {
        context.qualitativeRanges = [];
        context.qualitativeRangesIndex = [];
      }

      var helpers = DataProcessor.helpers,
        qualitativeRanges = context.qualitativeRanges[index],
        qualitativeRangesIndex = context.qualitativeRangesIndex[index],
        processedseriesData = context.getEncode('y', index).seriesData,
        chartName = helpers.getChartType(processedseriesData[0].type || context.globalChartType, 'string'),
        conf = context.data.chart.plot.plotoptions[chartName],
        levelMarker = conf.levelMarker,
        targetMarker = conf.targetMarker,
        whiskers = conf.whiskers,
        levelMarkerIndex,
        targetMarkerIndex,
        whiskersIndex;
      var dataIndices = new Array(0);
      if (!qualitativeRangesIndex) {
        qualitativeRanges = context.qualitativeRanges[index] = [];
        qualitativeRangesIndex = context.qualitativeRangesIndex[index] = [];

        processedseriesData.forEach(function (series) {
          var plotOptions = series.plotoptions || {};

          levelMarker = mergeJSON$1(levelMarker, plotOptions.levelMarker);
          targetMarker = mergeJSON$1(targetMarker, plotOptions.targetMarker);
          whiskers = mergeJSON$1(whiskers, plotOptions.whiskers);

          levelMarkerIndex = levelMarker.dataindex;
          targetMarkerIndex = targetMarker.dataindex;
          whiskersIndex = whiskers.dataindex;

          if (levelMarker.enabled) {
            if (defined(levelMarkerIndex)) {
              dataIndices.push(levelMarkerIndex);
            } else {
              if (isArray$1(levelMarker.ranges)) {
                qualitativeRanges = d3_merge(levelMarker.ranges);
              } else if (defined(levelMarker.values)) {
                qualitativeRanges = qualitativeRanges.concat(levelMarker.values);
              }
            }
          }
          if (targetMarker.enabled && defined(targetMarkerIndex)) {
            dataIndices.push(targetMarkerIndex);
          }
          if (whiskers.enabled) {
            context.hasWhiskers = true;
          }
          if (whiskers.enabled && defined(whiskersIndex)) {
            dataIndices.push(whiskersIndex);
          }
        });
        context.qualitativeRangesIndex[index] = qualitativeRangesIndex = dataIndices;
        context.qualitativeRanges[index].values = qualitativeRanges;
      }

      return {
        indices: qualitativeRangesIndex,
        values: context.qualitativeRanges[index].values
      };
    };

    DataProcessor.prototype.getStackingIndices = function (index) {
      var context = this;

      var yEncode = context.getEncode('y', index),
        seriesData = yEncode.seriesData,
        seriesIndices = yEncode.seriesIndices;

      var stackIndices = new Array(0),
        nonStackseriesIndices = new Array(0),
        _stackData = new Array(0),
        _nonStackData = new Array(0);
      if (context.pivot) {
        var pivotLayout = context.hierarchical.pivotLayout,
          layers = pivotLayout.layers;
        seriesData = objectValues(layers.panes);
      }
      seriesData.map(function (series, i) {
        var seriesIndex = context.pivot ? i : seriesIndices[i],
          seriesAssist = context.seriesAssist[seriesIndex];

        if (arrayIncludes(seriesAssist.layout || [], 'stack')) {
          var stackIndex = context.pivot ? "".concat(series.row, "_").concat(series.column) : seriesAssist.stackIndex;
          stackIndices.push(stackIndex);
          _stackData.push(series);
        } else {
          nonStackseriesIndices.push(seriesIndex);
          _nonStackData.push(series);
        }
      });

      return {
        _stackData: _stackData,
        _nonStackData: _nonStackData,
        stackIndices: stackIndices,
        nonStackseriesIndices: nonStackseriesIndices
      };
    };

    function _mainBar(_data3) {
      var _this = this;
      var currentData = _data3.data,
        builderC = this.builderC,
        anime_config = builderC.animationOptions,
        racing = this.chart.racing && this.chart.racing.syncTransition,
        morphing = this.chart.systemConf.chart.plot.morph.enabled && this.chart.oldSeriesInfo,
        liveUpdate = builderC.liveUpdate,
        attrs = {};

      var key = 'bar';
      var enterMarks, updateMarks, exitMarks;
      /*
      Default enter marks
       */
      enterMarks = {
        d: function d(_d15) {return _this.helpers.position[key].start(_d15);}
      };

      if (racing) {
        key = 'bar_racing';
        enterMarks = {
          d: function d(_d16) {return _this.helpers.position[key].start(_d16);}
        };
        updateMarks = [
        {
          transition: racing,
          d: function d(_d17) {return _this.helpers.position[key].end(_d17);}
        }];


        exitMarks = {
          transition: racing,
          d: function d(_d18) {return _this.helpers.position[key].exit(_d18);}
        };
      } else if (morphing) {
        updateMarks = [
        {
          duration: anime_config._duration,
          d: {
            property: 'attrTween',
            to: function to(d, i) {
              var interpolator = _this.helpers.position.bar_morphing.interpolator[i];
              return function (t) {
                return _this.helpers.position.bar_morphing.line_d3(
                interpolator.map(function (p) {
                  return p(t);
                }));

              };
            }
          }
        },
        {
          duration: 0,
          d: function d(_d19) {return _this.helpers.position[key].end(_d19);}
        }];

      } else if (liveUpdate) {
        updateMarks = [
        {
          duration: _this.phase == 'redraw' ? anime_config._duration : 0,
          d: function d(_d20) {return _this.helpers.position[key].end(_d20);}
        }];

      } else {
        updateMarks = [
        {
          duration: _this.phase == 'redraw' ? anime_config._duration : 0,
          delay: anime_config._delay,
          d: function d(_d21) {return _this.helpers.position[key].stop_1(_d21);}
        },
        {
          duration: anime_config._duration,
          delay: anime_config._delay,
          d: function d(_d22) {return _this.helpers.position[key].end(_d22);}
        }];


        exitMarks = {
          duration: _this.builderC.animationOptions._exitduration,
          d: function d(_d23) {return _this.helpers.position[key].exit(_d23);}
        };
      }

      if (this.chart.dataObject.hierarchical) {
        attrs = {
          levelbycolumn: function levelbycolumn(d) {return d.levelByColumn;},
          levelbyrow: function levelbyrow(d) {return d.levelByRow;}
        };
      }

      var _mainPath = {
        mark: 'g',
        selector: '.subseries',
        data: function data() {
          return _data3.disabled ? [] : _data3.data;
        },
        properties: {
          attrs: {
            "class": function _class(d, i) {
              d.subseriesIdx = i;
              return "subseries subseries_".concat(i);
            }
          }
        },
        anime: {
          exit: {
            delay: anime_config._exitduration
          }
        },
        children: [
        {
          mark: '_rect',
          selector: '.zc_bar',
          data: function data(d, i) {
            return _data3.disabled ? [] : _this.helpers.filterData(d);
          },
          dataAccessor: function dataAccessor(_) {return _this.chart.dataset.getX(_);},
          config: {
            enter: enterMarks,
            strokeWidth: _this.helpers.styles.bar.strokeWidth,
            dashStyle: _this.helpers.styles.bar.strokeDasharray,
            lineCap: 'none'
          },
          anime: {
            update: updateMarks,
            exit: exitMarks
          },
          properties: {
            attrs: attrs,
            styles: {
              fill: function fill(d, i) {return _this.helpers.styles.bar.fill(d, i);},
              stroke: function stroke(d, i) {return _this.helpers.styles.bar.stroke(d, i);},
              'fill-opacity': _this.helpers.styles.bar.fillOpacity,
              opacity: _this.helpers.styles.bar.opacity
            }
          }
        }]

      };
      return _mainPath;
    }

    MarksRegistry.add('bar.default', _mainBar);

    // export function _mainBar(data) {
    //     let _this = this;
    //     let currentData = data.data;
    //
    //     let _mainPath = {
    //         mark: 'g',
    //         selector: '.subseries',
    //         data: data.data,
    //         properties: {
    //             attrs: {
    //                 class: (d, i) => `subseries subseries_${i}`
    //             }
    //         },
    //         children: [
    //             {
    //                 mark: '_rect',
    //                 selector: '.zc-bar',
    //                 data: function (d, i) {
    //                     return _this.helpers.filterData(d);
    //                 },
    //                 config: {
    //                     enter: {
    //                         y: _this.chart.plotarea.height
    //                     },
    //                     x: (d) => _this.helpers.position.bar.end(d, 'x'),
    //
    //                     // y: (d) => _this.helpers.position.bar.end(d, 'y'),
    //                     width: (d) => _this.helpers.position.bar.end(d, 'width'),
    //                     // height: (d) => _this.helpers.position.bar.end(d, 'height'),
    //                     radius: _this.helpers.position.bar.end(null, 'radius'), //TODO If border is available as function it would be better
    //                     strokeWidth: _this.helpers.styles.bar.strokeWidth
    //                 },
    //                 properties: {
    //                     styles: {
    //                         fill: (d, i) => _this.helpers.styles.bar.fill(d, i),
    //                         stroke: (d, i) => _this.helpers.styles.bar.stroke(d, i),
    //                         'stroke-dasharray': _this.helpers.styles.bar.strokeDasharray,
    //                         'fill-opacity': _this.helpers.styles.bar.fillOpacity
    //                     }
    //                 },
    //                 anime: {
    //                     update: {
    //                         duration: 500,
    //                         y: { to: (d) => _this.helpers.position.bar.end(d, 'y') },
    //                         height: (d) => _this.helpers.position.bar.end(d, 'height')
    //                     },
    //                     exit: {
    //                         duration: 200,
    //                         y: _this.chart.plotarea.height,
    //                         height: 0
    //                     }
    //                 }
    //             }
    //         ]
    //     };
    //     return _mainPath;
    // }

    // export function _defaultBarMark(data) {
    //     let _this = this;
    //     let ____dummyOptions = {
    //         scales: {
    //             x: '',
    //             y: '',
    //             fillColor: ''
    //         },
    //         stack: true,
    //         rotated: false,
    //         type: 'bullet',
    //         sliding: '',
    //         rp: {
    //             hasNegValue: '',
    //             threshold: ''
    //         }
    //     };
    //     let currentData = data.data;
    //
    //     let _barMark = {
    //         mark: 'g',
    //         selector: '.subseries',
    //         data: data.data,
    //         children: [
    //             {
    //                 mark: '_rect',
    //                 selector: '.zc-bar',
    //                 data: function(d, i) {
    //                     return _this.helpers.filterData(d);
    //                 },
    //                 config: {
    //                     x: d => _this.helpers.position.barEnd(d, 'x'),
    //                     y: d => _this.helpers.position.barEnd(d, 'y', 0),
    //                     width: d => _this.helpers.position.barEnd(d, 'width'),
    //                     height: d => _this.helpers.position.barEnd(d, 'height')
    //                 },
    //                 properties: {
    //                     styles: {
    //                         fill: (d, i) => _this.helpers.styles.fill(d, i),
    //                         stroke: '',
    //                         'stroke-width': '',
    //                         'stroke-dasharray': '',
    //                         'fill-opacity': ''
    //                     }
    //                 }
    //             }
    //         ]
    //     };
    //     return _barMark;
    //
    //     return function(_data) {
    //         // let currentData = data.data;
    //         // let _barMark = {
    //         //     mark: {
    //         //         mark: 'g',
    //         //         selector: '.subseries',
    //         //         data: data.data
    //         //     },
    //         //     children: [
    //         //         {
    //         //             mark: 'rect-path',
    //         //             selector: '.zc-bar',
    //         //             data: function(d, i) {
    //         //                 return this.helpers.filterData(data);
    //         //             },
    //         //             properties: {
    //         //                 x: d => this.helpers.position.barEnd(d, 'x'),
    //         //                 y: d => this.helpers.position.barEnd(d, 'y', 0),
    //         //                 w: d => this.helpers.position.barEnd(d, 'width'),
    //         //                 h: d => this.helpers.position.barEnd(d, 'height'),
    //         //                 fill: 'blue'
    //         //             }
    //         //         }
    //         //     ]
    //         // };
    //         // let _barMark = {
    //         //     mark: {
    //         //         mark: 'g',
    //         //         // selector: '.barseries_i', //i should be dynamic
    //         //         selector: '.subseries_i', //i should be dynamic
    //         //         selector: function(cache) {
    //         //             return cache.dataIndex;
    //         //         },
    //         //         data: function(d, i) {
    //         //             return data.disabled ? [] : [d];
    //         //         },
    //         //         children: [
    //         //             {
    //         //                 mark: 'rect-path',
    //         //                 selector: '.zc-bar',
    //         //                 data: function(d, i) {
    //         //                     //dataUpdate
    //         //                     // let seriesdata = d.data[i];
    //         //                     let seriesdata = this.helpers.filterData(data);
    //         //                     //updateseriesdataby categories
    //         //                     //renderVisiblePointsOnly
    //         //                     //xAxisReverseed
    //         //                     return options.dataset.getX(d);
    //         //                 },
    //         //                 properties: {
    //         //                     enter: {
    //         //                         //line: 595
    //         //                         x: this.helpers.position('x'),
    //         //                         y: this.helpers.position('y'),
    //         //                         w: ____dummyOptions.rotated ? 0 : this.helpers.position('width'),
    //         //                         h: ____dummyOptions.rotated ? this.helpers.position('height') : 0,
    //         //                         //line: 620
    //         //                         stroke: options.stroke,
    //         //                         'stroke-width': options.borderSize,
    //         //                         'stroke-dasharray': options.dashStyle,
    //         //                         fill: options.fill,
    //         //                         fill: options.fillOpacity
    //         //                     },
    //         //                     update: {
    //         //                         y: {
    //         //                             from: this.__config___.y || 'init',
    //         //                             to: ''
    //         //                         },
    //         //                         x: {},
    //         //                         y: this.helpers.position('y'),
    //         //                         height: this.helpers.position('height'),
    //         //                         animate: {
    //         //                             //if morphing line: 753
    //         //                             attrTween: {
    //         //                                 d: (d, ele) => {
    //         //                                     return function(t) {
    //         //                                         return d3_line()(
    //         //                                             ____dummyOptions.interpolator.map(function(p) {
    //         //                                                 return p(t);
    //         //                                             })
    //         //                                         );
    //         //                                     };
    //         //                                 }
    //         //                             },
    //         //                             //normal bar line:802
    //         //                             delay: i => (____dummyOptions.sliding ? 0 : i * 10),
    //         //                             d: {
    //         //                                 from: '',
    //         //                                 to: () => this.helpers.position('all') //'all' I meant all attrs x,y,w,h
    //         //                             }
    //         //                         }
    //         //                     },
    //         //                     exit: {
    //         //                         //line: 351
    //         //                         d: (d, ele) => {
    //         //                             return {
    //         //                                 x: this.helpers.position('x'),
    //         //                                 y: this.helpers.position('y'),
    //         //                                 w: ____dummyOptions.rotated ? 0 : this.helpers.position('width'),
    //         //                                 h: ____dummyOptions.rotated ? this.helpers.position('height') : 0
    //         //                             };
    //         //                         }
    //         //                     }
    //         //                 }
    //         //             },
    //         //             {
    //         //                 //line:906
    //         //                 mark: 'g',
    //         //                 selector: '.subdividerseries_',
    //         //                 data: function(d, i) {
    //         //                     return data.disabled || !(i > 0 && options.stack) ? [] : [d];
    //         //                 },
    //         //                 children: [
    //         //                     {
    //         //                         name: 'UNIQUE_0', //merge properties or marks by names or any other better way
    //         //                         mark: 'rect-path',
    //         //                         selector: '.zc-bar',
    //         //                         data: function(d) {
    //         //                             return options.dataset.getX(d);
    //         //                         },
    //         //                         properties: {
    //         //                             attrs: {
    //         //                                 x: this.helpers.position('x'),
    //         //                                 y: this.helpers.position('y'),
    //         //                                 w: ____dummyOptions.rotated ? 1 : this.helpers.position('width'),
    //         //                                 h: ____dummyOptions.rotated ? this.helpers.position('width') : 1
    //         //                             },
    //         //                             styles: {
    //         //                                 fill: 'white',
    //         //                                 opacity: 0.7,
    //         //                                 'shape-rendering': 'crispedges'
    //         //                             }
    //         //                         }
    //         //                     }
    //         //                 ]
    //         //             },
    //         //             {
    //         //                 /*
    //         //                 Bar, bullet, gantt - level marker
    //         //                  */
    //         //                 //line:302
    //         //                 mark: 'g',
    //         //                 selector: options.stack ? 'levelMarkerSeries_' : '.subseries_levelMarker_',
    //         //                 data: d => (options.levelMarker ? [d] : []),
    //         //                 children: [
    //         //                     {
    //         //                         mark: 'rect-path',
    //         //                         selector: '.zc-levelMarker',
    //         //                         data: d => options.dataset.getX(d),
    //         //                         properties: {
    //         //                             enter: {
    //         //                                 d: () => {
    //         //                                     return {
    //         //                                         //line: 512
    //         //                                         x: this.helpers.levelMarkerPosition('x'),
    //         //                                         y: this.helpers.levelMarkerPosition('y'),
    //         //                                         w: this.helpers.levelMarkerPosition('width'),
    //         //                                         h: this.helpers.levelMarkerPosition('height')
    //         //                                     };
    //         //                                 },
    //         //                                 //line: 457
    //         //                                 fill: options.fill
    //         //                             },
    //         //                             exit: {
    //         //                                 animate: {
    //         //                                     d: {
    //         //                                         to: () => {
    //         //                                             //line: 313
    //         //                                             if (options.type == 'gantt') {
    //         //                                                 return 'd'; // dummy
    //         //                                             } else {
    //         //                                                 return {
    //         //                                                     x: this.helpers.levelMarkerPosition('x'),
    //         //                                                     y: this.helpers.levelMarkerPosition('y'),
    //         //                                                     w: this.helpers.levelMarkerPosition('width'),
    //         //                                                     h: this.helpers.levelMarkerPosition('height')
    //         //                                                 };
    //         //                                             }
    //         //                                         }
    //         //                                     }
    //         //                                 }
    //         //                             }
    //         //                         }
    //         //                     }
    //         //                 ]
    //         //             },
    //         //             {
    //         //                 /*
    //         //                 Bullet - target marker
    //         //                 Gantt - connector marker
    //         //                 waterfall - connector, comparison
    //         //                 bar, barrange, boxplot - whisker, median
    //         //                  */
    //         //             }
    //         //         ]
    //         //     }
    //         // };
    //     };
    // }

    // User data:
    // {
    //     "columns": {
    //     "market": {
    //         "name": "Market",
    //             "dataIndex": 0,
    //             "dataType": "ordinal"
    //     },
    //     "sales":{
    //         "name": "Sales",
    //             "dataIndex": 1,
    //             "dataType": "numeric"
    //     }
    // },
    //     "encode":{
    //     "x": "market",
    //         "y": "sales"
    // },
    //     "series":{
    //     "data": [
    //         ["central", 10000],
    //         ["east", 20000],
    //         ["west", 30000]
    //     ],
    //         "type": "bar"
    // }
    // }
    //
    // Parser data:
    // {
    //     "columns": {
    //     "market": {
    //         "name": "Market",
    //             "dataIndex": 0,
    //             "dataType": "ordinal"
    //     },
    //     "sales":{
    //         "name": "Sales",
    //             "dataIndex": 1,
    //             "dataType": "numeric"
    //     }
    // },
    //     "series": [{
    //     "data":[
    //         ["central", 10000],
    //         ["east", 20000],
    //         ["west", 30000]
    //     ],
    //     "mark": [
    //         {
    //             "mark": "rect-path",
    //             "encode":{
    //                 "x": "market",
    //                 "y": "sales",
    //                 "color": "",
    //             p    "size": ""
    //             },
    //worst case
    //"transition": {
    //
    // },
    //             "animate":{
    //custom hooks adding any d3 transition or selection API
    //                 "enter": {
    //                     //on start, end // what is the use here? is there any other way we can use this
    //                     "transition":{
    //                         "delay": ""
    //                     },
    //                     "attrs":{
    //                         "y": {
    //                             "from": "", //from element may be object or function or self element or we can ignore this pro
    //                             "to": ""
    //                         }
    //                     }
    //
    //                 },
    //                 "exit": {
    //                     "height": {
    //                         "from": "",
    //                         "to": ""
    //                     }
    //                 }
    //             },
    //             "enter": {
    //                 "x": "",
    //                 "y": "",
    //                 "w": "",
    //                 "h": ""
    //             }
    //         }
    //     ]
    // }]
    // }

    function _subseriesDividerMark(_data4) {
      var _this = this;
      var currentData = _data4.data;

      var _subdividerMark = {
        mark: 'g',
        selector: '.subdividerseries',
        data: function data() {
          return _data4.disabled || !_this.builderC.stacked ? [] : _data4.data;
        },
        properties: {
          attrs: {
            "class": function _class(d, i) {return "subdividerseries subdividerseries_".concat(i);}
          }
        },
        children: [
        {
          mark: '_rect',
          selector: '.zc-bar',
          data: function data(d, i) {
            return i > 0 ? _this.helpers.filterData(d) : [];
          },
          config: {
            update: {
              d: function d(_d24) {return _this.helpers.position.subdivider.end(_d24);}
            }
          },
          properties: {
            styles: {
              fill: 'white',
              opacity: 0.7,
              'shape-rendering': 'crispedges'
            }
          }
        }]

      };

      return _subdividerMark;
    }

    MarksRegistry.add('bar.subdivider', _subseriesDividerMark);

    function _levelMarkerMark(_data5, phase, condition) {
      var _this = this,
        attrs;
      if (this.chart.dataObject.hierarchical) {
        attrs = {
          levelbycolumn: function levelbycolumn(d) {return d.levelByColumn;},
          levelbyrow: function levelbyrow(d) {return d.levelByRow;}
        };
      }
      var _levelMarkerG = {
        mark: 'g',
        order: ':first-child',
        selector: '.subseries_levelMarker',
        properties: {
          attrs: {
            "class": function _class(d, i) {
              d.subseriesIdx = i;
              return "subseries_levelMarker subseries_levelMarker_".concat(i);
            }
          }
        },
        data: function data(d) {
          return condition ? _this.builderC.stacked ? _data5.data : !_data5.disabled ? _data5.data : [] : [];
        },
        children: []
      };
      if (condition) {
        _levelMarkerG.children.push({
          mark: '_rect',
          selector: '.zc_levelMarker',
          data: function data(d, i) {
            return _this.helpers.filterData(d);
          },
          dataAccessor: function dataAccessor(_) {return _this.chart.dataset.getX(_);},
          config: {
            // rect: d => _this.helpers.position.levelMarker.end(),
            d: function d(_d25) {return _this.helpers.position.levelMarker.end(_d25);}
          },
          properties: {
            attrs: attrs,
            styles: {
              fill: function fill(d, i) {return _this.helpers.styles.levelMarker.fill(d, i);},
              'fill-opacity': _this.helpers.styles.levelMarker.fillOpacity,
              opacity: _this.helpers.styles.levelMarker.opacity
            }
          }
        });
      }
      return _levelMarkerG;
    }

    MarksRegistry.add('bullet.levelmarker', _levelMarkerMark);

    function zcMorph(property) {
      this.sampling = property.sampling;
    }
    zcMorph.prototype.interpolate = interpolator;

    function getPoints$1(samplingDistance, path, maxLength, nonDependentShape) {
      var pathPoints = [];
      var i = 0,
        l,
        p = 0;
      if (nonDependentShape) {
        l = i;
      } else {
        l = p;
      }
      for (; l < maxLength;) {
        pathPoints.push(path.getPointAtLength(i));
        i = i + samplingDistance;
        p++;
        if (nonDependentShape) {
          l = i;
        } else {
          l = p;
        }
      }
      return pathPoints;
    }

    function interpolator(firstPathObject, secondPathObject) {
      var samplingDist = this.sampling;
      var firstPath = firstPathObject.path;
      var secondPath = secondPathObject.path;
      if (firstPath.getTotalLength() > secondPath.getTotalLength()) {
        var firstPathPoints = getPoints$1(samplingDist, firstPath, firstPath.getTotalLength(), true);
        var secondPathPoints = getPoints$1(secondPath.getTotalLength() / firstPathPoints.length, secondPath, firstPathPoints.length, false);
      } else {
        var secondPathPoints = getPoints$1(samplingDist, secondPath, secondPath.getTotalLength(), true);
        var firstPathPoints = getPoints$1(firstPath.getTotalLength() / secondPathPoints.length, firstPath, secondPathPoints.length, false);
      }
      var interpolatedArray = [];
      for (var l = 0; l < firstPathPoints.length; l++) {
        var interpolate = d3.interpolate(
        [firstPathPoints[l].x + firstPathObject.xOffset, firstPathPoints[l].y + firstPathObject.yOffset],
        [secondPathPoints[l].x + secondPathObject.xOffset, secondPathPoints[l].y + secondPathObject.yOffset]);

        interpolatedArray.push(interpolate);
      }
      return interpolatedArray;
    }

    function bar_morph_collectors() {
      var _this = this,
        builderC = this.builderC,chart = this.chart,
        morphConfig = chart.systemConf.chart.plot.morph,
        morph_Obj = new zcMorph({ sampling: morphConfig.samplingDistance });

      var oldData = chart.oldSeriesInfo.get(builderC.datasetIndex),
        oldInfo = {
          seriesIdx: oldData.seriesIndex,
          color: oldData.color,
          transform: oldData.transformationInfo
        },
        offsetValue = getOffsetValue(chart, oldInfo.seriesIdx),
        transitionDuration = morphConfig.duration;

      var interpolated = {};
      var line = d3_line();

      var current_data = this.helpers.filterData(this.data.data[0]); //subseriesIdx
      current_data.map(function (d, i) {
        var params = _this.helpers.position.bar.end(d);
        if (isNaN(params.x1) || isNaN(params.y1)) {
          params.x1 = -1;
          return null;
        }
        var _radius = builderC.border && builderC.border.show ? builderC.border.radius : 0;

        var currentPath = roundedRect(params.x1, params.y1, params.x2, params.y2, getBorderRadius(_radius), null, null, true);
        var fromPath = chart.oldSeriesInfo.get(oldInfo.seriesIdx).pathData[i];
        var fromPathAttribute = fromPath.getAttribute('d');
        fromPath.setAttribute('d', currentPath);
        var toPath = fromPath.cloneNode();
        fromPath.setAttribute('d', fromPathAttribute);
        interpolated[i] = morph_Obj.interpolate(
        {
          path: fromPath,
          xOffset: offsetValue.x + oldInfo.transform[i].x,
          yOffset: offsetValue.y + oldInfo.transform[i].y
        },
        { path: toPath, xOffset: 0, yOffset: 0 });

      });
      _this.helpers.position.bar_morphing = {
        interpolator: interpolated,
        line_d3: line
      };
      return interpolated;
    }

    MarksRegistry.add('bar.morph', bar_morph_collectors);

    function getMarkerConfig(config, animationOptions, symbol) {
      return {
        enabled: config.enabled,
        dataindex: config.dataindex,
        columnindex: config.columnindex,
        size: config.size,
        symbol: config.symbol || symbol || 'line',
        innerFillColor: 'transparent',
        innerStrokeColor: 'transparent',
        innerStrokeWidth: 0,
        innerStrokeOpacity: 0,
        outerFillColor: config.color,
        outerStrokeOpacity: config.opacity,
        outerStrokeWidth: config.strokeWidth,
        outerStrokeColor: config.color,
        animation: animationOptions,
        hoveroptions: {
          size: config.hoveroptions.size || config.size,
          symbol: config.symbol || symbol || 'line',
          innerFillColor: config.hoveroptions.innerFillColor || 'transparent',
          innerStrokeColor: 'transparent',
          innerStrokeWidth: 0,
          innerStrokeOpacity: 0,
          outerFillColor: config.hoveroptions.color || config.color,
          outerStrokeOpacity: config.hoveroptions.opacity || config.opacity,
          outerStrokeWidth: config.hoveroptions.strokeWidth || config.strokeWidth,
          outerStrokeColor: config.hoveroptions.color || config.color
        }
      };
    }

    function BarWhiskerHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }
    inherit(BarWhiskerHighlighter, BarHighlighter);
    var proto$i = BarWhiskerHighlighter.prototype;

    proto$i._defaultH = function (point) {
      if (point._type == 'segment') {
        return [
        {
          shape: 'whisker',
          data: proto$i.data,
          segments: proto$i.segments,
          path: this.path,
          context: this.renderingContext,
          translate: this.translateContext
        }];

      } else {
        return [
        {
          shape: RECT_ELEMENT,
          path: _super(this).path,
          data: _super(this).data,
          context: _super(this).renderingContext,
          translate: _super(this).translateContext,
          styles: patternFillEffect
        }];

      }
    };
    proto$i.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('scatter').call(this, this.chart);
    };

    proto$i.segments = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params;
      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key];
        if (!defined(cache._segments)) {
          var _data = point._data();
          var symbolSegment = getSegmentsForSymbol(
          'horizontal-whisker',
          rp.whiskers.size,
          _data._x,
          _data._y,
          whiskerSize(point, rp.yscale, null, null, null, rp.whiskers.dataindex));

          cache._segments = symbolSegment;
        }
        return point;
      };
    };

    proto$i._options = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params;

      return rp.whiskersOptionsMerged.hoveroptions;
    };

    proto$i.whiskerY = function (point) {
      var renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        whiskerIndex = rp.whiskers.dataindex;
      return (rp.yscale(point[whiskerIndex][0]) + rp.yscale(point[whiskerIndex][1])) / 2;
    };
    proto$i.path = function (point, model) {
      point = point._data && point._data() || point;
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        cp = renderer.commonOption;

      var _hoveroptions = this._options(point);
      var context = model.context.call(this),
        translate = model.translate.call(this),_point4 =
        point,seriesIndex = _point4.seriesIndex,paneid = _point4.paneid,
        pathContext = appendEle(
        context,
        'g',
        [1],
        '.',
        'class',
        "highlight".concat(point.paneid).concat(seriesIndex).concat(point.itemIndex).concat(model.type) || '_'),

        mPosition = rp.axisrotated ?
        [this.whiskerY(point), point._y + cp.barWidth / 2] :
        [point._x + cp.barWidth / 2, this.whiskerY(point)],
        wSize = whiskerSize(point, rp.yscale, null, null, null, rp.whiskers.dataindex),
        mSize;

      if (typeof _hoveroptions.size === 'string' && _hoveroptions.size.indexOf('%') > -1) {
        //if user gives size as percent, '75%'
        _hoveroptions.size = mSize = parseFloat(_hoveroptions.size) / 100 * cp.barWidth / 10;
      }
      addSVGmarker(
      pathContext,
      null,
      _hoveroptions,
      {
        color: _hoveroptions.color,
        symbolSize: {
          inner: 0,
          outer: 1
        },
        symbol: 'horizontal-whisker',
        transform: mPosition,
        rotate: rp.axisrotated ? 90 : 0,
        imageSize: 15,
        size2d: wSize
      },
      this.chart);

      context.style('display', '');
      context.attr('transform', "translate(".concat(translate[0], ",").concat(translate[1], ")"));
      return pathContext;
    };

    function applyClippathToLivePlot(data, holder, renderer, chart) {
      if (renderer.phase == 'redraw') {
        var clipX = renderer.scales.x(chart.dataset.getX(data[0]));
        var properties = {
            name: 'rect',
            id: chart.id,
            x: clipX,
            y: 0,
            width: chart.plotarea.width,
            height: chart.plotarea.height
          },
          args = {
            chartObj: chart
          };
        var clipID = effects.get(effects.svg_clips, 'rect', properties, args);
        holder.attr('clip-path', "url(".concat(chart.defsLocation, "#").concat(clipID, ")"));
      }
    }

    var bar_parser_helpers = function bar_parser_helpers() {var _this34 = this;
      var chart = this.chart,
        processor = chart.dataObject,
        dataset = chart.dataset;
      var helpers = {
        column: function column(type, order) {
          var columnIdx = dataset.getColumnIdx(type, order);
          return chart.systemConf.metadata.columns[columnIdx];
        },
        datatype: function datatype(type, order) {return dataset.getDataType(type, order);},
        filterData: function filterData(data) {
          var subseriesIdx = data.subseriesIdx || 0,
            liveUpdate = _this34.builderC.liveUpdate; //TODO if flatten data calculated first, we can remove this property
          if (_this34.seriesdataAfterUpdate[subseriesIdx] && !liveUpdate) {
            return _this34.seriesdataAfterUpdate[subseriesIdx];
          }

          if (liveUpdate) {
            applyClippathToLivePlot(data, _this34.placeHolder, _this34, chart);
            return DataProcessor.helpers.getDynamicData(data, _this34.chart);
          }

          //updateseriesdataby categories
          //renderVisiblePointsOnly
          //xAxisReverseed

          var datatypeY = chart.dataset.getDataType('y', _this34.commonOption.yaxiscolumnorder),
            xCategories = _this34.scales.x.domain(),
            yCategories = datatypeY == ORDINAL_DATATYPE ? _this34.scales.y.domain() : null,
            dataProcessorHelpers = DataProcessor.helpers;
          var serData = processor.updateSeriesdatabyCategories(
          d3_values(data),
          xCategories,
          yCategories,
          _this34.commonOption.yaxiscolumnorder,
          true,
          subseriesIdx);

          if (chart.renderVisiblePointsOnly) {
            serData = dataProcessorHelpers.filterPointsInViewport(chart, serData, 'bar', 'x', _this34.rendererIndex, subseriesIdx || 0);
          }
          _this34.seriesdataAfterUpdate[subseriesIdx || 0] = serData;
          var dataUpdate = _this34.seriesdataAfterUpdate[subseriesIdx || 0];
          _this34.oldRenderer.seriesdataAfterUpdate[subseriesIdx || 0] = serData; //update in existing renderer
          _this34.builderC.xcategoriesReversed = xCategories;
          if (_this34.builderC.xaxisreversed) {
            serData = serData.slice(0).reverse();
            _this34.builderC.xcategoriesReversed = xCategories.slice(0).reverse();
          }
          var showLevelMarker = _this34.builderC.levelMarker && _this34.builderC.levelMarker._zc_enabled;
          if (showLevelMarker && _this34.builderC.stacked && xCategories.length != dataUpdate.length) {
            plot.render.bulletHelpers.addDummyDataForLevelmarker(dataUpdate, xCategories, dataset, _this34.commonOption.yaxiscolumnorder);
          }

          return _this34.seriesdataAfterUpdate[subseriesIdx || 0];
        },
        position: {},
        styles: {},
        styleComponent: {}
      };
      return helpers;
    };

    function setBarBuilderConfig() {
      var _this = this,
        builderC = this.builderC,
        seriesOptions = this.config.series,
        commonOptions = this.config.common,
        animationOptions = getAnimationConf(commonOptions, seriesOptions, this.chart, 'bar'),
        morphing = this.chart.systemConf.chart.plot.morph.enabled && this.chart.oldSeriesInfo;

      /*
      ENTER UPDATE EXIT TRANSITION DURATION
       */
      if (animationOptions.enabled) {
        if (morphing) {
          animationOptions._duration = this.chart.systemConf.chart.plot.morph.duration || animationOptions.duration;
        } else if (animationOptions.type == VERTICALALL_ANIMATION) {
          animationOptions._duration = animationOptions.duration;
        } else {
          animationOptions._duration = function (d, j) {
            var slicedDuration =
            animationOptions.duration / (_this.seriesdataAfterUpdate[d.subseriesIdx || 0].length * builderC.barSeriesCount);
            return slicedDuration;
          };
        }
      } else {
        animationOptions._duration = 0;
      }

      animationOptions._delay = function (d, j) {
        if (animationOptions.type == VERTICALALL_ANIMATION || _this.phase == 'redraw') {
          return 1;
        } else {
          var slicedDuration =
          animationOptions.duration / (_this.seriesdataAfterUpdate[d.subseriesIdx || 0].length * builderC.barSeriesCount);
          return (j * builderC.barSeriesCount + builderC.datasetIndex) * slicedDuration;
        }
      };

      animationOptions._exitduration = animationOptions.enabled ? 100 : 0;

      this.builderC.animationOptions = animationOptions;

      this.builderC.barSeriesCount = this.chart.dataObject.noofBarEnabledSeries;

      this.builderC.border =
      seriesOptions && seriesOptions.border ? mergeJSON$1(commonOptions.border, seriesOptions.border, true) : commonOptions.border;

      this.builderC.levelMarker =
      seriesOptions && seriesOptions.levelMarker ?
      mergeJSON$1(commonOptions.levelMarker, seriesOptions.levelMarker, true) :
      commonOptions.levelMarker;

      var stackIndex = _this.builderC.stacked ?
      getStackGroupIndex(_this.chart.dataObject.getStackGroup(), _this.builderC.datasetIndex) :
      null;
      _this.builderC.stackIndex = stackIndex;
      if (this.builderC.levelMarker) {
        this.builderC.levelMarker._zc_enabled = _this.builderC.levelMarker && _this.builderC.levelMarker.enabled;

        if (_this.builderC.stacked) {
          this.builderC.levelMarker._zc_enabled =
          this.builderC.levelMarker._zc_enabled && (
          _this.builderC.stacked && _this.chart.dataObject.noofBarEnabledSeries > 0 || !this.data.disabled) &&
          !_this.chart.dataObject.isStackedPercentChart && (
          !_this.builderC.stacked || !!_this.chart.dataObject.getEncode('stack', stackIndex));
        }
      }

      this.builderC.whiskers =
      seriesOptions && seriesOptions.whiskers ? mergeJSON$1(commonOptions.whiskers, seriesOptions.whiskers, true) : commonOptions.whiskers;

      if (this.builderC.whiskers) {
        var whiskersSymbol = this.builderC.whiskers.showOn == 'edges' ? 'whiskers' : 'horizontal-whisker';
        this.builderC.whiskersOptionsMerged = getMarkerConfig(this.builderC.whiskers, animationOptions, whiskersSymbol);
      }
    }

    var ZC_BAR_MARKS_MAPPING = function ZC_BAR_MARKS_MAPPING() {var _this35 = this;
      var _this = this;
      var mapping = {
        bar: {
          operator: MarksRegistry.get('bar.default')
        },
        subdivider: {
          operator: MarksRegistry.get('bar.subdivider')
        },
        levelmarker: {
          condition: function condition() {
            return _this.builderC.levelMarker && _this.builderC.levelMarker._zc_enabled;
          },
          operator: MarksRegistry.get('bullet.levelmarker'),
          holder: function holder() {
            if (_this.builderC.stacked) {
              var stackIndex = getStackGroupIndex(_this.chart.dataObject.getStackGroup(), _this.builderC.datasetIndex);
              return createElement('g', ".levelMarkerSeries_".concat(stackIndex), [_this35.chart.seriesdata], _this.container, ':first-child');
            }
          }
        },
        targetmarker: {
          condition: function condition() {return _this.builderC.targetMarker && _this.builderC.targetMarker.enabled;},
          operator: MarksRegistry.get('bullet.targetmarker'),
          holder: function holder() {return _this.chart.staticPaneSVG.selectAll("g.qualitativeGroup");}
        },
        whisker: {
          condition: function condition() {return _this.builderC.whiskers && _this.builderC.whiskers.enabled;},
          operator: MarksRegistry.get('boxplot.whisker'),
          holder: function holder() {return _this.chart.staticPaneSVG.selectAll("g.qualitativeGroup");}
        },
        median: {
          condition: function condition() {return _this.builderC.median && _this.builderC.median.enabled;},
          operator: MarksRegistry.get('boxplot.median'),
          holder: function holder() {return _this.chart.staticPaneSVG.selectAll("g.qualitativeGroup");}
        }
      };
      return mapping;
    };

    var bar_position = function bar_position() {var _this36 = this;
      var position_helpers = {};

      var KEY = 'bar';

      var borderComponent = this.builderC.border,
        radius = borderComponent && borderComponent.show ? borderComponent.radius : null;

      this.helpers.position[KEY] = {};

      /*
      START POSITION
       */
      this.helpers.position[KEY].start = function (d, encode) {
        var _this36$builderC = _this36.builderC,stacked = _this36$builderC.stacked,hasNegValue = _this36$builderC.hasNegValue;
        var chartPhase = _this36.chart.phase;
        var x, y, width, height;

        var x_data = _this36.chart.dataset.getX(d),
          yRange_low = _this36.scales.y.range()[0],
          y_negValue = hasNegValue != null ? _this36.scales.y(hasNegValue) : null,
          rangeY_0 = _this36.rangeYType ? _this36.scales.y(_this36.chart.dataset.getY(d, 0, 0)) : null,
          y_priority = pick(rangeY_0, y_negValue);

        x = stacked ?
        _this36.scales.x(x_data) + _this36.scales.interX(_this36.commonOption.stackGroupIndex) + _this36.commonOption.padding :
        _this36.scales.x(x_data) + _this36.scales.interX(_this36.barDatasetIndex + (d.subseriesIdx || 0)) + _this36.commonOption.padding;
        if (_this36.scales.y.bandwidth) {
          y = _this36.scales.y.origRange[0];
        } else {
          if (y_priority != null) {
            y = y_priority;
          } else {
            if (stacked && chartPhase == 'legendFilter') {
              yRange_low = _this36.scales.y(d.y0);
            }
            var y_zeroValue = _this36.scales.y(0);
            y = _this36.chart.axes.rotated || stacked ? yRange_low : y_zeroValue != null ? mathMin(y_zeroValue, yRange_low) : yRange_low;
          }
        }

        width = _this36.chart.axes.rotated ? 0 : _this36.commonOption.barWidth;
        height = _this36.chart.axes.rotated ? _this36.commonOption.barWidth : 0;

        var rect = _this36.chart.axes.rotated ? { x: y, y: x, width: width, height: height, radius: radius } : { x: x, y: y, width: width, height: height, radius: radius };

        if (isNaN(x)) {
          return getAbsRectPartialCoords(rect, _this36.builderC.yaxisreversed, _this36.chart.axes.rotated, _this36.chart.axes.rotated ? 'y' : 'x');
        }
        if (isNaN(y)) {
          return getAbsRectPartialCoords(rect, _this36.builderC.yaxisreversed, _this36.chart.axes.rotated, _this36.chart.axes.rotated ? 'x' : 'y');
        }
        if (!encode) {
          var coords = getAbsRectCoords(rect, _this36.builderC.yaxisreversed, _this36.chart.axes.rotated);
          return coords;
        }
      };

      /*
       END POSITION
        */


      this.helpers.position[KEY].end = function (d, encode, yRangePos, relative) {
        var rectValue = _this36.chart.dataObject.getTransRectValue;
        if (encode) {
          if (encode == 'radius') {
            return radius;
          }
          return _this36.chart.dataObject.getTransRectValue(encode, d, d.subseriesIdx || 0, null, _this36.commonOption, null, yRangePos);
        }
        var x, y, width, height;

        x = _this36.chart.dataObject.getTransRectValue('x', d, d.subseriesIdx || 0, null, _this36.commonOption),
        y = _this36.chart.dataObject.getTransRectValue('y', d, d.subseriesIdx || 0, null, _this36.commonOption, yRangePos),
        width = _this36.chart.dataObject.getTransRectValue('width', d, d.subseriesIdx || 0, null, _this36.commonOption),
        height = _this36.chart.dataObject.getTransRectValue('height', d, d.subseriesIdx || 0, null, _this36.commonOption);
        if (relative) {
          return { x: x, y: y, width: width, height: height };
        }
        var coords = getAbsRectCoords({ x: x, y: y, width: width, height: height, radius: radius }, _this36.builderC.yaxisreversed, _this36.chart.axes.rotated);
        return coords;
      };

      /*
       INTERMEDIATE STOP 1 - CHAIN ANIMATED
        */


      this.helpers.position[KEY].stop_1 = function (d, encode, yRangePos) {
        var start = _this36.helpers.position[KEY].start(d),
          end = _this36.helpers.position[KEY].end(d);
        var x1, y1, x2, y2;
        if (_this36.chart.axes.rotated) {
          y1 = end.y1;
          y2 = end.y2;
          return { y1: y1, y2: y2 };
        } else {
          x1 = end.x1;
          x2 = end.x2;
          return { x1: x1, x2: x2 };
        }
        // let coords = getAbsRectCoords({ x, y, width, height }, this.builderC.yaxisreversed, this.chart.axes.rotated);
        return { x1: x1, y1: y1, x2: x2, y2: y2 };
      };

      this.helpers.position[KEY].exit = this.helpers.position[KEY].start;

      return position_helpers;
    };

    /*
     ENCODE FOR RACING BAR
       */



    function racing_bar_position() {var _this37 = this;

      var KEY = 'bar_racing',
        SUPER_KEY = 'bar';

      var borderComponent = this.builderC.border,
        radius = borderComponent && borderComponent.show ? borderComponent.radius : null;

      this.helpers.position[KEY] = {};

      this.helpers.position[KEY].start = function (d, encode, yRangePos) {
        if (_this37.chart.axes.rotated && !_this37.chart.axes.x.reversed) {
          var _coords = _this37.helpers.position[SUPER_KEY].end(d);
          _coords.y1 = -_this37.chart.plotarea.top;
          _coords.y2 = _this37.scales.x.bandwidth() - _this37.chart.plotarea.top;
          return _coords;
        }
        var coords = _this37.helpers.position[SUPER_KEY].end(d);
        coords.y1 = _this37.chart.plotarea.height + 20;
        coords.y2 = _this37.scales.x.bandwidth() + _this37.chart.plotarea.height + 20;
        return coords;
      };

      this.helpers.position[KEY].end = function (d, encode, yRangePos) {
        return _this37.helpers.position[SUPER_KEY].end(d);
      };

      this.helpers.position[KEY].exit = function (d, encode, yRangePos) {
        if (_this37.chart.axes.rotated && !_this37.chart.axes.x.reversed) {
          var _y6 = -_this37.chart.plotarea.top;
          var _y7 = _this37.scales.x.bandwidth() - _this37.chart.plotarea.top;
          return { y1: _y6, y2: _y7 };
        }
        var y1 = _this37.chart.plotarea.height + 20;
        var y2 = _this37.scales.x.bandwidth() + _this37.chart.plotarea.height + 20;
        return { y1: y1, y2: y2 };
      };
    }

    function getAbsRectCoords(rect, yReverse, rotated) {
      var r = rect.radius ? checkRadiusWithinBoundary(getBorderRadius(rect.radius), rect.width, rect.height) : 0;
      return {
        x1: yReverse && rotated ? rect.x - rect.width : rect.x,
        y1: yReverse && !rotated ? rect.y - rect.height : rect.y, //x1,y1 should be at top left . x2,y2 should be at bottom right .
        x2: yReverse && rotated ? rect.x : rect.x + rect.width,
        y2: yReverse && !rotated ? rect.y : rect.y + rect.height,
        radius: r
      };
    }
    function getAbsRectPartialCoords(rect, yReverse, rotated, type) {
      var r = rect.radius ? checkRadiusWithinBoundary(getBorderRadius(rect.radius), rect.width, rect.height) : 0;
      if (type == 'x') {
        return {
          y1: yReverse && !rotated ? rect.y - rect.height : rect.y, //x1,y1 should be at top left . x2,y2 should be at bottom right .
          y2: yReverse && !rotated ? rect.y : rect.y + rect.height
        };
      } else {
        return {
          x1: yReverse && rotated ? rect.x - rect.width : rect.x,
          x2: yReverse && rotated ? rect.x : rect.x + rect.width
        };
      }
    }
    var bar_styles = function bar_styles() {var _this38 = this;
      var KEY = 'bar';
      var chart = this.chart,
        fillComponent = getBarFillColor.call(this), //TODO move this function here. avoid calling .call(this)
        strokeComponent = getStrokeColor(this.chart, this.builderC.datasetIndex, this.paneid, this.builderC),
        borderComponent = this.builderC.border || {};
      var multiColoring = isMultiColoring(this.config.common, this.chart),
        patternPallete = this.chart.patternPallete && this.chart.patternPallete.length;

      this.oldRenderer.fillColorFunc = fillComponent; //FEATURESEVENTS_TICKLABEL_6

      this.helpers.styleComponent[KEY] = {
        fillComponent: fillComponent
      };
      this.helpers.styles[KEY] = {
        fill: function fill(d, i) {
          var itemPos = _this38.chart.systemConf.chart.plot.allowDuplicateCategories ?
          _this38.builderC.xcategoriesReversed.indexOf(_this38.chart.dataset.getX(d)) :
          pick(d.sortedItemIndex, i);
          var baseClrIdx = multiColoring ? itemPos : _this38.legendOrder;
          var dim = patternPallete ? _this38.helpers.position.bar.end(d, null, null, true) : null;
          return fillComponent(baseClrIdx, d, null, _this38.builderC.paneColor, null, null, dim);
        },
        stroke: function stroke(d, i) {
          // if (borderComponent.show) {
          var itemPos = _this38.chart.systemConf.chart.plot.allowDuplicateCategories ?
          _this38.builderC.xcategoriesReversed.indexOf(_this38.chart.dataset.getX(d)) :
          pick(d.sortedItemIndex, i);
          var baseClrIdx = multiColoring ? itemPos : _this38.legendOrder;
          return strokeComponent(baseClrIdx, d, borderComponent.color || _this38.builderC.paneColor);
          // }
        },
        strokeWidth: borderComponent.show ? pick(borderComponent.size, 1) : 0,
        strokeDasharray: borderComponent.show ? borderComponent.style : null,
        fillOpacity: this.builderC.gvp('fillOpacity'),
        opacity: function opacity(d, i) {
          var opacity = _setOpacityForTickFilterElements(d, i, chart, 'bar');
          d3_select(this).attr('filtered-opacity', opacity);
          return opacity;
        }
      };
    };

    function getBarFillColor() {
      var gradientDim = gradient_helpers.getDimension(this.chart, this.builderC.datasetIndex, this.paneid);
      return getFillColor(this.chart, this.builderC.datasetIndex, this.paneid, gradientDim);
    }

    var bar_subdivider_position = function bar_subdivider_position() {var _this39 = this;
      var KEY = 'subdivider',
        SUPER_KEY = 'bar';

      this.helpers.position[KEY] = {};

      this.helpers.position[KEY].end = function (d, encode) {
        var end = _this39.helpers.position[SUPER_KEY].end(d);

        var x, y, width, height;
        if (_this39.chart.axes.rotated) {
          x = _this39.scales.y(d.y0);
          y = end.y1;
          width = 1, height = _this39.commonOption.barWidth;
        } else {
          x = end.x1;
          y = _this39.scales.y(d.y0);
          width = _this39.commonOption.barWidth, height = 1;
        }

        var coords = getAbsRectCoords({ x: x, y: y, width: width, height: height }, _this39.builderC.yaxisreversed, _this39.chart.axes.rotated);
        return coords;
      };
    };

    function getBaseMark4BarMarker(type, _data6, options, order, prefix) {
      var _this = this;
      var markerParser = getMarkerParserForBar(_this, type, options, order, prefix);
      var baseG = {
        mark: 'g',
        selector: ".markers".concat(order),
        data: function data(d) {
          return d;
        },
        properties: {
          attrs: {
            transform: "translate(".concat(_this.chart.plotarea.left, ",").concat(_this.chart.plotarea.top, ")")
          }
        },
        children: [
        {
          mark: 'g',
          data: function data(d) {
            return _data6 || _this.helpers.filterData(d);
          },
          properties: {
            attrs: {
              transform: function transform(d) {
                var axisrotated = _this.chart.axes.rotated,
                  x = _this.helpers.position[type].end(d).x,
                  y = _this.helpers.position[type].end(d, 'y', order).y,
                  rotate = _this.helpers.position[type].end(d).rotate;
                return "translate(".concat(axisrotated ? y : x, ",").concat(axisrotated ? x : y, ") rotate(").concat(axisrotated ? 90 : 0, ")");
              }
            }
          },
          children: [_objectSpread({}, markerParser)]
        }]

      };
      return baseG;
    }

    function getMarkerParserForBar(_this, type, options, order, prefix) {
      var options_cloned = _objectSpread({}, options);
      /*
      UPDATE STROKECOLOR & STROKEWIDTH IN OPTIONS
       */
      options_cloned.outerStrokeColor = function (d) {
        if (!isWithinColorRange(_this.chart.dataset.getClr(d), _this.chart)) {
          return 'transparent';
        } else {
          return options.outerStrokeColor;
        }
      };
      options_cloned.strokeWidth = options.strokeWidth || 0; //DOC_BULLET_11

      /*
      HIDE INNER MARKER ON FOLLOWING CONDITIONS
       */
      var innerData;
      if (prefix == 'inner') {
        var hasImage = options.imageUrl != null && options.imageUrl !== '',
          innerColor = options.innerFillColor || options.color;
        innerData =
        hasImage || options.innerStrokeWidth === 0 && (options.innerFillOpacity === 0 || innerColor === 'transparent') ? [] : [1];
      }

      var _markerParser = MarkerParser({
        data: function data(d) {
          return prefix == 'inner' ? innerData : [d];
        },
        prefix: prefix || 'outer',
        selection: prefix ? ".".concat(prefix) : '.outer',
        config: _objectSpread(_objectSpread({
          x: 0,
          y: 0,
          rotate: function rotate(d) {return _this.helpers.position[type].end(d).rotate;} },
        options_cloned), {}, {
          shape: options.symbol,
          color: null,
          size: function size(d, i) {return _this.helpers.position[type].end(d, 'size', order, prefix);} }),

        context: _this.chart.getPatternSvg(),
        defsPath: _this.chart.defsLocation
      });

      if (options.animation && options.animation.enabled) {
        delete _markerParser.config.strokeOpacity;
        _markerParser.config.enter = {
          strokeOpacity: 0
        };
        _markerParser.anime = {
          update: {
            duration: options.animation.duration,
            delay: options.animation.duration,
            strokeOpacity: options.outerStrokeOpacity
          }
        };
      }
      return _markerParser;
    }

    function getBarMarkerSize(type, prefix) {
      //Reset old config.size
      var _config = this.builderC[type];
      if (_config._size !== undefined) {
        _config.size = _config._size;
      } else {
        _config._size = _config.size || null;
      }
      var DIM = 10,
        symbolSize = { outer: 1, inner: 0.6 },
        config = this.builderC[type],
        hasImage = config.imageUrl != null && config.imageUrl !== '',
        size = config.size;
      size = defined(size) ? size : this.commonOption.levelMarkerWidth - 2 * validateNullVal(config.padding, this.commonOption.padding / 2);
      if (defined(config.size) && typeof size === 'string' && size.indexOf('%') > -1) {
        //if user gives size as percent, '75%'
        size = parseFloat(size) / 100 * this.commonOption.levelMarkerWidth / 10;
      }
      if (defined(config.size) && type == 'targetMarker') {
        size = mathMin(size, this.scales.x.bandwidth() / 10);
      }
      this.builderC[type].size = defined(config.size) ? size : size / 10;
      size = pick(config.size, 1);
      // let imgSize = (id != null ? size : size * symbolSize.outer) * DIM;
      var outersize = size * symbolSize[prefix || 'outer'] * DIM;
      return outersize;
    }

    var boxplot_whisker_position = function boxplot_whisker_position() {var _this40 = this;
      var position_helpers = {};

      var KEY = 'whiskers',
        KEY_MERGED = 'whiskersOptionsMerged';

      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        var builderC = this.builderC,
          whiskerOptions = builderC[KEY_MERGED],
          yidx = this.chart.dataset.yidx(this.commonOption.yaxiscolumnorder),
          whiskerIdx = whiskerOptions.dataindex,
          isWhiskerOnEdges = builderC.whiskers.showOn == 'edges',
          barMSize = getBarMarkerSize.call(this, KEY_MERGED);

        this.helpers.position[KEY] = {
          start: function start(d, encode) {},
          end: function end(d, encode, order) {
            var x = _this40.scales.x(_this40.chart.dataset.getX(d)) + _this40.commonOption.levelMarkerWidth / 2;
            x = x + _this40.scales.interX(_this40.commonOption.barDatasetIndex) + _this40.commonOption.padding;

            var y = defined(order) ?
            _this40.scales.y(d[whiskerIdx][order]) :
            (_this40.scales.y(d[whiskerIdx][0]) + _this40.scales.y(d[whiskerIdx][1])) / 2;
            if (encode == 'size') {
              var wSize, customMarkers;
              if (isWhiskerOnEdges) {
                wSize = whiskerSize(d, _this40.builderC.yscale, whiskerIdx, yidx, order);
                wSize = _this40.chart.axes.rotated ? -wSize : wSize;
              } else {
                wSize = whiskerSize(d, _this40.builderC.yscale, null, null, null, whiskerIdx);
              }
              customMarkers = {
                symbol: 'vertical-line-z',
                size: wSize
              };

              return [barMSize, wSize, customMarkers];
            }
            return {
              x: x,
              y: y,
              rotate: _this40.chart.rotated ? 90 : 0
            };
          }
        };
      }

      return position_helpers;
    };

    function boxplot_whisker_styles() {
      var KEY = 'whiskers',
        KEY_MERGED = 'whiskersOptionsMerged';

      var options = this.builderC[KEY_MERGED];

      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        this.helpers.styles[KEY] = {
          fill: options.color,
          stroke: options.color,
          strokeWidth: pick(options.strokeWidth, 1),
          strokeDasharray: options.dashStyle,
          strokeLinecap: options.lineCap
        };
      }
    }

    var bullet_levelmarker_position = function bullet_levelmarker_position() {var _this41 = this;
      var KEY = 'levelMarker';

      var position_helpers = {};

      var builderC = this.builderC;

      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        this.helpers.position[KEY] = {
          start: function start(d, encode) {},
          end: function end(d, relative) {
            var bullet_coords = plot.render.bulletHelpers.ZC_BAR_getLevelMarkerRect(
              d,
              _this41.builderC.levelMarker,
              _this41.chart,
              _this41.commonOption,
              _this41.builderC,
              d.subseriesIdx || 0,
              _this41.builderC.datasetIndex),

              rect_coords;
            if (_this41.chart.axes.rotated) {
              rect_coords = {
                x: bullet_coords.y,
                y: bullet_coords.x,
                width: bullet_coords.width,
                height: bullet_coords.height
              };
            } else {
              rect_coords = bullet_coords;
            }
            if (relative) {
              return rect_coords;
            }
            rect_coords.radius = _this41.helpers.position.bar.end(null, 'radius');
            var coords_abs = getAbsRectCoords(rect_coords, _this41.builderC.yaxisreversed, _this41.chart.axes.rotated);
            return coords_abs;
          }
        };
      }

      return position_helpers;
    };

    var bullet_levelmarker_styles = function bullet_levelmarker_styles() {var _this42 = this;
      var KEY = 'levelMarker';
      var chart = this.chart,
        options = this.builderC[KEY],
        multiColoring = isMultiColoring(this.config.common, this.chart),
        patternPallete = this.chart.patternPallete && this.chart.patternPallete.length;

      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        options.overlayRange = 'below';
        this.helpers.styles[KEY] = {
          fill: function fill(d, i) {
            var itemPos = _this42.chart.systemConf.chart.plot.allowDuplicateCategories ?
            _this42.builderC.xcategoriesReversed.indexOf(_this42.chart.dataset.getX(d)) :
            pick(d.sortedItemIndex, i);
            var baseClrIdx = multiColoring ? itemPos : _this42.legendOrder;
            var baseClr = multiColoring ? _this42.chart.seriesColor[baseClrIdx % _this42.chart.seriesColor.length] : _this42.builderC.color;
            var dim = patternPallete ? _this42.helpers.position.levelMarker.end(d, true) : null;
            var clr = isArray$1(options.color) ? options.color[0] : options.color;
            if (patternPallete) {
              return _this42.helpers.styleComponent.bar.fillComponent(baseClrIdx, null, null, clr, null, null, dim);
            }
            return (
              plot.render.bulletHelpers.getBulletLevelMarkerGradient(d, options, _this42.chart, baseClr, options.color) || clr || baseClr);

          },
          fillOpacity: options.fillOpacity,
          opacity: function opacity(d, i) {
            var opacity = _setOpacityForTickFilterElements(d, i, chart, 'bar');
            d3_select(this).attr('filtered-opacity', opacity);
            return opacity;
          }
        };
      }
    };

    function bar_encode_collectors() {
      bar_position.call(this);
      bar_subdivider_position.call(this);
      boxplot_whisker_position.call(this);
      bullet_levelmarker_position.call(this);

      var racing = this.chart.racing && this.chart.racing.syncTransition;
      if (racing) {
        racing_bar_position.call(this);
      }

      var morphing = this.chart.systemConf.chart.plot.morph.enabled && this.chart.oldSeriesInfo;
      if (morphing) {
        MarksRegistry.get('bar.morph').call(this);
      }
      bar_styles.call(this);
      bullet_levelmarker_styles.call(this);
    }var

    BarRenderer = /*#__PURE__*/function () {
      function BarRenderer(args) {_classCallCheck(this, BarRenderer);
        var data = args.data,config = args.config,rendererIndex = args.rendererIndex,legendOrder = args.legendOrder,paneid = args.paneid,chart = args.chart,builderC = args.builderC,barDatasetIndex = args.barDatasetIndex,phase = args.phase,type = args.type;
        this.data = data;
        this.config = config;
        this.paneid = paneid;
        this.rendererIndex = rendererIndex;
        this.barDatasetIndex = barDatasetIndex;
        this.conf = chart.rendererConf[rendererIndex];
        this.legendOrder = legendOrder;
        this.builderC = builderC;
        this.chart = chart;
        this.type = type;
        this.phase = phase;
        this.oldRenderer = args.oldRenderer;
        this.markOperator = args.operator;
        this.setMarkMapping();
      }_createClass(BarRenderer, [{ key: "initialize", value:

        function initialize(container) {
          this.rangeYType = this.type == BARRANGE_CHARTNAME ? true : false;
          this.container = container;
          this.commonOption = getBarCommonOption(this.conf, this.rendererIndex, this.legendOrder, this.paneid);
          setBarBuilderConfig.call(this);
          this.seriesdataAfterUpdate = new Array(0);
          this.oldRenderer.seriesdataAfterUpdate = new Array(0);
          this.scales = {
            x: this.commonOption.bandwidth1,
            interX: this.commonOption.bandwidth2,
            y: this.commonOption.yscale
          };
          this.helpers = bar_parser_helpers.call(this);
          this.collectEncode();
        } }, { key: "collectEncode", value:
        function collectEncode() {
          bar_encode_collectors.call(this);
        } }, { key: "getAllowedMarkOperator", value:
        function getAllowedMarkOperator() {
          return ['levelmarker', 'bar', 'subdivider', 'whisker'];
        } }, { key: "setMarkMapping", value:

        function setMarkMapping(mapping) {
          this.markMapping = (mapping || ZC_BAR_MARKS_MAPPING).call(this);
        } }, { key: "getDefaultMarkParser", value:

        function getDefaultMarkParser() {
          var operators = this.getAllowedMarkOperator(),
            markMapping = this.markMapping,
            customOperator = this.markOperator;
          this._mark = executeMarkOperators.call(this, this.data, markMapping, operators, customOperator);
        } }, { key: "render", value:

        function render(parent) {var _this43 = this;
          var holderIndex = pick(this.builderC.dynamicSeriesPosition, this.builderC.datasetIndex);
          this.placeHolder = createElement(
          'g', ".barseries_".concat(
          holderIndex),
          [{ data: this.data, index: this.conf.renderingOrderIndex() }],
          parent);

          this._mark.map(function (d) {
            renderDom(d.mark, d.holder || _this43.placeHolder);
          });
        } }]);return BarRenderer;}();


    function setBoxplotBuilderConfig() {
      var seriesOptions = this.config.series,
        commonOptions = this.config.common,
        animationOptions = this.builderC.animationOptions;

      this.builderC.median =
      seriesOptions && seriesOptions.median ? mergeJSON$1(commonOptions.median, seriesOptions.median, true) : commonOptions.median;
      this.builderC.medianOptionsMerged = getMarkerConfig(this.builderC.median, animationOptions);
    }

    var boxplot_median_position = function boxplot_median_position() {var _this44 = this;
      var position_helpers = {};

      var KEY = 'median',
        KEY_MERGED = 'medianOptionsMerged';

      var builderC = this.builderC,
        medianOptions = builderC[KEY_MERGED],
        medianIdx = medianOptions.dataindex,
        barMSize = getBarMarkerSize.call(this, 'medianOptionsMerged');

      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        this.helpers.position[KEY] = {
          start: function start(d, encode) {},
          end: function end(d, encode) {
            var x = _this44.scales.x(_this44.chart.dataset.getX(d)) + _this44.commonOption.levelMarkerWidth / 2;
            x = x + _this44.scales.interX(_this44.commonOption.barDatasetIndex) + _this44.commonOption.padding;

            var y = _this44.scales.y(d[medianIdx]);

            if (encode == 'size') {
              return [barMSize, null, null];
            }
            return {
              x: x,
              y: y,
              rotate: _this44.chart.rotated ? 90 : 0
            };
          }
        };
      }

      return position_helpers;
    };

    function boxplot_median_styles() {
      var KEY = 'median',
        KEY_MERGED = 'medianOptionsMerged';

      var options = this.builderC[KEY_MERGED];

      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        this.helpers.styles[KEY] = {
          fill: options.color,
          stroke: options.color,
          strokeWidth: pick(options.strokeWidth, 1),
          strokeDasharray: options.dashStyle,
          strokeLinecap: options.lineCap
        };
      }
    }

    function boxplot_encode_collectors() {
      bar_position.call(this);
      bullet_levelmarker_position.call(this);
      boxplot_whisker_position.call(this);
      boxplot_median_position.call(this);

      bar_styles.call(this);
      bullet_levelmarker_styles.call(this);
      boxplot_whisker_styles.call(this);
      boxplot_median_styles.call(this);
    }

    function setBulletBuilderConfig() {
      var seriesOptions = this.config.series,
        commonOptions = this.config.common,
        animationOptions = getAnimationConf(commonOptions, seriesOptions, this.chart, 'bullet');

      this.builderC.targetMarker =
      seriesOptions && seriesOptions.targetMarker ?
      mergeJSON$1(commonOptions.targetMarker, seriesOptions.targetMarker, true) :
      commonOptions.targetMarker;
    }var

    BoxplotRenderer = /*#__PURE__*/function (_BarRenderer) {_inherits(BoxplotRenderer, _BarRenderer);var _super16 = _createSuper(BoxplotRenderer);function BoxplotRenderer() {_classCallCheck(this, BoxplotRenderer);return _super16.apply(this, arguments);}_createClass(BoxplotRenderer, [{ key: "initialize", value:
        function initialize(container) {
          _get(_getPrototypeOf(BoxplotRenderer.prototype), "initialize", this).call(this, container);
          this.rangeYType = true;
        } }, { key: "collectEncode", value:

        function collectEncode() {
          setBulletBuilderConfig.call(this);
          setBoxplotBuilderConfig.call(this);
          boxplot_encode_collectors.call(this);
        } }, { key: "getAllowedMarkOperator", value:
        function getAllowedMarkOperator() {
          return ['levelmarker', 'bar', 'median', 'whisker'];
        } }]);return BoxplotRenderer;}(BarRenderer);


    var bullet_targetmarker_position = function bullet_targetmarker_position() {var _this45 = this;
      var KEY = 'targetMarker';

      var position_helpers = {};

      var builderC = this.builderC,
        targetMarker = builderC[KEY],
        targetMarkerIdx = targetMarker.dataindex,
        barMSize_outer = getBarMarkerSize.call(this, KEY, 'outer'),
        barMSize_inner = getBarMarkerSize.call(this, KEY, 'inner');

      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        this.helpers.position[KEY] = {
          start: function start(d, encode) {},
          end: function end(d, encode, order, prefix) {
            if (encode == 'size') {
              return prefix == 'outer' ? [barMSize_outer, null, null] : [barMSize_inner, null, null];
            }
            var x = _this45.scales.x(_this45.chart.dataset.getX(d)) + _this45.scales.x.bandwidth() / 2;

            var y = _this45.scales.y(d[targetMarkerIdx]);

            return {
              x: x,
              y: y,
              rotate: _this45.chart.rotated ? 90 : 0
            };
          }
        };
      }

      return position_helpers;
    };

    function bullet_targetmarker_styles() {
      var KEY = 'targetMarker';

      var options = this.builderC[KEY];
      if (this.builderC[KEY] && this.builderC[KEY].enabled) {
        this.helpers.styles[KEY] = {
          fill: options.color,
          stroke: options.color,
          strokeWidth: pick(options.strokeWidth, 1),
          strokeDasharray: options.dashStyle,
          strokeLinecap: options.lineCap
        };
      }
    }

    function bullet_encode_collectors() {
      bar_position.call(this);
      bullet_levelmarker_position.call(this);
      bullet_targetmarker_position.call(this);

      bar_styles.call(this);
      bullet_levelmarker_styles.call(this);
      bullet_targetmarker_styles.call(this);
    }var

    BulletRenderer = /*#__PURE__*/function (_BarRenderer2) {_inherits(BulletRenderer, _BarRenderer2);var _super17 = _createSuper(BulletRenderer);function BulletRenderer() {_classCallCheck(this, BulletRenderer);return _super17.apply(this, arguments);}_createClass(BulletRenderer, [{ key: "collectEncode", value:
        function collectEncode() {
          setBulletBuilderConfig.call(this);
          bullet_encode_collectors.call(this);
        } }, { key: "getAllowedMarkOperator", value:
        function getAllowedMarkOperator() {
          return ['levelmarker', 'bar', 'targetmarker'];
        } }]);return BulletRenderer;}(BarRenderer);


    //$Id$

    /**
     * @returns {chart} bar renderer.
     */

    svg_plot_renderer.bar = function () {
      var commonRendererProp,
        bandwidth1,
        bandwidth2,
        yscale,
        barDatasetIndex,
        isredraw = false,
        shiftInfo,
        transitionDuration,
        dataProcessorHelpers = DataProcessor.helpers,
        newBarParser = false,
        newBarRenderer;

      function chart(selection) {
        selection.each(function (data) {
          var container = d3_select(this);
          chart.update = function () {
            container.transition().call(chart);
          };

          //renderer config values
          var rp = commonRendererProp.params,
            chartObj = rp.chartObj,
            xscale = rp.xscale,
            stacked = rp.stacked,
            index = rp.datasetIndex,
            renderingOrder = rp.renderingOrderIndex,
            legendOrder = rp.legendOrderIndex,
            rendererIndex = rp.rendererIndex,
            axisrotated = rp.axisrotated,
            commonPlotOptions = rp.commonPlotOptions,
            color = rp.color,
            paneColor = rp.paneColor,
            labelQueue = rp.labelQueue,
            hasNegValue = rp.hasNegValue,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            dataset = rp.dataset,
            systemconf = chartObj.systemConf,
            plotarea = chartObj.plotarea,
            dataObject = chartObj.dataObject,
            threshold = rp.threshold,
            colorOverlay = rp.colorOverlay,
            xaxisData = getAxisData(chartObj, 'x', 0, false),
            yaxisData = getAxisData(chartObj, 'y', rp.yaxiscolumnorder, false),
            yaxisReversed = rp.yaxisreversed = yaxisData.reversed,
            xAxisReverseed = rp.xaxisreversed = xaxisData.reversed,
            allowDuplicateCategories = systemconf.chart.plot.allowDuplicateCategories,
            parser_data,
            data1;
          yscale = rp.yscale;

          if (chartObj.viewFlow && chartObj.viewFlow.marks._default.chart.length) {
            // let marks_plot = chartObj.viewFlow.marks._default;
            // renderdata = marks_plot;
            parser_data = data[index];
            data1 = parser_data.data;
          }

          var currentdata = data1 || data[index],
            data_bind = { data: currentdata, index: renderingOrder },
            defsLocation = chartObj.defsLocation,
            plotoptions = currentdata.plotoptions,
            currentseriesdata = currentdata.data,
            paneid = "".concat(currentdata.row, "_").concat(currentdata.column),
            cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
            cType = cType_Obj.name,
            plotConfig = chartObj.dataSplicer.getPlotConfig(parser_data || currentdata, index),
            gvp = rp.gvp = utils.getValueOfPlotOptions(plotConfig, commonPlotOptions),
            gradientDim = gradient_helpers.getDimension(chartObj, index, paneid),
            patternPallete = chartObj.patternPallete && chartObj.patternPallete.length,
            noofbarDatas = chartObj.dataObject.noofBarEnabledSeries,
            isBullet = cType == 'bullet',
            isGantt = cType == 'gantt',
            isWaterfall = cType == 'waterfall',
            isBoxplot = cType == 'boxplot',
            isRangePlot = chartcategory.rangePlot.has(cType_Obj.value),
            isWhiskerPlot = chartcategory.whiskerPlot.has(cType_Obj.value),
            datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
            xCategories = xscale.domain(),
            yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
            categories = defined(dataObject.hierarchical) ? dataObject.getCategories('x') : xCategories,
            categoryReversed = xCategories,
            dynamicPosition = rp.dynamicSeriesPosition;
          if (dynamicPosition === undefined) {
            dynamicPosition = index;
          }

          /*
              Trying bar mark parser
           */
          if (cType != 'gantt' && cType != 'waterfall') {
            newBarParser = true;
            rp.liveUpdate = shiftInfo;
            barDatasetIndex = pick(parser_data && parser_data.datasetIndex, barDatasetIndex);
            var args = {
              type: cType,
              chart: chartObj,
              oldRenderer: chart,
              data: data1 || data[index],
              operator: parser_data ? parser_data.operator : null,
              paneid: paneid,
              legendOrder: legendOrder,
              rendererIndex: rendererIndex,
              barDatasetIndex: barDatasetIndex,
              config: {
                common: commonPlotOptions,
                series: plotConfig,
                merged: gvp
              },
              builderC: rp,
              phase: isredraw ? 'redraw' : 'draw'
            };

            var barRenderer =
            cType == 'boxplot' ? new BoxplotRenderer(args) : cType == 'bullet' ? new BulletRenderer(args) : new BarRenderer(args);
            commonRendererProp.parser = newBarRenderer = barRenderer;
            barRenderer.initialize(container);
            if (!bandwidth1 || !bandwidth2) {
              //Test_515.json (Combinational chart(bar + line) where all the bar series are disabled)
              isredraw = true;
              chart.chartRendered = true;
              return;
            }
            barRenderer.getDefaultMarkParser();
            barRenderer.render(container);

            /*
            HOOK for DATALABEL
            
            
             */
            var builderC = barRenderer.builderC,
              seriesDataUpdate = barRenderer.seriesdataAfterUpdate;
            if (isBoxplot) {
              var yidx = chartObj.dataset.getColumnIdx('y', yaxiscolumnorder),
                medianidx = builderC.median.columnindex,
                whiskeridx = builderC.whiskers.columnindex;
              var labelrenderer = chartObj.datalabels.renderer,
                labelConfig = labelrenderer ? labelrenderer[index] : {};
              var labeltype_boxplot = [];
              if (labelConfig && labelConfig.show) {
                var labeltype = labelConfig.labeltype;
                var labelidx;
                if (_typeof(labeltype) == 'object') {
                  var indices = labeltype.get('val');
                  if (indices && indices.length == 1) {
                    //CURRENTLY MULTI CUSTOMIZED INDICES NOT SUPPORTED
                    //FOR THAT CHANGES TO BE DONE IN getCustomizedVal for parsing only particular {{val(3)}} from separator
                    labelidx = indices[0];
                    if (labelidx == medianidx) {
                      labeltype_boxplot.push(labelidx);
                    } else if (labelidx == whiskeridx || labelidx == yidx) {
                      labeltype_boxplot.push(labelidx, labelidx);
                    } else {
                      labeltype_boxplot.push('others');
                    }
                  } else {
                    labeltype_boxplot.push('others');
                  }
                } else if (labeltype == 'y') {
                  labeltype_boxplot.push(yidx, yidx);
                } else {
                  labeltype_boxplot.push('others');
                }

                labeltype_boxplot.map(function (d, i) {
                  var rangeidx = d == medianidx || d == 'others' ? null : i % 2,
                    columnidx = d == 'others' ? null : d;
                  labelQueue.push({
                    renderer: chart,
                    charttype: 'bar',
                    chartObj: chartObj,
                    rendererIndex: rendererIndex,
                    paneid: paneid,
                    args: [currentdata, index, 0, rangeidx, columnidx]
                  });
                });
              }
            } else if (cType == 'barrange') {
              labelQueue.push({
                renderer: chart,
                charttype: 'bar',
                chartObj: chartObj,
                paneid: paneid,
                args: [currentdata, index, 0, 1]
              });
              labelQueue.push({
                renderer: chart,
                charttype: 'bar',
                chartObj: chartObj,
                paneid: paneid,
                args: [currentdata, index, 0, 0]
              }); //last argument in args for yrangePos
            } else {
              if (cType == 'bullet') {
                LabelRegistry.get('bullet').call(chartObj, builderC.targetMarker, chart, seriesDataUpdate[0], {
                  paneid: paneid,
                  rendererIndex: rendererIndex,
                  subIndex: 0
                }); //TODO subIndex hardcoded
              }
              labelQueue.push({
                renderer: chart,
                charttype: 'bar',
                chartObj: chartObj,
                rendererIndex: rendererIndex,
                paneid: paneid,
                args: [currentdata, legendOrder, null, null, null, rendererIndex]
              });
            }
            return;
          }
          /*
              The End
           */
          var series = appendEle(container, 'g', [data_bind], '.', 'class', "barseries_".concat(dynamicPosition));

          if (!bandwidth1 || !bandwidth2) {
            //Test_515.json (Combinational chart(bar + line) where all the bar series are disabled)
            isredraw = true;
            chart.chartRendered = true;
            return;
          }

          var levelMarker = rp.levelMarker =
            plotoptions && plotoptions.levelMarker ?
            mergeJSON$1(commonPlotOptions.levelMarker, plotoptions.levelMarker, true) :
            commonPlotOptions.levelMarker,
            borderOptions =
            plotoptions && plotoptions.border ?
            mergeJSON$1(commonPlotOptions.border, plotoptions.border, true) :
            commonPlotOptions.border,
            multiColoring = isMultiColoring(commonPlotOptions, chartObj);
          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, 'bar'),
            isAnimationEnable = animationOptions.enabled,
            easingType = animationOptions.easingType,
            animationType = animationOptions.type,
            exitDuration = isAnimationEnable ? 100 : 0,
            duration;
          transitionDuration = isredraw ? isAnimationEnable ? 300 : 0 : animationOptions.duration;
          var transition_ = chartObj.syncTransition || selection.transition().duration(transitionDuration);

          /**
           *
           * @type {{stacked, categories, axisrotated, bandwidth1, bandwidth2, barDatasetIndex, padding, yscale, hasNegValue, yaxiscolumnorder, addRangeBand, barWidth, levelMarkerWidth, levelMarkerPadding}|*}
           */
          var commonOption = getBarCommonOption(chartObj.rendererConf[rendererIndex], rendererIndex, legendOrder, paneid),
            barWidth = commonOption.barWidth,
            addRangeBand = commonOption.addRangeBand,
            actualStackGroupIndex = getStackGroupIndex(dataObject.getStackGroup(), index);

          chart.getParamValue = function () {
            return chartObj.dataObject.getTransRectValue.apply(chartObj.dataObject, toArray(arguments));
          };

          var getMultiColorIndex = function getMultiColorIndex(d, j) {
            if (allowDuplicateCategories) {
              d.categoryIndex = j = categoryReversed.indexOf(dataset.getX(d));
            }
            return j;
          };

          var getGanttColor = function getGanttColor(d, j) {
            if (multiColoring) {
              j = getMultiColorIndex(d, j);
              return chartObj.seriesColor[j % chartObj.seriesColor.length];
            } else {
              return color;
            }
          };

          var targetMarker, targetMarkerSeries, levelMarkerColor, whiskers, whiskerSeries;
          if (levelMarker) {
            //For waterfall there will be no levelmarker
            levelMarkerColor = levelMarker.color; //Saving the levelMarker colors, helps in multi categories bullet if each categories dont have same no of levels
            levelMarker.overlayRange = 'below';
          }

          if (isBullet || isRangePlot && cType !== 'barrange') {
            var markerPropertyName = isGantt ? 'marker' : isBoxplot ? 'median' : 'targetMarker',
              groupName = isBoxplot ? 'threshold' : 'qualitativeGroup';

            commonRendererProp.params.targetMarker = targetMarker =
            plotoptions && plotoptions[markerPropertyName] ?
            mergeJSON$1(commonPlotOptions[markerPropertyName], plotoptions[markerPropertyName], true) :
            commonPlotOptions[markerPropertyName];
            targetMarker = isBoxplot ? getMarkerConfig(targetMarker, animationOptions) : targetMarker;
            targetMarkerSeries = appendEle(
            chartObj.staticPaneSVG.selectAll("g.".concat(groupName)),
            'g',
            targetMarker.enabled === true && !currentdata.disabled ? [index] : [],
            '.',
            'class',
            isGantt || isBoxplot ? "markerSeries".concat(index) : 'markerSeries');

          }
          if (isWhiskerPlot) {
            var groupName = isBoxplot ? 'threshold' : 'qualitativeGroup';
            commonRendererProp.params.whiskers = whiskers =
            plotoptions && plotoptions.whiskers ?
            mergeJSON$1(commonPlotOptions.whiskers, plotoptions.whiskers, true) :
            commonPlotOptions.whiskers;

            var whiskersSymbol = commonRendererProp.params.whiskers.showOn == 'edges' ? 'whiskers' : 'horizontal-whisker';
            whiskers = getMarkerConfig(whiskers, animationOptions, whiskersSymbol);

            commonRendererProp.params.whiskersOptionsMerged = whiskers;
            whiskerSeries = appendEle(
            chartObj.staticPaneSVG.selectAll("g.".concat(groupName)),
            'g',
            whiskers.enabled === true && !currentdata.disabled ? [index] : [],
            '.',
            'class', "whiskerSeries".concat(
            index));

          }

          var startRadius = {
              tlx: 0,
              tly: 0,
              trx: 0,
              trY: 0,
              brx: 0,
              bry: 0,
              blx: 0,
              bly: 0
            },
            borderRadius = startRadius,
            borderSize = 0,
            borderColor = null,
            borderStyle = null,
            levelMarkerRadius = startRadius;
          if (defined(borderOptions) && isTrue(borderOptions.show)) {
            borderSize = borderOptions.size;
            borderColor = borderOptions.color;
            borderStyle = borderOptions.style;
            borderRadius = chart.getParamValue('radius', null, null, null, commonOption, borderOptions.radius);
          }

          var dashStyle = getDashArray(borderStyle, borderSize == null ? 2 : borderSize);
          var fillColor = chart.fillColorFunc = getFillColor(chartObj, index, paneid, gradientDim, null, null, null, null),
            strokeColor = getStrokeColor(chartObj, index, paneid, rp);

          //Save seriesdata reference without null points , that can also be used in zcevents
          chart.seriesdataAfterUpdate = [];
          currentseriesdata.forEach(function (d, i) {
            chart.getBarLevelMarkerProp = isGantt ? plot.render.bulletHelpers.getLevelMarkerParams : null;
            var startx, starty, startwid, starthei, endx, endy, endwid, endhei;
            var ishideable = currentdata.disabled;

            var serData = chartObj.dataObject.updateSeriesdatabyCategories(
            d3_values(d),
            xCategories,
            yCategories,
            yaxiscolumnorder,
            true);

            if (chartObj.renderVisiblePointsOnly) {
              serData = dataProcessorHelpers.filterPointsInViewport(chartObj, serData, 'bar', 'x', index, i);
            }
            chart.seriesdataAfterUpdate[i] = serData;

            if (xAxisReverseed) {
              serData = serData.slice(0).reverse();
              categoryReversed = categoryReversed.slice(0).reverse();
            }

            var ShiftedData;
            if (shiftInfo != null) {
              ShiftedData = d3_values(d);
              var co = shiftInfo.count;
              for (var ii = 0; ii <= co; ii++) {
                ShiftedData.splice(ii, 0, [null, null]);
              }

              if (isredraw) {
                var clipX = xscale(dataset.getX(d[0]));
                var properties = {
                    name: 'rect',
                    id: chartObj.id,
                    x: clipX,
                    y: 0,
                    width: chartObj.plotarea.width,
                    height: chartObj.plotarea.height
                  },
                  args = {
                    chartObj: chartObj
                  };
                var clipID = effects.get(effects.svg_clips, 'rect', properties, args);
                series.attr('clip-path', "url(".concat(defsLocation, "#").concat(clipID, ")"));
              }
            }
            var dataUpdate = shiftInfo != null ? ShiftedData : chart.seriesdataAfterUpdate[i];
            duration =
            animationType == VERTICALALL_ANIMATION || isredraw ?
            transitionDuration :
            transitionDuration / (dataUpdate.length * noofbarDatas);
            var showLevelMarker =
            levelMarker &&
            levelMarker.enabled === true && (
            stacked && noofbarDatas > 0 || !ishideable) &&
            !chartObj.dataObject.isStackedPercentChart && (
            !stacked || !!chartObj.dataObject.getEncode('stack', actualStackGroupIndex)); // If specified stackgroup is disabled, remove it

            //subseries levelmarker
            var subseries_levelMarkerNode = (stacked ? container : series).
            selectAll(stacked ? "g.levelMarkerSeries_".concat(actualStackGroupIndex) : "g.subseries_levelMarker_".concat(i)).
            data(function (d) {
              return showLevelMarker ? [d] : [];
            });

            //Removing unnecessary 'g' on redraw ((stacked bar to bar) or (bar to stacked bar))
            (!stacked ? container : series).
            selectAll(!stacked ? "g.levelMarkerSeries_".concat(actualStackGroupIndex) : "g.subseries_levelMarker_".concat(i)).
            remove();

            subseries_levelMarkerNode.
            exit().
            selectAll('path.levelMarker').
            transition().
            duration(exitDuration).
            attr('d', function (d, j) {
              if (isGantt) {
                var path = d3_select(this).attr('d'); // If the category is no more available at the categoryStore, We get the x,y from the 'd' attr by parsing
                var points = parseSVGPath(path);
                var x = points[0].moves[0],
                  y = points[3].moves[1];

                var prop = plot.render.bulletHelpers.getLevelMarkerParams(d, i, j, chart, commonOption);
                var exitx = prop.x || x,
                  exity = prop.y + (axisrotated ? 0 : prop.height * (yaxisReversed ? -1 : 1)) || y,
                  exitwid = axisrotated ? 0 : prop.width,
                  exithei = axisrotated ? prop.height : 0;
                return roundedRect(exitx, exity, exitwid, exithei, borderRadius, yaxisReversed, axisrotated);
              }
              var exitx = chart.getParamValue('x', d, i, j, commonOption) || parseSVGPath(d3_select(this).attr('d'))[0].moves[0],
                exity = yscale(yscale.domain()[0]),
                exitwid = axisrotated ? 0 : chart.getParamValue('width', d, i, j, commonOption),
                exithei = axisrotated ? chart.getParamValue('height', d, i, j, commonOption) : 0;
              return roundedRect(exitx, exity, exitwid, exithei, borderRadius, yaxisReversed, axisrotated);
            }).
            remove();

            //subseries
            var subseriesNode = series.selectAll("g.subseries_".concat(i)).data(function (d) {
              return ishideable ? [] : [d];
            });

            subseriesNode.
            exit().
            selectAll('path.zc_bar').
            transition().
            duration(exitDuration).
            attr('d', function (d, j) {
              var path = d3_select(this).attr('d'); // If the category is no more available at the categoryStore, We get the x,y from the 'd' attr by parsing
              var points = parseSVGPath(path);
              var x = points[0].moves[0],
                y = points[3].moves[1],
                exitx = chart.getParamValue('x', d, i, j, commonOption) || x,
                exity =
                (axisrotated ?
                chart.getParamValue('y', d, i, j, commonOption) :
                isRangePlot ?
                chart.getParamValue('y', d, i, j, commonOption, null, 0) :
                (stacked ?
                yscale(d.y0) :
                hasNegValue != null ?
                yscale(hasNegValue) :
                yscale(0) != null ?
                mathMin(yscale(0), yscale.range()[0]) :
                yscale.range()[0]) +
                addRangeBand() * 2) || y,
                exitwid = axisrotated ? 0 : chart.getParamValue('width', d, i, j, commonOption),
                exithei = axisrotated ? chart.getParamValue('height', d, i, j, commonOption) : 0;
              return roundedRect(exitx, exity, exitwid, exithei, borderRadius, yaxisReversed, axisrotated);
            }).
            remove();

            var subseries = subseriesNode.
            enter().
            append('g').
            merge(subseriesNode).
            attr('class', "subseries_".concat(i));

            if (isWaterfall) {
              //Connector lines
              var subseries_connectorLines = appendEle(
              stacked ? container : series,
              'g',
              stacked || !ishideable ? [1] : [],
              '.',
              'class',
              'connectorLines',
              null);

              svg_plot_renderer.waterfallHelpers.drawConnectorLines(subseries_connectorLines, dataUpdate, {
                chart: chartObj,
                yaxiscolumnorder: yaxiscolumnorder,
                axisrotated: axisrotated,
                stacked: stacked,
                xscale: xscale,
                yscale: yscale,
                renderer: chart,
                seriesindex: i,
                plotoptions: plotoptions,
                commonPlotOptions: commonPlotOptions
              });

              //Comparison lines
              var subseries_comparisonLines = appendEle(
              stacked ? container : series,
              'g',
              stacked || !ishideable ? [1] : [],
              '.',
              'class',
              'comparisonLines',
              null);

              svg_plot_renderer.waterfallHelpers.drawComparisonLine(subseries_comparisonLines, dataUpdate, {
                chart: chartObj,
                yaxiscolumnorder: yaxiscolumnorder,
                axisrotated: axisrotated,
                stacked: stacked,
                xscale: xscale,
                yscale: yscale,
                renderer: chart,
                seriesindex: i,
                plotoptions: plotoptions,
                commonPlotOptions: commonPlotOptions
              });
            }

            var subseries_levelMarkerZindex = isGantt ?
            subseries_levelMarkerNode.
            enter().
            append('g').
            merge(subseries_levelMarkerNode) :
            subseries_levelMarkerNode.
            enter().
            insert('g', ':first-child').
            merge(subseries_levelMarkerNode);

            subseries_levelMarkerZindex.attr(
            'class',
            stacked ? "levelMarkerSeries_".concat(actualStackGroupIndex) : "subseries_levelMarker_".concat(i));

            if (showLevelMarker && stacked && xCategories.length != dataUpdate.length) {
              plot.render.bulletHelpers.addDummyDataForLevelmarker(dataUpdate, xCategories, dataset, yaxiscolumnorder);
            }

            var rect_levelMarkerNode = subseries_levelMarkerZindex.selectAll('path.levelMarker').data(dataUpdate, function (d) {
              return isGantt ? d : dataset.getX(d);
            });

            var rect_levelMarker = rect_levelMarkerNode.
            enter().
            append('path').
            merge(rect_levelMarkerNode).
            attr('class', 'levelMarker');
            rect_levelMarker.
            styles({
              fill: function fill(d, j) {
                if (isGantt) {
                  return levelMarker.color || getGanttColor(d, j);
                  // return levelMarker.color || (multiColoring ? chartObj.seriesColor[j % chartObj.seriesColor.length] : color);
                }
                if (
                !plot.render.bulletHelpers.ZC_BAR_getLevelMarkerRect ||
                !plot.render.bulletHelpers.getBulletLevelMarkerGradient)
                {
                  throw 'Level marker or bullet module was not loaded';
                }
                // var baseClr = multiColoring ? chartObj.seriesColor[j % chartObj.seriesColor.length] : color;
                var baseClr = getGanttColor(d, j);
                var clr = isArray$1(levelMarker.color) ? levelMarker.color[0] : levelMarker.color;
                if (patternPallete) {
                  var prop = isGantt ?
                  plot.render.bulletHelpers.getLevelMarkerParams(d, i, j, chart, commonOption) :
                  plot.render.bulletHelpers.ZC_BAR_getLevelMarkerRect(
                  d,
                  levelMarker,
                  chartObj,
                  commonOption,
                  rp,
                  i,
                  index);

                  var x = prop.x,
                    y = prop.y,
                    wid = prop.width,
                    hei = prop.height;
                  // #ZC2804 $j param
                  clr = fillColor(multiColoring ? getMultiColorIndex(d, j) : legendOrder, null, null, clr, null, null, {
                    x: x,
                    y: y,
                    width: wid,
                    height: hei
                  });
                }

                return (
                  plot.render.bulletHelpers.getBulletLevelMarkerGradient(
                  d,
                  levelMarker,
                  chartObj,
                  baseClr,
                  levelMarkerColor) ||

                  clr ||
                  baseClr);

              },
              'fill-opacity': levelMarker ? levelMarker.fillOpacity : null
            }).
            attr('d', function (d, j) {
              var prop = isGantt ?
              plot.render.bulletHelpers.getLevelMarkerParams(d, i, j, chart, commonOption) :
              plot.render.bulletHelpers.ZC_BAR_getLevelMarkerRect(d, levelMarker, chartObj, commonOption, rp, i, index);
              var x = prop.x,
                y = prop.y,
                wid = prop.width,
                hei = prop.height;
              if (isGantt) {
                return roundedRect(x, y, wid, hei, levelMarkerRadius, yaxisReversed, axisrotated);
              } else {
                return axisrotated ?
                roundedRect(y, x, wid, hei, borderRadius, yaxisReversed, axisrotated) :
                roundedRect(x, y, wid, hei, borderRadius, yaxisReversed, axisrotated);
              }
            });
            setOpacityForTickFilterElements(rect_levelMarker, chartObj, cType);

            if (dataObject.hierarchical) {
              rect_levelMarker.attr('levelbycolumn', function (d, i) {
                return d.levelByColumn;
              });
              if (dataObject.pivot) {
                rect_levelMarker.attr('levelbyrow', function (d, i) {
                  return d.levelByRow;
                });
              }
            }

            if (levelMarker) {
              levelMarker.color = levelMarkerColor; //Saving back the levelMarker colors, helps in multi categories bullet if each categories dont have same no of levels
            }

            rect_levelMarkerNode.exit().remove();

            if (isBullet) {
              svg_plot_renderer.ganttHelpers.addMarker(targetMarkerSeries, dataUpdate, chart, i, targetMarker, multiColoring, '');
              LabelRegistry.get('bullet').call(chartObj, targetMarker, chart, dataUpdate, { paneid: paneid, rendererIndex: rendererIndex, subIndex: i });
            } else if (isGantt) {
              svg_plot_renderer.ganttHelpers.addMarker(
              targetMarkerSeries,
              dataUpdate,
              chart,
              i,
              targetMarker.start,
              multiColoring,
              0);

              svg_plot_renderer.ganttHelpers.addMarker(targetMarkerSeries, dataUpdate, chart, i, targetMarker.end, multiColoring, 1);
            } else if (isWhiskerPlot) {
              //For Median line
              if (isBoxplot) {
                svg_plot_renderer.ganttHelpers.addMarker(
                targetMarkerSeries,
                dataUpdate,
                chart,
                index,
                targetMarker,
                multiColoring,
                '');

              }
              //For whiskers (minimum and maximum)
              if (commonRendererProp.params.whiskers.showOn == 'edges') {
                svg_plot_renderer.ganttHelpers.addMarker(whiskerSeries, dataUpdate, chart, index, whiskers, multiColoring, 0);
                svg_plot_renderer.ganttHelpers.addMarker(whiskerSeries, dataUpdate, chart, index, whiskers, multiColoring, 1);
              } else {
                svg_plot_renderer.ganttHelpers.addMarker(whiskerSeries, dataUpdate, chart, index, whiskers, multiColoring, 0);
              }
            }

            //Main rect
            var rect = subseries.
            selectAll('path.zc_bar').
            attr('class', 'zc_bar').
            data(dataUpdate, function (d) {
              return isGantt ? d : dataset.getX(d); // For gantt chart we should support different timeline data for the same category
            });
            var rectEnter = rect.
            enter().
            append('path').
            style('fill-opacity', gvp('fillOpacity')).
            attrs({
              "class": 'zc_bar',
              height: function height(d, j) {
                if (chartObj.syncTransition) {
                  var param = axisrotated ? 'width' : 'height';
                  return chart.getParamValue(param, d, i, j, commonOption);
                } else {
                  return 0;
                }
              },
              d: function d(_d26, j) {
                var params = getInitialParams(_d26);
                if (chartObj.syncTransition) {
                  if (axisrotated) {
                    params.x = chartObj.plotarea.height + 20;
                    params.y = chart.getParamValue('x', _d26, i, j, commonOption);
                    params.width = chart.getParamValue('width', _d26, i, j, commonOption);
                    params.height = chart.getParamValue('height', _d26, i, j, commonOption);
                  } else {
                    if (chartObj.axes.x.reversed) {
                      params.x = chartObj.plotarea.height + 20;
                      params.y = chart.getParamValue('x', _d26, i, j, commonOption);
                      params.width = chart.getParamValue('width', _d26, i, j, commonOption);
                      params.height = chart.getParamValue('height', _d26, i, j, commonOption);
                    }
                  }
                }
                d3_select(this).attr('y', params.y);
                return axisrotated ?
                roundedRect(params.y, params.x, params.width, params.height, startRadius, yaxisReversed, axisrotated) :
                roundedRect(params.x, params.y, params.width, params.height, startRadius, yaxisReversed, axisrotated);
              }
            }).
            merge(rect);

            var rectUpdate = rectEnter.
            attrs({
              stroke: function stroke(d, j) {
                // return getMultiColorIndex(d, pick(d.sortedItemIndex, j));
                return strokeColor(multiColoring ? getMultiColorIndex(d, j) : legendOrder, d, borderColor || paneColor);
              },
              'stroke-width': borderSize,
              'stroke-dasharray': dashStyle
            }).
            styles({
              fill: function fill(d, j) {
                if (patternPallete) {
                  return fillColor(multiColoring ? getMultiColorIndex(d, j) : legendOrder, d, null, null, null, null, {
                    x: chart.getParamValue('x', d, i, j, commonOption),
                    y: chart.getParamValue('y', d, i, j, commonOption),
                    width: chart.getParamValue('width', d, i, j, commonOption),
                    height: chart.getParamValue('height', d, i, j, commonOption)
                  });
                }
                // #ZC2087
                // return getMulticolorIndex(d, pick(d.sortedItemIndex, j));
                return fillColor(
                multiColoring ? getMultiColorIndex(d, pick(d.sortedItemIndex, j)) : legendOrder,
                d,
                null,
                paneColor);

              },
              'fill-opacity': gvp('fillOpacity'),
              transition: 'opacity ease 0.2s'
            });

            setOpacityForTickFilterElements(rectUpdate, chartObj, cType);

            if (dataObject.hierarchical) {
              rectEnter.attr('levelbycolumn', function (d, i) {
                return d.levelByColumn;
              });
              if (dataObject.pivot) {
                rectEnter.attr('levelbyrow', function (d, i) {
                  return d.levelByRow;
                });
              }
            }
            if (shiftInfo == null) {
              if (chartObj.syncTransition) {
                rectEnter.
                transition(chartObj.syncTransition).
                attr('d', function (d, k) {
                  var params = getFinalParams(d, k);
                  if (isNaN(params.x) || isNaN(params.y)) {
                    params.x = -1;
                    return null;
                  }
                  return roundedRect(
                  params.x,
                  params.y,
                  params.width,
                  params.height,
                  borderRadius,
                  yaxisReversed,
                  axisrotated);

                }).
                attrs({
                  y: function y(d, j) {
                    var param = axisrotated ? 'x' : 'y';
                    return chart.getParamValue(param, d, i, j, commonOption);
                  },
                  height: function height(d, j) {
                    var param = axisrotated ? 'width' : 'height';
                    return chart.getParamValue(param, d, i, j, commonOption);
                  }
                });
              } else {
                if (chartObj.systemConf.chart.plot.morph.enabled && chartObj.oldSeriesInfo != undefined) {
                  var morph_Obj = new zcMorph({ sampling: chartObj.systemConf.chart.plot.morph.samplingDistance });
                  var oldseriesData = chartObj.oldSeriesInfo.get(index);
                  var oldseriesIndex = oldseriesData.seriesIndex;
                  var oldseriesColor = oldseriesData.color;
                  var offsetValue = getOffsetValue(chartObj, oldseriesIndex);
                  var multicoloring = isMultiColoring(commonPlotOptions, chartObj);
                  var individualElementTransform = oldseriesData.transformationInfo;
                  transitionDuration = chartObj.systemConf.chart.plot.morph.duration;

                  var interpolated = {};
                  var line = d3_line();

                  rectEnter.each(function (d, i) {
                    var params = getFinalParams(d, i);
                    if (isNaN(params.x) || isNaN(params.y)) {
                      params.x = -1;
                      return null;
                    }
                    var currentPath = roundedRect(
                    params.x,
                    params.y,
                    params.width,
                    params.height,
                    borderRadius,
                    yaxisReversed,
                    axisrotated);

                    var fromPath = chartObj.oldSeriesInfo.get(oldseriesIndex).pathData[i];
                    var fromPathAttribute = fromPath.getAttribute('d');
                    fromPath.setAttribute('d', currentPath);
                    var toPath = fromPath.cloneNode();
                    fromPath.setAttribute('d', fromPathAttribute);
                    interpolated[i] = morph_Obj.interpolate(
                    {
                      path: fromPath,
                      xOffset: offsetValue.x + individualElementTransform[i].x,
                      yOffset: offsetValue.y + individualElementTransform[i].y
                    },
                    { path: toPath, xOffset: 0, yOffset: 0 });

                  });

                  rectEnter.
                  style('fill', function (d, i) {
                    return oldseriesColor[i];
                  }).
                  transition().
                  duration(transitionDuration).
                  ease(easingType).
                  style('fill', function (d, i) {
                    if (multicoloring) {
                      return getRawColor(chartObj, i, d, oldseriesIndex, null);
                    } else {
                      return getRawColor(chartObj, 0, d, oldseriesIndex, null);
                    }
                  }).
                  attrTween('d', function (d, i) {
                    var interpolator = interpolated[i];
                    return function (t) {
                      return line(
                      interpolator.map(function (p) {
                        return p(t);
                      }));

                    };
                  }).
                  on('end', function (d, i) {
                    if (chartObj.oldSeriesInfo) {
                      delete chartObj.oldSeriesInfo;
                    }
                    d3_select(this).style('fill', function () {
                      if (multicoloring) {
                        return fillColor(i, d, null);
                      } else {
                        return fillColor(0, d, null);
                      }
                    });
                    rectEnter.attrs({
                      y: function y(d, j) {
                        var param = axisrotated ? 'x' : 'y';
                        return chart.getParamValue(param, d, i, j, commonOption);
                      },
                      height: function height(d, j) {
                        var param = axisrotated ? 'width' : 'height';
                        return chart.getParamValue(param, d, i, j, commonOption);
                      }
                    });
                    //});
                    var params = getFinalParams(d, i);
                    if (isNaN(params.x) || isNaN(params.y)) {
                      params.x = -1;
                      return null;
                    }
                    var currentPath = roundedRect(
                    params.x,
                    params.y,
                    params.width,
                    params.height,
                    borderRadius,
                    yaxisReversed,
                    axisrotated);

                    this.setAttribute('d', currentPath);
                  });
                } else {
                  rectEnter.
                  transition().
                  duration(isredraw ? duration : 0).
                  delay(function (d, j) {
                    return animationType == VERTICALALL_ANIMATION || isredraw ? 0 : (j * noofbarDatas + index) * duration;
                  }).
                  attr('d', function (d, j) {
                    var curele = d3_select(this);
                    var starthei = parseFloat(curele.attr('height'));
                    endx =
                    axisrotated && !isRangePlot ?
                    parseFloat(curele.attr('y')) :
                    chart.getParamValue('x', d, i, j, commonOption);
                    endy = axisrotated ?
                    chart.getParamValue('y', d, i, j, commonOption) :
                    isRangePlot && !starthei ?
                    chart.getParamValue('y', d, i, j, commonOption, null, 0) :
                    parseFloat(curele.attr('y')); // Why (isGantt && !starthei)? -> rectEnter animation should start from y0
                    endwid = axisrotated ?
                    parseFloat(curele.attr('height')) :
                    chart.getParamValue('width', d, i, j, commonOption);
                    endhei = axisrotated ? chart.getParamValue('height', d, i, j, commonOption) : starthei;
                    return roundedRect(endx, endy, endwid, endhei, borderRadius, yaxisReversed, axisrotated);
                  }).
                  on('end', function (d, k) {
                    d3_select(this).
                    transition().
                    delay(function (d, j) {
                      return animationType == VERTICALALL_ANIMATION || isredraw ?
                      0 :
                      (k * noofbarDatas + index) * duration;
                    }).
                    duration(duration).
                    ease(easingType).
                    attr('d', function (d) {
                      var params = getFinalParams(d, k);
                      if (isNaN(params.x) || isNaN(params.y)) {
                        params.x = -1;
                        return null;
                      }
                      return roundedRect(
                      params.x,
                      params.y,
                      params.width,
                      params.height,
                      borderRadius,
                      yaxisReversed,
                      axisrotated);

                      // return roundedRect(endx, endy, endwid, endhei, borderRadius, yaxisReversed, axisrotated);
                    });
                  }).
                  attrs({
                    y: function y(d, j) {
                      var param = axisrotated ? 'x' : 'y';
                      return chart.getParamValue(param, d, i, j, commonOption);
                    },
                    height: function height(d, j) {
                      var param = axisrotated ? 'width' : 'height';
                      return chart.getParamValue(param, d, i, j, commonOption);
                    }
                  });
                }
              }
            } else {
              rectEnter.
              transition().
              duration(isredraw ? duration : 0).
              attrs({
                d: function d(_d27, j) {
                  var params = getFinalParams(_d27, j);
                  return roundedRect(
                  params.x,
                  params.y,
                  params.width,
                  params.height,
                  borderRadius,
                  yaxisReversed,
                  axisrotated);

                },
                y: function y(d, j) {
                  var param = axisrotated ? 'x' : 'y';
                  return chart.getParamValue(param, d, i, j, commonOption);
                },
                height: function height(d, j) {
                  var param = axisrotated ? 'width' : 'height';
                  return chart.getParamValue(param, d, i, j, commonOption);
                }
              });
            }
            if (chartObj.syncTransition) {
              rect.exit().remove();
            } else {
              rect.exit().
              transition().
              duration(duration).
              remove();
            }

            if (i > 0 && stacked) {
              var subdividerseries = appendEle(series, 'g', ishideable ? [] : [1], '.', 'class', "subdividerseries_".concat(i));
              var dividerbarNode = subdividerseries.selectAll('rect').data(dataUpdate, function (d) {
                return dataset.getX(d);
              });
              var dividerbar = dividerbarNode.
              enter().
              append('rect').
              merge(dividerbarNode).
              styles({
                fill: 'white',
                opacity: 0.7,
                'shape-rendering': 'crispedges'
              }).
              attrs({
                width: getDividerParam('width'),
                height: getDividerParam('height'),
                x: function x(d, j) {
                  return getDividerParam('x', d, i, j, commonOption);
                },
                y: function y(d, j) {
                  return getDividerParam('y', d, i, j, commonOption);
                }
              });
              dividerbar.
              transition().
              duration(duration).
              ease(easingType).
              styles({
                fill: 'white',
                opacity: 0.7,
                'shape-rendering': 'crispedges'
              }).
              attrs({
                width: getDividerParam('width'),
                height: getDividerParam('height'),
                x: function x(d, j) {
                  return getDividerParam('x', d, i, j, commonOption);
                },
                y: function y(d, j) {
                  return getDividerParam('y', d, i, j, commonOption);
                }
              });
              dividerbar.exit().remove();
            }
            if (isGantt) {
              svg_plot_renderer.ganttHelpers.showDependencies(chart, dataUpdate, series, i);
            }

            function getDividerParam(paramType, d, i, j, cp) {
              switch (paramType) {
                case 'x':
                  return axisrotated ? yscale(d.y0) : chart.getParamValue('x', d, i, j, cp);
                case 'y':
                  return axisrotated ? chart.getParamValue('y', d, i, j, cp) : yscale(d.y0);
                case 'width':
                  return axisrotated ? 1 : barWidth;
                case 'height':
                  return axisrotated ? barWidth : 1;}

            }

            function getInitialParams(d) {
              var v = dataset.getX(d);
              startx = stacked ? bandwidth1(v) : bandwidth1(v) + bandwidth2(barDatasetIndex + i);
              starty = yscale.bandwidth ?
              yscale.origRange[0] :
              axisrotated ?
              stacked ?
              hasNegValue != null ?
              yscale(hasNegValue) :
              yscale.range()[0] :
              hasNegValue != null ?
              yscale(hasNegValue) :
              yscale.range()[0] :
              stacked ?
              hasNegValue != null ?
              yscale(hasNegValue) :
              yscale.range()[0] :
              hasNegValue != null ?
              yscale(hasNegValue) :
              yscale(0) != null ?
              mathMin(yscale(0), yscale.range()[0]) :
              yscale.range()[0];
              starty = isWaterfall ? yscale(d.y0) : starty;
              startwid = axisrotated ? 0 : barWidth;
              starthei = axisrotated ? barWidth : 0;
              return { x: startx, y: starty, width: startwid, height: starthei };
            }

            function getFinalParams(d, j) {
              endx = chart.getParamValue('x', d, i, j, commonOption);
              endy = chart.getParamValue('y', d, i, j, commonOption);
              endwid = chart.getParamValue('width', d, i, j, commonOption);
              endhei = chart.getParamValue('height', d, i, j, commonOption);
              return { x: endx, y: endy, width: endwid, height: endhei };
            }

            chart.getMarkerPosition = isGantt ? svg_plot_renderer.ganttHelpers.getMarkerPosition : null;
          });

          if (isBoxplot) {
            var yidx = chartObj.dataset.getColumnIdx('y', yaxiscolumnorder),
              medianidx = targetMarker.columnindex,
              whiskeridx = whiskers.columnindex;
            var labelrenderer = chartObj.datalabels.renderer,
              labelConfig = labelrenderer ? labelrenderer[index] : {};
            var labeltype_boxplot = [];
            if (labelConfig && labelConfig.show) {
              var labeltype = labelConfig.labeltype;
              var labelidx;
              if (labeltype.constructor.name == 'Map') {
                var indices = labeltype.get('val');
                if (indices && indices.length == 1) {
                  //CURRENTLY MULTI CUSTOMIZED INDICES NOT SUPPORTED
                  //FOR THAT CHANGES TO BE DONE IN getCustomizedVal for parsing only particular {{val(3)}} from separator
                  labelidx = indices[0];
                  if (labelidx == medianidx) {
                    labeltype_boxplot.push(labelidx);
                  } else if (labelidx == whiskeridx || labelidx == yidx) {
                    labeltype_boxplot.push(labelidx, labelidx);
                  } else {
                    labeltype_boxplot.push('others');
                  }
                } else {
                  labeltype_boxplot.push('others');
                }
              } else if (labeltype == 'y') {
                labeltype_boxplot.push(yidx, yidx);
              } else {
                labeltype_boxplot.push('others');
              }

              labeltype_boxplot.map(function (d, i) {
                var rangeidx = d == medianidx || d == 'others' ? null : i % 2,
                  columnidx = d == 'others' ? null : d;
                labelQueue.push({
                  renderer: chart,
                  charttype: 'bar',
                  chartObj: chartObj,
                  rendererIndex: rendererIndex,
                  paneid: paneid,
                  args: [currentdata, index, 0, rangeidx, columnidx]
                });
              });
            }
          } else if (cType == 'barrange') {
            labelQueue.push({
              renderer: chart,
              charttype: 'bar',
              chartObj: chartObj,
              paneid: paneid,
              args: [currentdata, index, 0, 1]
            });
            labelQueue.push({
              renderer: chart,
              charttype: 'bar',
              chartObj: chartObj,
              paneid: paneid,
              args: [currentdata, index, 0, 0]
            }); //last argument in args for yrangePos
          } else {
            labelQueue.push({
              renderer: chart,
              charttype: 'bar',
              chartObj: chartObj,
              rendererIndex: rendererIndex,
              paneid: paneid,
              args: [currentdata, legendOrder, null, null, null, rendererIndex]
            });
          }
        });
        function getSegments(d) {
          var _data = d._data(),
            mSize = commonRendererProp.params.whiskers.size;
          if (typeof commonRendererProp.params.whiskers.size === 'string' && commonRendererProp.params.whiskers.size.indexOf('%') > -1) {
            //if user gives size as percent, '75%'
            mSize = parseFloat(commonRendererProp.params.whiskers.size) / 100 * commonRendererProp.params.xscale.bandwidth() / 10;
          }
          var whiskerIndex = commonRendererProp.params.whiskers.dataindex,
            y = (yscale(d[whiskerIndex][0]) + yscale(d[whiskerIndex][1])) / 2,
            attr = commonRendererProp.params.axisrotated ? '_y' : '_x';
          var symbolSegment = getSegmentsForSymbol(
          'horizontal-whisker',
          mSize,
          _data[attr] + chart.commonOption.barWidth / 2,
          y,
          whiskerSize(d, yscale, null, null, null, whiskerIndex),
          commonRendererProp.params.axisrotated);

          return symbolSegment;
        }

        chart.getSegments = getSegments;
        var chartInstance = commonRendererProp.params.chartObj;
        transitionDuration = newBarParser ? newBarRenderer.builderC.animationOptions._duration : transitionDuration;
        chartInstance.timerObj[chartInstance.timerObj.length] = chart.renderedTimer = setTimeout(function () {
          isredraw = true;
          chart.chartRendered = true;
        }, 2 * transitionDuration + 10);
        return chart;
      }
      chart.getHighlighter = function (chartObj, index, chartName) {
        if (!chart.highlighter) {
          var cType = chartName || getChartTypeByIndex(chartObj, null, index).name,
            isBullet = cType == 'bullet',
            isGantt = cType == 'gantt',
            isBoxplot = cType == 'boxplot',
            whiskers = commonRendererProp.params.whiskers && commonRendererProp.params.whiskers.enabled,
            overlayWhisker = whiskers && commonRendererProp.params.whiskers.showOn == 'overlay';
          chart.highlighter = isBullet ?
          new BulletHighlighter(chartObj, chart) :
          isGantt ?
          new GanttHighlighter(chartObj, chart) :
          overlayWhisker ?
          new BarWhiskerHighlighter(chartObj, chart) :
          isBoxplot ?
          new BoxplotHighlighter(chartObj, chart) :
          new BarHighlighter(chartObj, chart);
        }

        return chart.highlighter;
      };
      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.bandwidth1 = function (_) {
        if (!arguments.length) {
          return bandwidth1;
        }
        bandwidth1 = _;
        return chart;
      };

      chart.bandwidth2 = function (_) {
        if (!arguments.length) {
          return bandwidth2;
        }
        bandwidth2 = _;
        return chart;
      };

      chart.barDatasetIndex = function (_) {
        if (!arguments.length) {
          return barDatasetIndex;
        }
        barDatasetIndex = _;
        return chart;
      };

      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };

      return chart;
    };

    function _whiskerMark(data, phase, condition) {
      var KEY = 'whiskers',
        KEY_MERGED = 'whiskersOptionsMerged';

      var _this = this,
        isWhiskerOnEdges = _this.builderC[KEY].showOn == 'edges',
        highlightPhase = phase === 'highlight',
        options = highlightPhase ? this.builderC[KEY_MERGED].hoveroptions : this.builderC[KEY_MERGED];

      var _whiskerG = {
        mark: 'g',
        selector: ".whiskerSeries".concat(this.builderC.datasetIndex),
        data: data.disabled || !condition ? [] : [data.data],
        children: []
      };
      if (condition) {
        var args_data = highlightPhase ? data.data : null;
        if (isWhiskerOnEdges) {
          var whiskerMark_0 = getBaseMark4BarMarker.call(this, KEY, args_data, options, 0),
            whiskerMark_1 = getBaseMark4BarMarker.call(this, KEY, args_data, options, 1);
          _whiskerG.children.push(whiskerMark_0, whiskerMark_1);
        } else {
          var whiskerMark = getBaseMark4BarMarker.call(this, KEY, args_data, options);
          _whiskerG.children.push(whiskerMark);
        }
      }
      return _whiskerG;
    }

    MarksRegistry.add('boxplot.whisker', _whiskerMark);

    defaultTheme.boxplot = function () {
      return {
        outerPadding: 0.04,
        fillOpacity: 0.9,
        maxBandWidth: 200,
        multiColoring: false,
        border: {
          show: false,
          size: null,
          style: 'solid',
          radius: 0,
          color: null
        },
        whiskers: {
          enabled: true,
          columnindex: 3,
          dataindex: 3,
          size: '50%',
          color: '#d8d8d8',
          opacity: 0.9,
          strokeWidth: 1,
          showOn: 'edges', //'overlay'
          events: {
            enabled: true
          },
          hoveroptions: {
            strokeWidth: 2,
            opacity: 0.9,
            color: '#d8d8d8',
            size: '60%'
          }
        },
        median: {
          enabled: true,
          dataindex: 2,
          columnindex: 2,
          color: '#d8d8d8',
          opacity: 0.9,
          strokeWidth: 1,
          hoveroptions: {
            strokeWidth: 2,
            opacity: 0.9,
            color: '#d8d8d8',
            size: '60%'
          }
        },
        datalabels: {
          showAs: 'y' //x,y,percent
        },
        animation: {
          type: 'verticalAll' //verticalAll || vertical
        },
        gradients: {
          //linear || none
          options: {
            linear: {
              y2: 50
            }
          }
        }
      };
    };

    function _medianMark(data, phase, condition) {
      var KEY = 'median',
        KEY_MERGED = 'medianOptionsMerged';

      var highlightPhase = phase === 'highlight',
        options = highlightPhase ? this.builderC[KEY_MERGED].hoveroptions : this.builderC[KEY_MERGED];

      var _medianG = {
        mark: 'g',
        selector: ".medianSeries".concat(this.builderC.datasetIndex),
        data: !condition || data.disabled ? [] : [data.data],
        children: []
      };
      if (condition) {
        var args_data = highlightPhase ? data.data : null;
        var _medianMark2 = getBaseMark4BarMarker.call(this, KEY, args_data, options);
        _medianG.children.push(_medianMark2);
      }
      return _medianG;
    }

    MarksRegistry.add('boxplot.median', _medianMark);

    //$Id$

    DataProcessor.prototype.processBubblePieData = function (_data) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // chartType = bubblepie | geobubblepie | geopie

      var chartType = options.chartType || charttype.bubblepie,
        keyAccessor = options.keyAccessor || bubblepieUtils.getKey,
        _dataIndex = options.dataIndex;

      var processor = this,
        processedseriesData = _data || processor.processedseriesData,
        chartObj = processor.chartObj,
        dataset = processor.dataset,
        commonPlotOptions = processor.data.chart.plot.plotoptions[charttypenames.get(chartType)],
        pieDataIndex = pick(_dataIndex, validateNullVal(commonPlotOptions && commonPlotOptions.dataindex, 3)),
        pieData = [],
        keys = [],
        userCategories = {
          x: NULL$1,
          y: []
        },
        userXCategories = getPropVal(chartObj.userdata, 'chart.axes.xaxis.categories'),
        hasUserXCategories =
        dataset.getDataType('x') == ORDINAL_DATATYPE && userXCategories && userXCategories.length && !isFacet(chartObj);

      if (hasUserXCategories) {
        userCategories.x = userXCategories;
      }

      processedseriesData.forEach(function (series, seriesIndex) {
        var yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(series.yaxiscolumnorder),
          userYCategories = getPropVal(chartObj.userdata, "chart.axes.yaxis[".concat(yaxiscolumnorder, "].categories")),
          hasUserYCategories =
          dataset.getDataType('y', yaxiscolumnorder) == ORDINAL_DATATYPE &&
          userYCategories &&
          userYCategories.length &&
          !isFacet(chartObj),
          chartType = getChartTypeByIndex(chartObj, "".concat(series.row, "_").concat(series.column), seriesIndex).value;

        if (hasUserYCategories) {
          userCategories.y[yaxiscolumnorder] = userYCategories;
        }

        series.data.forEach(function (subseries, subseriesIndex) {
          subseries.forEach(function (dataPoint) {
            var inactive = isInactive(dataPoint, seriesIndex, chartType);
            keys[subseriesIndex] = keys[subseriesIndex] || [];
            pieData[subseriesIndex] = pieData[subseriesIndex] || [];

            if (!inactive) {
              var key = keyAccessor(dataPoint, seriesIndex, chartObj); //TODO: check with multi yaxiscolumnorder
              var keyIndex = keys[subseriesIndex].indexOf(key);

              if (keyIndex === -1) {
                keyIndex = keys[subseriesIndex].length;
                pieData[subseriesIndex][keyIndex] = getPieReference(dataPoint, yaxiscolumnorder);
              }
              pieData[subseriesIndex][keyIndex][seriesIndex] = dataPoint;
              keys[subseriesIndex].push(key);
            }
            dataPoint.disabled = dataPoint.dummy = inactive;
          });
          pieData[subseriesIndex] = pieData[subseriesIndex] || [];
        });
      });
      addDummyDataForMissing();

      return pieData;

      // Helpers
      function isInactive(dataPoint, seriesIndex, chartType) {
        var currentSeriesData = processedseriesData[seriesIndex],
          yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(currentSeriesData.yaxiscolumnorder),
          inactive = currentSeriesData.disabled || !(isMultiPieChartType(chartType) || !arrayIncludes(chartcategory.axis, chartType)),
          xVal = dataset.getX(dataPoint),
          yVal = dataset.getY(dataPoint, yaxiscolumnorder);

        if (userCategories.x) {
          inactive = inactive || userCategories.x.indexOf(xVal) === -1;
        }
        if (userCategories.y[yaxiscolumnorder]) {
          inactive = inactive || userCategories.y[yaxiscolumnorder].indexOf(yVal) === -1;
        }

        if (chartObj.isGeoMap && !inactive) {
          inactive = !processor.isValidPoint(dataPoint);
        }
        return inactive;
      }

      function addDummyDataForMissing() {
        pieData.forEach(function (subseries) {
          subseries.forEach(function (data) {
            processedseriesData.forEach(function (series, seriesIndex) {
              if (!data[seriesIndex]) {
                data[seriesIndex] = getDummyData(data, seriesIndex);
              }
            });
          });
        });
      }

      function getDummyData(reference, seriesIndex) {
        var yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(processedseriesData[seriesIndex].yaxiscolumnorder),
          dataset = chartObj.dataset,
          data = [];

        data[dataset.xidx] = reference.x;
        if (isFunction(dataset.yidx)) {
          data[dataset.yidx(yaxiscolumnorder)] = reference.y;
        }
        data[dataset.zidx] = reference.z;
        data[pieDataIndex] = null;
        data.dummy = true;

        return data;
      }

      function getPieReference(dataPoint, yaxiscolumnorder) {
        var meta = [];
        meta.x = dataset.getX(dataPoint);
        meta.y = dataset.getY(dataPoint, yaxiscolumnorder);
        meta.z = dataset.getZ(dataPoint);
        meta.reference = dataPoint;
        return meta;
      }
    };

    var _bubblePieProcessor = DataProcessor.prototype.processBubblePieData;

    function isWithinSizeEncode(d, chartObj) {
      var scaleComponent = arrayFind(chartObj.scales, function (_) {return _.id === 'z-0';}),
        scale = scaleComponent.scale,schema = scaleComponent.schema,_schema$data2 =
        schema.data,dataType = _schema$data2.dataType,meta = _schema$data2.meta,
        config = getLegendConfig(scaleComponent.encode, scaleComponent.key, chartObj),
        nullAs = config.nullAs,
        size = chartObj.dataset.getZ(d),
        nullAsCondition = function nullAsCondition(val) {
          if (isUndefined(val)) {
            return defined(nullAs) || dataType === ORDINAL_DATATYPE && isObjectPropDefined(meta[meta.datatype], 'nullformatting');
          }

          return true;
        };

      return isWithinEncode(size, 'z', chartObj, scale, config, { condition: nullAsCondition });
    }

    Registry.setComponent('size.isWithinSizeEncode', isWithinSizeEncode);

    //$Id$

    function arcInnerTween(element, arc, innerRadius, outerRadius) {
      element.attrTween('d', function (d, i) {
        var interpolateOuterRadius = d3_interpolate(outerRadius[0], outerRadius[1]);
        var interpolateInnerRadius = d3_interpolate(innerRadius[0], innerRadius[1]);

        return function (t) {
          arc.outerRadius(interpolateOuterRadius(t));
          arc.innerRadius(interpolateInnerRadius(t));
          return arc(d);
        };
      });
    }

    function updateSelectionOnDatapoint(point, tempData) {
      point.selected = tempData.selected;
    }

    //$Id$

    var annotation$2 = Registry.getComponent('annotation');
    /**
     *
     * @returns {chart} pie renderer.
     */
    svg_plot_renderer.pie = function () {
      var MAXWIDTH_DATALABELS = 0.3;
      var pie = d3_pie().sort(NULL$1),
        arc = d3_arc(),
        sliceOut = function sliceOut(d) {
          return polarToXY(sliceOutHeight, (d.startAngle + d.endAngle) / 2);
        },
        isredraw = false,
        InsidelabelTextGroup,
        labelLinkGroup,
        labelTextGroup,
        innerBoundBoxGroup,
        boundBoxGroup,
        hasNegValue,
        hasPreviousNegValue,
        gElementsCollected,
        hasBoundBox,
        previousRadiusFactors,
        previousInnerRadius,
        previousOuterRadius,
        baseValue;
      var commonRendererProp,
        chartObj,
        outerRadius,
        innerRadius,
        totalEngagement,
        color,
        container,
        piegroup,
        chartheight,
        chartwidth,
        pieArcs,
        paneid;
      var oldData, arcLabel, commonPlotOptions, systemconf, notesArray, isDial;
      var rad, OR, strokeWid, noofNonZeroDatas, sliceOutHeight;
      var modelOptions, transX, transY, customPlotarea, plotarea, dataindex;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          notesArray = rp.notesArray,
          systemconf = chartObj.systemConf;
          var labelQueue = rp.labelQueue,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            dataset = rp.dataset,
            index = rp.datasetIndex || 0,
            bound = rp.bound,_rp$rendererIndex7 = rp.rendererIndex,rendererIndex = _rp$rendererIndex7 === void 0 ? index : _rp$rendererIndex7;

          var defsLocation = chartObj.defsLocation,
            currentRadiusFactors = "".concat(commonPlotOptions.maxRadius, " _ ").concat(commonPlotOptions.outerPadding, " _ ").concat(commonPlotOptions.innerRadius);
          paneid = isFacet(chartObj) ? "".concat(
          getValByPriority([data, data[index]], 'row'), "_").concat(getValByPriority([data, data[index]], 'column')) :
          null;
          var chartName = getChartTypeByIndex(chartObj, paneid, index).name;

          isDial = chartName === DIAL_CHARTNAME;
          var isPie = chartName === PIE_CHARTNAME,
            isBubblePie = !isDial && !isPie,
            serData = isBubblePie || isFacet(chartObj) && hasColorColumnInNonAxis(chartObj) ? data : data[index];

          dataindex = isBubblePie ? validateNullVal(commonPlotOptions.dataindex, 3) : dataset.yidx(yaxiscolumnorder);

          if (isDial) {
            plotarea = _objectSpread(_objectSpread({}, chartObj.plotarea_approx), bound && bound.polar);
          } else {
            plotarea = _objectSpread(_objectSpread({}, bound), customPlotarea);
          }

          chartwidth = plotarea.width,
          chartheight = plotarea.height,
          outerRadius = validateNullVal(plotarea.radius, mathMin(chartwidth, chartheight) / 2);
          gElementsCollected = false;

          var plotoptions = serData.plotoptions,
            dataLabels = commonPlotOptions.datalabels,
            gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions);

          var _commonPlotOptions = commonPlotOptions,_commonPlotOptions$mo = _commonPlotOptions.mode,mode = _commonPlotOptions$mo === void 0 ? 'radial' : _commonPlotOptions$mo,
            maxRadius = validateNullVal(gvp('maxRadius'), 250),
            levelMarkerConf = commonPlotOptions.levelMarker,
            padding = isPie ? +gvp('outerPadding') : 0,
            strokeWidth = gvp('strokeWidth'),
            visibility,
            cornerRadius = gvp('cornerRadius') || 0,
            padAngle = gvp('padAngle') || 0,
            finalDisplay = function finalDisplay(d) {
              var hidden = d.data.disabled || d.startAngle === d.endAngle || !d.value; // if disabled or value = 0 | null
              return hidden ? NONE : NULL$1;
            },
            initialDisplay = function initialDisplay(d) {
              var prevDisplay = d3_select(this).style('display'),
                curDisplay = finalDisplay(d);
              return !isredraw ||
              prevDisplay === NONE && curDisplay === NONE ||
              !isDataActive(d, chartObj, index) ||
              mode !== 'radial' && (d.data.disabled || d.data.dummy) ?
              curDisplay :
              NULL$1;
            };

          if (isFacet(chartObj) && padding > outerRadius) {
            // ZC2770
            padding = 0;
          }

          baseValue = commonPlotOptions.baseValue !== undefined ? commonPlotOptions.baseValue : 0;

          var showlabel = chartObj.datalabels.moduleExists && isDatalabelEnabled(dataLabels, chartObj),
            datalabelPadding = showlabel ?
            +(dataLabels.padding || 0) + (
            isBoundBoxEnabled(dataLabels, chartObj) ?
            (getBoundBoxPadding(dataLabels, chartObj) + getBoundBoxStrokeWidth(dataLabels, chartObj)) * 2 :
            0) :
            0,
            extraOptions = {},
            datalabelsWidth = 0;
          hasBoundBox = chartObj.datalabels.moduleExists && isBoundBoxEnabled(dataLabels, chartObj);

          padding += isPie ? datalabelPadding : 0;
          rad = mathMin(maxRadius, outerRadius - padding);
          if (isPie && showlabel) {
            /*
             *If chart width is lesser than height, datalabels are hidden as default padding is 30 and there is no space to show datalabels.
             * So 30% of the width is allocated for datalabels and the default padding will be changed to 2
             */
            var minDatalabelsWidth = chartwidth * MAXWIDTH_DATALABELS,
              availableDatalabelsWidth = chartwidth - 2 * rad;
            if (availableDatalabelsWidth < minDatalabelsWidth) {
              datalabelPadding = extraOptions.padding = 5;
              datalabelsWidth = mathMax(minDatalabelsWidth - availableDatalabelsWidth, 0);
              rad -= datalabelsWidth / 2;
            }
          }
          innerRadius = getInnerRadius(commonPlotOptions, rad);
          strokeWidth = validateNullVal(strokeWidth, 1);

          if (isDial && levelMarkerConf.enabled) {
            var innerPadding, outerPadding;

            if (defined(commonPlotOptions.bandWidth) || defined(commonPlotOptions.maxBandWidth)) {
              var maxDialBandWidth = validateNullVal(commonPlotOptions.maxBandWidth, rad);
              var dialBandWidth = mathMin(perToPx(commonPlotOptions.bandWidth, rad, rad - innerRadius), maxDialBandWidth);

              innerPadding = -(rad - innerRadius - dialBandWidth) / 2, outerPadding = -(rad - innerRadius - dialBandWidth) / 2;

              visibility = dialBandWidth === 0 ? 'hidden' : NULL$1;
            } else {
              innerPadding = mathMin(0, perToPx(levelMarkerConf.innerPadding, outerRadius, 0));
              outerPadding = mathMin(0, perToPx(levelMarkerConf.outerPadding, outerRadius, 0));
            }

            rad += outerPadding;
            innerRadius -= innerPadding;
          }

          rad -= 0.5 * strokeWidth;
          OR = mathMax(innerRadius, rad);
          modelOptions =
          (plotoptions && plotoptions.models ?
          mergeJSON$1(commonPlotOptions.models, plotoptions.models, true) :
          commonPlotOptions.models) || {};
          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, chartName);
          var isAnimationEnable = animationOptions.enabled,
            transitionDuration = !isAnimationEnable ? 0 : isredraw ? 200 : animationOptions.duration,
            easingType = isredraw ? d3_ease_linear : animationOptions.easingType,
            animationType = animationOptions.type,
            transitionEnd = function transitionEnd() {
              d3_select(this).style('display', finalDisplay);
            };
          var eventDisabled = validateNullVal(getEventConf(plotoptions, commonPlotOptions, chartObj, 'enabled'), true) == false;
          var cursor = eventDisabled ? NULL$1 : getEventConf(plotoptions, commonPlotOptions, chartObj, 'cursor') || POINTER;

          container = d3_select(this);
          piegroup = appendEle(container, 'g', [data], '.', 'class', 'piegroup');
          piegroup.styles({
            'stroke-width': strokeWidth,
            'fill-opacity': gvp('fillOpacity'),
            'stroke-opacity': commonPlotOptions.strokeOpacity,
            cursor: cursor,
            visibility: visibility
          });

          pie.startAngle(commonPlotOptions.startAngle).
          endAngle(commonPlotOptions.endAngle).
          value(function (d) {
            return d.disabled ? 0 : mathAbs(d[dataindex] || 0);
          }); //d[dataindex] || 0 --> Why || 0 is, it may contain undefined Y value
          var pieData = pie(data = isBubblePie || isFacet(chartObj) && hasColorColumnInNonAxis(chartObj) ? data : serData.data[0]);
          chart.data = pieData;

          noofNonZeroDatas = pieData.reduce(function (prev, cur, i) {
            return prev + (cur.value ? 1 : 0);
          }, 0);
          chart.total = totalEngagement = pieData.reduce(function (prev, cur, i) {
            return prev + cur.value;
          }, 0);
          chart.arc = arc;

          if (mode === 'radial') {
            arc.outerRadius(OR).innerRadius(innerRadius);
          } else {
            var interPadding = perToPx(commonPlotOptions.interPadding, OR, 10),
              len = data.reduce(function (prev, cur) {return prev + (cur.disabled || cur.dummy ? 0 : 1);}, 0),
              band = (OR - innerRadius - (len - 1) * interPadding) / len,
              _index = -1;

            pieData.forEach(function (d) {
              if (!d.data.disabled && !d.data.dummy) {
                _index++;
              }
              d.innerRadius = _index * (band + interPadding) + innerRadius;
              d.outerRadius = (_index + 1) * band + _index * interPadding + innerRadius;
            });

            arc.startAngle(commonPlotOptions.startAngle);
          }
          arcLabel = d3_arc().
          innerRadius(OR).
          outerRadius(OR + datalabelPadding);
          var arcLabel1 = d3_arc().innerRadius(OR).outerRadius(OR);

          // translating the piegroup to center
          strokeWid = strokeWidth;
          var bb = translateWrap(piegroup);
          //calculating new radius
          var heightPercent = (bb.height + strokeWidth) / rad,
            widthPercent = (bb.width + strokeWidth) / rad;
          var newrad =
          rad +
          mathMin(
          (chartwidth - 2 * padding - datalabelsWidth - (bb.width + strokeWidth)) / widthPercent,
          (chartheight - 2 * padding - datalabelsWidth - (bb.height + strokeWidth)) / heightPercent);

          newrad = mathMin(maxRadius, mathMax(rad, newrad));
          if (isDial) {
            currentRadiusFactors += " _ ".concat(commonPlotOptions.bandWidth, " _ ").concat(levelMarkerConf.bandWidth, " _ ").concat(levelMarkerConf.innerPadding, " _ ").concat(levelMarkerConf.outerPadding);

            var yscale = rp.yscale || chartObj.axes.y.groups[0].scale;
            var minMax = yscale.domain();
            // var prev = yscale.domain()[0];
            pieData.forEach(function (d) {
              // d.startAngle = yscale(prev);
              // d.endAngle = yscale(prev + d.value);
              // prev += d.value;
              var val = d.data[dataindex];
              hasPreviousNegValue = hasNegValue;
              if (hasNegValue = val < 0) {
                // Test_529.json
                d.startAngle = yscale(baseValue != NULL$1 ? Math.min(baseValue, minMax[1]) : minMax[1]);
                d.endAngle = yscale(Math.max(val, minMax[0]));
              } else {
                d.startAngle = yscale(baseValue != NULL$1 ? Math.max(baseValue, minMax[0]) : minMax[0]);
                d.endAngle = yscale(Math.min(d.value, minMax[1]));
              }
            });
          } else if (newrad != rad) {
            // updating values based on new radius
            rad = newrad;
            innerRadius = getInnerRadius(commonPlotOptions, rad);
            OR = mathMax(innerRadius, rad);
            arc.outerRadius(OR).innerRadius(innerRadius);
            arcLabel = d3_arc().
            innerRadius(OR).
            outerRadius(OR + datalabelPadding);
            arcLabel1 = d3_arc().innerRadius(OR).outerRadius(OR);
            translateWrap(piegroup);
          }
          // set the cornerRadius and padAngle
          arc.cornerRadius(cornerRadius).padAngle(padAngle);

          var modelID = !isDial && modelOptions.type ? "url(".concat(defsLocation, "#").concat(createModelClippath(getModelPath()), ")") : NULL$1;
          var gradientDim = [OR, OR];
          var fillColor = chart.fillColorFunc = getFillColor(chartObj, index, paneid, gradientDim),
            strokeColor = getStrokeColor(chartObj, index, paneid);
          sliceOutHeight = perToPx(gvp('sliceOutHeight'), rad, 0) * 2;

          oldData = piegroup.selectAll(PATH_ELEMENT).data();

          pieArcs = appendEle(piegroup, PATH_ELEMENT, pieData);
          cancelAnimation(pieArcs);

          pieArcs.
          attrs({
            'clip-path': modelID,
            "class": 'zc_pie',
            id: function id(d, i) {
              return "arc_".concat(i);
            }
          }).
          styles({
            display: initialDisplay,
            fill: function fill(d, i) {
              if (isFacet(chartObj)) {
                return getFillColor(chartObj, i, paneid, gradientDim)(i, d.data);
              }
              return fillColor(i, d.data, null);
            },
            stroke: function stroke(d, i) {
              if (isFacet(chartObj)) {
                return getStrokeColor(chartObj, i, paneid)(i, d.data, commonPlotOptions.strokeColor);
              }

              return strokeColor(i, d.data, commonPlotOptions.strokeColor);
            }
          });

          setPivotAttributes(pieArcs, chartObj, 'pie');
          setOpacityForTickFilterElements(pieArcs, chartObj, 'pie');

          setPointerEvents(chartObj, pieArcs, eventDisabled, paneid);
          if (!chartObj.cache.search) {
            chartObj.cache.search = {};
          }
          if (!eventDisabled) {
            var mousemove = function mousemove(d, i) {
                var args = getEventArgs(d, i);
                chartObj.eventHandler.handlers.mousemove.call(chartObj.eventHandler, args);
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = paneid;
              },
              mouseout = function mouseout(d, i) {
                var args = getEventArgs(d, i);
                chartObj.eventHandler.handlers.mouseout.call(chartObj.eventHandler, args);
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = null;
              },
              click = function click(d, i) {
                var args = getEventArgs(d, i);
                chartObj.eventHandler.handlers.click.call(chartObj.eventHandler, args, chart, 0, i, d); //chart,d swapped
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = paneid;
              },
              dblclick = function dblclick(d, i) {
                var data = !annotation$2._empty ? generateDataForAnnotation(d.data, NULL$1) : d.data;
                var coordinates = arcLabel.centroid(d);
                coordinates = [coordinates[0] + transX, coordinates[1] + transY];
                var args = getEventArgs(d, i);
                args.coordinate = coordinates;
                args.basedOn = 'plot';
                args.data = data;
                chartObj.eventHandler.handlers.doubleclick.call(chartObj.eventHandler, args, i, args);
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = paneid;
              },
              eventAttacherOptions = {
                target: 'plot',
                touchleave: true,
                chartObj: chartObj
              };
            var mouseHandlers = {
                mousemove: mousemove,
                mouseout: mouseout,
                click: click,
                dblclick: dblclick
              },
              touchHandlers = {
                singletouchmove: mousemove,
                touchend: mouseout,
                tap: click,
                dbltap: dblclick
              };
            attachevents(pieArcs, mouseHandlers, touchHandlers, eventAttacherOptions);
          }
          if (/(\D)+onebyone/.test(animationType) && !isredraw) {
            var isFan = animationType == FANONEBYONE_ANIMATION;
            var duration = isFan ? transitionDuration : transitionDuration / noofNonZeroDatas;
            var prev = 0;
            pieArcs.
            transition().
            ease(easingType).
            duration(function (d) {
              return isFan ? duration * (d.value / totalEngagement) : duration;
            }).
            delay(function (d) {
              var dur = duration * prev;
              prev += isFan ? d.value / totalEngagement : 1;
              return dur;
            }).
            call(isFan ? arcTween : innerTween).
            on('end', transitionEnd);
          } else {
            var tweenType;
            if (isredraw) {
              tweenType = currentRadiusFactors != previousRadiusFactors ? innerTween : fanAllTween;
            } else {
              tweenType = animationType == FANALL_ANIMATION ? fanAllTween : animationType == INNER_ANIMATION ? innerTween : arcTween;
            }

            if (chartObj.systemConf.chart.plot.morph.enabled && chartObj.oldSeriesInfo != undefined) {
              var morph_Obj = new zcMorph({ sampling: chartObj.systemConf.chart.plot.morph.samplingDistance });
              var oldseriesData = chartObj.oldSeriesInfo.get(index);
              var oldseriesIndex = oldseriesData.seriesIndex;
              var oldseriesColor = oldseriesData.color;
              var offsetValue = getOffsetValue(chartObj, oldseriesIndex);
              var individualElementTransform = oldseriesData.transformationInfo;
              transitionDuration = chartObj.systemConf.chart.plot.morph.duration;
              var line = d3_line();
              var interpolated = {};

              pieArcs.each(function (d, i) {
                var fromPath = chartObj.oldSeriesInfo.get(oldseriesIndex).pathData[i];
                var fromPathAttribute = fromPath.getAttribute('d');
                fromPath.setAttribute('d', arc(d));
                var toPath = fromPath.cloneNode();
                fromPath.setAttribute('d', fromPathAttribute);
                interpolated[i] = morph_Obj.interpolate(
                {
                  path: fromPath,
                  xOffset: offsetValue.x + individualElementTransform[i].x,
                  yOffset: offsetValue.y + individualElementTransform[i].y
                },
                { path: toPath, xOffset: 0, yOffset: 0 });

              });
              pieArcs.
              style('fill', function (d, i) {
                return oldseriesColor[i];
              }).
              transition().
              duration(transitionDuration).
              ease(easingType).
              style('fill', function (d, i) {
                return getRawColor(chartObj, i, d.data, oldseriesIndex, null);
              }).
              attrTween('d', function (d, i) {
                var interpolator = interpolated[i];
                return function (t) {
                  return line(
                  interpolator.map(function (p) {
                    return p(t);
                  }));

                };
              }).
              on('end', function (d, i) {
                if (chartObj.oldSeriesInfo) {
                  delete chartObj.oldSeriesInfo;
                }
                d3_select(this).style('fill', function () {
                  return fillColor(i, d.data, null);
                });
                this.setAttribute('d', arc(d));
              });
            } else {
              pieArcs.transition().duration(transitionDuration).ease(easingType).call(tweenType).on('end', transitionEnd);
            }
          }
          chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
            previousRadiusFactors = currentRadiusFactors;
            previousInnerRadius = innerRadius;
            previousOuterRadius = OR;
            if (isDial) {
              chartObj.renderer[rendererIndex].endFunctions();
            } else {
              if (labelRenderer && !isBubblePie) {
                var translation = hasColorColumnInNonAxis(chartObj) ?
                [transX + plotarea.translate[0], transY + plotarea.translate[1]] :
                [transX, transY];

                var args = [
                piegroup.datum(),
                0,
                pieData,
                OR,
                totalEngagement,
                arcLabel,
                arcLabel1,
                arc,
                translation,
                extraOptions,
                chart.subSeriesIndex || 0];

                labelQueue.push({
                  renderer: chart,
                  charttype: PIE_CHARTNAME,
                  chartObj: chartObj,
                  rendererIndex: rendererIndex,
                  paneid: pick(paneid, index),
                  args: args
                });
                labelQueue.push({
                  renderer: chart,
                  charttype: 'pieInnerLabels',
                  chartObj: chartObj,
                  rendererIndex: rendererIndex,
                  paneid: pick(paneid, index),
                  args: args
                });
              }
            }

            //Annotation preprocessing
            var notes = chartObj.systemConf.notes;
            if (defined(notes) && notes.enabled && !isBubblePie && !annotation$2._empty) {
              //MODULARIZE
              notesArray = annotation$2.preprocessAnnotations(
              chartObj.seriesdata,
              0,
              function (dt, k, j) {
                var c = arcLabel.centroid(pieData[j]);
                return [c[0] + transX, c[1] + transY];
              },
              notesArray,
              chartObj,
              rp);

            }
            chart.chartRendered = true;
            isredraw = true;

            if (hasColorColumnInNonAxis(chartObj)) {
              chartObj.renderer[rendererIndex].endFunctions();
            }
          }, transitionDuration + 1000 / 60);

          function getEventArgs(d, i) {
            var ev = getEventObject(d3_event());
            return {
              renderer: chart,
              seriesIndex: hasColorColumnInNonAxis(chartObj) ? i : 0,
              subSeriesIndex: 0,
              itemIndex: i,
              paneid: paneid,
              rendererIndex: rendererIndex,
              color: color[i % color.length],
              coordinates: [ev.pageX, ev.pageY],
              element: this,
              data: d,
              selected: d.selected,
              _key: DataProcessor.helpers.generatePointKey(chartObj.id, paneid, 0, 0, i)
            };
          }
        });
        return chart;
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.plotarea = function (_) {
        //Bubble Pie chart will give you the plotarea
        if (!arguments.length) {
          return customPlotarea || plotarea;
        }
        customPlotarea = _;
        return chart;
      };

      chart.innerRadius = function (_) {
        if (!arguments.length) {
          return innerRadius;
        }
        innerRadius = _;
        return chart;
      };

      chart.defaultMouseOverFunc = function (d, seriesPos, itemPos) {
        if (noofNonZeroDatas == 1) {
          return;
        }

        if (!gElementsCollected) {
          collectGroups(commonRendererProp.params.rendererIndex);
        }

        var pt = sliceOut(d),
          subSeriesIndex = chart.subSeriesIndex || 0;
        var slicedPosition = {
          transform: "translate(".concat(pt[0], ",").concat(pt[1], ")")
        };

        pieArcs.transition().ease(d3_ease_linear).attr('transform', 'translate(0,0)');

        //Reset previous pane mouseover
        // if(chartObj.dataObject.pivot){
        //     var allPieGroups = chartObj.wrap.selectAll('g.piegroup'),
        //         allPieArcs = allPieGroups.selectAll('path');
        //     allPieArcs
        //         .transition()
        //         .ease(d3_ease_linear)
        //         .attr('transform', 'translate(0,0)');
        // }

        piegroup.selectAll("#arc_".concat(itemPos)).transition().ease(d3_ease_linear).attrs(slicedPosition);

        InsidelabelTextGroup.selectAll("#innerlbl0_".concat(subSeriesIndex, "_").concat(itemPos)).transition().ease(d3_ease_linear).attrs(slicedPosition);

        if (!hasBoundBox) {
          labelLinkGroup.selectAll("#link0_".concat(subSeriesIndex, "_").concat(itemPos)).style('stroke-width', 3 * chart.lineStrokeWidth);
        }

        var label = labelTextGroup.selectAll("#lbl0_".concat(subSeriesIndex, "_").concat(itemPos)).node(),
          boundBoxSlicedPos = label ?
          {
            transform: 'translate(' + (Number(label.getAttribute('x')) + pt[0]) + ',' + (Number(label.getAttribute('y')) + pt[1]) + ')'
          } :
          slicedPosition,
          innerlabel = InsidelabelTextGroup.selectAll("#innerlbl0_".concat(subSeriesIndex, "_").concat(itemPos)).node(),
          innerBoundBoxSlicedPos = innerlabel ?
          {
            transform: 'translate(' + (Number(innerlabel.getAttribute('x')) + pt[0]) + ',' + (Number(innerlabel.getAttribute('y')) + pt[1]) + ')'
          } :
          slicedPosition;

        if (chart.showlabel == 'circular') {
          labelTextGroup.selectAll("#lbl0_".concat(subSeriesIndex, "_").concat(itemPos)).transition().ease(d3_ease_linear).attrs(slicedPosition);

          boundBoxGroup.selectAll("#boundboxlbl0_".concat(subSeriesIndex, "_").concat(itemPos)).transition().ease(d3_ease_linear).attrs(boundBoxSlicedPos);
        }
        labelTextGroup.selectAll("#lbl0_".concat(subSeriesIndex, "_").concat(itemPos)).style('text-shadow', '0 0 0 rgba(0,0,0,1)');

        innerBoundBoxGroup.
        selectAll("#boundboxinnerlbl0_".concat(subSeriesIndex, "_").concat(itemPos)).
        transition().
        ease(d3_ease_linear).
        attrs(innerBoundBoxSlicedPos);
      };

      chart.defaultMouseOutFunc = function (d, i, forceMouseOut) {
        if (!gElementsCollected) {
          collectGroups(commonRendererProp.params.rendererIndex);
        }

        var actualPosition = {
          transform: 'translate(0,0)'
        };

        labelTextGroup.selectAll(TEXT_ELEMENT).style('text-shadow', NULL$1);
        if (!hasBoundBox) {
          labelLinkGroup.selectAll(PATH_ELEMENT).style('stroke-width', chart.lineStrokeWidth);
        }

        var subSeriesIndex = chart.subSeriesIndex || 0,
          label = labelTextGroup.selectAll("#lbl0_".concat(subSeriesIndex, "_").concat(d.itemIndex)).node(),
          boundBoxSlicedPos = label ?
          {
            transform: 'translate(' + label.getAttribute('x') + ',' + label.getAttribute('y') + ')'
          } :
          actualPosition,
          innerlabel = InsidelabelTextGroup.selectAll("#innerlbl0_".concat(subSeriesIndex, "_").concat(d.itemIndex)).node(),
          innerBoundBoxSlicedPos = innerlabel ?
          {
            transform: 'translate(' + innerlabel.getAttribute('x') + ',' + innerlabel.getAttribute('y') + ')'
          } :
          actualPosition;

        if (!$ZCG.clickedTime && forceMouseOut) {
          pieArcs.attrs(actualPosition);

          InsidelabelTextGroup.selectAll(TEXT_ELEMENT).attrs(actualPosition);

          innerBoundBoxGroup.selectAll("#boundboxinnerlbl0_".concat(subSeriesIndex, "_").concat(d.itemIndex)).transition().ease(d3_ease_linear).attrs(innerBoundBoxSlicedPos);

          if (chart.showlabel == 'circular') {
            labelTextGroup.selectAll(TEXT_ELEMENT).attrs(actualPosition);
            boundBoxGroup.selectAll("#boundboxlbl0_".concat(subSeriesIndex, "_").concat(d.itemIndex)).transition().ease(d3_ease_linear).attrs(boundBoxSlicedPos);
          }
          return;
        }
        pieArcs.transition().ease(d3_ease_linear).attrs(actualPosition);

        InsidelabelTextGroup.selectAll(TEXT_ELEMENT).transition().ease(d3_ease_linear).attrs(actualPosition);

        if (chart.showlabel == 'circular') {
          labelTextGroup.selectAll(TEXT_ELEMENT).transition().ease(d3_ease_linear).attrs(actualPosition);
          boundBoxGroup.selectAll("#boundboxlbl0_".concat(subSeriesIndex, "_").concat(d.itemIndex)).transition().ease(d3_ease_linear).attrs(boundBoxSlicedPos);
        }
        innerBoundBoxGroup.selectAll("#boundboxinnerlbl0_".concat(subSeriesIndex, "_").concat(d.itemIndex)).transition().ease(d3_ease_linear).attrs(innerBoundBoxSlicedPos);
      };

      function getGearData(count) {
        var array = [],
          data = [],
          x = 0;
        for (var i = 0; i < count; i++) {
          modelOptions.type == 'gear1' ? data.push([x++, 0], [x++, 1], [x++, 1]) : data.push([x, 0], [x++, 1], [x, 1], [x++, 0]);
        }
        array.push(data);
        return array;
      }

      function getModelPath() {
        var index = -1,
          count = modelOptions.count,
          min = modelOptions.type == 'zigzag' ? -50 + innerRadius / 5 : modelOptions.type == 'sun' ? -1 : -10;
        var gearData = getGearData(count);
        var angleScale = d3_scaleLinear().
        range([0, 2 * mathPI]).
        domain([0, modelOptions.type == 'gear1' ? 3 * count : 2 * count]);
        var radiusScale = d3_scaleLinear().range([innerRadius, OR]).domain([min, 1]);
        var radialLine = d3_lineRadial().
        curve(d3_curves('linearClosed')).
        radius(function (d) {
          return radiusScale(d[1]);
        }).
        angle(function (d, i) {
          index =
          modelOptions.type == 'gear' ?
          i % 2 == 0 ?
          index + 1 :
          index :
          modelOptions.type != 'gear1' ?
          i % 2 != 0 ?
          index + 1 :
          index :
          index;
          return angleScale(modelOptions.type == 'gear1' ? index++ : index);
        });
        return radialLine(gearData[0]);
      }

      function createModelClippath(gearPath) {
        var properties = {
            name: 'pieModels',
            id: chartObj.id,
            d: gearPath
          },
          args = {
            chartObj: chartObj
          };
        var clipID = effects.get(effects.svg_clips, 'polygon', properties, args);
        return clipID;
      }

      function innerTween(element) {
        arcInnerTween(
        element,
        arc,
        [isredraw ? previousInnerRadius : innerRadius, innerRadius],
        [isredraw ? previousOuterRadius : innerRadius, OR]);

      }

      function arcTween(transition) {
        transition.attrTween('d', function (d, i) {
          var interpolate = d3_interpolate(d.startAngle, d.endAngle);
          return function (t) {
            d.endAngle = interpolate(t);
            return arc(d);
          };
        });
      }

      function fanAllTween(transition) {
        transition.attrTween('d', function (d, i) {
          var od = oldData[i] || oldData[oldData.length - 1],
            prevEA,
            prevSA;

          if (hasNegValue) {
            prevEA = isredraw && od && hasPreviousNegValue ? od.endAngle : d.startAngle,
            prevSA = isredraw && od && hasPreviousNegValue ? od.startAngle : d.startAngle;
          } else {
            prevEA = isredraw && od && !hasPreviousNegValue ? od.endAngle : isDial ? d.startAngle : commonPlotOptions.startAngle,
            prevSA =
            isredraw && od && !hasPreviousNegValue ?
            oldData[i] ?
            od.startAngle :
            od.endAngle :
            isDial ?
            d.startAngle :
            commonPlotOptions.startAngle;
          }

          var interpolate = d3_interpolate(prevEA, d.endAngle);
          var interpolate1 = d3_interpolate(prevSA, d.startAngle);

          return function (t) {
            d.endAngle = interpolate(t) || 0;
            d.startAngle = interpolate1(t) || 0;
            return arc(d, i);
          };
        });
      }

      function translateWrap(wrap) {
        //dummy data
        var dummyData = [];
        dummyData[dataindex] = 1;
        var dummyPieData = pie([dummyData])[0];
        dummyPieData.innerRadius = 0;
        dummyPieData.outerRadius = outerRadius;

        //dummy pie for getting the bound
        var dummy = container.
        append(PATH_ELEMENT).
        attr('d', arc(dummyPieData, chart.data.length - 1)).
        styles({
          fill: NONE,
          stroke: NONE
        });
        var bb = bbox(dummy.node());
        dummy.remove();

        //Reference point calculation for pie layout
        var pt = polarRefPoint(bb, chartwidth, chartheight, rad, strokeWid);
        transX = isDial ? plotarea.x : pt[0], transY = isDial ? plotarea.y : pt[1];
        chartObj.plotarea.centerX = transX, chartObj.plotarea.centerY = transY;
        wrap.attr('transform', function (d, i) {
          return "translate(".concat(transX, ",").concat(transY, ")");
        });
        return bb;
      }

      function collectGroups() {var rendererIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var subSeriesIndex = chart.subSeriesIndex || 0,
          parentWrap = isFacet(chartObj) ? chartObj.staticPaneSVG.selectAll("g.grid".concat(paneid)) : chartObj.staticPaneSVG;
        InsidelabelTextGroup =
        InsidelabelTextGroup || parentWrap.selectAll("g.".concat(INNERLABEL_LABELTYPE, "_").concat(rendererIndex, " g.subseries_").concat(subSeriesIndex));
        labelLinkGroup = labelLinkGroup || parentWrap.selectAll("g.link_".concat(rendererIndex, " g.subseries_").concat(subSeriesIndex));
        labelTextGroup = labelTextGroup || parentWrap.selectAll("g.label_".concat(rendererIndex, " g.subseries_").concat(subSeriesIndex));
        boundBoxGroup = boundBoxGroup || parentWrap.selectAll("g.boundboxseries_".concat(rendererIndex, " g.subseries_").concat(subSeriesIndex));
        innerBoundBoxGroup =
        innerBoundBoxGroup || parentWrap.selectAll("g.innerboundboxseries_".concat(rendererIndex, " g.subseries_").concat(subSeriesIndex));
        gElementsCollected = true;
      }

      return chart;
    };

    var _pieChart = svg_plot_renderer.pie;
    Registry.setComponent('svgRenderer.pie', _pieChart);

    defaultTheme.pie = function (type) {
      var defaultOptions = {
        startAngle: 0,

        endAngle: 2 * mathPI,
        innerRadius: 0,
        outerPadding: 10,
        datalabels: {
          type: 'circular', // circular || doubleside
          padding: 5,
          line: {
            strokeColor: 'grey',
            strokeWidth: 0.3
          },
          innerLabel: {
            show: false,
            showAs: 'percent' //x,y,percent
          }
        },
        animation: {
          type: 'fanAll' //inner, wheel, fanAll, fanonebyone , inneronebyone
        },
        gradients: {
          // radial || linear || none
          options: {
            linear: {
              x2: 15,
              spreadMethod: 'repeat', // pad || repeat || reflect
              gradientUnits: 'userSpaceOnUse' //objectBoundingBox || userSpaceOnUse
            },
            radial: {
              radius: 90
            }
          }
        },
        models: {
          count: 50
        }
      };
      if (type === 'bubblepie' || type === 'geobubblepie') {
        defaultOptions.strokeColor = 'transparent';
        defaultOptions.outerPadding = 0.02;
        defaultOptions.datalabels.showAs = 'percent'; //x,y,percent
        defaultOptions.hoveroptions = {
          innerFillColor: 'transparent',
          innerStrokeColor: 'transparent',
          outerFillColor: 'transparent',
          outerStrokeWidth: 3
        };
      } else {
        defaultOptions.strokeColor = 'white';
        defaultOptions.sliceOutHeight = 5;
        defaultOptions.maxRadius = 250;
        defaultOptions.datalabels.showAs = 'x'; //x,y,percent
      }
      return defaultOptions;
    };

    //

    function sizeRange() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var tempScaleLinear = d3_scaleLinear(),
        tempScalePoint = d3_scalePoint();
      var dim = options.dim,bound = options.bound,_options$correction = options.correction,correction = _options$correction === void 0 ? function (_) {return _;} : _options$correction;
      var chartObj = this.chartObj,
        config = this.getConfig(),
        userSizes = config.sizes,
        schema = this.schema.domain,
        domain = this.d3_scale.domain,
        dataType = this.schema.data.meta.datatype,
        ranges = schema.ranges,
        convertTo = function convertTo(_) {return perToPx(_, dim);};

      if (userSizes) {
        userSizes = invokeFunction(userSizes, chartObj, bound, this);
        return userSizes.map(convertTo);
      } else {
        var _default = correction(_defaultSize(config, chartObj, this, bound).map(convertTo), bound, this, chartObj);

        if (ranges || dataType === ORDINAL_DATATYPE) {
          var tempDomain = ranges || domain;
          tempScalePoint.
          domain(tempDomain) // multiple values
          .range(_default);

          return tempDomain.map(function (_) {return tempScalePoint(_);});
        } else {
          var _tempDomain = [domain[0], domain[domain.length - 1]],
            mid = _default[0] + (_default[1] - _default[0]) / 2;

          tempScaleLinear.
          domain(_tempDomain) // multiple stops may have
          .range(_tempDomain[0] == _tempDomain[1] ? [mid, mid] : _default);

          return domain.map(function (_) {return tempScaleLinear(_);});
        }
      }
    }

    function _defaultSize(config, chartObj, scaleComponent, bound) {
      var _default = _defaultPercent$1(chartObj, scaleComponent),
        minSize = invokeFunction(config.minSize, chartObj, bound, scaleComponent),
        maxSize = invokeFunction(config.maxSize, chartObj, bound, scaleComponent);

      return [pick(minSize, _default[0]), pick(maxSize, _default[1])];
    }

    function _defaultPercent$1(chartObj, scaleComponent) {
      if (_isMatrix$1(chartObj)) {
        return ['25%', '100%'];
      }

      if (chartObj.systemConf.legend.singleLayout && scaleComponent.encode === 'z') {
        return ['2.5%', '25%'];
      }

      return ['2%', '20%'];
    }

    function _isMatrix$1(chartObj) {
      var chartType = chartObj.chartTypes[0].value;
      return isHeatMapChartType(chartType);
    }

    //
    var
    sizeScale = /*#__PURE__*/function (_Scale) {_inherits(sizeScale, _Scale);var _super18 = _createSuper(sizeScale);function sizeScale() {_classCallCheck(this, sizeScale);return _super18.apply(this, arguments);}_createClass(sizeScale, [{ key: "init", value:
        function init() {
          _get(_getPrototypeOf(sizeScale.prototype), "init", this).call(this);

          this.d3_scale.clamp = true;

          // default base
          var config = this.getConfig(),
            baseValue = config.base,
            chartObj = this.chartObj,
            _domain = this.schema.domain,
            ranges = _domain.ranges,
            schema = this.schema;

          if (ranges && ranges._dummy) {
            _domain.ranges = null;
          }

          if (this.schema.data.dataType === NUMERIC_DATATYPE) {
            if (!chartObj.isGeoMap) {
              this.schema.domain.base = baseValue !== UNDEFINED ? baseValue : 0;
            }

            //Remove---
            if (chartObj.systemConf.legend.singleLayout) {
              schema.data.source = function () {return chartObj.dataObject.getMinMaxZ();};
              schema.data.condition = null;
              schema.domain.key = [0, 1];
            }
            //---Remove
          }

          var key = schema.domain.key,
            nullAsOptions = { config: config, columnKey: chartObj.dataset.getColumnIdx('z') },
            _keyFunction = function _keyFunction(_key) {
              return function (d) {
                var val = d[_key];
                val = convertNull(val, nullAsOptions);
                return val;
              };
            };
          schema.domain.key = isArray$1(key) ? key.map(_keyFunction) : _keyFunction(key);
        } }, { key: "create", value:

        function create() {
          var scale = _get(_getPrototypeOf(sizeScale.prototype), "create", this).call(this),
            config = this.config,schema = this.schema,
            encode = 'z',
            view = _legendType(encode, { config: config, dataType: schema.data.dataType }),
            newRanges = generateRanges(config, schema, scale, view);

          if (newRanges) {
            config.ranges = newRanges;
            schema.domain.ranges = newRanges;
            scale = _get(_getPrototypeOf(sizeScale.prototype), "create", this).call(this);
          }

          return this.scale = scale;
        } }, { key: "parseRange", value:

        function parseRange(customMax) {
          var chartObj = this.chartObj,
            dim = _getDimension(chartObj),
            config = this.getConfig(),
            bound = getLegendBound(config, chartObj.chartarea, customMax);

          var options = { dim: dim, bound: bound, correction: sizeCorrection };
          return sizeRange.call(this, options);
        } }]);return sizeScale;}(Scale);


    function _getDimension(chartObj) {
      if (_isMatrix$2(chartObj)) {
        return 1;
      }

      var plotarea = chartObj.plotarea;
      return mathMin(plotarea.width, plotarea.height);
    }

    function _isMatrix$2(chartObj) {
      var chartType = chartObj.chartTypes[0].value;
      return isHeatMapChartType(chartType);
    }
    Registry.setComponent('sizeScale', sizeScale);

    defaultTheme.bullet = function (userProp) {
      return {
        strictBandWidth: true,
        outerPadding: 0.00000001,
        levelMarker: {
          enabled: true,
          dataindex: 2,
          color: [],
          colorGamma: [0.3, 0.9],
          fillOpacity: 0.9,
          maxBandWidth: 200
        },
        targetMarker: {
          enabled: true,
          dataindex: 3,
          symbol: 'line',
          innerFillColor: 'transparent',
          innerStrokeColor: 'transparent',
          innerStrokeWidth: 0,
          innerStrokeOpacity: 0,
          outerFillColor: 'rgba(0, 0, 0, 0.6)',
          outerStrokeOpacity: 1,
          outerStrokeWidth: 5,
          outerStrokeColor: 'rgba(0, 0, 0, 0.6)',
          label: {
            fontSize: userProp.datalabels.fontSize.l5
          }
        },
        animation: {
          type: 'verticalAll'
        },
        datalabels: {
          textOverlap: 'none',
          showAs: 'y', //x,y,percent
          stackLabels: {
            show: false,
            showAs: 'y' //y,percent
          }
        },
        gradients: {
          // linear || none
          options: {
            linear: {
              y2: 50
            }
          }
        },
        stacked: {
          enabled: true
        }
      };
    };

    function _targetmarkerMark(data, phase, condition) {
      var KEY = 'targetMarker';

      var options = this.builderC[KEY];

      var _targetmarkerG = {
        mark: 'g',
        selector: ".targetMarkerSeries",
        data: data.disabled || !condition ? [] : [data.data],
        children: []
      };
      if (condition) {
        var _targetmarkerMark_outer = getBaseMark4BarMarker.call(this, KEY, null, options, null, 'outer'),
          _targetmarkerMark_inner = getBaseMark4BarMarker.call(this, KEY, null, options, null, 'inner');
        _targetmarkerG.children.push(_targetmarkerMark_outer);
        _targetmarkerG.children.push(_targetmarkerMark_inner);
      }

      return _targetmarkerG;
    }

    MarksRegistry.add('bullet.targetmarker', _targetmarkerMark);

    defaultTheme.dial = function (userProp) {
      var defaultDialOptions = {
        startAngle: -mathPI / 2,
        endAngle: mathPI / 2,
        innerRadius: '65%',
        maxRadius: 500,
        outerPadding: 20,
        padding: 0,
        interPadding: 10,
        strokeColor: 'rgba(0,0,0,0.1)',
        mode: 'radial',
        animation: {
          type: 'fanAll' //fanAll
        },
        needle: {
          show: true,
          type: 'round', //clock || round || sharp
          strokeColor: 'black',
          fillColor: 'grey',
          width: 15,
          padding: 15
        },
        minmaxlabels: {
          show: true,
          fontSize: userProp.datalabels.fontSize.l5
        },
        datalabels: {
          show: true,
          showAs: 'y', //x,y,percent
          padding: 2
        },
        levelMarker: {
          enabled: true,
          strokeColor: 'rgba(0,0,0,0.1)',
          // "color" : ["#d1d1d1"],
          innerPadding: 0,
          outerPadding: 0,
          colorGamma: [0.3, 0.9]
        },
        targetMarker: {
          outerStrokeWidth: 3,
          symbol: 'line',
          innerFillOpacity: 0,
          innerStrokeOpacity: 0,
          outerFillColor: 'grey',
          outerStrokeColor: '#000'
        },
        gradients: {
          // radial || linear || none
          options: {
            linear: {
              x2: 2,
              y2: 2,
              spreadMethod: 'repeat', // pad || repeat || reflect
              gradientUnits: 'userSpaceOnUse' //objectBoundingBox || userSpaceOnUse
            },
            radial: {
              radius: 16.5,
              spreadMethod: 'reflect' // pad || repeat || reflect
            }
          }
        },
        events: {
          enabled: false
        }
      };
      return defaultDialOptions;
    };

    //$Id$

    dialUtils.handleEvents = function (chartObj, element, options, type, data) {
      var currentPoint = data[0].data[0][0],
        isLevelMarker = type === 'levelmarker',
        levelMarkerInstance = chartObj.renderer[0].levelMarker,
        levelMarkerLength = levelMarkerInstance && levelMarkerInstance.values.length,
        commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions.dial,
        tooltipEnabled = chartObj.systemConf.tooltip.enabled,
        events_dial = options.events || {},
        metaInfo,
        formatConf,
        datatype;

      var isEventEnabled = validateNullVal(events_dial.enabled, commonPlotOptions.events.enabled);
      var cursor = isEventEnabled ? events_dial.cursor || POINTER : null;

      element.style('cursor', cursor);

      if (isEventEnabled) {
        var dataset = chartObj.dataset,
          columns = chartObj.userdata.metadata.columns,
          totalData = data[0].data[0].length,
          columnidx = columns.filter(function (d) {
            return d.dataindex === options.dataindex;
          }),
          targetColumn = columnidx.length ? columnidx[0] : columns[dataset.getColumnIdx('y', 0)],
          defaultMouseOverFunc = function defaultMouseOverFunc(d, i) {
            var val = isLevelMarker ? d[1] : d[options.dataindex],
              userCallback = createUserObject(d),
              position = getTooltipPosition(
              d3_event(),
              {
                x: 0,
                y: 0
              },
              0,
              0,
              chartObj,
              {
                seriesIndex: 0,
                subseriesIndex: 0,
                itemIndex: i
              });


            if (d._color) {
              position.helpers.color = d._color;
            }

            if (tooltipEnabled) {
              var tooltipContent =
              invokeFunction(events_dial.tooltipContent, userCallback, chartObj) ||
              (isLevelMarker ? 'Range: ' : 'Target: ') + userCallback.formattedValue;
              var tooltip = chartObj.eventHandler.tooltipElement;
              tooltip.show(chartObj, getTooltipPositionForNonAxisCharts(), tooltipContent, false, position.helpers);
            }
          },
          defaultMouseOutFunc = function defaultMouseOutFunc() {
            if (tooltipEnabled) {
              var tooltip = chartObj.eventHandler.tooltipElement;
              tooltip.hide(tooltip.element);
            }
          };
        datatype = targetColumn.datatype;
        formatConf = targetColumn[datatype];

        var mousemove = function mousemove(d, i) {
            var tooltip = chartObj.eventHandler.tooltipElement;
            if (tooltip && tooltip.timeout) {
              clearTimeout(tooltip.timeout); // To avoid flickering on  mouse move, clearing the timeout that makes the tooltip's display prop to none
            }

            if (chartObj.stopPropogate !== false) {
              d3_event().stopPropagation();
            }

            var eventType = chartObj.zcEventType || 'mousemove';
            handleUserCallback(currentPoint, eventType, d3_event(), d);
            defaultMouseOverFunc(d, i);
          },
          mouseout = function mouseout(d, i) {
            var eventType = chartObj.zcEventType || 'mouseout';
            handleUserCallback(currentPoint, eventType, d3_event(), d);
            defaultMouseOutFunc();
          },
          click = function click(d, i) {
            var isTouchEvent = d3_event() && d3_event().touches,
              eventType = chartObj.zcEventType || 'click',
              itemPos = totalData + i + 1 + (type === 'targetmarker' ? levelMarkerLength : 0);

            handleUserCallback(currentPoint, eventType, d3_event(), d);
            if (isTouchEvent && eventType !== 'taphold') {
              docTapFunction(chartObj);
              var clickedTime = new Date().getTime(),
                clickArguments = [chartObj.renderer[0], d, 0, itemPos];

              var tapOldInfo = chartObj.eventHandler.tapOldInfo;
              if (!tapOldInfo || tapOldInfo.itemPos != itemPos) {
                defaultMouseOverFunc(d, i);
                chartObj.eventHandler.tapOldInfo = {
                  seriesPos: 0,
                  subseriesindex: 0,
                  itemPos: itemPos,
                  type: type
                };
              } else {
                defaultMouseOutFunc();
                chartObj.eventHandler.tapOldInfo = null;
              }
            }
          },
          dblclick = function dblclick(d, i) {
            var eventType = chartObj.zcEventType || 'doubleclick';
            handleUserCallback(currentPoint, eventType, d3_event(), d);
          },
          eventAttacherOptions = {
            target: 'plot',
            touchleave: true,
            chartObj: chartObj
          };
        var mouseHandlers = {
            mousemove: mousemove,
            mouseout: mouseout,
            click: click,
            dblclick: dblclick
          },
          touchHandlers = {
            singletouchmove: mousemove,
            touchend: mouseout,
            tap: click,
            dbltap: dblclick
          };
        attachevents(element, mouseHandlers, touchHandlers, eventAttacherOptions);
      }

      function getTooltipPositionForNonAxisCharts() {
        var mouse = getMousePosition(chartObj.svg.node(), d3_event());
        var relmousePt = {
          x: mouse[0],
          y: mouse[1]
        };
        var tooltipPos = {
          left: relmousePt.x,
          top: relmousePt.y
        };
        var evt = getEventObject(d3_event());
        var dLeft = relmousePt.x - evt.clientX,
          dTop = relmousePt.y - evt.clientY;
        tooltipPos.left -= dLeft;
        tooltipPos.top -= dTop;
        tooltipPos.dLeft = dLeft;
        tooltipPos.dTop = dTop;
        return tooltipPos;
      }

      function handleUserCallback(data, type, event, d) {
        return invokeFunction(events_dial[type], event, createUserObject(d), chartObj);
      }

      function createUserObject(d) {
        var val = isLevelMarker ? d[1] : d[options.dataindex];
        return {
          value: val,
          formattedValue: getFormattedValue(formatConf, val, datatype, chartObj),
          actualData: currentPoint,
          data: metaInfo = metaInfo || chartObj.dataset.getMetaInfoObj(chartObj, currentPoint, 0)
        };
      }
    };

    //$Id$

    dialUtils.targetMarker = function (container, OR, innerRadius, chartObj, data, handleEvent, labelContainer) {var options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
      var systemconf = chartObj.systemConf,
        commonPlotOptions = systemconf.chart.plot.plotoptions.dial,
        dataset = chartObj.dataset,
        index = 0,
        paneid = options.paneid,bound = options.bound;

      var yscale = chartObj.axes.y.groups[0].scale,
        minMax = yscale.domain(),
        targetData = data[0].data[0];
      var targetMarkerOptions = commonPlotOptions.targetMarker;
      var align = targetMarkerOptions.align,
        dAlign = targetMarkerOptions.dAlign,
        padding = +(targetMarkerOptions.padding || 0),
        symbol_rotation = /line/.test(targetMarkerOptions.symbol) ? 90 : 0; //For line symbol, the symbol should be rotated by 90 degree

      var default_size = !/(outer|inner)/g.test(align) && /line/.test(targetMarkerOptions.symbol) ? (OR - innerRadius - 2 * padding) / 10 : 1;
      var size = validateNullVal(targetMarkerOptions.size, default_size) * 10;
      var extraOptions = {
        symbolSize: {
          outer: 1,
          inner: 0.5
        },
        color: chartObj.seriesColor[0],
        strokeWidth: default_size
      };
      var dr =
      dAlign === OUTER_ALIGN // dr - shift along radius
      ? size / 2 + padding :
      dAlign === INNER_ALIGN ?
      -(size / 2) - padding :
      0;
      var r =
      align === OUTER_ALIGN // radius
      ? OR + dr :
      align === INNER_ALIGN ?
      innerRadius + dr :
      (OR + innerRadius) / 2;

      var targetMarker = appendEle(container, 'g', targetMarkerOptions.enabled ? targetData : [], '.', 'class', 'targetmarker'),
        targetMarkerEventHandler = appendEle(
        container,
        'g',
        targetMarkerOptions.enabled && handleEvent ? targetData : [],
        '.',
        'class',
        'targetmarker-eventhandler');


      targetMarker.
      attr('transform', getPosition).
      styles({
        display: getDisplay,
        'stroke-dasharray': getDashArray(targetMarkerOptions.dashStyle, validateNullVal(targetMarkerOptions.outerStrokeWidth, 1)),
        'stroke-linecap': getLineCap(targetMarkerOptions.lineCap, targetMarkerOptions.dashStyle)
      }).
      each(function () {
        var ele = d3_select(this);
        addSVGmarker(ele, null, targetMarkerOptions, extraOptions, chartObj);
      });

      // add event listeners for dial target marker
      drawEventHandler(targetMarkerEventHandler);
      dialUtils.handleEvents(chartObj, targetMarkerEventHandler, targetMarkerOptions, 'targetmarker', data);

      var targetLabelOptions = targetMarkerOptions.label || {};
      var targetLabelPadding = validateNullVal(targetLabelOptions.padding, 2);
      var targetLabelRadius =
      align === OUTER_ALIGN ?
      r + size / 2 + targetLabelPadding :
      align === INNER_ALIGN ?
      (dAlign === OUTER_ALIGN ? innerRadius : r - size / 2) - targetLabelPadding :
      OR + targetLabelPadding;

      if (!labelContainer) {
        var labelHolder = chartObj.staticPaneSVG.selectAll('g.labelholder'),
          g = createElement('g', '.targetSeries', [1], labelHolder),
          plotarea_approx = chartObj.plotarea_approx;

        if (isFacet(chartObj)) {
          labelContainer = createElement('g', '.target_grid' + paneid, [1], g);
          labelContainer.attr('transform', "translate(".concat(bound.x + plotarea_approx.x || 0, ",").concat(bound.y + plotarea_approx.y || 0, ")"));
        } else {
          labelContainer = createElement('g', '.target_0', [1], g);
          labelContainer.attr('transform', "translate(".concat(plotarea_approx.x || 0, ",").concat(plotarea_approx.y || 0, ")"));
        }
      }

      var targetLabel = appendEle(
      labelContainer,
      'text',
      targetMarkerOptions.enabled && pick(targetLabelOptions.enabled, true) && !chartObj.renderer[0].firedList.targetSeries ?
      targetData :
      []);

      applyFont(targetLabel, [targetLabelOptions, systemconf.chart, systemconf.canvas, $ZCG]);

      targetLabel.each(function (d) {
        var ele = d3_select(this);
        ele.style('display', NONE);

        var targetValue = d[targetMarkerOptions.dataindex];
        if (defined(targetValue)) {
          targetValue = dialUtils.getValueWithinRange(targetValue, minMax);
          if (!(!JSON.parse(commonPlotOptions.minmaxlabels.show) || minMax.indexOf(targetValue) == -1) || isDisabled(d)) {
            return;
          }
          var angle = yscale(targetValue);
          var angle_radian = d0_360(angle);
          var xy = polarToXY(targetLabelRadius, angle);

          var columns = chartObj.userdata.metadata.columns;
          var columnidx = columns.filter(function (d) {
            return d.dataindex === targetMarkerOptions.dataindex;
          });
          var targetColumn = columnidx.length ? columnidx[0] : columns[dataset.getColumnIdx('y', 0)];
          var datatype = targetColumn.datatype;
          var formatConf = targetColumn[datatype];

          var TEXTANCHOR =
            angle_radian === 0 ?
            'middle' :
            align === INNER_ALIGN ?
            angle_radian < 0 || angle_radian > mathPI ?
            null :
            'end' :
            angle_radian < 0 || angle_radian > mathPI ?
            'end' :
            null,
            DY =
            align === INNER_ALIGN ?
            !(angle_radian > mathPI / 2 && angle_radian < 3 * mathPI / 2) ? "".concat(
            -getDY(angle_radian), "em") :
            null :
            angle_radian > mathPI / 2 && angle_radian < 3 * mathPI / 2 ? "".concat(
            getDY(angle_radian), "em") :
            null,
            TEXT = defined(targetLabelOptions.text) ?
            dataset.getCustomizedVal(chartObj, targetLabelOptions.text, index, null, null, d, 'targetLabel') :
            getFormattedValue(formatConf, targetValue, datatype, chartObj, 'targetLabel');

          ele.text(TEXT).
          style('display', null).
          attrs({
            'text-anchor': TEXTANCHOR,
            dy: DY,
            transform: "translate(".concat(xy[0], ",").concat(xy[1], ")")
          });
        }
      });

      var labelNodes = targetLabel.
        filter(function () {
          return d3_select(this).style('display') !== NONE;
        }).
        nodes().
        reverse(),
        eleBounds = getLabelBounds(labelNodes),
        overlappingHandler = function overlappingHandler(ele, i) {
          d3_select(ele).style('display', NONE);
          eleBounds[i] = { x1: 0, y1: 0, x2: 0, y2: 0 };
        };
      handleOverlap$1(labelNodes, eleBounds, overlappingHandler);

      function getPosition(d) {
        var targetValue = d[targetMarkerOptions.dataindex];
        if (defined(targetValue)) {
          targetValue = dialUtils.getValueWithinRange(targetValue, minMax);
          var angle_radian = yscale(targetValue),
            xy = polarToXY(r, angle_radian),
            angle_degree = radianToDegree(angle_radian) + symbol_rotation;
          return "translate(".concat(xy[0], ",").concat(xy[1], ") rotate(").concat(angle_degree, ",0,0)");
        }
      }

      function getDisplay(d) {
        var targetValue = d[targetMarkerOptions.dataindex];
        return !defined(targetValue) || isDisabled(d) ? NONE : null;
      }

      function isDisabled(d) {
        return d.disabled;
      }

      function drawEventHandler(element) {
        var triggerOffset = targetMarkerOptions.events && targetMarkerOptions.events.triggerOffset || 0;
        extraOptions.strokeWidth = (size + triggerOffset * 2) / 10;

        element.
        attrs({
          transform: getPosition,
          id: function id(d, i) {return "ZCtargetmarker_eventhandler_".concat(i);}
        }).
        styles({
          display: getDisplay,
          opacity: 0
        }).
        each(function () {
          var ele = d3_select(this);
          addSVGmarker(ele, null, targetMarkerOptions, extraOptions, chartObj);
          if (targetMarkerOptions.symbol === 'line') {
            var w = size >= OR - innerRadius ? size : mathMax(size + triggerOffset, OR - innerRadius),
              h = triggerOffset || 1; // If triggerOffset = 0, use height as 1 (As stroke properties are not considered if height is 0)
            ele.selectAll('*').attr('d', getSVGsymbol('rect')(w, h));
          }
        });
      }
    };

    //$Id$
    /**
     *
     * @returns {chart} dial chart renderer.
     */
    /*
     * PENDING:-
     * If target label is overlapping with minmax label
     * Pre render target
     */
    svg_plot_renderer.dial = function () {
      var commonRendererProp,
        chartObj,
        innerRadius,
        color,
        isredraw = false,
        commonPlotOptions,
        dataset,
        yaxiscolumnorder,
        totalEngagement,
        plotarea_approx,
        systemconf,
        yscale,
        oldData,
        minMax,
        hasNegValue,
        previousRadiusFactors,
        previousOuterRadius,
        previousInnerRadius,
        currentRadiusFactors,
        arc,
        _data;
      var pie = svg_plot_renderer.pie(),
        valueAccessor = function valueAccessor(d) {return dataset.getY(d, yaxiscolumnorder);};

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params,
            bound = rp.bound;
          chartObj = rp.chartObj,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          dataset = rp.dataset,
          yaxiscolumnorder = rp.yaxiscolumnorder;
          systemconf = chartObj.systemConf;
          _data = data[0].data[0];

          var plotoptions = data[0].plotoptions,
            serData = data[0],
            dataCount = _data.length,
            paneid = isFacet(chartObj) ? "".concat(serData.row, "_").concat(serData.column) : null;
          totalEngagement = valueAccessor(_data);
          hasNegValue = totalEngagement < 0;
          var defsLocation = chartObj.defsLocation;
          var labelQueue = rp.labelQueue,
            rendererIndex = rp.rendererIndex,
            seriesIndex = 0;

          yscale = rp.yscale || chartObj.axes.y.groups[0].scale;
          minMax = yscale.domain();
          plotarea_approx = bound.polar;

          commonPlotOptions = plotoptions ? mergeJSON$1(commonPlotOptions, plotoptions, true) : commonPlotOptions;
          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, DIAL_CHARTNAME);
          var isAnimationEnable = animationOptions.enabled,
            easingType = animationOptions.easingType,
            transitionDuration = isredraw ? isAnimationEnable ? 200 : 0 : animationOptions.duration,
            _generatedData = createDataForPie(data);

          var container = d3_select(this).data(_generatedData);
          oldData = container.selectAll("".concat(PATH_ELEMENT, ".dial")).data();

          var levelMarkerConf = commonPlotOptions.levelMarker;
          currentRadiusFactors = "".concat(commonPlotOptions.innerRadius, " _ ").concat(commonPlotOptions.outerPadding, " _ ").concat(commonPlotOptions.maxRadius, " _ ").concat(commonPlotOptions.bandWidth, " _ ").concat(levelMarkerConf.bandWidth, " _ ").concat(levelMarkerConf.innerPadding, " _ ").concat(levelMarkerConf.outerPadding);
          var OR = plotarea_approx.radius,
            levelmarkerSW = validateNullVal(levelMarkerConf.strokeWidth, 1),
            visibility,
            cornerRadius = pick(levelMarkerConf.cornerRadius, commonPlotOptions.cornerRadius),
            padAngle = pick(levelMarkerConf.padAngle, commonPlotOptions.padAngle);

          var _commonPlotOptions2 = commonPlotOptions,_commonPlotOptions2$m = _commonPlotOptions2.mode,mode = _commonPlotOptions2$m === void 0 ? 'radial' : _commonPlotOptions2$m;
          var IR = getInnerRadius(commonPlotOptions, OR);
          arc = d3_arc().
          endAngle(function (d) {
            return yscale(d[1]);
          }).
          cornerRadius(cornerRadius).
          padAngle(padAngle);

          var levelsInfo = chart.levelMarker = dialUtils.createLevelsNColors(
            data,
            levelMarkerConf,
            getColorByIndex(chartObj, seriesIndex, paneid),
            minMax),

            levelmarkerClr = levelsInfo.colors;

          if (mode === 'radial') {
            var innerPadding, outerPadding;

            if (defined(levelMarkerConf.bandWidth) || defined(levelMarkerConf.maxBandWidth)) {
              var maxLevelMarkerBandWidth = validateNullVal(levelMarkerConf.maxBandWidth, OR);
              var levelMarkerBandWidth = Math.min(perToPx(levelMarkerConf.bandWidth, OR, OR - IR), maxLevelMarkerBandWidth);

              innerPadding = (OR - IR - levelMarkerBandWidth) / 2, outerPadding = (OR - IR - levelMarkerBandWidth) / 2;

              visibility = levelMarkerBandWidth === 0 ? 'hidden' : null;
            } else {
              innerPadding = mathMax(0, perToPx(levelMarkerConf.innerPadding, OR, 0)),
              outerPadding = mathMax(0, perToPx(levelMarkerConf.outerPadding, OR, 0));
            }

            arc.innerRadius(IR + innerPadding).
            outerRadius(OR - outerPadding - 0.5 * levelmarkerSW).
            startAngle(function (d) {
              return yscale(d[0]);
            });
          } else {
            var activeDataCount = _data.reduce(function (prev, cur) {return prev + (cur.disabled ? 0 : 1);}, 0),
              interPadding = perToPx(commonPlotOptions.interPadding, OR, 10),
              band = (OR - IR - (activeDataCount - 1) * interPadding) / activeDataCount,
              _index = -1;

            levelsInfo.values.forEach(function (d, i) {
              if (!_data[i].disabled) {
                _index++;
              }
              d.innerRadius = _index * (band + interPadding) + IR;
              d.outerRadius = (_index + 1) * band + _index * interPadding + IR;
            });

            arc.startAngle(commonPlotOptions.startAngle);
            visibility = function visibility(d, i) {return _data[i].disabled ? 'hidden' : null;};
          }

          var levelmarkerSeries = appendEle(container, 'g', [1], '.', 'class', 'levelmarkerSeries');
          var levelmarker = appendEle(levelmarkerSeries, PATH_ELEMENT, levelMarkerConf.enabled ? levelsInfo.values : []);
          levelmarker.
          attr('class', function (d, i) {
            return "ZClevelmarker_".concat(i);
          }).
          attr('transform', "translate(".concat(plotarea_approx.x, ",").concat(plotarea_approx.y, ")")).
          styles({
            stroke: function stroke(d, i) {
              return levelMarkerConf.strokeColor || levelmarkerClr[i];
            },
            'stroke-width': levelmarkerSW,
            'stroke-opacity': levelMarkerConf.strokeOpacity,
            'fill-opacity': levelMarkerConf.fillOpacity,
            fill: function fill(d, i) {
              var clr = levelmarkerClr[i];
              var prop = getGradientProp(commonPlotOptions.gradients, [OR, OR], clr);
              var gradientID = prop ?
              effects.get(effects.svg_gradients, 'svgGradientFill', prop, { offset: 'pie', chartObj: chartObj }) :
              null;
              return gradientID ? "url(".concat(defsLocation, "#").concat(gradientID, ")") : clr;
            },
            visibility: visibility
          });

          if (isredraw && currentRadiusFactors != previousRadiusFactors) {
            levelmarker.
            transition().
            duration(transitionDuration).
            ease(d3_ease_linear).
            call(function (element) {
              arcInnerTween(element, arc, [previousInnerRadius, arc.innerRadius()()], [previousOuterRadius, arc.outerRadius()()]);
            });
          } else {
            levelmarker.attr('d', arc);
          }

          // add event listeners for dial level marker
          dialUtils.handleEvents(chartObj, levelmarker, levelMarkerConf, 'levelmarker', data);

          if (dataCount > 1 && mode === 'radial') {
            container.selectAll('g.piegroup path').sort(function (a, b) {return a.index - b.index;});
          }

          commonRendererProp.commonPlotOptions(commonPlotOptions);
          pie.commonRendererProp(commonRendererProp);
          pie.chartRendered = false;
          container.call(pie);

          if (dataCount > 1 && mode === 'radial') {
            container.selectAll('g.piegroup path').sort(function (a, b) {return d3_descending(valueAccessor(a.data), valueAccessor(b.data));});
          }

          innerRadius = pie.innerRadius();

          // Target marker---
          var targetMarkerSeries = appendEle(container, 'g', [1], '.', 'class', 'targetSeries');
          dialUtils.targetMarker(
          targetMarkerSeries,
          plotarea_approx.actualRadius,
          plotarea_approx.innerRadius,
          chartObj,
          data,
          true,
          undefined,
          { paneid: paneid, bound: bound });

          targetMarkerSeries.attr('transform', "translate(".concat(plotarea_approx.x, ",").concat(plotarea_approx.y, ")"));
          // ---Target marker

          var needleOptions = commonPlotOptions.needle,
            needleData = _generatedData[0][0].data[0],
            needleFillColor = needleOptions.fillColor,needleStrokeColor = needleOptions.strokeColor;

          var dialPath = appendEle(container, PATH_ELEMENT, needleOptions.show ? needleData : [], '.', 'class', 'dial');
          dialPath.
          attr('d', dialUtils.getNeedlePolygon(needleOptions, plotarea_approx, innerRadius)).
          styles({
            stroke: needleStrokeColor === null ? function (d, i) {return getColorByIndex(chartObj, i, paneid);} : needleStrokeColor || 'black',
            fill: needleFillColor === null ? function (d, i) {return getColorByIndex(chartObj, i, paneid);} : needleFillColor || NONE,
            'stroke-width': needleOptions.strokeWidth,
            visibility: function visibility(d) {return isDisabled(d) ? 'hidden' : null;}
          }).
          transition().
          duration(transitionDuration).
          ease(easingType).
          call(dialTween);

          if (labelRenderer) {
            labelQueue.push({
              renderer: chart,
              charttype: DIAL_CHARTNAME,
              chartObj: chartObj,
              args: [data, 0],
              rendererIndex: rendererIndex,
              paneid: pick(paneid, 0)
            });
          }
        });
        return chart;
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.endFunctions = function () {
        previousRadiusFactors = currentRadiusFactors;
        previousOuterRadius = arc.outerRadius()(_data[0]);
        previousInnerRadius = arc.innerRadius()(_data[0]);
        chart.chartRendered = true;
        isredraw = true;
      };

      chart.defaultMouseOutFunc = function () {
        if (chartObj.systemConf.tooltip.enabled) {
          var tooltip = chartObj.eventHandler.tooltipElement;
          tooltip.hide(tooltip.element);
        }
      };

      function createDataForPie(data) {
        if (isFacet(chartObj)) {
          var dt = data[0].data[0];
          data[0].data[0] = [dt[0]];
        }

        return [data];
      }

      function isDisabled(d) {
        return d.disabled;
      }

      function dialTween(element) {
        var cx = plotarea_approx.x,
          cy = plotarea_approx.y,
          baseValue = commonPlotOptions.baseValue !== undefined ? commonPlotOptions.baseValue : 0,
          currentValue,
          previousValue,
          currentAngle,
          previousAngle;

        element.attrTween('transform', function (d, i) {
          if (isredraw) {
            previousAngle = getSvgTransform(this).rotate;
          } else {
            previousValue = hasNegValue ? minMax[1] : minMax[0];
            if (baseValue != null) {
              previousValue = hasNegValue ? mathMin(baseValue, previousValue) : mathMax(baseValue, previousValue);
            }
            previousAngle = radianToDegree(yscale(previousValue));
          }

          currentValue = mathMin(mathMax(valueAccessor(d), minMax[0]), minMax[1]); //currentValue should be in between min & max
          currentAngle = radianToDegree(yscale(currentValue));

          var interpolateAngle = d3_interpolate(previousAngle, currentAngle);
          return function (t) {
            return "translate(".concat(cx, ",").concat(cy, ") rotate(").concat(interpolateAngle(t), ",0,0)");
          };
        });
      }

      return chart;
    };

    defaultTheme.funnel = function () {
      return {
        weighted: 'height', //height | width | none
        split: false,
        canOverlap: true,
        threeDimension: true,
        outerPadding: '2%',
        stemHeight: '20%',
        stemWidth: '20%',
        coneWidth: '100%',
        strokeColor: 'transparent',
        emptyFunnel: {
          show: false,
          color: '#FAFAFA'
        },
        datalabels: {
          showAs: 'x', //x,y,percent
          type: 'strokeddoubleside', // singleside || doubleside || strokeddoubleside
          padding: 30,
          line: {
            strokeColor: 'grey',
            strokeWidth: 0.3
          },
          innerLabel: {
            show: false,
            showAs: 'percent' //x,y,percent
          }
        },
        gradients: {
          // linear || none
          options: {
            linear: {
              x2: 50,
              spreadMethod: 'reflect', // pad || repeat || reflect
              colorGamma: [0.6, 0]
            }
          }
        },
        animation: {
          type: 'vertical' //horizontalAll, verticalAll, vertical
        }
      };
    };

    //$Id$

    var annotation$3 = Registry.getComponent('annotation');
    /**
     *
     * @returns {chart} funnel renderer.
     */
    svg_plot_renderer.funnel = function () {
      var MAXWIDTH_DATALABELS = 0.3;
      var cfg = {};
      var commonRendererProp,
        chartObj,
        data_processed,
        noofNonZeroDatas,
        coneHeigth,
        noOfGaps,
        stemHeight,
        stemWidth,
        xAxisWidth,
        dataset,
        percentage = 0.375,
        chartWidth,
        totalEngagement,
        trapezoid,
        chartHeight,
        color,
        funnelsections,
        ellipseSections;
      var threeDimension,
        arcHeight,
        arcHeight1,
        padding,
        minPadding,
        maxPadding,
        minArcHeight = 1,
        isredraw = false,
        arcCorrection = 0,
        container,
        ellipse,
        funnel,
        label,
        labelLinkgroup,
        rightXscale,
        leftXscale,
        yaxiscolumnorder;
      var plotoptions,
        commonPlotOptions,
        systemconf,
        notesArray,
        datalabelPadding,
        isSplit,
        outerPadding,
        gradientDim,
        isPatternPalleteEnabled;
      var maxPer,
        isWeightedWidth,
        noWeighted,
        defsLocation,
        rp,
        gElementsCollected,
        customPlotarea,
        fillColor = [],
        paneid;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          rp = commonRendererProp.params;
          chartObj = rp.chartObj,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          notesArray = rp.notesArray,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset;
          systemconf = chartObj.systemConf;
          var labelQueue = rp.labelQueue,_rp =
            rp,bound = _rp.bound,rendererIndex = _rp.rendererIndex,
            seriesData = isFacet(chartObj) && hasColorColumnInNonAxis(chartObj) ? data : data[0];
          paneid = isFacet(chartObj) ? "".concat(seriesData.row, "_").concat(seriesData.column) : null;

          defsLocation = chartObj.defsLocation;

          var plotarea = _objectSpread(_objectSpread({}, bound), customPlotarea);
          chartWidth = plotarea.width;
          chartHeight = plotarea.height;

          gElementsCollected = false;

          plotoptions = data[0].plotoptions;
          var gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions);
          isPatternPalleteEnabled = systemconf.legend.imagePallete || legend_helpers.hasPatternPallete(chartObj);
          cfg.canOverlap = gvp('canOverlap');
          isSplit = gvp('split');
          threeDimension = gvp('threeDimension');
          var emptyFunnelOptions = commonPlotOptions.emptyFunnel;
          datalabelPadding = commonPlotOptions.datalabels.padding;
          var showlabel = chartObj.datalabels.moduleExists && isDatalabelEnabled(commonPlotOptions.datalabels, chartObj);

          var strokeColor = getStrokeColor(chartObj, 0);

          minPadding = pick(commonPlotOptions.minPadding, threeDimension ? 4 : 1);
          maxPadding = pick(commonPlotOptions.maxPadding, 10);

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, FUNNEL_CHARTNAME);
          var animationType = animationOptions.type,
            easingType = animationOptions.easingType,
            isAnimationEnable = animationOptions.enabled,
            transitionDuration = animationOptions.duration,
            redrawDuration = isAnimationEnable ? 200 : 0;

          outerPadding = perToPx(gvp('outerPadding'), chartHeight, 0) / 2;
          stemHeight = gvp('stemHeight');
          stemWidth = gvp('stemWidth');
          isWeightedWidth = gvp('weighted') === 'width', noWeighted = gvp('weighted') === NONE;

          if (isWeightedWidth) {
            stemHeight = stemWidth = 0;
            isSplit = true;
          }

          data_processed = data = hasColorColumnInNonAxis(chartObj) ? data : data[0].data[0];
          noofNonZeroDatas = data_processed.reduce(function (prev, cur, i) {
            return prev + (dataset.getY(cur, yaxiscolumnorder) && !cur.disabled ? 1 : 0);
          }, 0);
          noOfGaps = noofNonZeroDatas - 1;
          var preArcHeight = preCalArcHeight();
          cfg.height = chartHeight - 2 * preArcHeight - chartHeight * 0.01 - 2 * outerPadding;

          var coneWidth = gvp('coneWidth');
          coneWidth = perToPx(coneWidth, cfg.height, cfg.height * 0.95);
          cfg.width = mathMin(chartWidth, coneWidth);

          padding = getFunnelPadding(cfg.height);
          cfg.gapHeight = !isAnimationEnable || isSplit || isredraw ? padding : animationType == HORIZONTALALL_ANIMATION ? padding : 0;

          if ((isWeightedWidth || noWeighted) && defined(commonPlotOptions.maxSliceHeight)) {
            /*
             * Set max height for each trapezoid if isWeightedWidth or noWeighted
             */
            cfg.height -= mathMax(
            0,
            cfg.height - padding * noOfGaps - perToPx(commonPlotOptions.maxSliceHeight, cfg.height) * noofNonZeroDatas);

          }
          if (showlabel) {
            /*
             *If chart width is lesser than height, datalabels are hidden as default padding is 30 and there is no space to show datalabels.
             * So 30% of the width is allocated for datalabels and the default padding will be changed to 5
             */
            var minDatalabelsWidth = chartWidth * MAXWIDTH_DATALABELS,
              availableDatalabelsWidth = chartWidth - cfg.width;
            if (availableDatalabelsWidth < minDatalabelsWidth) {
              datalabelPadding = cfg.datalabelPadding = 5;
              cfg.width -= mathMax(minDatalabelsWidth - availableDatalabelsWidth, 0);
            }
          }
          stemHeight = perToPx(stemHeight, cfg.height, cfg.height * 0.2);
          xAxisWidth = stemWidth = perToPx(stemWidth, cfg.width, stemHeight * cfg.width / cfg.height) / 2;
          coneHeigth = cfg.height - stemHeight;
          arcHeight = cfg.height * 0.05;

          arcHeight = mathMax(minArcHeight, (arcHeight - data_processed.length) / data_processed.length);
          arcHeight1 = arcHeight = !threeDimension ? 0 : cfg.canOverlap ? arcHeight + maxPadding / 2 : padding / 2 - arcCorrection;
          chart.total = totalEngagement = data_processed.reduce(function (prev, cur, i) {
            return prev + (data_processed[i].disabled ? 0 : mathAbs(dataset.getY(data_processed[i], yaxiscolumnorder) || 0));
          }, 0);
          maxPer = mathMax.apply(
          null,
          data_processed.map(function (d, i) {
            return data_processed[i].disabled ? 0 : mathAbs(dataset.getY(data_processed[i], yaxiscolumnorder)) / totalEngagement;
          }));

          leftXscale = d3_scaleLinear().
          domain(isWeightedWidth ? [0, maxPer] : [stemHeight, cfg.height]).
          range([cfg.width / 2 - stemWidth, 0]);
          rightXscale = d3_scaleLinear().
          domain(isWeightedWidth ? [0, maxPer] : [stemHeight, cfg.height]).
          range([cfg.width / 2 + stemWidth, cfg.width]);
          trapezoid = funnelLayout(data_processed);
          gradientDim = [cfg.width, cfg.height];
          chart.fillColorFunc = getFillColor(chartObj, 0, null, gradientDim);

          if (isFacet(chartObj)) {
            data_processed.forEach(function (d, i) {
              fillColor[i] = getFillColor(chartObj, i, paneid, gradientDim);
            });
          } else {
            fillColor[0] = chart.fillColorFunc;
          }

          var eventDisabled = validateNullVal(getEventConf(plotoptions, commonPlotOptions, chartObj, 'enabled'), true) == false;
          var cursor = eventDisabled ? null : getEventConf(plotoptions, commonPlotOptions, chartObj, 'cursor') || POINTER;

          var transX = perToPx(invokeFunction(gvp('x'), chartObj, cfg), chartWidth, chartWidth / 2 - cfg.width / 2),
            transY = perToPx(invokeFunction(gvp('y'), chartObj, cfg), chartHeight, arcHeight + 2 + outerPadding);

          chartObj.plotarea.centerX = transX, chartObj.plotarea.centerY = transY;

          var containerArea = d3_select(this);
          container = appendEle(containerArea, 'g', [data], '.', 'class', 'funnelgroup');
          container.attr('transform', "translate(".concat(transX, ",").concat(transY, ")")).styles({
            cursor: cursor,
            'stroke-opacity': gvp('strokeOpacity'),
            'stroke-width': gvp('strokeWidth')
          });
          ellipse = appendEle(container, 'g', [1], '.', 'class', 'ellipsegroup');
          funnel = appendEle(container, 'g', [1], '.', 'class', 'trapezoidgroup');

          funnelsections = appendEle(funnel, PATH_ELEMENT, data_processed);
          changeSelectionOrder(funnelsections);

          funnelsections.
          attrs({
            "class": 'zc_funnel',
            id: function id(d, i) {return "funnel".concat(i);}
          }).
          styles({
            'fill-opacity': commonPlotOptions.fillOpacity,
            fill: function fill(d, i) {
              if (isFacet(chartObj)) {
                return fillColor[i](i, d);
              }

              return fillColor[0](i, d);
            },
            stroke: function stroke(d, i) {
              if (isFacet(chartObj)) {
                return getStrokeColor(chartObj, i, paneid)(i, d, commonPlotOptions.strokeColor);
              }

              return strokeColor(i, d, commonPlotOptions.strokeColor);
            }
          });

          ellipseSections = appendEle(ellipse, PATH_ELEMENT, threeDimension ? data_processed : []);
          changeSelectionOrder(ellipseSections);

          ellipseSections.
          attrs({
            "class": 'zc_funnel',
            id: function id(d, i) {return "ellipse".concat(i);}
          }).
          styles({
            'fill-opacity': commonPlotOptions.fillOpacity,
            fill: function fill(d, i) {
              if (isFacet(chartObj)) {
                return fillColor[i](i, d, 0.5);
              }

              return fillColor[0](i, d, 0.5);
            },
            stroke: function stroke(d, i) {
              if (isFacet(chartObj)) {
                return getStrokeColor(chartObj, i, paneid)(i, d, commonPlotOptions.strokeColor, 0.5);
              }

              return strokeColor(i, d, commonPlotOptions.strokeColor, 0.5);
            }
          });

          setPivotAttributes(funnelsections, chartObj);
          setPivotAttributes(ellipseSections, chartObj);

          setOpacityForTickFilterElements(funnelsections, chartObj, 'funnel');
          setOpacityForTickFilterElements(ellipseSections, chartObj, 'funnel');

          setPointerEvents(chartObj, funnelsections, eventDisabled, paneid);
          setPointerEvents(chartObj, ellipseSections, eventDisabled, paneid);
          if (!chartObj.cache.search) {
            chartObj.cache.search = {};
          }
          if (!eventDisabled) {
            var mousemove = function mousemove(d, i) {
                var args = getEventArgs(d, i);
                chartObj.eventHandler.handlers.mousemove.call(chartObj.eventHandler, args);
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = paneid;
              },
              mouseout = function mouseout(d, i) {
                var args = getEventArgs(d, i);
                chartObj.eventHandler.handlers.mouseout.call(chartObj.eventHandler, args, i);
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = null;
              },
              click = function click(d, i) {
                var args = getEventArgs(d, i);
                chartObj.eventHandler.handlers.click.call(chartObj.eventHandler, args, d, 0, i, chart);
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = paneid;
              },
              dblclick = function dblclick(d, i) {
                var dt = !annotation$3._empty ? generateDataForAnnotation(d, null) : d;
                var coordinates = trapezoid[data.length - 1 - i].bottomLeft;
                coordinates = [coordinates[0] + (chartWidth / 2 - cfg.width / 2), coordinates[1] + (arcHeight + 2 + outerPadding)];
                var args = getEventArgs(d, i);
                args.coordinate = coordinates;
                args.basedOn = 'plot';
                args.data = dt;
                chartObj.eventHandler.handlers.doubleclick.call(chartObj.eventHandler, args, i, d);
                updateSelectionOnDatapoint(d, args);
                chartObj.cache.search.lastPane = paneid;
              },
              eventAttacherOptions = {
                target: 'plot',
                touchleave: true,
                chartObj: chartObj
              };
            var mouseHandlers = {
                mousemove: mousemove,
                mouseout: mouseout,
                click: click,
                dblclick: dblclick
              },
              touchHandlers = {
                singletouchmove: mousemove,
                touchend: mouseout,
                tap: click,
                dbltap: dblclick
              };
            attachevents(funnelsections, mouseHandlers, touchHandlers, eventAttacherOptions);
            attachevents(ellipseSections, mouseHandlers, touchHandlers, eventAttacherOptions);
          }

          var A = cfg.canOverlap ? 2 * stemWidth / cfg.width * arcHeight : arcHeight + arcCorrection;
          var funnelOutline =
          "M0,0L".concat(cfg.width / 2 - stemWidth, ",").concat(coneHeigth, "L").concat(cfg.width / 2 - stemWidth, ",").concat(
          cfg.height, "A").concat(
          stemWidth, ",").concat(A, ",0,0,0,").concat(cfg.width / 2 + stemWidth, ",").concat(cfg.height, "L").concat(cfg.width / 2 + stemWidth, ",").concat(coneHeigth, "L").concat(
          cfg.width, ",0A").concat(
          cfg.width / 2, ",").concat(arcHeight, ",0,0,0,0,0") + "A".concat(cfg.width / 2, ",").concat(arcHeight, ",0,0,0,").concat(cfg.width, ",0");
          var eFunnel = appendEle(
          container,
          PATH_ELEMENT,
          !isredraw && emptyFunnelOptions.show && isAnimationEnable ? [1] : [],
          '#',
          'id',
          'emptyFunnel');

          eFunnel.attr('d', funnelOutline).styles({
            stroke: emptyFunnelOptions.color || 'grey',
            fill: NONE
          });
          if (!(chartObj.systemConf.chart.plot.morph.enabled && chartObj.oldSeriesInfo != undefined)) {
            addFunnelClipPath(funnelOutline);
          }
          if (!isredraw) {
            hideDisabledElements(data, 0);
            var prev = 0,
              funneldrawn = 0;

            var index = 0;
            if (chartObj.systemConf.chart.plot.morph.enabled && chartObj.oldSeriesInfo != undefined) {
              var morph_Obj = new zcMorph({ sampling: chartObj.systemConf.chart.plot.morph.samplingDistance });
              var oldseriesData = chartObj.oldSeriesInfo.get(index);
              var oldseriesIndex = oldseriesData.seriesIndex;
              var oldseriesColor = oldseriesData.color;
              var offsetValue = getOffsetValue(chartObj, oldseriesIndex);
              var morphDuration = chartObj.systemConf.chart.plot.morph.duration;
              var individualElementTransform = oldseriesData.transformationInfo;
              var line = d3_line();
              var interpolated = {};

              funnelsections.each(function (d, i) {
                var fromPath = chartObj.oldSeriesInfo.get(oldseriesIndex).pathData[i];
                var fromPathAttribute = fromPath.getAttribute('d');
                fromPath.setAttribute('d', drawTrapezoid(trapezoid[data_processed.length - 1 - i]));
                var toPath = fromPath.cloneNode();
                fromPath.setAttribute('d', fromPathAttribute);
                interpolated[i] = morph_Obj.interpolate(
                {
                  path: fromPath,
                  xOffset: offsetValue.x + individualElementTransform[i].x,
                  yOffset: offsetValue.y + individualElementTransform[i].y
                },
                { path: toPath, xOffset: 0, yOffset: 0 });

              });
              funnelsections.
              style('fill', function (d, i) {
                return oldseriesColor[i];
              }).
              transition().
              duration(function () {
                return morphDuration;
              }).
              ease(easingType).
              style('fill', function (d, i) {
                return getRawColor(chartObj, i, d.data, oldseriesIndex, null);
              }).
              attrTween('d', function (d, i) {
                var interpolator = interpolated[i];
                return function (t) {
                  return line(
                  interpolator.map(function (p) {
                    return p(t);
                  }));

                };
              }).
              on('end', function (d, i) {
                if (chartObj.oldSeriesInfo) {
                  delete chartObj.oldSeriesInfo;
                }
                d3_select(this).style('fill', function () {
                  return (isFacet(chartObj) ? fillColor[i] : fillColor[0])(i, d, null);
                });
                funneldrawn++;
                this.setAttribute('d', drawTrapezoid(trapezoid[data_processed.length - 1 - i]));
              });
            } else {
              funnelsections.
              transition().
              duration(function (d, i) {
                var yVal = dataset.getY(d, yaxiscolumnorder);
                return animationType == VERTICAL_ANIMATION ?
                d.disabled || !yVal ?
                0 :
                isWeightedWidth || noWeighted ?
                transitionDuration / noofNonZeroDatas :
                mathAbs(yVal) / totalEngagement * transitionDuration :
                transitionDuration;
              }).
              delay(function (d, i) {
                var yVal = dataset.getY(d, yaxiscolumnorder);
                prev +=
                d.disabled || !yVal ?
                0 :
                isWeightedWidth || noWeighted ?
                transitionDuration / noofNonZeroDatas :
                mathAbs(yVal);
                var del =
                animationType == VERTICAL_ANIMATION ?
                isWeightedWidth || noWeighted ?
                transitionDuration - prev :
                (totalEngagement - prev) / totalEngagement * transitionDuration :
                0;
                return del || 0;
              }).
              ease(easingType).
              attrTween('d', function (d, i) {
                return tweenAll(d, data_processed.length - 1 - i, 'funnel', animationType);
              }).
              on('end', function (d, i) {
                funneldrawn++;
              });
              prev = 0;
              ellipseSections.
              transition().
              duration(function (d, i) {
                var yVal = dataset.getY(d, yaxiscolumnorder);
                return animationType == VERTICAL_ANIMATION ?
                d.disabled || !yVal ?
                0 :
                isWeightedWidth || noWeighted ?
                transitionDuration / noofNonZeroDatas :
                mathAbs(yVal) / totalEngagement * transitionDuration :
                transitionDuration;
              }).
              delay(function (d, i) {
                var yVal = dataset.getY(d, yaxiscolumnorder);
                prev +=
                d.disabled || !yVal ?
                0 :
                isWeightedWidth || noWeighted ?
                transitionDuration / noofNonZeroDatas :
                mathAbs(yVal);
                var del =
                animationType == VERTICAL_ANIMATION ?
                isWeightedWidth || noWeighted ?
                transitionDuration - prev :
                (totalEngagement - prev) / totalEngagement * transitionDuration :
                0;
                return del || 0;
              }).
              ease(easingType).
              attrTween('d', function (d, i) {
                return tweenAll(d, data_processed.length - 1 - i, 'ellipse', animationType);
              });
            }
            var includeGap = setInterval(function () {
              if (funneldrawn == data_processed.length) {
                if (animationType != HORIZONTALALL_ANIMATION) {
                  cfg.gapHeight = padding;
                  trapezoid = funnelLayout(data_processed);
                  funnelsections.
                  transition().
                  duration(isAnimationEnable ? 250 : 0).
                  delay(50).
                  ease(d3_ease_linear).
                  attr('d', function (d, i) {
                    return drawTrapezoid(trapezoid[data_processed.length - 1 - i]);
                  });
                  ellipseSections.
                  transition().
                  duration(isAnimationEnable ? 250 : 0).
                  delay(50).
                  ease(d3_ease_linear).
                  attr('d', function (d, i) {
                    return drawEllipse(trapezoid[data_processed.length - 1 - i]);
                  });
                }
                lableManagent();
                container.
                selectAll("".concat(PATH_ELEMENT, "#emptyFunnel")).
                transition().
                duration(50).
                delay(310).
                style('stroke-opacity', 0).
                remove();
                clearInterval(includeGap);
              }
            }, 10);
          } else {
            funnelsections.
            transition().
            duration(redrawDuration).
            ease(d3_ease_linear).
            attr('d', function (d, i) {
              return drawTrapezoid(trapezoid[data_processed.length - 1 - i]);
            });
            ellipseSections.
            transition().
            duration(redrawDuration).
            ease(d3_ease_linear).
            attr('d', function (d, i) {
              return drawEllipse(trapezoid[data_processed.length - 1 - i]);
            });
            hideDisabledElements(data, redrawDuration);
            lableManagent();
          }

          function lableManagent() {
            chart.renderedTimer = setTimeout(
            function () {
              var labelPosition = calculatePointsForLabelPlacement(data_processed, trapezoid);
              if (labelRenderer) {
                var translation = hasColorColumnInNonAxis(chartObj) ?
                [transX + plotarea.translate[0], transY + plotarea.translate[1]] :
                [transX, transY];

                var args = [
                chartObj.seriesdata,
                0,
                data_processed,
                noofNonZeroDatas,
                arcHeight + 2 + outerPadding,
                totalEngagement,
                cfg,
                labelPosition,
                chart.subSeriesIndex || 0,
                translation];

                labelQueue.push({
                  renderer: chart,
                  charttype: FUNNEL_CHARTNAME,
                  chartObj: chartObj,
                  args: args,
                  rendererIndex: rendererIndex,
                  paneid: paneid
                });
                labelQueue.push({
                  renderer: chart,
                  charttype: 'funnelInnerLabels',
                  chartObj: chartObj,
                  args: args,
                  rendererIndex: rendererIndex,
                  paneid: pick(paneid, 0)
                });
              }

              //Annotation preprocessing
              if (!annotation$3._empty) {
                notesArray = annotation$3.preprocessAnnotations(
                chartObj.seriesdata,
                0,
                function (dt, k, j) {
                  return [
                  trapezoid[trapezoid.length - 1 - j].bottomLeft[0] + (chartWidth / 2 - cfg.width / 2),
                  trapezoid[trapezoid.length - 1 - j].bottomLeft[1] + (arcHeight + 2 + outerPadding)];

                },
                notesArray,
                chartObj,
                rp);

              }

              isredraw = true;
              chart.chartRendered = true;

              if (hasColorColumnInNonAxis(chartObj)) {
                chartObj.renderer[rendererIndex].endFunctions();
              }
            },
            !isAnimationEnable ? 0 : isredraw ? redrawDuration : 300);

            if (chartObj.timerObj) {
              chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer;
            }
          }

          function changeSelectionOrder(selection) {
            /*
             * Reverse the selection order. ISSUE: https://docs.zoho.com/viewcommentattachment/4807920000000048005?width=770&height=515&owner=42061464
             */
            selection._groups[0].reverse();
            selection.data(data_processed);
          }

          function getEventArgs(d, i) {
            var ev = getEventObject(d3_event());
            return {
              renderer: chart,
              seriesIndex: hasColorColumnInNonAxis(chartObj) ? i : 0,
              subSeriesIndex: 0,
              itemIndex: i,
              paneid: paneid,
              rendererIndex: rendererIndex,
              color: color[i % color.length],
              coordinates: [ev.pageX, ev.pageY],
              element: this,
              data: d,
              selected: d.selected,
              _key: "ZC_".concat(chartObj.id, "_0_0_").concat(i)
            };
          }
        });
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.plotarea = function (_) {
        //Bubble Pie chart will give you the plotarea
        if (!arguments.length) {
          return customPlotarea;
        }
        customPlotarea = _;
        return chart;
      };

      function funnelLayout(data) {
        var sumofvalues = 0,
          hgt = cfg.height,
          ht = 0,
          h = 0;
        trapezoid = [], xAxisWidth = stemWidth;
        data.forEach(function (value, index) {
          var d = data[data.length - 1 - index],
            yVal = dataset.getY(d, yaxiscolumnorder),
            disabled = d.disabled;
          h = !totalEngagement ?
          0 :
          (disabled ? 0 : isWeightedWidth || noWeighted ? yVal ? 1 / noofNonZeroDatas : 0 : mathAbs(yVal) / totalEngagement) * (
          cfg.height - (noofNonZeroDatas - 1) * cfg.gapHeight);
          h = h || 0;
          sumofvalues += disabled ? 0 : yVal;
          h = ht + h;
          var per = yVal / totalEngagement;
          per = per || 0;
          var points = {};
          if (sumofvalues == totalEngagement && (yVal == 0 || disabled)) {
            points.topLeft = points.bottomLeft = points.middleLeft = [leftXscale(isWeightedWidth ? maxPer : cfg.height), 0];
            points.topRight = points.bottomRight = points.middleRight = [rightXscale(isWeightedWidth ? maxPer : cfg.height), 0];
          } else {
            if (isWeightedWidth) {
              points.bottomLeft = [leftXscale(per), cfg.height - h];
              points.topLeft = [leftXscale(per), hgt];
              points.middleLeft = [leftXscale(per), cfg.height - h];
              points.bottomRight = [rightXscale(per), cfg.height - h];
              points.topRight = [rightXscale(per), hgt];
              points.middleRight = [rightXscale(per), cfg.height - h];
            } else {
              points.bottomLeft = [cfg.height - h >= coneHeigth ? cfg.width / 2 - stemWidth : leftXscale(h), cfg.height - h];
              points.topLeft = [hgt >= coneHeigth ? cfg.width / 2 - stemWidth : leftXscale(ht), hgt];
              points.middleLeft = [
              hgt >= coneHeigth ? cfg.width / 2 - stemWidth : points.bottomLeft[0],
              hgt >= coneHeigth && cfg.height - h <= coneHeigth ? coneHeigth : cfg.height - h];

              points.bottomRight = [cfg.height - h >= coneHeigth ? cfg.width / 2 + stemWidth : rightXscale(h), cfg.height - h];
              points.topRight = [hgt >= coneHeigth ? cfg.width / 2 + stemWidth : rightXscale(ht), hgt];
              points.middleRight = [
              hgt >= coneHeigth ? cfg.width / 2 + stemWidth : points.bottomRight[0],
              hgt >= coneHeigth && cfg.height - h <= coneHeigth ? coneHeigth : cfg.height - h];

            }
          }
          trapezoid.push(points);
          hgt = !yVal || disabled ? cfg.height - h : cfg.height - h - cfg.gapHeight;
          ht = !yVal || disabled ? h : h + cfg.gapHeight;
        });
        return trapezoid;
      }

      function calculatePointsForLabelPlacement(data, trapezoid) {
        var trape = [],
          ht = 0,
          h = 0,
          _x = function _x(_, isLeft) {
            if (isLeft) {
              return _ >= coneHeigth ? cfg.width / 2 - stemWidth : leftXscale(cfg.height - _);
            } else {
              return _ >= coneHeigth ? cfg.width / 2 + stemWidth : rightXscale(cfg.height - _);
            }
          };
        data.forEach(function (value, index) {
          var d = data[data.length - 1 - index],
            yVal = dataset.getY(d, yaxiscolumnorder),
            disabled = d.disabled,
            point = trapezoid[index];
          h =
          (disabled ? 0 : isWeightedWidth || noWeighted ? yVal ? 1 / noofNonZeroDatas : 0 : mathAbs(yVal) / totalEngagement) * (
          cfg.height - (noofNonZeroDatas - 1) * cfg.gapHeight) /
          2;
          h = h || 0;
          var half = h;
          h = ht + h;
          var per = yVal / totalEngagement;
          per = per || 0;
          var leftX = isWeightedWidth ? leftXscale(per) : cfg.height - h >= coneHeigth ? cfg.width / 2 - stemWidth : leftXscale(h);
          var rightX = isWeightedWidth ? rightXscale(per) : cfg.height - h >= coneHeigth ? cfg.width / 2 + stemWidth : rightXscale(h);
          trape.push({
            rightx: rightX + datalabelPadding,
            leftx: leftX - datalabelPadding,
            y: mathAbs(cfg.height - h),
            y0: mathAbs(cfg.height - h + half),
            polygon: [point.bottomRight, point.middleRight, point.topRight, point.topLeft, point.middleLeft, point.bottomLeft],
            _x: _x
          });

          h = h + half;
          ht = !yVal || disabled ? h : h + cfg.gapHeight;
        });
        return trape;
      }

      function addFunnelClipPath(emptyFunnelPath) {
        var clipID;
        if (isWeightedWidth) {
          clipID = null;
        } else {
          var properties = {
              name: 'FunnelClipPath',
              id: chartObj.id,
              d: emptyFunnelPath
            },
            args = {
              chartObj: chartObj
            };
          clipID = effects.get(effects.svg_clips, 'polygon', properties, args);
        }
        container.attr('clip-path', !clipID ? null : "url(".concat(defsLocation, "#").concat(clipID, ")"));
      }

      chart.defaultMouseOverFunc = function (d, seriesPos, itemPos) {
        if (!gElementsCollected) {
          collectGroups(commonRendererProp.params.rendererIndex);
        }
        //Reset previous pane mouseover
        // if(chartObj.dataObject.pivot){
        //     var allEllipseGroups = chartObj.wrap.selectAll('g.ellipsegroup'),
        //         allTrapezoidGroups = chartObj.wrap.selectAll('g.trapezoidgroup');
        //     if(isPatternPalleteEnabled){
        //         allTrapezoidGroups.selectAll('path').style('opacity', null);
        //         allEllipseGroups.style('opacity', null);
        //     }else{
        //         allTrapezoidGroups.selectAll('path').style('fill', (d,i)=>{
        //             return fillColor[i](i,d,null);
        //         });
        //         allEllipseGroups.selectAll('path').style('fill', (d,i)=>{
        //             return fillColor[i](i,d,0.5);
        //         });
        //     }
        //
        // }

        if (isPatternPalleteEnabled) {
          funnelsections.style('opacity', function (d, i) {
            return i === itemPos ? null : 0.4;
          });
          ellipseSections.style('opacity', function (d, i) {
            return i === itemPos ? null : 0.4;
          });
        } else {
          funnelsections.style('fill', function (d, i) {
            return (isFacet(chartObj) ? fillColor[i] : fillColor[0])(i, d, i === itemPos ? 0.6 : null);
          });
          ellipseSections.style('fill', function (d, i) {
            return (isFacet(chartObj) ? fillColor[i] : fillColor[0])(i, d, i === itemPos ? 1 : 0.5);
          });
        }

        var subSeriesIndex = chart.subSeriesIndex || 0;
        label.selectAll('text').style('text-shadow', null);
        labelLinkgroup.selectAll(PATH_ELEMENT).style('stroke-width', null);
        label.selectAll("#lbl0_".concat(subSeriesIndex, "_").concat(data_processed.length - 1 - itemPos)).style('text-shadow', '0 0 0 rgba(0,0,0,1)');
        labelLinkgroup.selectAll("#link0_".concat(subSeriesIndex, "_").concat(data_processed.length - 1 - itemPos)).style('stroke-width', 1);
      };

      chart.defaultMouseOutFunc = function (d, i) {
        if (!gElementsCollected) {
          collectGroups(commonRendererProp.params.rendererIndex);
        }

        if (isPatternPalleteEnabled) {
          funnelsections.style('opacity', null);
          ellipseSections.style('opacity', null);
        } else {
          funnelsections.style('fill', function (d, i) {
            return (isFacet(chartObj) ? fillColor[i] : fillColor[0])(i, d);
          });
          ellipseSections.style('fill', function (d, i) {
            return (isFacet(chartObj) ? fillColor[i] : fillColor[0])(i, d, 0.5);
          });
        }
        label.selectAll('text').style('text-shadow', null);
        labelLinkgroup.selectAll(PATH_ELEMENT).style('stroke-width', null);
      };

      function tweenAll(d, i, elementType, animationType) {
        var base = baseData(animationType, i),
          dt = trapezoid[i];
        var interpolate =
        elementType == 'funnel' ?
        d3_interpolate(drawTrapezoid(base), drawTrapezoid(dt)) :
        d3_interpolate(drawEllipse(base), drawEllipse(dt));
        return function (t) {
          return interpolate(t);
        };
      }

      function baseData(animationType, i) {
        var d = simpleClone(trapezoid[animationType == VERTICALALL_ANIMATION ? 0 : i]);
        if (animationType === HORIZONTALALL_ANIMATION) {
          d.topLeft[0] = d.middleLeft[0] = d.bottomLeft[0] = d.topRight[0] = d.middleRight[0] = d.bottomRight[0] = cfg.width / 2;
        } else {
          d.middleLeft = d.bottomLeft = d.topLeft;
          d.middleRight = d.bottomRight = d.topRight;
        }
        return d;
      }

      function hideDisabledElements(data, dur) {
        ellipseSections.each(function (d, i) {
          var hide = data[i].disabled || !dataset.getY(data_processed[i], yaxiscolumnorder);
          var t = hide ? dur : 0;
          if (t) {
            setTimeout(function () {
              hideSection(i, hide);
            }, t);
          } else {
            hideSection(i, hide);
          }
        });
      }

      function hideSection(i, hide) {
        var display = hide ? NONE : null;

        ellipse.selectAll("#ellipse".concat(i)).style('display', display);
        funnel.selectAll("#funnel".concat(i)).style('display', display);
      }

      function preCalArcHeight() {
        var h = chartHeight - 2 * outerPadding;
        var arcHeight = h * 0.05;
        var padding = getFunnelPadding(h);
        arcHeight = (arcHeight - data_processed.length) / data_processed.length;
        arcHeight = mathMax(minArcHeight, arcHeight);
        arcHeight = !threeDimension ? 0 : cfg.canOverlap ? arcHeight + maxPadding / 2 : padding / 2 - arcCorrection;
        return arcHeight;
      }

      function getFunnelPadding(h) {
        var userPadding = commonPlotOptions.padding;
        if (defined(userPadding)) {
          return invokeFunction(userPadding, h, noOfGaps, chartObj);
        }

        var maxPaddingHeight = h * percentage;
        return mathMin(maxPadding, mathMax(minPadding, maxPaddingHeight / noOfGaps));
      }

      function drawTrapezoid(d) {
        var topW = (d.topRight[0] - d.topLeft[0]) / 2,
          bottomW = (d.bottomRight[0] - d.bottomLeft[0]) / 2;
        var topCurve = cfg.canOverlap ? 2 * topW / cfg.width * arcHeight : arcHeight1,
          bottomCurve = cfg.canOverlap ? 2 * bottomW / cfg.width * arcHeight : arcHeight1;
        return "M".concat(d.topLeft[0], " ").concat(d.topLeft[1], " A").concat(topW, " ").concat(topCurve, " 0 0 0 ").concat(d.topRight[0], " ").concat(d.topRight[1], " L").concat(d.middleRight[0], " ").concat(d.middleRight[1], " L").concat(d.bottomRight[0], " ").concat(d.bottomRight[1], " A").concat(bottomW, " ").concat(bottomCurve, " 0 0 1 ").concat(d.bottomLeft[0], " ").concat(d.bottomLeft[1], " L").concat(d.middleLeft[0], " ").concat(d.middleLeft[1], "Z");
      }

      function drawEllipse(d) {
        var bottomW = (d.bottomRight[0] - d.bottomLeft[0]) / 2;
        var bottomCurve = cfg.canOverlap ? 2 * bottomW / cfg.width * arcHeight + arcCorrection : arcHeight1;
        return "M".concat(d.bottomLeft[0], " ").concat(d.bottomLeft[1], " A").concat(bottomW, " ").concat(bottomCurve, " 0 0 1 ").concat(d.bottomRight[0], " ").concat(
        d.bottomRight[1], " A").concat(
        bottomW, " ").concat(cfg.canOverlap ? bottomCurve : bottomCurve + arcCorrection, " 0 0 1 ").concat(d.bottomLeft[0], " ").concat(d.bottomLeft[1]);
      }

      function collectGroups() {var rendererIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var subSeriesIndex = chart.subSeriesIndex || 0,
          parentWrap = isFacet(chartObj) ? chartObj.staticPaneSVG.selectAll("g.grid".concat(paneid)) : chartObj.staticPaneSVG;

        labelLinkgroup = labelLinkgroup || parentWrap.selectAll("g.link_".concat(rendererIndex, " g.subseries_").concat(subSeriesIndex));
        label = label || parentWrap.selectAll("g.label_".concat(rendererIndex, " g.subseries_").concat(subSeriesIndex));
        gElementsCollected = true;
      }

      return chart;
    };

    defaultTheme.gantt = function () {
      return {
        outerPadding: 0.04,
        padding: 0,
        interPadding: 0.05,
        maxBandWidth: 200,
        levelMarker: {
          enabled: false,
          dataindex: 2,
          fillOpacity: 0.3,
          bandWidth: 4
        },
        hoveroptions: {
          enabled: false,
          start: {
            innerStrokeOpacity: 1,
            outerFillColor: 'white',
            outerStrokeWidth: 2
          },
          end: {
            innerStrokeOpacity: 1,
            outerFillColor: 'white',
            outerStrokeWidth: 2
          }
        },
        marker: {
          enabled: false,
          start: {
            size: 1,
            innerStrokeWidth: 0,
            outerStrokeWidth: 2
          },
          end: {
            size: 1,
            innerStrokeWidth: 0,
            outerStrokeWidth: 2
          }
        },
        border: {
          show: false,
          size: null,
          style: 'solid',
          radius: 0,
          color: null
        },
        stacked: {
          enabled: false,
          showAs: 'values' //values,percent
        },
        animation: {
          type: 'verticalAll'
        },
        datalabels: {
          showAs: 'y' //x,y,percent
        },
        gradients: {
          // linear || none
          options: {
            linear: {
              y2: 50
            }
          }
        },
        dependency: {
          enabled: false,
          targetIndex: 0,
          link: {
            type: 'ES',
            strokeWidth: 2,
            strokeColor: '#111111',
            errorStyle: 'red',
            padding: 20
          },
          marker: {
            enabled: true,
            padding: 10,
            size: 1.5,
            innerFillColor: 'transparent',
            innerStrokeWidth: 0,
            innerStrokeOpacity: 0,
            outerStrokeOpacity: 0,
            outerStrokeColor: 'red',
            outerFillColor: 'blue'
          }
        }
      };
    };

    //ganttUtils.js

    svg_plot_renderer.ganttHelpers = function () {};
    plot.render.ganttHelpers = function () {};
    svg_plot_renderer.ganttHelpers.showDependencies = function (renderer, data, series, index) {
      var rp = renderer.commonRendererProp().params,
        cp = renderer.commonOption,
        chartObj = rp.chartObj,
        plotarea = chartObj.plotarea,
        dataset = rp.dataset,
        axisrotated = rp.axisrotated,
        commonPlotOptions = rp.commonPlotOptions,
        yaxiscolumnorder = cp.yaxiscolumnorder,
        color = rp.color;

      var dependencyConfig = commonPlotOptions.dependency,
        showDependency = dependencyConfig.enabled === true;

      var dependencies = null;
      var dependenceSeriesNode = series.selectAll('g.dependencySeries').data(showDependency ? [data] : []);

      var dependenceSeries = dependenceSeriesNode.
      enter().
      insert('g', ':first-child').
      attr('class', 'dependencySeries').
      merge(dependenceSeriesNode);
      // dependenceSeries.attr('class', 'dependencySeries');
      dependenceSeries.exit().remove();
      if (showDependency && defined(dependencyConfig.sourceIndex) && defined(dependencyConfig.targetIndex)) {
        dependencies = getDependencies(data, +dependencyConfig.sourceIndex, +dependencyConfig.targetIndex);
      }
      if (dependencies) {
        var symbolConf = dependencyConfig.marker,
          linkConf = dependencyConfig.link,
          linkPadding = defined(linkConf.padding) ? linkConf.padding : 1,
          symbolPadding = defined(symbolConf.padding) ? symbolConf.padding : linkPadding;
        symbolPadding = mathMin(linkPadding, symbolPadding);
        // dependency links

        var linkGroup = appendEle(dependenceSeries, 'g', [1], '.', 'class', 'links');
        var arrowGroup = appendEle(dependenceSeries, 'g', [1], '.', 'class', 'symbol');

        // links
        var path = appendEle(linkGroup, 'path', dependencies, '.', 'class', 'link');
        path.attr('d', function (d, j) {
          var details = getDependencyDetails(d, dependencyConfig, renderer, index);
          return getDependencyPathString(details.type, details.end, details.start, linkPadding, symbolPadding, rp)(new Array(6));
        }).
        attr('stroke', function (d) {
          var startTime = dataset.getY(d.source, yaxiscolumnorder)[0];
          var endTime = dataset.getY(d.target, yaxiscolumnorder)[1];
          var error = startTime < endTime;
          return error ? linkConf.errorStyle : linkConf.strokeColor;
        }).
        attr('stroke-width', linkConf.strokeWidth).
        attr('fill', 'none');

        // symble

        var markerEnabled = dependencyConfig.marker.enabled === true;
        var arrows = appendEle(arrowGroup, 'g', markerEnabled ? dependencies : [], '.', 'class', 'arrow');

        if (dependencyConfig.marker.enabled) {
          arrows.each(function (d, j) {
            var symbolType = symbolConf.symbol,
              temp;
            var mSize = {
              inner: 0.4,
              outer: 0.7
            };
            var self = d3_select(this);
            self.attr('transform', function (d) {
              var details = getDependencyDetails(d, dependencyConfig, renderer, index),
                x,
                y;
              var type = details.type;
              if (type == 'SS' || type == 'ES') {
                x = axisrotated ? details.start.x - symbolPadding : details.start.x + details.start.width / 2;
                y = axisrotated ?
                details.start.y + details.start.height / 2 :
                details.start.y + details.start.height + symbolPadding;
                temp = axisrotated ? 'triangle-right' : 'triangle-up';
              } else if (type == 'EE' || type == 'SE') {
                x = axisrotated ? details.start.x + details.start.width + symbolPadding : details.start.x + details.start.width / 2;
                y = axisrotated ? details.start.y + details.start.height / 2 : details.start.y - symbolPadding;
                temp = axisrotated ? 'triangle-left' : 'triangle-down';
              }
              return "translate(".concat(x, ",").concat(y, ")");
            });
            addSVGmarker(
            self,
            null,
            symbolConf,
            {
              symbolSize: mSize,
              color: null,
              symbol: temp
            },
            chartObj);

          });
        }
      }
    };

    function getDependencyDetails(d, dependencyConfig, renderer, i) {
      return {
        start: getPos(d.source, renderer, i),
        end: getPos(d.target, renderer, i),
        type: dependencyConfig.link.type.toUpperCase() || 'ES'
      };
    }

    function getDependencyPathString(type, startPosition, endPosition, padding, markerPadding, rp) {
      type = type.toUpperCase();

      var chartObj = rp.chartObj,
        axisrotated = rp.axisrotated,
        xAxisReverseed = chartObj.systemConf.chart.axes.xaxis.reversed,
        x = null,
        y = null,
        pos = null,
        crucialCurve = isCrucialCurve(type, axisrotated, startPosition, endPosition, padding);

      return d3_line().
      x(function (d, j) {
        switch (j) {
          case 0:
          case 1:
          case 2:{
              pos = startPosition;
              if (j == 0) {
                if (type == 'SS' || type == 'SE') {
                  x = axisrotated ? pos.x : pos.x + pos.width / 2;
                } else if (type == 'EE' || type == 'ES') {
                  x = axisrotated ? pos.x + pos.width : pos.x + pos.width / 2;
                }
              } else if (j == 1) {
                if (type == 'SS' || type == 'SE') {
                  x = axisrotated ? pos.x - padding : x;
                } else if (type == 'EE' || type == 'ES') {
                  x = axisrotated ? pos.x + pos.width + padding : x;
                }
              } else {
                var dist;
                if (type == 'SS') {
                  dist = startPosition.x - endPosition.x;
                  dist = dist < 0 ? 0 : dist;
                  x = axisrotated ? pos.x - dist - padding : x;
                } else if (type == 'EE') {
                  dist = startPosition.x + startPosition.width - (endPosition.x + endPosition.width);
                  dist = dist > 0 ? 0 : dist;
                  x = axisrotated ? pos.x + pos.width + padding - dist : x;
                } else if (type == 'SE') {
                  if (axisrotated) {
                    x = pos.x - padding;
                    y = crucialCurve ? pos.y + pos.height : endPosition.y;
                  } else {
                    x = xAxisReverseed ? x - pos.width : x + pos.width;
                  }
                } else if (type == 'ES') {
                  if (axisrotated) {
                    x = pos.x + padding + pos.width;
                    y = crucialCurve ? pos.y + pos.height : endPosition.y;
                  } else {
                    x = xAxisReverseed ? x - pos.width : x + pos.width;
                  }
                }
              }
              break;
            }
          default:{
              if (axisrotated) {
                y = null;
              }
              pos = endPosition;
              if (j == 3) {
                if (axisrotated && crucialCurve) {
                  y = startPosition.y + startPosition.height;
                }
                if (type == 'SS' || type == 'EE') {
                  x = axisrotated ? x : pos.x + pos.width / 2;
                } else if (type == 'SE') {
                  x = axisrotated ? pos.x + pos.width + padding : x;
                } else if (type == 'ES') {
                  x = axisrotated ? pos.x - padding : x;
                }
              } else if (j == 4) {
                if (type == 'SE') {
                  x = axisrotated ? pos.x + pos.width + padding : pos.x + pos.width / 2;
                } else if (type == 'ES') {
                  x = axisrotated ? x : pos.x + pos.width / 2;
                }
              } else {
                if (type == 'SS' || type == 'ES') {
                  x = axisrotated ? pos.x - markerPadding : x;
                } else if (type == 'EE' || type == 'SE') {
                  x = axisrotated ? pos.x + pos.width + markerPadding : x;
                }
              }
            }}

        return x;
      }).
      y(function (d, j) {
        if (axisrotated) {
          return (y || pos.y) + pos.height / 2;
        }

        if (j == 0) {
          if (type == 'SS' || type == 'SE') {
            y = startPosition.y + startPosition.height;
          } else if (type == 'EE' || type == 'ES') {
            y = startPosition.y;
          }
        } else if (j == 1) {
          if (type == 'SS' || type == 'SE') {
            y = y + padding;
          } else if (type == 'EE' || type == 'ES') {
            y = startPosition.y - padding;
          }
        } else if (j == 2) {
          if (type == 'SS') {
            y =
            startPosition.y + startPosition.height < endPosition.y + endPosition.height ?
            endPosition.y + endPosition.height + padding :
            y;
          } else if (type == 'EE') {
            y = startPosition.y > endPosition.y ? endPosition.y - padding : y;
          }
        } else if (j == 3) {
          if (type == 'SE') {
            y = crucialCurve ? endPosition.y - padding : y;
          } else if (type == 'ES') {
            y = crucialCurve ? endPosition.y + endPosition.height + padding : y;
          }
        } else if (j == 4) {
          y = y + 0;
        } else {
          if (type == 'SS' || type == 'ES') {
            y = endPosition.y + endPosition.height + markerPadding;
          } else if (type == 'EE' || type == 'SE') {
            y = endPosition.y - markerPadding;
          }
        }
        return y;
      }).
      curve(d3_curves('linear'));
    }

    function isCrucialCurve(type, axisrotated, start, end, linkPadding) {
      var direct = false;
      switch (type) {
        case 'SS':
        case 'EE':{
            direct = true;
            break;
          }
        case 'SE':{
            direct = axisrotated ? start.x > end.x + end.width : start.y + start.height < end.y;
            break;
          }
        case 'ES':{
            direct = axisrotated ? start.x + start.width < end.x - linkPadding * 2 : start.y > end.y + end.height;
          }}

      return !direct;
    }

    function getDependencies(source, dependencyIndex, searchIndex) {
      var allDependencies = [];
      source.forEach(function (dd) {
        var currentDependency = dd[dependencyIndex];
        source.forEach(function (data) {
          if (data !== dd && defined(currentDependency) && isArray$1(currentDependency)) {
            if (currentDependency.indexOf(data[searchIndex]) !== -1) {
              allDependencies.push({
                source: dd,
                target: data
              });
            }
          }
        });
      });
      if (allDependencies.length) {
        return allDependencies;
      }
    }

    function getPos(d, renderer, i) {
      var width,
        height,
        x,
        y,
        cp = renderer.commonOption;
      x = renderer.getParamValue('x', d, i, null, cp);
      y = renderer.getParamValue('y', d, i, null, cp);
      width = renderer.getParamValue('width', d, i, null, cp);
      height = renderer.getParamValue('height', d, i, null, cp);
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }

    svg_plot_renderer.ganttHelpers.addMarker = function (series, data, renderer, index, markerOption, multiColoring, id) {
      var rp = renderer.commonRendererProp().params,
        cp = renderer.commonOption,
        chartObj = rp.chartObj,
        plotarea = chartObj.plotarea,
        dataset = rp.dataset,
        axisrotated = rp.axisrotated,
        color = rp.color,
        levelMarkerWidth = cp.levelMarkerWidth,
        cType = cp.charttype,
        isBullet = cType == 'bullet',
        isGantt = cType == 'gantt',
        isWhiskerPlot = chartcategory.whiskerPlot.has(charttype[cType]),
        isWhisker = markerOption.symbol == 'whiskers' || markerOption.symbol == 'horizontal-whisker',
        isWhiskerOnEdges = isWhisker && rp.whiskers.showOn == 'edges',
        bandwidth = isBullet ? rp.xscale.bandwidth() : levelMarkerWidth,
        bandwidth1 = renderer.bandwidth1(),
        customMarkerSize = markerOption.size,
        iscustomMarkerSize = defined(customMarkerSize),
        size = iscustomMarkerSize ? customMarkerSize : levelMarkerWidth - 2 * validateNullVal(markerOption.padding, cp.padding / 2),
        target = appendEle(series, 'g', [data], '.', 'class', "markers".concat(id), null, function (d) {
          return [dataset.getX(d)];
        });

      if (iscustomMarkerSize && typeof size === 'string' && size.indexOf('%') > -1) {
        //if user gives size as percent, '75%'
        size = parseFloat(size) / 100 * bandwidth / 10;
      }

      // var markerWidth = ((markerOption.strokeWidth == null || markerOption.strokeWidth === "") ? 1 : JSON.parse(markerOption.strokeWidth));
      var markerWidth = pick(markerOption.strokeWidth, 1);

      // target.enter().append("g")
      // target.exit().remove();
      target.attrs({
        "class": "markers".concat(id),
        transform: "translate(".concat(plotarea.left, ",").concat(plotarea.top, ")"),
        'stroke-width': markerWidth,
        'stroke-dasharray': getDashArray(markerOption.dashStyle, validateNullVal(markerOption.outerStrokeWidth, 1)),
        'stroke-linecap': getLineCap(markerOption.lineCap, markerOption.dashStyle),
        fill: markerOption.color,
        stroke: markerOption.color
      });
      // isWithinColorRange(dataset.getClr(d), chartObj) ? dataset.getX(d) : null
      var marker = appendEle(target, 'g', data, null, null, null, null, function (d) {
        return dataset.getX(d);
      });
      marker.enter().append('g');
      var mSize =
      markerOption.symbol === 'line' ?
      {
        inner: 0,
        outer: 1
      } :
      {
        inner: 0.6,
        outer: 1
      };

      marker.each(function (d, j) {
        var m = d3_select(this);
        var clonedMarkerOptions;
        var clr = multiColoring ? chartObj.seriesColor[j % chartObj.seriesColor.length] : color;
        m.attrs({
          transform: function transform(d, k) {
            var x = 0,
              y = 0;
            if (isGantt) {
              var position = svg_plot_renderer.ganttHelpers.getMarkerPosition(d, index, k, renderer);
              if (id === 0) {
                x = position.x + position.width / 2;
                y = position.y - markerOption.size * 10 / 2;
              } else {
                x = position.x + position.width / 2;
                y = position.y + position.height + markerOption.size * 10 / 2;
              }
              return "translate(".concat(axisrotated ? y : x, ",").concat(axisrotated ? x : y, ")");
            } else {
              x = bandwidth1(dataset.getX(d)) + bandwidth / 2;
              x = isWhiskerPlot ? x + cp.bandwidth2(cp.barDatasetIndex) + cp.padding : x; //For boxplot median and whiskers need to add bandwidth2
              y = isWhisker ?
              isWhiskerOnEdges ?
              rp.yscale(d[markerOption.dataindex][id]) :
              (rp.yscale(d[markerOption.dataindex][0]) + rp.yscale(d[markerOption.dataindex][1])) / 2 :
              rp.yscale(d[markerOption.dataindex]);
              return d[markerOption.dataindex] == null ?
              null : "translate(".concat(
              axisrotated ? y : x, ",").concat(axisrotated ? x : y, ") rotate(").concat(axisrotated ? 90 : 0, ")");
            }
          }
        }).style('display', function (d) {
          return d[markerOption.dataindex] == null && isBullet ? 'none' : null;
        });

        markerOption.size = iscustomMarkerSize ? isBullet ? mathMin(size, bandwidth / 10) : size : size / 10;
        var customMarkers, wSize;
        if (isWhiskerPlot && isWhisker) {
          if (isWhiskerOnEdges) {
            wSize = whiskerSize(d, rp.yscale, markerOption.dataindex, dataset.yidx(cp.yaxiscolumnorder), id);
            wSize = axisrotated ? -wSize : wSize;
            customMarkers = {
              symbol: 'vertical-line-z',
              size: wSize
            };
          } else {
            wSize = whiskerSize(d, rp.yscale, null, null, null, markerOption.dataindex);
          }
        }
        if (!isWithinColorRange(dataset.getClr(d), chartObj)) {
          clonedMarkerOptions = _objectSpread({}, markerOption);
          clonedMarkerOptions.outerStrokeColor = 'transparent';
        }
        addSVGmarker(
        m,
        null,
        clonedMarkerOptions || markerOption,
        {
          symbolSize: mSize,
          color: isGantt ? clr : null,
          custom: customMarkers,
          size2d: wSize
        },
        chartObj);

      });
      markerOption.size = customMarkerSize; //reset with actual value

      if (isGantt) {
        renderer.markerProperties = {
          subseriesIndex: index
        };
      }
    };

    svg_plot_renderer.ganttHelpers.getMarkerPosition = function (d, i, j, renderer) {
      var width,
        height,
        x,
        y,
        cp = renderer.commonOption;
      x = renderer.getParamValue(cp.axisrotated ? 'y' : 'x', d, i, j, cp);
      y = renderer.getParamValue(cp.axisrotated ? 'x' : 'y', d, i, j, cp);
      width = renderer.getParamValue(cp.axisrotated ? 'height' : 'width', d, i, j, cp);
      height = renderer.getParamValue(cp.axisrotated ? 'width' : 'height', d, i, j, cp);
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    };

    var _ganttDependency = plot.render.ganttHelpers;

    function HeatmapHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    inherit(HeatmapHighlighter, BarHighlighter);

    var proto$j = HeatmapHighlighter.prototype;

    proto$j.data = function (point) {
      var rp = this.renderer.commonRendererProp().params;
      var chart = this.chart;
      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key];
        cache.rect = cache.rect || getHeatCellPosition(chart, point, rp.xscale, rp.yscale, rp.yaxiscolumnorder);
        point._x = cache.rect.x;
        point._y = cache.rect.y;
        point._width = cache.rect.width;
        point._height = cache.rect.height;
        cache._uid = point._uid = chart.dataset.getX(point);
        cache._visible = point._visible = isPointVisible(chart, point);
        return point;
      };
    };
    proto$j.options = function (point) {
      var chart = this.chart,
        renderer = this.renderer,
        rp = renderer.commonRendererProp().params,
        radius = rp.gvp('borderRadius'),
        color = getRawColor(
        this.chart,
        isMultiColoring(rp.commonPlotOptions, this.chart) ? point.itemIndex : point.seriesIndex,
        point,
        point.seriesIndex);

      return {
        radius: chart.dataObject.getTransRectValue('radius', null, null, null, renderer.commonOption, radius),
        color: color
      };
    };

    proto$j.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('bar').call(this, this.chart);
    };

    proto$j.path = function (point, model) {
      var rp = this.renderer.commonRendererProp().params,
        translate = model.translate.call(this),
        tx = translate[0],
        ty = translate[1],
        shape = rp.gvp('symbol'),
        symbolPath = shape && getSVGsymbol(shape),
        yaxisReversed = this.chart.systemConf.chart.axes.yaxis[point.yaxisOrder || 0].reversed,
        shape;

      if (symbolPath) {
        shape = symbolPath(mathMin(point._width, point._height));
        tx += point._x + point._width / 2;
        ty += point._y + point._height / 2;
      } else {
        shape = roundedRect(
        point._x,
        point._y,
        point._x + point._width,
        point._y + point._height,
        this.options(point).radius,
        NULL$1,
        this.chart.axes.rotated,
        true);

      }

      var context = model.context.call(this),
        pathContext = appendEle(context, 'path', [1], '.', 'class', "highlight".concat(point.seriesIndex).concat(point.subSeriesIndex));
      context.style('display', '');
      pathContext.
      style('display', '').
      attr('d', shape).
      attr('transform', "translate(".concat(tx, ",").concat(ty, ")"));
      return pathContext;
    };

    //$Id$

    canvas_plot_renderer.heatmap = function () {
      var commonRendererProp;

      function chart(context, seriesdata, effect, filterIndex) {
        var rp = commonRendererProp.params,
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          yscale = rp.yscale,
          index = rp.datasetIndex,
          commonPlotOptions = rp.commonPlotOptions,
          labelQueue = rp.labelQueue,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
          xCategories = xscale.domain(),
          yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
          symbolPath = commonPlotOptions.symbol && getSVGsymbol(commonPlotOptions.symbol),
          borderRadius = chartObj.dataObject.getTransRectValue('radius', null, null, null, null, commonPlotOptions.borderRadius),
          fillStyle = chart.fillColorFunc = getFillColor(chartObj, index),
          strokeColor = getStrokeColor(chartObj, index),
          hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj);

        seriesdata = chartObj.dataObject.categoryHierarchy ? seriesdata[index] : chartObj.seriesdata[index];

        var plotoptions = seriesdata.plotoptions,
          gvp = rp.gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions);
        if (!seriesdata.disabled) {
          chart.seriesdataAfterUpdate = [];
          seriesdata.data.forEach(function (data, i) {
            var dataUpdate = chartObj.dataObject.updateSeriesdatabyCategories(
            d3_values(data),
            xCategories,
            yCategories,
            yaxiscolumnorder);

            chart.seriesdataAfterUpdate[i] = dataUpdate;

            if (hasColorScale && defined(filterIndex)) {
              dataUpdate = legend_helpers.filterSelectionByColor(dataUpdate, true, filterIndex, chartObj);
            }

            dataUpdate.forEach(function (d, j) {
              var pos = getHeatCellPosition(chartObj, d, xscale, yscale, yaxiscolumnorder),
                x = pos.x,
                y = pos.y,
                w = pos.width,
                h = pos.height;

              var drawCell = function drawCell(context, fillStyle) {
                context.save();
                context.translate(x + w / 2, y + h / 2);
                context.beginPath();
                context.lineWidth = commonPlotOptions.strokeWidth;
                context.strokeStyle = strokeColor(index, d, commonPlotOptions.strokeColor, NULL$1, commonPlotOptions.strokeOpacity);
                context.fillStyle = fillStyle;

                if (symbolPath) {
                  var size = mathMin(w, h) / 2;
                  if (commonPlotOptions.symbol === 'circle') {
                    context.arc(0, 0, size, 0, mathPI * 2);
                  } else {
                    var path = symbolPath(size * 2);
                    canvasUtils.drawPath(context, path);
                  }
                } else {
                  canvasUtils.roundedRect(context, -w / 2, -h / 2, w, h, borderRadius);
                }
                context.fill();
                context.stroke();
                context.closePath();
                context.restore();
              };

              if (chartObj.imagePallete && isWithinColorRange(chartObj.dataset.getClr(d), chartObj)) {
                effects.canvas_patterns.imageFill(
                { x: x, y: y, context: context, name: getRawColor(chartObj, index, d, index) },
                drawCell);

              } else {
                var fillStyle = defined(effect) ?
                effect :
                chart.fillColorFunc(index, d, null, null, commonPlotOptions.fillOpacity, [w, h]);
                drawCell(context, fillStyle);
              }
            });
          });
        }

        if (labelRenderer) {
          labelQueue.push({
            renderer: chart,
            charttype: 'hierarchy',
            chartObj: chartObj,
            args: [seriesdata, index, null, null, null, seriesdata.disabled ? [] : d3_merge(chart.seriesdataAfterUpdate)]
          });
        }

        chart.chartRendered = true;
        return chart;
      }
      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          chart.highlighter = new HeatmapHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };
      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      return chart;
    };

    defaultTheme.heatmap = function () {
      return {
        strokeColor: 'white',
        animation: {},
        datalabels: {
          showAs: 'y'
        },
        gradients: {
          //linear | radial | none
          options: {
            linear: {
              y2: 100
            },
            radial: {
              radius: 100
            }
          }
        }
      };
    };

    //$Id$

    /**
     *
     * @returns {chart} heatmap renderer.
     */

    //hierarchy series name on the top like fusion chart
    svg_plot_renderer.heatmap = function () {
      var isredraw = false,
        commonRendererProp;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          var chartObj = rp.chartObj,
            xscale = rp.xscale,
            yscale = rp.yscale,
            index = rp.datasetIndex,
            commonPlotOptions = rp.commonPlotOptions,
            labelQueue = rp.labelQueue,
            yaxiscolumnorder = rp.yaxiscolumnorder;

          var currentdata = data[index];
          var currentseriesdata = currentdata.data;

          //plotoptions

          var plotoptions = currentdata.plotoptions,
            gvp = rp.gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions);

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, null, chartObj, HEATMAP_CHARTNAME);
          var isAnimationEnable = animationOptions.enabled,
            animationType = animationOptions.type,
            easingType = animationOptions.easingType,
            transitionDuration = isredraw ? isAnimationEnable ? 200 : 0 : animationOptions.duration,
            isRandomAnimation = animationType === SIZINGRANDOM_ANIMATION || animationType === FADERANDOM_ANIMATION,
            delay = isredraw ?
            0 :
            isRandomAnimation ?
            function () {
              return mathRandom() * (transitionDuration * 3 / 5);
            } :
            0,
            duration = isredraw ? transitionDuration : isRandomAnimation ? transitionDuration * 2 / 5 : transitionDuration;

          var fillColor = chart.fillColorFunc = getFillColor(chartObj, index),
            strokeColor = getStrokeColor(chartObj, index),
            borderRadius = chartObj.dataObject.getTransRectValue('radius', null, null, null, null, commonPlotOptions.borderRadius),
            shape = gvp('symbol'),
            symbolPath = shape && getSVGsymbol(shape),
            xCategories = xscale.domain(),
            yCategories = yscale.domain(),
            hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj);

          var container = d3_select(this);
          var series = appendEle(container, 'g', [1], '.', 'class', "heatmapseries_".concat(index));
          chart.seriesdataAfterUpdate = [];

          currentseriesdata.forEach(function (d, i) {
            var serData = chart.seriesdataAfterUpdate[i] = chartObj.dataObject.updateSeriesdatabyCategories(
            d3_values(d),
            xCategories,
            yCategories,
            yaxiscolumnorder);

            var subseries = appendEle(series, 'g', !hasColorScale && currentdata.disabled ? [] : [1], '.', 'class', "subseries_".concat(i));
            var path = appendEle(subseries, PATH_ELEMENT, serData);

            path.styles({
              fill: function fill(d, i) {
                var pos = getHeatCellPosition(chartObj, d, xscale, yscale, yaxiscolumnorder);
                return fillColor(index, d, null, null, null, [pos.width, pos.height]);
              },
              'fill-opacity': commonPlotOptions.fillOpacity,
              stroke: function stroke(d) {
                return strokeColor(index, d, commonPlotOptions.strokeColor);
              },
              'stroke-width': commonPlotOptions.strokeWidth,
              'stroke-opacity': commonPlotOptions.strokeOpacity
            }).
            attr('transform', function (d) {
              var pos = getHeatCellPosition(chartObj, d, xscale, yscale, yaxiscolumnorder);
              return "translate(".concat(pos.x + pos.width / 2, ",").concat(pos.y + pos.height / 2, ")");
            }).
            attr('d', function (d) {
              var pos = getHeatCellPosition(chartObj, d, xscale, yscale, yaxiscolumnorder);
              if (symbolPath) {
                return symbolPath(mathMin(pos.width, pos.height));
              } else {
                return roundedRect(-pos.width / 2, -pos.height / 2, pos.width, pos.height, borderRadius);
              }
            });

            //animation
            if (!isredraw) {
              cancelAnimation(path); //REFER: heatmap redraw- animation issue
              path.attr('opacity', 0) //#ZC892
              .transition().
              delay(delay).
              duration(duration).
              ease(easingType).
              on('start', function () {
                d3_select(this).attr('opacity', null); //#ZC892
              }).
              call(isRandomAnimation ? fadeTween : function () {}).
              call(
              animationType === SIZING_ANIMATION || animationType === SIZINGRANDOM_ANIMATION ?
              scaleTween :
              animationType === FADE_ANIMATION || animationType === FADERANDOM_ANIMATION ?
              fadeTween :
              flipTween);

            }
          });

          if (labelRenderer) {
            labelQueue.push({
              renderer: chart,
              charttype: 'hierarchy',
              chartObj: chartObj,
              args: [currentdata, index, null, null, null, d3_merge(chart.seriesdataAfterUpdate)]
            });
          }

          chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
            isredraw = true;
            chart.chartRendered = true;
          }, transitionDuration + 17);
        });
        return chart;
      }
      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          chart.highlighter = new HeatmapHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };
      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      return chart;
    };

    defaultTheme.map = function () {
      return {
        allAreas: true,
        renderingMode: window.rendererMode || 'svg',
        fillColor: '#dddddd',
        strokeColor: '#444',
        strokeWidth: 0.6,
        gradients: {
          options: {
            linear: {
              y2: 100
            },
            radial: {
              radius: 100,
              gradientUnits: 'objectBoundingBox'
            }
          }
        },
        globe: {
          strokeWidth: 1.5
        },
        labels: {
          strokeWidth: 1.5
        },
        extent: {
          top: 10,
          right: 10,
          bottom: 10,
          left: 10
        },
        layerName: 'source',
        useMeshOutline: true,
        textStrokeWidth: 2,
        animation: {
          enabled: true,
          type: 'fade',
          duration: 500,
          easingType: 'cubic'
        }
      };
    };

    //MapLayer.js

    /**
     *
     * @param {Object} layer
     * @param {{projection: function, geoPath: d3.geoPath}} util
     * @param {SVGGElement|CanvasRenderingContext2D} layerContainer
     * @param {styles} styles
     * @param {GeoMap} geoMap
     * @param {boolean} useMesh
     * @constructor
     */
    function MapLayer(layer, util, layerContainer, styles, geoMap, useMesh) {
      this.layer = layer;
      this.utils = util;
      this.layerContainer = layerContainer;
      this.styles = styles;
      this.geoMap = geoMap;
      this.useMesh = useMesh;
      this.initialize();
    }

    /**
     * add supported types
     */
    MapLayer.GEO_FORMATS = d3_set([
    'Point',
    'MultiPoint',
    'LineString',
    'MultiLineString',
    'Polygon',
    'MultiPolygon',
    'GeometryCollection',
    'Feature',
    'FeatureCollection',
    'Topology']);


    /**
     *
     * @return {*}
     */
    MapLayer.getMapFeatures = function (object) {
      if (object.type === 'FeatureCollection') {
        return object.features;
      } else {
        return splat(object);
      }
    };

    /**
     *
     * @param feature
     * @param property
     * @param checkForGradient
     * @returns {*}
     */
    MapLayer.prototype.getStyle = function (feature, property, checkForGradient) {
      var mapLayer = this,
        styles = mapLayer.styles || {},
        featureStyle = feature.styles || {},
        properties = feature.properties || {};

      var styleValue = pick(styles[property], featureStyle[property], properties[property], mapLayer.defaultStyles[property]);

      if (typeof styleValue === 'function') {
        return styleValue.call(this, feature, styleValue);
      }

      // check gradient if needed
      if (checkForGradient) {
        if (!mapLayer._gradient) {
          var gradients = pick(styles.gradients, featureStyle.gradients, properties.gradients, {});
          if (gradients.type === 'linear' || gradients.type === 'radial') {
            var bbox_geo = GeoUtils.getFeatureGradientBBox(feature, gradients.type, mapLayer.utils.geoPath);
            styleValue = getGradients(
            gradients,
            [bbox_geo.width, bbox_geo.height],
            mapLayer.getStyle(feature, 'fillColor'),
            mapLayer.renderingMode,
            mapLayer.fillOpacity,
            'area',
            null,
            mapLayer.geoMap);

            feature.transform = {
              x: bbox_geo.x,
              y: bbox_geo.y
            };

            //cache for svg because it uses relative coordinate for each element
            if (!mapLayer.isCanvasMode && gradients.type === 'linear') {
              mapLayer._gradient = styleValue;
            }
          }
        } else {
          styleValue = mapLayer._gradient;
        }
      } else if (property === 'dashStyle' && defined(styleValue)) {
        styleValue = getDashArray(styleValue, mapLayer.getStyle('strokeWidth'));
      }

      return styleValue;
    };

    MapLayer.prototype.initialize = function () {
      var mapLayer = this,
        renderingMode = mapLayer.layerContainer.isD3Selection ? 'svg' : 'canvas';

      // set a default styles
      mapLayer.defaultStyles = {
        fillColor: 'transparent',
        strokeColor: '#333',
        strokeWidth: 0.6,
        dashStyle: null
      };

      mapLayer.renderingMode = renderingMode;
      mapLayer.isCanvasMode = mapLayer.layerContainer.isD3Selection !== true;
      mapLayer.renderingModeCapitialized = toCapitalize(renderingMode);
      mapLayer.paintLayer();
    };

    /**
     * for update repaint with the settings
     */
    MapLayer.prototype.update = function (newLayer) {
      if (newLayer) {
        this.layer = newLayer;
      }
      this.paintLayer(true);
    };

    MapLayer.prototype.paintLayer = function (update) {
      var mapLayer = this;
      mapLayer["paint".concat(mapLayer.renderingModeCapitialized, "Layer")](update); // init the current mode
    };

    /**
     *
     */
    MapLayer.prototype.paintSvgLayer = function (update) {
      var mapLayer = this,
        areas = MapLayer.getMapFeatures(mapLayer.layer),
        applyBorderStyles = function applyBorderStyles(features) {
          features.attrs({
            stroke: function stroke(feature) {
              return mapLayer.getStyle(feature, 'strokeColor');
            },
            'stroke-width': function strokeWidth(feature) {
              return mapLayer.getStyle(feature, 'strokeWidth');
            },
            'stroke-dasharray': function strokeDasharray(feature) {
              return mapLayer.getStyle(feature, 'dashStyle');
            },
            'stroke-opacity': function strokeOpacity(feature) {
              return mapLayer.getStyle(feature, 'strokeOpacity');
            }
          });
        },
        features = createElement('path', '.map-feature', MapLayer.getMapFeatures(areas), mapLayer.layerContainer).attrs({
          fill: function fill(feature) {
            return mapLayer.getStyle(feature, 'fillColor', true);
          },
          'fill-opacity': function fillOpacity(feature) {
            return mapLayer.getStyle(feature, 'fillOpacity') || 1;
          },
          d: mapLayer.utils.geoPath
        });

      if (mapLayer.useMesh && mapLayer.layer.length) {
        var mesh = mapLayer.geoMap.dataObject.getFeatureMesh(MapLayer.getMapFeatures(mapLayer.layer));
        mapLayer.mesh = features = createElement('path', '.map-feature-outline', [areas[0]], mapLayer.layerContainer).attrs({
          fill: 'none',
          d: mapLayer.utils.geoPath(mesh)
        });
        // make it to the top
        features.raise();

        applyBorderStyles(features);
      } else {
        if (mapLayer.mesh) {
          mapLayer.mesh.remove();
        }
        applyBorderStyles(features);
      }
    };

    /**
     *
     */
    MapLayer.prototype.paintCanvasLayer = function (update) {
      var mapLayer = this,
        context = mapLayer.layerContainer,
        areas = MapLayer.getMapFeatures(mapLayer.layer);

      // update the context;
      mapLayer.utils.geoPath.context(context);

      each(areas, function (feature) {
        // set the styles
        context.save();
        context.fillStyle = mapLayer.getStyle(feature, 'fillColor', true);
        context.strokeStyle = mapLayer.getStyle(feature, 'strokeColor');
        context.lineWidth = mapLayer.getStyle(feature, 'strokeWidth');

        // set dash array only if user has given
        var dashArray = mapLayer.getStyle(feature, 'dashStyle');

        // #ZC1452
        if (dashArray && defined(context.setLineDash)) {
          context.setLineDash(dashArray);
        }

        context.beginPath();
        mapLayer.utils.geoPath(feature);

        //set the transform before the fill
        if (feature.transform) {
          context.translate(feature.transform.x, feature.transform.y);
        }

        context.fill();

        if (!mapLayer.useMesh) {
          context.stroke();
        }

        context.closePath();
        context.restore();
      });

      // #ZC1493 error when empty layer is passed.
      if (mapLayer.useMesh && areas.length) {
        var mesh = mapLayer.geoMap.dataObject.getFeatureMesh(MapLayer.getMapFeatures(mapLayer.layer));

        if (!mesh) {
          return;
        }

        context.save();
        context.fillStyle = mapLayer.getStyle(areas[0], 'fillColor', true);
        context.strokeStyle = mapLayer.getStyle(areas[0], 'strokeColor');
        context.lineWidth = mapLayer.getStyle(areas[0], 'strokeWidth');

        var dashArray = mapLayer.getStyle(mesh, 'dashStyle');

        // #ZC1452
        if (dashArray && defined(context.setLineDash)) {
          context.setLineDash(dashArray);
        }

        context.beginPath();
        mapLayer.utils.geoPath(mesh);
        context.stroke();
        context.closePath();
        context.restore();
      }
    };

    MapLayer.prototype.destroy = function () {
      var mapLayer = this;
      mapLayer.update([]); // remove all layer
      each(mapLayer, function (value, key) {
        mapLayer[key] = null;
        delete mapLayer[key];
      });
    };

    //GeoPoint.js

    /**
     *
     * @param {number} x
     * @param {number} y
     * @constructor
     */
    function GeoPoint(x, y) {
      this.x = x;
      this.y = y;
    }

    /**
     *
     * @return {{x: number, y: number}}
     */
    GeoPoint.prototype.toJSON = function () {
      return {
        x: this.x,
        y: this.y
      };
    };

    /**
     *
     * @return {number[]}
     */
    GeoPoint.prototype.toArray = function () {
      return [this.x, this.y];
    };

    //LatLong.js

    /**
     *
     * @param {number} longitude is the x value (+180 E ---> +180 W || -180 E)
     * @param {number} latitude is the y value (+90 N ---> +90 S || -90 N)
     * @constructor
     */
    function LatLong(longitude, latitude) {
      this.longitude = longitude;
      this.latitude = latitude;
    }

    /**
     *
     * @return {{latitude: number, longitude: number}}
     */
    LatLong.prototype.toJSON = function () {
      return {
        latitude: this.latitude,
        longitude: this.longitude
      };
    };

    /**
     *
     * @return {number[]}
     */
    LatLong.prototype.toArray = function () {
      return [this.longitude, this.latitude];
    };

    /**
     *
     * @param geoMap
     * @return {[number, number]}
     */
    LatLong.prototype.toXY = function (geoMap) {
      var latLong = this,
        xy = GeoUtils.toXY(geoMap, latLong.longitude, latLong.latitude) || [null, null];

      return new GeoPoint(xy[0], xy[1]);
    };

    GeoPoint.prototype.toLatLong = function (geoMap) {
      var latLong = GeoUtils.toLatLong(geoMap, this.x, this.y) || [null, null];
      // d3 will return [longitude , latitude]
      return new LatLong(latLong[0], latLong[1]);
    };

    //map-labels.js

    /**
     *
     * @param {String} text
     * @param {LatLong} latLong
     * @param {Object} styles
     * @param {GeoMap} geoMap
     * @constructor
     */
    function Label(text, latLong, styles, geoMap) {
      this.text = text;
      this.latLong = latLong;
      this.styles = styles;
      this.geoMap = geoMap;
    }

    /**
     *
     * @return {{x: *, y: *}}
     */
    Label.prototype.getXY = function () {
      var label = this,
        coordinates = label._coordinates;

      // cache
      if (!coordinates) {
        coordinates = label._coordinates = label.latLong.toXY(label.geoMap);
      }

      return coordinates;
    };

    /**
     *
     * @return {{width: (*|number), height: *}}
     */
    Label.prototype.getDimension = function () {
      var label = this,
        style = label.styles,
        dimension = label._dimension;

      // cache
      if (!dimension) {
        dimension = label._dimension = {
          width: utils.fontUtils.getTextWidth(label.text, style.fontSize, style.fontFamily, style.fontStyle, style.fontWeight),
          height: utils.fontUtils.getTextHeight(label.text, style.fontSize, style.fontFamily, style.fontStyle, style.fontWeight)
        };
      }

      return dimension;
    };

    /**
     *
     * @return {{x: number, y: number, width: (*|number), height: *}|*}
     */
    Label.prototype.getBBox = function () {
      var label = this,
        bbox_geo = label._bbox,
        padding = 5,
        paddingEqual = padding / 2;

      if (!bbox_geo) {
        var xy = label.getXY(),
          dimension = label.getDimension();

        bbox_geo = label._bbox = {
          x: xy.x - dimension.width / 2 - paddingEqual,
          y: xy.y - dimension.height / 2 - paddingEqual,
          width: dimension.width + paddingEqual,
          height: dimension.height + paddingEqual
        };
      }

      return bbox_geo;
    };

    /**
     *
     * @param {Label} anotherLabel
     */
    Label.prototype.overlapsWith = function (anotherLabel) {
      var bbox_geo = this.getBBox(),
        otherBBox = anotherLabel.getBBox();

      return (
        bbox_geo.x < otherBBox.x + otherBBox.width &&
        bbox_geo.x + bbox_geo.width > otherBBox.x &&
        bbox_geo.y < otherBBox.y + otherBBox.height &&
        bbox_geo.height + bbox_geo.y > otherBBox.y);

    };

    /**
     *
     * @param rect
     * @return {boolean}
     */
    Label.prototype.insideRect = function (rect) {
      var R2 = this.getBBox();
      return R2.x + R2.width < rect.x + rect.width && R2.x > rect.x && R2.y > rect.y && R2.y + R2.height < rect.y + rect.height;
    };

    Label.prototype.clearCache = function () {
      this._bbox = this._coordinates = this._dimension = null;
    };

    /**
     *
     * @param {GeoMap} geoMap
     * @constructor
     */
    function GeoLabels(geoMap) {
      this.geoMap = geoMap;
      this.initialize();
    }

    GeoLabels.prototype.initialize = function () {
      var geoLabels = this,
        geoMap = geoLabels.geoMap,
        userLabelStyles = geoMap.systemConf.map.labels || {},
        geoLabelStyles = geoLabels.geoLabelStyles = Object.create(userLabelStyles),
        labelArray = geoLabels.labels = [],
        labelBoundary = {
          x: 0,
          y: 0,
          width: geoMap.plotarea.width,
          height: geoMap.plotarea.height
        };

      /**
       *
       * @param {Label} label
       */

      var addLabelToList = function addLabelToList(label) {
        if (
        // ZC1432
        label.insideRect(labelBoundary) &&
        !labelArray.some(function (visibleLabel) {
          return label.overlapsWith(visibleLabel);
        }))
        {
          labelArray.push(label);
        }
      };

      // series labels
      // loop through series and collect labels
      // each(geoMap.renderer, function(chartSeries, seriesIndex) {
      //
      //     var plopOptions = chartSeries.plotOptions,
      //         dataLabels = plopOptions.datalabels,
      //         chartValue = geoMap.chartTypes[seriesIndex].value;
      //
      //     if (!chartSeries.series.disabled && geoMap.datalabels.moduleExists && isDatalabelEnabled(dataLabels, geoMap) && chartValue === $ZC.charttype.geoheatmap) {
      //
      //         /**
      //          *
      //          * @type {function} getLabelText
      //          */
      //         var getLabelText = dataLabelTextContent(geoMap, null, dataLabels, DATALABELS_LABELTYPE, null, seriesIndex),
      //             seriesLabelStyles = {};
      //
      //         seriesLabelStyles.fontFamily = getFontFamilyByHierarchy(dataLabels, geoMap);
      //         seriesLabelStyles.fontSize = getFontSizeByHierarchy(dataLabels, geoMap);
      //         seriesLabelStyles.fontWeight = dataLabels.fontWeight || "normal";
      //         seriesLabelStyles.fontStyle = dataLabels.fontStyle || "normal";
      //         seriesLabelStyles.textShadow = dataLabels.textShadow;
      //         seriesLabelStyles.strokeColor = pick(dataLabels.strokeColor, userLabelStyles.strokeColor);
      //         seriesLabelStyles.strokeWidth = pick(dataLabels.strokeWidth, userLabelStyles.strokeWidth);
      //         seriesLabelStyles.type = "point";
      //
      //         each(chartSeries.series.data, function(subSeriesPoints, subSeriesIndex) {
      //
      //             each(subSeriesPoints, function(point, itemIndex) {
      //
      //                 var feature = geoMap.dataObject.getMapFeaturesByDataPoint(point, "array")[0];
      //
      //                 if (feature) {
      //
      //                     var text = getLabelText(point),
      //                         label = new Label(text, new LatLong(feature.properties.longitude, feature.properties.latitude), seriesLabelStyles, geoMap),
      //                         rawColor = getRawColor(geoMap, seriesIndex, point),
      //                         render = true;
      //
      //                     // set the font color separately
      //                     label.fontColor = getLabelFontColor(geoMap.systemConf, rawColor, dataLabels, geoMap, false, seriesIndex, false);
      //
      //                     if (geoMap.updating && geoMap.hasColorScale) {
      //                         render = isWithinColorRange(geoMap.dataset.getClr(point), geoMap);
      //                     }
      //
      //                     if (render) {
      //                         addLabelToList(label);
      //                     }
      //                 }
      //
      //             })
      //         })
      //     }
      // });

      // add the default area labels if enabled

      if (geoLabelStyles.show === true) {
        // set geo labels styles
        geoLabelStyles.fontFamily = getFontFamilyByHierarchy(userLabelStyles, geoMap);
        geoLabelStyles.fontSize = getFontSizeByHierarchy(userLabelStyles, geoMap);
        geoLabelStyles.fontWeight = userLabelStyles.fontWeight || 'normal';
        geoLabelStyles.fontStyle = userLabelStyles.fontStyle || 'normal';
        geoLabelStyles.fontColor = userLabelStyles.fontColor || '#333';
        geoLabelStyles.textShadow = userLabelStyles.textShadow;
        geoLabelStyles.strokeColor = userLabelStyles.strokeColor;
        geoLabelStyles.strokeWidth = userLabelStyles.strokeWidth;
        geoLabelStyles.type = 'background';

        // first get series labels if enabled
        if (geoMap.systemConf.map.allAreas === true) {
          geoMap.dataObject.userUnmatchedMapFeatures.each(function (feature, index) {
            var properties = feature.properties,
              userValue = invokeFunction(true, userLabelStyles.showAs, feature, geoMap),
              // get the text
              text = pick(properties[userValue], userValue, properties.name),
              // create a label instance
              label = new Label(text, new LatLong(properties.longitude, properties.latitude), geoLabelStyles, geoMap);

            // add
            addLabelToList(label);
          });
        }
      }

      // finally render
      geoLabels.render();
    };

    /**
     *
     * @param update
     */
    GeoLabels.prototype.render = function (update) {
      var geoLabels = this,
        geoMap = geoLabels.geoMap;

      if (this.geoMap.geo.isCanvasMode) {
        geoLabels.renderCanvasLabel(update);
      } else {
        geoLabels.renderSvgLabel(update);
      }
    };

    GeoLabels.prototype.renderCanvasLabel = function () {
      var geoLabel = this,
        labelLayer = geoLabel.geoMap.geo.geoLabelLayer, // add the labels with the feature itself
        getCanvasFont = function getCanvasFont(fontStyle, fontWeight, fontSize, fontFamily) {
          return "".concat(fontStyle, " ").concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
        },
        shadowCache = {};

      geoLabel.labels.forEach(function (label) {
        var styles = label.styles,
          fillColor = pick(label.fontColor, styles.fontColor),
          textStroke = styles.strokeColor || getContrastColor(fillColor),
          coordinates = label.getXY();

        if (defined(coordinates.x) && defined(coordinates.y)) {
          labelLayer.save();

          if (styles.textShadow && !defined(shadowCache[label.type])) {
            shadowCache[label.type] = _canvasDatalabelUtils.parseTextShadow(styles.textShadow);
          }

          if (shadowCache[label.type]) {
            var textShadow = shadowCache[label.type];

            if (defined(textShadow)) {
              labelLayer.shadowOffsetX = textShadow[0];
              labelLayer.shadowOffsetY = textShadow[1];
              labelLayer.shadowBlur = textShadow[2];
              labelLayer.shadowColor = textShadow[3];
            }
          }

          labelLayer.textAlign = 'center';
          labelLayer.textBaseline = 'middle';
          labelLayer.fillStyle = fillColor;
          labelLayer.strokeStyle = textStroke;
          labelLayer.font = getCanvasFont(styles.fontStyle, styles.fontWeight, styles.fontSize, styles.fontFamily);

          if (styles.strokeWidth > 0) {
            labelLayer.lineWidth = styles.strokeWidth;
            labelLayer.strokeText(label.text, coordinates.x, coordinates.y);
          }

          labelLayer.fillText(label.text, coordinates.x, coordinates.y);
          labelLayer.restore();
        }
      });
    };

    GeoLabels.prototype.renderSvgLabel = function () {
      var geoLabel = this,
        labelLayer = geoLabel.geoMap.geo.geoLabelLayer;

      // set the style to the parent element
      geoLabel.labelElements = createElement('text', '.geo-labels', geoLabel.labels, labelLayer).each(function (label) {
        var labelElement = d3_select(this),
          coordinates = label.getXY(),
          styles = label.styles,
          fillColor = pick(label.fontColor, styles.fontColor),
          textStroke = styles.strokeColor || getContrastColor(fillColor);

        if (defined(coordinates.x) && defined(coordinates.y)) {
          labelElement.attrs({
            'font-family': styles.fontFamily,
            'font-size': styles.fontSize,
            'font-style': styles.fontStyle,
            'font-weight': styles.fontWeight,
            'text-anchor': 'middle',
            'dominant-baseline': 'middle',
            transform: "translate(".concat(coordinates.x, ",").concat(coordinates.y, ")")
          });

          if (styles.textShadow) {
            labelElement.style('text-shadow', styles.textShadow);
          }

          if (styles.strokeWidth > 0) {
            //stroke text
            createElement('tspan', '.stroke-text', [1], labelElement).
            text(label.text).
            attrs({
              stroke: textStroke,
              'stroke-width': styles.strokeWidth,
              x: 0,
              y: 0
            });
          }

          createElement('tspan', '.fill-text', [1], labelElement).
          text(label.text).
          attrs({
            fill: fillColor,
            x: 0,
            y: 0
          });
        }
      });
    };

    GeoLabels.prototype.update = function () {
      var mapLabel = this,
        geoMap = mapLabel.geoMap;

      // fix canvas zoom transforms
      // if (geoMap.geo.isCanvasMode) {
      //     // GeoUtils.clearContext(geoMap.geo.labelLayer);
      // }

      mapLabel.labels.forEach(function (label) {
        label.clearCache();
      });
      mapLabel.initialize(true);
    };

    //MapDataProcessor.js
    /**
     *
     * @param {GeoMap} geoMap
     * @constructor
     */
    function MapDataProcessor(geoMap) {
      this.geoMap = geoMap;
      this.initialize();
    }

    MapDataProcessor.prototype.initialize = function () {
      var dataProcessor = this,
        geoMap = dataProcessor.geoMap,
        geoConfig = geoMap.geo,
        dataSet = geoMap.dataset,
        allSeries = geoMap.seriesdata,
        userMapConfig = geoMap.systemConf.map,
        excludeAreas = d3_set(userMapConfig.excludeAreas || []),
        includeAreas = d3_set(userMapConfig.includeAreas || []),
        // get the map features for data mapping
        mapFeatures = dataProcessor.mapFeatures = geoConfig.defaultLayer.layerGeojson.features,
        joinBy = dataProcessor.joinByKey = dataSet.getMapByKey(),
        hasLatLongJoinBy = dataProcessor.hasLatLongJoinBy = dataSet.latLongJoinByKeys.has(joinBy),
        hashBy = hasLatLongJoinBy ? 'zc-key' : joinBy,
        // hash the map features by joinBy key for faster lookup
        mapFeaturesHashed = dataProcessor.mapFeaturesHashed = MapDataProcessor.helpers.hashFeaturesByProperty(
        mapFeatures,
        hashBy,
        includeAreas,
        excludeAreas,
        true),

        // hash the data for faster reverse lookup
        userDataHashed = dataProcessor.userDataHashed = d3_map(),
        // testing
        userUnmatchedMapFeatures = dataProcessor.userUnmatchedMapFeatures = d3_map(),
        // create hash for faster lookup
        userMapFeatures = dataProcessor.userMapFeatures = d3_map(),
        // also create a map for unmatched data
        userUnmatchedData = dataProcessor.userUnmatchedData = d3_set(),
        flattenPoints;

      // total data count;
      dataProcessor.totalDataCount = 0;
      dataProcessor.extents = d3_map();
      dataProcessor.hasPointChart = false;
      dataProcessor.isCombinationalChart = d3_set();
      dataProcessor.flattenPoints = flattenPoints = d3_map();
      dataProcessor.hasHeatmap = dataProcessor.hasBubblePie = dataProcessor.hasPointChart = false;
      dataProcessor.encodes = {};
      dataProcessor.markerSize = {};
      dataProcessor.processedseriesData = allSeries;
      dataProcessor.annotation = [];
      geoMap.cache.data = {};
      geoMap.cache.search = {};

      // set identification
      geoMap.isGeoMap = true;
      geoMap.hasColorScale = colorscale_helpers.isQuantileColorScale(geoMap);

      dataProcessor.hasZaxis =
      defined(dataSet.zidx) &&
      chartcategory.zaxis.some(function (type) {
        return dataProcessor.containsChartType(type);
      });

      // hashing function
      var hash = function hash(point, seriesIndex, subSeriesIndex, itemIndex) {
        var userJoinBy = dataSet.getGeo(point),
          chartName = geoMap.chartTypes[seriesIndex].name,
          flattenArray = flattenPoints.get(chartName);

        // set index on point
        //Flatten data - for axis chart it was handled in flatten-data.js
        point.seriesIndex = seriesIndex;
        point.subSeriesIndex = subSeriesIndex;
        point.itemIndex = itemIndex;
        point.rendererIndex = seriesIndex;
        point._key = DataProcessor.helpers.generatePointKey(geoMap.id, '0_0', seriesIndex, subSeriesIndex, itemIndex);
        point._data = dataHash(point, seriesIndex, geoMap);

        // flatten array
        if (!defined(flattenArray)) {
          flattenArray = [];
          flattenPoints.set(chartName, flattenArray);
        }
        flattenArray.push(point);

        /**
         * We support geo heatmap with only key value. Not by Lat-Long
         */
        if (!hasLatLongJoinBy || dataProcessor.isValidPoint(point)) {
          if (mapFeaturesHashed.has(userJoinBy)) {
            userMapFeatures.set(userJoinBy, mapFeaturesHashed.get(userJoinBy));
            // hash data
            if (userDataHashed.has(userJoinBy)) {
              userDataHashed.get(userJoinBy).push(point);
            } else {
              userDataHashed.set(userJoinBy, [point]);
            }
            // #ZC1652
            // calculate the total data count
            dataProcessor.totalDataCount++;
            saveAnnotation$2(point, geoMap, dataProcessor.annotation);
          } else if (hasLatLongJoinBy) {
            // calculate the total data count
            // #ZC1652
            dataProcessor.totalDataCount++;
            saveAnnotation$2(point, geoMap, dataProcessor.annotation);
          } else {
            userUnmatchedData.add(userJoinBy);
          }
        }
      };

      var annotationHash = function annotationHash(point, seriesIndex, subSeriesIndex, itemIndex) {
        var userJoinBy = dataSet.getGeo(point);

        if (!hasLatLongJoinBy || dataProcessor.isValidPoint(point)) {
          if (mapFeaturesHashed.has(userJoinBy) || hasLatLongJoinBy) {
            saveAnnotation$2(point, geoMap, dataProcessor.annotation, seriesIndex, subSeriesIndex, itemIndex);
          }
        }
      };

      var dataHash = function dataHash(point, seriesIndex, geoMap) {
        return function () {
          return geoMap.renderer[seriesIndex].highlighter.data(point);
        };
      };

      var zExtremes = [];

      // loop through all series
      each(allSeries, function (series, i) {
        // convert to 3D array if needed
        MapDataProcessor.helpers.convertTo3DArray(series);

        var chartType = geoMap.chartTypes[i];

        dataProcessor.isCombinationalChart.add(chartType.name);

        if (!series.disabled) {
          if (!dataProcessor.hasHeatmap && charttype.geoheatmap === chartType.value) {
            dataProcessor.hasHeatmap = dataProcessor.containsChartType('geoheatmap');
          }

          if (!dataProcessor.hasBubblePie && charttype.geobubblepie === chartType.value) {
            dataProcessor.hasBubblePie = true;
          }

          dataProcessor.isBubbleEnabled = dataProcessor.isBubbleEnabled || isBubbleChartType$1(chartType.value);

          if (!dataProcessor.hasPointChart && charttype.geoheatmap !== chartType.value) {
            dataProcessor.hasPointChart = true;
          }

          each(series.data, function (subSeriesPoints, j) {
            // hash each point
            each(subSeriesPoints, function (point, k) {
              hash(point, i, j, k);
            });

            // get the extent for bubble chart
            if (dataProcessor.hasZaxis) {
              dataProcessor.saveEncode('z', 0, i);
              zExtremes.push(
              d3_extent(subSeriesPoints, function (point) {
                return dataSet.getZ(point);
              }));

            }
          });
        }

        each(series.data, function (subSeriesPoints, j) {
          each(subSeriesPoints, function (point, k) {
            annotationHash(point, i, j, k);
          });
        });
      });

      // filter out the invalid points
      flattenPoints.each(function (points, chartType) {
        flattenPoints.set(
        chartType,
        points.filter(function (point) {
          if (dataProcessor.isValidPoint(point)) {
            return point;
          }
        }));

      });

      // set the final extent
      if (dataProcessor.hasZaxis) {
        dataProcessor.extents.set('z', d3_extent(d3_merge(zExtremes)));
      }

      // for lat-long data type, declare all areas as background layer
      if (hasLatLongJoinBy) {
        dataProcessor.userUnmatchedMapFeatures = mapFeaturesHashed;
      } else {
        mapFeaturesHashed.keys().forEach(function (key) {
          if (!userMapFeatures.has(key) && !excludeAreas.has(key)) {
            userUnmatchedMapFeatures.set(key, mapFeaturesHashed.get(key));
          }
        });
      }

      // process the bubble pie data
      if (dataProcessor.hasBubblePie) {
        // dependency
        dataProcessor.data = geoMap.systemConf;
        dataProcessor.chartObj = geoMap;
        dataProcessor.dataset = dataSet;
        dataProcessor.processedseriesData = geoMap.seriesdata;

        dataProcessor.bubblepieData = dataProcessor.processBubblePieData(null, { chartType: charttype.geobubblepie });
      }

      //finally userMapFeatures save as array for later use
      dataProcessor.isCombinationalChart = dataProcessor.isCombinationalChart.values().length > 1;
      dataProcessor.userMapFeaturesArray = userMapFeatures.values();
      dataProcessor.totalnoofdatas = dataProcessor.totalDataCount;
    };

    MapDataProcessor.prototype.getFeatureMesh = function (features) {
      var dataProcessor = this,
        tempSet = d3_set(),
        baseTopojsonLayer = dataProcessor.geoMap.geo.defaultLayer.layerOriginal,
        mesh = null,
        layerName = dataProcessor.geoMap.systemConf.map.layerName,
        joinByKey = dataProcessor.hasLatLongJoinBy ? 'zc-key' : dataProcessor.joinByKey;

      if (baseTopojsonLayer.type === 'Topology') {
        features.forEach(function (feature) {
          if (feature.properties && feature.properties[joinByKey]) {
            tempSet.add(feature.properties[joinByKey]);
          }
        });
        mesh = topojson.mesh(baseTopojsonLayer, baseTopojsonLayer.objects[layerName], function (a, b) {
          // #ZC2830
          return tempSet.has(a.properties[joinByKey]) || tempSet.has(b.properties[joinByKey]);
        });
      }
      return mesh;
    };

    /**
     *
     * @return {boolean}
     */
    MapDataProcessor.prototype.getAxisRotated = function () {
      //TODO: remove
      return false;
    };

    /**
     *
     * @param chartName
     * @return {boolean}
     */
    MapDataProcessor.prototype.containsChartType = function (chartName) {
      return this.geoMap.chartTypes.some(function (chartType) {
        return chartType.name === chartName || chartType.value === chartName;
      });
    };

    /**
     *
     * @param point
     * @return {*}
     */
    MapDataProcessor.prototype.getXYPoint = function (point) {
      return this.getLatLonPoint(point).toXY(this.geoMap);
    };

    /**
     *
     * @param point
     * @return {null|*}
     */
    MapDataProcessor.prototype.getFeatureByPoint = function (point) {
      var dataProcessor = this,
        userMapFeatures = dataProcessor.userMapFeatures,
        dataset = dataProcessor.geoMap.dataset,
        key = dataset.getGeo(point);

      if (userMapFeatures.has(key)) {
        return userMapFeatures.get(key);
      }
      return null;
    };

    /**
     *
     * @param point
     * @return {LatLong}
     */
    MapDataProcessor.prototype.getLatLonPoint = function (point) {
      var dataProcessor = this,
        geoMap = dataProcessor.geoMap,
        dataSet = geoMap.dataset,
        userMapFeatures = dataProcessor.userMapFeatures,
        // get the key from the data
        key = dataSet.getGeo(point),
        lonLat = [0, 0];

      if (userMapFeatures.has(key)) {
        var feature = userMapFeatures.get(key),
          properties = feature.properties;

        if (defined(properties.latitude) && defined(properties.longitude)) {
          lonLat = [+properties.longitude, +properties.latitude];
        } else {
          lonLat = d3_geoCentroid(feature);
        }
      } else if (dataProcessor.hasLatLongJoinBy) {
        lonLat = [dataSet.getLongitude(key), dataSet.getLatitude(key)];
      }
      return new LatLong(lonLat[0], lonLat[1]);
    };

    /**
     *
     * @param axisRotated
     * @param stacked
     * @param xScale
     * @param yScale
     * @param yAxisColumnOrder
     * @param point
     * @param type
     * @return {number}
     */
    MapDataProcessor.prototype.getXYvalue = function (axisRotated, stacked, xScale, yScale, yAxisColumnOrder, point, type) {
      var dataProcessor = this;
      if (type === 'z') {
        return dataProcessor.getZFromPoint(point);
      }
      return dataProcessor.getXYPoint(point)[type];
    };

    /**
     *
     * @param point
     * @return {number}
     */
    MapDataProcessor.prototype.getZFromPoint = function (point) {
      var geoMap = this.geoMap;
      return getSizeFromPoint(point, geoMap.dataset, geoMap);
    };

    /**
     *
     * @param latLong
     * @return {GeoPoint}
     */
    MapDataProcessor.prototype.getXYFromLatLng = function (latLong) {
      var xy = GeoUtils.toXY(this.geoMap, latLong.longitude, latLong.latitude);
      return new GeoPoint(xy[0], xy[1]);
    };

    /**
     *
     * @param type
     * @return {Array|d3.map|{}}
     */
    MapDataProcessor.prototype.getUserMapFeatures = function (type) {
      var dataProcessor = this;
      if (type === 'geojson') {
        return MapDataProcessor.helpers.arrayToGeojson(dataProcessor.userMapFeaturesArray);
      } else if (type === 'array') {
        return dataProcessor.userMapFeaturesArray;
      }
      return dataProcessor.userMapFeatures;
    };

    /**
     *
     * @param dataPoints
     * @param type
     */
    MapDataProcessor.prototype.getMapFeaturesByDataPoint = function (dataPoints, type) {
      var dataProcessor = this,
        dataSet = dataProcessor.geoMap.dataset,
        map = d3_map();

      if (!(dataPoints[0] instanceof Array)) {
        dataPoints = [dataPoints];
      }

      dataPoints.forEach(function (point) {
        // dataProcessor.userMapFeatures
        var key = point[dataSet.geoidx];

        if (dataProcessor.userMapFeatures.has(key)) {
          map.set(key, dataProcessor.userMapFeatures.get(key));
        }
      });

      if (type === 'geojson') {
        return MapDataProcessor.helpers.arrayToGeojson(map.values());
      } else if (type === 'array') {
        return map.values();
      }
      return map;
    };

    /**
     *
     * @param type
     * @return {Array|d3.map|{}}
     */
    MapDataProcessor.prototype.getMapFeatures = function (type) {
      var dataProcessor = this;

      var features = d3_map(dataProcessor.userMapFeatures);
      dataProcessor.userUnmatchedMapFeatures.keys().forEach(function (key) {
        features.set(key, dataProcessor.userUnmatchedMapFeatures.get(key));
      });

      if (type === 'geojson') {
        return MapDataProcessor.helpers.arrayToGeojson(features.values());
      } else if (type === 'array') {
        return features;
      }

      return features;
    };

    /**
     *
     * @return {*}
     */
    MapDataProcessor.prototype.getMinMaxZ = function () {
      return this.extents.get('z');
    };

    /**
     *
     * @return {boolean}
     */
    MapDataProcessor.prototype.isstacked = function () {
      return false;
    };

    MapDataProcessor.prototype.containsNegativeData = function (index) {
      return false;
    };

    MapDataProcessor.prototype.getScaleProxy = function () {
      var processor = this,
        geoMap = processor.geoMap;

      return {
        xScale: function xScale(point) {
          return processor.getXYPoint(point).x;
        },
        yScale: function yScale(point) {
          return processor.getXYPoint(point).y;
        }
      };
    };

    /**
     *
     * @return {boolean}
     */
    MapDataProcessor.prototype.isValidLatLong = function (lat, _long) {
      return numberIsBetween(lat, [-90, 90]) && numberIsBetween(_long, [-180, 180]);
    };

    /**
     *
     * @param point
     * @return {boolean}
     */
    MapDataProcessor.prototype.isValidPoint = function (point) {
      var processor = this,
        geoIndex = processor.geoMap.dataset.getGeo(point);

      if (!point.length || !defined(geoIndex) || !geoIndex.length) {
        return false;
      }

      if (processor.hasLatLongJoinBy) {
        var lat = processor.geoMap.dataset.getLatitude(geoIndex),
          _long2 = processor.geoMap.dataset.getLongitude(geoIndex);
        return defined(lat) && defined(_long2) && processor.isValidLatLong(lat, _long2);
      } else {
        return processor.userDataHashed.has(geoIndex);
      }
    };

    /**
     *
     * @param {Array} points
     * @return {Array}
     */
    MapDataProcessor.prototype.updateSeriesdatabyCategories = function (points) {
      var processor = this,
        ii = 0;
      // ,
      // currentViewPort = processor.geoMap.navigation && processor.geoMap.navigation.getCurrentViewPort();

      return points.filter(function (point) {
        var isValidPoint = processor.isValidPoint(point);

        // TODO remove points that are out of the viewport
        // if (isValidPoint) {
        //     if (currentViewPort) {
        //         let xy = processor.getXYPoint(point);
        //         isValidPoint =  (currentViewPort[0][0] <= xy.x && xy.x <= currentViewPort[1][0]) && (currentViewPort[0][1] <= xy.y && xy.y <= currentViewPort[1][1]);
        //     }
        // }

        if (isValidPoint) {
          point.itemIndex = ii++;
        }
        return isValidPoint;
      });
    };

    /**
     *
     * @type {DataProcessor.processBubblePieData}
     */
    MapDataProcessor.prototype.processBubblePieData = _bubblePieProcessor;

    // *************************************************************************** //

    MapDataProcessor.helpers = {
      /**
       *
       * @param data
       * @return {*}
       */
      is3D: function is3D(data) {
        return isArray$1(data) && isArray$1(data[0]) && isArray$1(data[0][0]);
      },

      /**
       *
       * @param series
       * @return {Array}
       */
      convertTo3DArray: function convertTo3DArray(series) {
        if (!this.is3D(series.data)) {
          series.data = [series.data];
        }
      },

      arrayToGeojson: function arrayToGeojson(features) {
        return {
          type: 'FeatureCollection',
          features: features
        };
      },

      /**
       *
       * @param object
       * @param property
       * @param includeAreas
       * @param excludeAreas
       * @param copy
       * @return {d3.map}
       */
      hashFeaturesByProperty: function hashFeaturesByProperty(object, property, includeAreas, excludeAreas, copy) {
        var hash = d3_map();
        each(object, function (feature, i) {
          var key = feature.properties[property] || i;
          if ((includeAreas.empty() || includeAreas.has(key)) && (excludeAreas.empty() || !excludeAreas.has(key))) {
            hash.set(key, copy ? Object.create(feature) : feature);
          }
        });
        return hash;
      }
    };

    function saveAnnotation$2(curdata, chart, arr, seriesIndex, subSeriesIndex, itemIndex) {
      var config = chart.systemConf.notes || {},
        dataIndex = config.dataIndex;

      if (isUndefined(dataIndex)) {
        return;
      }

      var data = curdata;
      if (data[dataIndex]) {
        arr.push({ data: curdata, seriesIndex: seriesIndex, subSeriesIndex: subSeriesIndex, itemIndex: itemIndex });
      }
    }

    extend(MapDataProcessor.prototype, encodeMethods);

    //map-data--parser.js

    /**
     *
     * @param {GeoMap} geoMap
     * @constructor
     */
    function MapDataSet(geoMap) {
      this.geoMap = geoMap;
      this.initialize();
    }

    /**
     * initialize the map data set.
     * It will create the relation between the columns and the series.
     *
     */
    MapDataSet.prototype.initialize = function () {
      var dataSet = this,
        geoMap = dataSet.geoMap,
        userData = geoMap.userdata,
        metaData = userData.metadata,
        columns = dataSet.columns = pick(metaData.columns, {}),
        axes = dataSet.axes = pick(metaData.axes, { geo: [0], clr: [1], z: [1] }),
        colorColumn = pick(columns[axes.clr], {}),
        geoColumn = pick(columns[axes.geo], {}),
        zColumn = pick(columns[axes.z], {}),
        geoMapByKey;

      // set the color index in dataSet

      dataSet.latLongJoinByKeys = d3_set(['lat-long', 'long-lat']);
      dataSet.clridx = pick(colorColumn.dataindex);
      dataSet.zidx = pick(zColumn.dataindex);
      dataSet.geoidx = pick(geoColumn.dataindex, 0);
      dataSet.geoMapByKey = geoMapByKey = dataSet.getJoinByKey(geoColumn);

      if (axes.label && columns[axes.label]) {
        dataSet.labelIndex = columns[axes.label].dataindex;
      }

      if (dataSet.latLongJoinByKeys.has(dataSet.geoMapByKey)) {
        if (geoMapByKey === 'lat-long') {
          dataSet.latitudeIndex = 0;
          dataSet.longitudeIndex = 1;
        } else {
          dataSet.latitudeIndex = 1;
          dataSet.longitudeIndex = 0;
        }
      }
    };

    /**
     *
     * @param column
     */
    MapDataSet.prototype.getJoinByKey = function (column) {
      var dataSet = this,
        geoColumn = pick(column, dataSet.columns[dataSet.axes.geo], {}),
        joinBy = pick(geoColumn.joinBy, 'zc-key');

      /**
       *
       * 1. This checks all joinBy key names except "zc-key". Since it is the standard key available
       *    in all geojson source.
       *
       * 2. If the joinBy key is defined by the user but the key is missing in the actual geojson properties,
       *    then it replaces the joinBy key with `zc-key` by default.
       */
      if (joinBy !== 'zc-key' && !dataSet.latLongJoinByKeys.has(joinBy)) {
        // take the first feature for testing assuming that remaining feature will have the properties.
        var feature = dataSet.geoMap.geo.defaultLayer.layerGeojson.features[0].properties;
        if (!defined(feature[joinBy])) {
          joinBy = 'zc-key';
        }
      }

      return joinBy;
    };

    /**
     *
     * @param type
     * @return {*}
     */
    MapDataSet.prototype.getColumnIdx = function (type) {
      if (isArray$1(this.axes[type])) {
        return this.axes[type][0];
      }
      return null;
    };

    /**
     *
     * @param type
     * @return {"numeric"|"ordinal"|"time"}
     */
    MapDataSet.prototype.getDataType = function (type) {
      var dataSet = this,
        columnIndex = dataSet.getColumnIdx(type);

      if (defined(dataSet.columns[columnIndex])) {
        return dataSet.columns[columnIndex].datatype;
      }
      return ORDINAL_DATATYPE;
    };

    /**
     *
     * @param point
     * @return {*}
     */
    MapDataSet.prototype.getZ = function (point) {
      return point[this.zidx];
    };

    /**
     *
     * @param point
     * @return {*}
     */
    MapDataSet.prototype.getClr = function (point) {
      return point[this.clridx];
    };

    /**
     *
     * @param point
     * @return {*}
     */
    MapDataSet.prototype.getGeo = function (point) {
      return point[this.geoidx];
    };

    /**
     *
     * @param point
     * @return {number}
     */
    MapDataSet.prototype.getLatitude = function (point) {
      return point[this.latitudeIndex];
    };

    /**
     *
     * @param point
     * @return {number}
     */
    MapDataSet.prototype.getLongitude = function (point) {
      return point[this.longitudeIndex];
    };

    /**
     *
     * @return {any}
     */
    MapDataSet.prototype.getMapByKey = function () {
      return this.geoMapByKey;
    };

    /**
     *
     * @param type
     * @return {*}
     */
    MapDataSet.prototype.getColumn = function (type) {
      return this.columns[this.getColumnIdx(type)];
    };

    MapDataSet.prototype.getX = MapDataSet.prototype.getY = MapDataSet.prototype.getGeo;

    /**
     *
     * @param chartObj
     * @param dataPoint
     * @param colidx
     * @param seriespos
     * @param percent
     * @param type
     * @param subseriespos
     * @param toDecode
     * @param subseriesLength
     * @return {*}
     */
    MapDataSet.prototype.getDataPointValue = function (
    chartObj,
    dataPoint,
    colidx,
    seriespos,
    percent,
    type,
    subseriespos,
    toDecode,
    subseriesLength)
    {
      if (colidx) {
        colidx = +colidx;
      }

      if (isUndefined(toDecode)) {
        toDecode = !/(tooltip|legend)/.test(type);
      }

      var axes = this.axes,
        columns = this.columns,
        colInfo = columns[colidx] || {},
        datatype = colInfo.datatype,
        dataindex = colInfo.dataindex;

      var format = colInfo[datatype];

      if (dataPoint != null) {
        //Even though clrIdx is not specified in metadata, the seriesname will be returned correctly
        if ((axes.clr != null || type === 'legend') && colidx == axes.clr) {
          if (defined(this.clridx) && colorscale_helpers.isQuantileColorScale(chartObj)) {
            if (type === 'legend') {
              return getFormattedValue(format, dataPoint, datatype, chartObj, type, toDecode, '-');
            }
            return getFormattedValue(format, this.getClr(dataPoint), datatype, chartObj, type, toDecode);
          } else {
            return getFormattedValue(format, this.geoMap.seriesdata[seriespos].seriesname, datatype, chartObj, type, toDecode);
          }
        } else {
          var value;
          var formatFn = percent ? getFormattedValueByPercent : getFormattedValue;
          if (subseriesLength) {
            //subserieslength - to iterate all subseries y value to show for tooltip shared series info
            var cumval = 0;
            for (var j = 0; j < subseriesLength; j++) {
              cumval += this.getDataPointUnformattedValue(datatype, seriespos, j, colidx, dataPoint, type, percent, dataindex);
            }
            value = cumval;
          } else {
            value = this.getDataPointUnformattedValue(datatype, seriespos, subseriespos, colidx, dataPoint, type, percent, dataindex);
          }
          if (value === '' && percent) {
            return value;
          }
          return formatFn(format, value, datatype, chartObj, type, toDecode);
        }
      }
      return null;
    };

    /**
     *
     * @param dataType
     * @param seriesIndex
     * @param subSeriesIndex
     * @param columnIndex
     * @param dataPoint
     * @param type
     * @param percent
     * @param dataIndex
     * @return {*}
     */
    MapDataSet.prototype.getDataPointUnformattedValue = function (
    dataType,
    seriesIndex,
    subSeriesIndex,
    columnIndex,
    dataPoint,
    type,
    percent,
    dataIndex)
    {
      var geoMap = this.geoMap,
        value = '';

      if (percent) {
        var total;

        if (dataType === NUMERIC_DATATYPE) {
          total = getTotal(geoMap, seriesIndex, subSeriesIndex, columnIndex, dataPoint, percent, type);
          if (defined(total)) {
            value = pick((type === STACKLABELS_LABELTYPE ? dataPoint : dataPoint[dataIndex]) / total * 100, 0);
            return value;
          }
        }
      }
      return type === STACKLABELS_LABELTYPE ? dataPoint : dataPoint[dataIndex];
    };

    /**
     *
     * @param geoMap
     * @param columnIndex
     * @param seriesIndex
     * @param subSeriesIndex
     * @param itemIndex
     * @param point
     * @return {*}
     */
    MapDataSet.prototype.getDataPoint = function (geoMap, columnIndex, seriesIndex, subSeriesIndex, itemIndex, point) {
      if (defined(point)) {
        return point;
      }

      var series = geoMap.seriesdata[seriesIndex].data,
        seriesAfterUpdate = geoMap.renderer[seriesIndex].seriesdataAfterUpdate;

      if (seriesAfterUpdate) {
        return seriesAfterUpdate[subSeriesIndex][itemIndex];
      } else {
        return series[subSeriesIndex][itemIndex];
      }
    };

    /**
     *
     *
     * @param chartObj
     * @param colidx
     * @param seriespos
     * @param subseriespos
     * @param itempos
     * @param d
     * @param type
     * @param color
     * @param toDecode
     * @param subseriesLength
     * @return {string}
     */
    MapDataSet.prototype.getCustomizedVal = function (
    chartObj,
    colidx,
    seriespos,
    subseriespos,
    itempos,
    d,
    type,
    color,
    toDecode,
    subseriesLength)
    {
      var dataSet = this;

      if (isUndefined(toDecode)) {
        toDecode = !/(tooltip|legend)/.test(type);
      }

      return colidx.toString().replace(CUSTOM_VALUE_PATTERN, function () {
        var matchedString = arguments[0],
          valIndex = arguments[1], //INDEX value of {{val(INDEX)}}
          colIndex = arguments[2], //INDEX value of {{col(INDEX)}}
          perIndex = arguments[3], //INDEX value of {{per(INDEX)}}
          splitPerIndex = arguments[4], //INDEX value of {{splitper(INDEX)}}
          maxPerIndex = arguments[5],
          geoProperty = arguments[6],
          idx = valIndex || colIndex || perIndex || splitPerIndex || maxPerIndex,
          dataPoint;

        if (matchedString.indexOf('{{clr}}') !== -1) {
          // theme color based on series color
          return color;
        }

        if (dataSet.columns[idx] != null) {
          dataPoint = type === STACKLABELS_LABELTYPE ? d : dataSet.getDataPoint(chartObj, idx, seriespos, subseriespos, itempos, d);
          if (dataPoint != null) {
            var operation = matchedString.match(/[a-z]+/gi)[0];
            switch (operation) {
              case 'col':
                return dataSet.getColumnName(colIndex, toDecode); //return columnname
              case 'val':
                return dataSet.getDataPointValue(
                chartObj,
                dataPoint,
                valIndex,
                seriespos,
                false,
                type,
                subseriespos,
                toDecode,
                subseriesLength);
              //return value
              case PER_SHOWAS:
              case SPLITPER_SHOWAS:
              case MAXPER_SHOWAS:
                return dataSet.getDataPointValue(
                chartObj,
                dataPoint,
                perIndex || splitPerIndex || maxPerIndex,
                seriespos,
                operation,
                type,
                subseriespos,
                toDecode,
                subseriesLength);}


          } else {
            return '';
          }
        } else if (geoProperty) {
          // #ZC1469
          dataPoint = dataSet.getDataPoint(chartObj, idx, seriespos, subseriespos, itempos, d);
          var feature = chartObj.dataObject.getMapFeaturesByDataPoint(dataPoint, 'array');
          if (feature.length) {
            return feature[0].properties[geoProperty] || matchedString;
          }
        } else {
          return matchedString;
        }
      });
    };

    MapDataSet.prototype.getColumnName = function (colidx, toDecode) {
      var dataSet = this;

      if (toDecode) {
        return encodeHTML(dataSet.columns[colidx].columnname);
      } else {
        return decodeHTML(dataSet.columns[colidx].columnname);
      }
    };

    /**
     *
     * @param chartObj
     * @param data
     * @param seriesIndex
     * @return {Array}
     */
    MapDataSet.prototype.getMetaInfoObj = function (chartObj, data, seriesIndex) {
      var dataSet = this,
        axes = dataSet.axes,
        columns = dataSet.columns,
        seriesdata = dataSet.geoMap.seriesdata,
        dataWithMetadata = [],
        getColObj = function getColObj(columnIndex, value) {
          var obj = simpleClone(columns[columnIndex] || {});
          obj.value = value;
          obj.columnindex = columnIndex;
          return obj;
        };

      if (isArray$1(data)) {
        data.forEach(function (d, i) {
          var columnIndex = columns.indexOf(
          columns.filter(function (c, j) {
            return c.dataindex === i;
          })[0]);

          dataWithMetadata.push(getColObj(columnIndex, d));
        });
      }

      if (defined(axes.clr)) {
        var clrColIdx = isArray$1(axes.clr) ? axes.clr[0] : axes.clr;
        dataWithMetadata.push(getColObj(clrColIdx, seriesdata[seriesIndex].seriesname));
      }

      return dataWithMetadata;
    };

    /**
     *
     * @param {GeoMap} geoMap
     * @constructor
     */
    function GeoPlotRenderer(geoMap) {
      this.geoMap = geoMap;
      this.initialize();
    }

    GeoPlotRenderer.prototype.initialize = function () {
      var renderer = this,
        geoMap = renderer.geoMap,
        mode = geoMap.systemConf.chart.plot.renderer.mode.toLowerCase();

      // if the mode is canvas check for support
      each(geoMap.chartTypes, function (chartType) {
        if (mode === 'canvas' && arrayIncludes(chartcategory.svgOnly, chartType.value)) {
          mode = 'svg';
          Console.warn("Fallback: ".concat(chartType.name, " was rendered on svg mode"));
        }
      });
      geoMap.renderer = [];
      geoMap.rendererConf = [];

      renderer.mode = mode;
      renderer.MODE = mode.toUpperCase();

      geoMap.extraParams = { labelQueue: [], notesArray: [], labelArray: {}, barDatasetIndex: 0 };
    };

    /**
     *
     */
    GeoPlotRenderer.prototype.draw = function () {
      var plotRenderer = this,
        geoMap = plotRenderer.geoMap,
        systemConfig = geoMap.systemConf;

      geoMap.chartRendered = false;

      // fire plot start event on first load
      // #ZC1732
      stateChangeListener(geoMap, systemConfig.chart.plot.events, 'plot', 'init');

      //setup z scale
      geoMap.setupZScale();

      plotRenderer.renderSeries();

      plotRenderer.transformWrap();
      renderer_helpers.renderCompletedEvents(geoMap, geoMap.updating, geoMap.extraParams, function () {
        if (!geoMap.updating) {
          geoMap.animate();
          geoMap.updating = false;
        } else {
          // ZC1740
          geoMap.chartRendered = true;
        }
      });
    };

    GeoPlotRenderer.prototype.update = function () {
      this.draw();
    };

    /**
     * render all the series
     */
    GeoPlotRenderer.prototype.renderSeries = function () {
      var plotRenderer = this,
        geoMap = plotRenderer.geoMap,
        systemConfig = geoMap.systemConf,
        allChartSeries = renderer_helpers.arrangeSeriesRenderingOrder(geoMap) || [],
        chartSeries,
        scaleProxy = d3_scaleLinear();

      geoMap.rendererArranged = [];

      each(allChartSeries, function (series, index) {
        var seriesIndex = pick(series.seriesidx, index),
          chartType = geoMap.chartTypes[seriesIndex];

        // define the bubble pie renderer index
        if (isUndefined(geoMap.bubblePieRendererIndex) && chartType.value === charttype.geobubblepie) {
          geoMap.bubblePieRendererIndex = seriesIndex;
        }

        chartSeries = geoMap.renderer[seriesIndex];

        if (!defined(chartSeries) && GeoSeriesTypes.has(chartType.name)) {
          chartSeries = new (GeoSeriesTypes.get(chartType.name))(series, geoMap, seriesIndex);
          geoMap.renderer[seriesIndex] = chartSeries;
          geoMap.rendererConf[seriesIndex] = new plot.rendererConf();
        }

        if (chartType.name === 'geoheatmap') {
          renderer_helpers.setRendererProp(geoMap, chartSeries, series, seriesIndex, 0, geoMap.extraParams);
        }

        geoMap.rendererArranged.push(chartSeries);

        // fix the scale dependency with a proxy.
        scaleProxy.origRange = [0, 0];
        geoMap.rendererConf[seriesIndex].
        xscale(scaleProxy).
        yscale(scaleProxy).
        datasetIndex(seriesIndex).
        legendOrderIndex(seriesIndex);

        clearTimeout(chartSeries.renderedTimer);

        chartSeries.render(geoMap.updating);
      });

      geoMap.rendererArrangedReveresd = geoMap.rendererArranged.slice(0).reverse();
    };

    /**
     *
     * @param {GeoHeatMapSeries|GeoBubbleSeries|MapSeries} mapSeries
     */
    GeoPlotRenderer.prototype.triggerChartRendering = function (mapSeries) {
      var plotRenderer = this,
        geoMap = plotRenderer.geoMap,
        series = mapSeries.series,
        seriesIndex = mapSeries.index,
        chartName = geoMap.chartTypes[seriesIndex].name;

      if (!defined(mapSeries.chartRenderer)) {
        mapSeries.chartRenderer =
        plotRenderer.MODE === 'CANVAS' ?
        plot.canvasRenderer.createCanvasRenderer(chartName) :
        plot.svgRenderer.createSVGRenderer(chartName, geoMap);
      }

      // hide it
      geoMap.container.select('.highlight-canvas').style('visibility', 'hidden');

      mapSeries.commonRendererProp = mapSeries.chartRenderer.commonRendererProp;
      renderer_helpers.setRendererProp(geoMap, mapSeries.chartRenderer, series, seriesIndex, 0, geoMap.extraParams);

      // assign the chartRendered property in the new instance
      if (!mapSeries.hasOwnProperty('chartRendered')) {
        Object.defineProperty(mapSeries, 'chartRendered', {
          get: function get() {
            return mapSeries.chartRenderer.chartRendered;
          }
        });
      }

      // finally render it
      plotRenderer["render".concat(plotRenderer.MODE)](mapSeries);

      // map the seriesdataAfterUpdate
      if (!mapSeries.hasOwnProperty('seriesdataAfterUpdate')) {
        Object.defineProperty(mapSeries, 'seriesdataAfterUpdate', {
          get: function get() {
            return pick(mapSeries.chartRenderer.seriesdataAfterUpdate);
          }
        });
      }
    };

    /**
     *
     * @param {GeoScatterSeries|GeoBubbleSeries|GeoBubblePieSeries} mapSeries
     */
    GeoPlotRenderer.prototype.renderSVG = function (mapSeries) {
      var plotRenderer = this,
        geoMap = plotRenderer.geoMap,
        series = mapSeries.series;
      plot.svgRenderer.drawSVG(geoMap, geoMap.seriesdata, mapSeries.chartRenderer);
    };

    /**
     *
     * @param {GeoScatterSeries|GeoBubbleSeries} mapSeries
     */
    GeoPlotRenderer.prototype.renderCANVAS = function (mapSeries) {
      var plotRenderer = this,
        geoMap = plotRenderer.geoMap,
        series = mapSeries.series;

      plot.canvasRenderer.drawCanvas(geoMap, series, mapSeries.chartRenderer);
    };

    GeoPlotRenderer.prototype.transformWrap = function () {
      var geoMap = this.geoMap,
        plotArea = geoMap.plotarea;

      // label container
      geoMap.staticPaneSVG.select('.labelholder').attr('transform', "translate(".concat(plotArea.left, ",").concat(plotArea.top, ")"));
    };

    /**
     *
     * @param zoomPosition
     * @param scale
     * @param zoomInstance
     * @constructor
     */
    function ZoomToPosition(zoomPosition, scale, zoomInstance) {
      switch (zoomPosition.type) {
        case 'bound':{
            zoomInstance.zoomToBounds(zoomPosition[zoomPosition.type], scale);
            break;
          }
        case 'rect':{
            zoomInstance.zoomToRect(zoomPosition.rect, scale);
            break;
          }
        case 'point':{
            zoomInstance.zoomToPoint(zoomPosition.point, scale);
            break;
          }
        case 'rotate':{
            zoomInstance.rotateTo(zoomPosition.rotate, scale);
            break;
          }}

    }var

    ZC_MapEvents = /*#__PURE__*/function (_ZC_ChartEvents) {_inherits(ZC_MapEvents, _ZC_ChartEvents);var _super19 = _createSuper(ZC_MapEvents);function ZC_MapEvents() {_classCallCheck(this, ZC_MapEvents);return _super19.apply(this, arguments);}_createClass(ZC_MapEvents, [{ key: "init", value:
        function init() {
          _get(_getPrototypeOf(ZC_MapEvents.prototype), "init", this).call(this);
          this.addListeners(this.tracker);

          this.eventManager.dataFinder({
            mousemove: ZC_MapEvents.findGeoData,
            click: ZC_MapEvents.findGeoData,
            doubleclick: ZC_MapEvents.findGeoData
          });

          this.eventManager.defaultBehaviour = getPlotDefaultBehaviour();
          this.eventManager.customBehaviour = ZC_ChartEvents.getCustomBehaviour;
        } }, { key: "addListeners", value:

        function addListeners(tracker, type) {
          _get(_getPrototypeOf(ZC_MapEvents.prototype), "addListeners", this).call(this, tracker, type);
        } }], [{ key: "findGeoData", value:

        function findGeoData(mouse) {
          var geoMap = this.chart,
            mapEvents = this.chart.eventHandler.mapEvents,
            geoPoint = new GeoPoint(mouse.x, mouse.y),
            pointObj = mapEvents.getPoint(geoPoint),
            point = pointObj ? pointObj.point : null;
          if (point) {
            pointObj.seriesIndex = point.seriesIndex;
            pointObj.itemIndex = point.itemIndex;
          }

          return {
            nearest: pointObj
          };
        } }]);return ZC_MapEvents;}(ZC_ChartEvents);


    function getGeoEnclosedPoints(data, key, mouse, mode, chart) {
      var accessor = chart.eventHandler.dataAccesor(mouse),
        searchCache = chart.cache.search,
        enclosed,
        tree;

      if (mode == 'QUADTREE') {
        var d = data,
          radius = accessor.radius(key),
          sizeOffset = accessor.sizeOffset(key),
          _extent3 = accessor.extent(),
          size = accessor.size(key),
          pane = '0_0';
        tree = searchCache["".concat(pane, "_").concat(key, "_").concat(mode)] || new Quadtreesearch(d, size, radius, _extent3, sizeOffset);
        enclosed = tree.find(mouse);
      }

      return enclosed;
    }

    //map-constructor.js

    var ZoomD3$1 = Registry.getComponent('ZoomD3');
    /**
     * The default map collection
     * @type {{}}
     */
    var mapCollections = {};

    /**
     *
     * @constructor
     */
    function GeoMap(container, data) {
      // define axis object for color axis (heatmap|choropleth)
      this.axes = {
        x: {},
        y: {}
      };

      VizLayout.call(this, container, data);
      this.initialize();
    }

    inherit(GeoMap, VizLayout);
    GeoMap.helpers = VizLayout.helpers; //IE

    // add a global type holder to keep all series types.
    GeoMap.SeriesTypes = GeoSeriesTypes;

    /**
     *
     * @return {{name: string}}
     */
    GeoMap.getDefaultProjection = function () {
      return {
        name: 'geoMercator'
      };
    };

    /**
     *
     * @param layers
     * @param layerName
     * @return {*}
     */
    GeoMap.getGeoJSON = function (layers, layerName) {
      // if the layer is Topojson convert it to Geojson
      // because d3 tools works purely in Geojson
      if (defined(layers) && MapLayer.GEO_FORMATS.has(layers.type) && layers.type === 'Topology') {
        // get the default projection settings from data
        // because it will be whipped off while geojson conversion.
        var projectionSettings = layers.projection;

        // convert the topojson to geojson
        layers = topojson.feature(layers, layers.objects[layerName]);

        // apply the default projection settings in converted geojson
        if (defined(projectionSettings)) {
          layers.projection = projectionSettings;
        }
      }
      return layers;
    };

    /**
     * The main map initializer.
     */
    GeoMap.prototype.initialize = function () {
      // inti the color axes
      var geoMap = this,
        userData = geoMap.userdata,
        userMapConfig = userData.map,
        hasSvgOnly = geoMap.chartTypes.some(function (chartType) {
          return arrayIncludes(chartcategory.svgOnly, chartType.value);
        });

      // add a ID
      geoMap.id = "ZC_GEO_".concat(geoMap.idNumeric);

      if ($Browser.IE && parseFloat($Browser.VERSION) < 11) {
        geoMap.fixIE = true;
      }

      // setup the internal config container
      geoMap.geo = {
        layerCount: 0,
        extraLayers: {},
        extraLayersRenderingOrder: ['globe', 'graticule', 'allAreas', 'backgroundLayer'],
        utils: {},
        highlightUtils: {},
        rawLayers: [],
        customLayers: d3_map()
      };
      geoMap.timerObj = new Array(0);
      // process the data
      geoMap.processUserData(geoMap.themeoptions);

      // fill color error
      geoMap.plot = {};
      geoMap.geo.isCanvasMode = geoMap.systemConf.map.renderingMode.toLowerCase() !== 'svg';
      geoMap.geo.isPlotCanvasMode = geoMap.systemConf.chart.plot.renderer.mode.toLowerCase() !== 'svg' && !hasSvgOnly;

      // create all the needed elements
      GeoMap.helpers.constructChartGroups(geoMap);

      // get the series holder
      geoMap.seriesContainer = geoMap.wrap.select('.seriesholder');
      geoMap.chartGroup = geoMap.svg.select('.chartgroup');

      // start rendering
      var legendHighlight = Registry.getComponent('LegendHighlight');
      geoMap.legendHighlight = legendHighlight(this, this.wrap);

      geoMap.render();
    };

    /**
     *
     */
    GeoMap.prototype.render = function () {
      var geoMap = this,
        systemConfig = geoMap.systemConf,
        animate = systemConfig.map.animation.enabled && !geoMap.updating;

      animate = animate && (geoMap.dataObject.hasHeatmap && !geoMap.dataObject.hasPointChart || !geoMap.seriesdata.length);

      /**
       * **************************************************************
       *
       * Setting up the main container and legend
       */
      // get the series holder
      geoMap.seriesContainer = geoMap.wrap.select('.seriesholder');
      geoMap.chartGroup = geoMap.svg.select('.chartgroup');

      // after processing set the chart dimension
      geoMap.setChartDimension();
      // render the container
      geoMap.updateCanvasArea();

      geoMap.applyChartProperties();

      // if all areas is false and data point also 0 then call no data
      if (!geoMap.hasGeoLayer || !systemConfig.map.allAreas && !geoMap.dataObject.totalDataCount) {
        // report no map layer found
        // #ZC1652
        geoMap.flushed = true;
        geoMap.clearMap();
        geoMap.hideLoading(geoMap.container);
        geoMap.handleNoData(systemConfig.noDataHandler);
        geoMap.chartRendered = true;
        geoMap.handleHiddenContainer(true);
        stateChangeListener(geoMap, systemConfig.canvas.events, 'chart', geoMap.updating ? 'onreload' : 'onload');
        return;
      } else if (!geoMap.dataObject.totalDataCount) {
        geoMap.flushed = true;
        geoMap.clearMap();
        geoMap.clearChart(null, null, true);
      }

      geoMap.clearNoData(systemConfig.noDataHandler);
      /**
       * **************************************************************
       *
       * Setting map rendering area, projection and path generator
       */

      // color dependency
      geoMap.getChartSeriesColor();
      geoMap.parseScale();

      if (geoMap.hasSeriesPoints) {
        // render the axis
        Registry.getComponent('legend.render')(geoMap);

        //#ZC1444
        tooltip_block_helpers.updatePlotarea4BlockTooltip(geoMap);

        // fix the legend position based on plot area
        // geoMap.fixLegendPosition();
      }

      //Adding block level annotations
      var annotation = Registry.getComponent('annotation');
      if (!annotation._empty) {
        annotation.addBlockAnnotations(geoMap);
      }

      geoMap.updatePlotareaProp();

      // setup the main container layer (svg|canvas)
      geoMap.setupFeatureContainerLayer();

      // draw the default background layer
      geoMap.setUpMapLayer();

      // IE fix
      // if animation is enabled
      if (animate) {
        geoMap.animateSelection = geoMap.container.
        selectAll('.geomap-features-series,.geomap-features-extras,.xychart,.static,.label-container,.labelholder').
        style('opacity', 0);
      }

      // fire plot start event on first load
      stateChangeListener(geoMap, systemConfig.map.events, 'map', 'init');

      // render the world out line
      geoMap.renderGlobe();

      // render graticule
      geoMap.renderGraticule();

      // render the map background layer
      geoMap.renderMapLayer();

      stateChangeListener(geoMap, systemConfig.map.events, 'map', geoMap.updating ? 'onreload' : 'onload');

      // render the custom layers added by the user
      if (geoMap.geo.customLayers.size()) {
        geoMap.geo.customLayers.each(function (layer) {return layer && layer.update();});
      }

      // return
      if (geoMap.plot.renderer) {
        geoMap.plot.renderer.draw(true);
      } else if (geoMap.hasSeriesPoints) {
        geoMap.plot = {
          renderer: new GeoPlotRenderer(geoMap)
        };
        geoMap.plot.renderer.draw();
      }

      geoMap.drawPlotBorder();

      geoMap.renderLabels();

      geoMap.handleEvent();

      // ZC1414
      geoMap.drawPlotareaClippath();

      if (!geoMap.plot.renderer) {
        geoMap.animate();
        stateChangeListener(geoMap, systemConfig.canvas.events, 'chart', geoMap.updating ? 'onreload' : 'onload');
        geoMap.updating = false;
      }
      geoMap.flushed = false;
    };

    /**
     * this will create the main container element based on the rendering mode.
     */
    GeoMap.prototype.setupFeatureContainerLayer = function () {
      var geoMap = this,
        geoConfig = geoMap.geo,
        layerNameCapitalized = toCapitalize(geoConfig.isCanvasMode ? 'canvas' : 'svg'),
        isGeoCanvasMode = geoConfig.isCanvasMode,
        isPlotCanvasMode = geoConfig.isPlotCanvasMode,
        mapArea = geoConfig.mapArea = Object.create(geoMap.plotarea);

      // translate the series holder.
      geoMap.seriesContainer.attr('transform', "translate(".concat(mapArea.left, ",").concat(mapArea.top, ")"));

      if (isGeoCanvasMode) {
        geoConfig.featureLayerExtra = plot.canvasRenderer.updateCanvasContext(
        geoMap,
        'geomap-features-extras',
        '.static',
        geoMap.chartParentElement);

        geoConfig.geoLabelLayer = geoConfig.featureSeriesLayer = plot.canvasRenderer.updateCanvasContext(
        geoMap,
        'geomap-features-series',
        '.static',
        geoMap.chartParentElement);

      } else {
        // geo config
        geoConfig.featureSeriesLayer = createElement('g', '.feature-layer-series', [1], geoMap.seriesContainer);
        geoConfig.geoLabelLayer = createElement('g', '.geo-label-layer', [1], geoMap.seriesContainer);
      }

      if (isPlotCanvasMode) {
        // data point config
        geoConfig.pointLabelLayer = geoMap.labelHolderContext = plot.canvasRenderer.updateCanvasContext(
        geoMap,
        'label-container',
        geoMap.fixIE ? '.static' : 'div.legendarea',
        geoMap.chartParentElement);

        geoConfig.pointLayer = plot.canvasRenderer.updateCanvasContext(geoMap, 'zc-canvas', '.static', geoMap.chartParentElement);
      } else {
        // data point config
        geoConfig.labelLayer = geoMap.staticPaneSVG.select('.labelholder').attr('transform', "translate(".concat(mapArea.left, ",").concat(mapArea.top, ")"));
      }
    };

    /**
     *
     * @param layer
     */
    GeoMap.prototype.setupLayerSettings = function (layer) {
      var geoMap = this,
        geoConfig = geoMap.geo,
        projection = geoConfig.utils.projection,
        rotation = projection && projection.rotate && projection.rotate(),
        behaviours = geoMap.behaviouralEvents && geoMap.behaviouralEvents.eventManager.behaviours || {},
        plotZoom = behaviours.PLOT_ZOOM;

      // setup the geo path renderer
      projection = geoConfig.utils.projection = geoConfig.highlightUtils.projection = geoMap.getProjection(layer);

      if (plotZoom) {
        var fitExtent = geoMap.getProjectionExtent();
        var transform = plotZoom.instance.getTransform(),
          baseProjectionTransform = __getBaseProjectionTransform(geoMap),
          _center2 = ZoomD3$1.centroid(GeoUtils.geoBoundToRect(fitExtent)),
          _translate3 = baseProjectionTransform.translate,
          _scale8 = baseProjectionTransform.scale;

        if (geoMap.geo.isGlobeMap) {
          projection.scale(baseProjectionTransform.scale * transform.k);
          projection.translate(_center2);
          projection.rotate(rotation);
        } else {
          projection.scale(_scale8 * transform.k);
          projection.translate([transform.x + _translate3[0] * transform.k, transform.y + _translate3[1] * transform.k]);
        }
      }

      // if (!defined(geoConfig.utils.projection)) {
      //     // projection = geoConfig.utils.projection = geoConfig.highlightUtils.projection = geoMap.getProjection(layer);
      // } else {
      //     let fitExtent = geoMap.getProjectionExtent();
      //
      //     if (geoMap.plotZoom) {
      //         let transform = geoMap.plotZoom.getTransform(),
      //         baseProjectionTransform = geoMap.plotZoom.__getBaseProjectionTransform(),
      //         center = Zoom.centroid(GeoUtils.geoBoundToRect(fitExtent)),
      //         translate = baseProjectionTransform.translate,
      //         scale = baseProjectionTransform.scale;
      //
      //         // if (geoMap.geo.isGlobeMap) {
      //         //     projection.scale(baseProjectionTransform.scale * transform.k);
      //         //     projection.translate(center);
      //         // } else {
      //         //     projection.scale(scale * transform.k);
      //         //     projection.translate([transform.x + translate[0] * transform.k, transform.y + translate[1] * transform.k]);
      //         // }
      //     } else {
      //         // projection.fitExtent(fitExtent, layer);
      //     }
      // }

      // set up the geo path with map projection
      geoConfig.utils.geoPath = d3_geoPath().projection(projection);
      geoConfig.highlightUtils.geoPath = d3_geoPath().projection(projection);

      // if canvas mode set the context in the geo path.
      if (geoConfig.isCanvasMode) {
        geoConfig.utils.geoPath.context(geoConfig.featureSeriesLayer);
      }
    };

    /**
     *
     * @param layer
     */
    GeoMap.prototype.getProjection = function (layer) {
      var geoMap = this,
        geoConfig = geoMap.geo,
        defaultLayer = geoConfig.defaultLayer.layerGeojson,
        userConfig = geoMap.systemConf.map,
        projectionSettings = pick(userConfig.projection, layer.projection, defaultLayer.projection),
        projection,
        geojsonLayer = layer,
        fitExtent = geoMap.getProjectionExtent();

      geoMap.geo.isGlobeMap = projectionSettings && projectionSettings.name === 'geoOrthographic';

      if (!defined(projectionSettings)) {
        projectionSettings = GeoMap.getDefaultProjection();
      } else if (geoMap.geo.isGlobeMap) {
        // if it is a globe map, render the complete globe
        geojsonLayer = {
          type: 'Sphere'
        };
      }
      // setup the geo path renderer
      projection = d3_zc[projectionSettings.name]();

      for (var prop in projectionSettings) {
        if (projectionSettings.hasOwnProperty(prop) && prop !== 'name' && projection[prop]) {
          projection[prop](projectionSettings[prop]);
        }
      }

      projection.fitExtent(fitExtent, geojsonLayer);

      return projection;
    };

    GeoMap.prototype.getProjectionExtent = function () {
      var geoMap = this,
        mapArea = geoMap.geo.mapArea,
        userConfig = geoMap.systemConf.map,
        extent = userConfig.extent;

      return [[extent.left, extent.top], [mapArea.width - extent.right, mapArea.height - extent.bottom]];
    };

    /**
     *
     * @param layer
     * @param styles
     * @param name
     * @param type
     * @param useMesh
     * @return {MapLayer}
     */
    GeoMap.prototype.addLayer = function (layer, styles, name, type, useMesh) {
      var geoMap = this,
        geoConfig = geoMap.geo,
        layerId = geoConfig.layerCount++,
        types = {
          series: geoConfig.featureSeriesLayer,
          extra: geoConfig.featureLayerExtra,
          highlight: geoConfig.highlightLayer
        },
        layerContainer = types[type];

      name = name || "map-layer-".concat(layerId);

      if (!geoConfig.isCanvasMode) {
        layerContainer = createElement('g', ".".concat(name), [name], geoConfig.featureSeriesLayer);
      }

      // layer, util, layerContainer, styles
      return new MapLayer(layer, geoConfig.utils, layerContainer, styles, geoMap, useMesh);
    };

    /**
     *
     * @param layer
     * @param styles
     */
    GeoMap.prototype.addGeoLayer = function (layer, styles) {
      var geoMap = this,
        customLayers = geoMap.geo.customLayers,
        layerId = "custom-geo-layer-".concat(geoMap.geo.layerCount++),
        mapLayer = geoMap.addLayer(layer, styles, layerId, 'extra', false);

      // save it
      customLayers.set(layerId, mapLayer);

      return layerId;
    };

    /**
     *
     * @param layerId
     */
    GeoMap.prototype.removeGeoLayer = function (layerId) {
      var geoMap = this;

      if (geoMap.geo.customLayers.has(layerId)) {
        geoMap.geo.customLayers.get(layerId).destroy();
        delete geoMap.geo.customLayers.remove(layerId);
      }
      GeoUtils.clearContext(geoMap.geo.featureLayerExtra);
      geoMap.repaintGeoLayer();
    };

    /**
     *
     */
    GeoMap.prototype.setupSvgLayer = function (styles) {
      var geoMap = this,
        geoConfig = geoMap.geo,
        mapArea = geoConfig.mapArea,
        userConfig = geoMap.systemConf.map;

      // move the feature layer
      geoConfig.featureSeriesLayer = createElement('g', '.feature-layer-series', [1], geoMap.seriesContainer);

      geoMap.seriesContainer.attr('transform', "translate(".concat(mapArea.left, ",").concat(mapArea.top, ")"));

      geoConfig.labelLayer = geoMap.staticPaneSVG.select('.labelholder').attr('transform', "translate(".concat(mapArea.left, ",").concat(mapArea.top, ")"));

      // plot labels rely on labelHolderContext
      if (geoMap.systemConf.chart.plot.renderer.mode === 'canvas') {
        geoMap.labelHolderContext = plot.canvasRenderer.updateCanvasContext(
        geoMap,
        'label-container',
        geoMap.fixIE ? '.static' : 'div.legendarea',
        geoMap.chartParentElement);

        geoConfig.pointLayer = plot.canvasRenderer.updateCanvasContext(geoMap, 'zc-canvas', '.static', geoMap.chartParentElement);
      }
    };

    /**
     *
     */
    GeoMap.prototype.setupCanvasLayer = function () {
      var geoMap = this,
        geoConfig = geoMap.geo;

      // insert before static svg
      geoConfig.featureLayerExtra = plot.canvasRenderer.updateCanvasContext(
      geoMap,
      'geomap-features-extras',
      '.static',
      geoMap.chartParentElement);

      geoConfig.featureSeriesLayer = plot.canvasRenderer.updateCanvasContext(
      geoMap,
      'geomap-features-series',
      '.static',
      geoMap.chartParentElement);


      if (geoMap.dataObject.hasPointChart) {
        geoConfig.pointLayer = plot.canvasRenderer.updateCanvasContext(geoMap, 'zc-canvas', '.static', geoMap.chartParentElement);
      }

      geoConfig.labelLayer = geoMap.labelHolderContext = plot.canvasRenderer.updateCanvasContext(
      geoMap,
      'label-container',
      geoMap.fixIE ? '.static' : 'div.legendarea',
      geoMap.chartParentElement);

    };

    /**
     *
     * @param {String} scopeName
     */
    GeoMap.prototype.getLayerData = function (scopeName) {
      var mapCollection = mapCollections;

      if (defined(mapCollection[scopeName])) {
        this.emptyMapLayer = false;
        return mapCollection[scopeName];
      } else {
        this.emptyMapLayer = true;
      }
    };

    /**
     * function to draw
     */
    GeoMap.prototype.setUpMapLayer = function () {
      var geoMap = this,
        systemConfig = geoMap.systemConf,
        dataProcessor = geoMap.dataObject,
        backgroundLayerData;

      if (systemConfig.map.allAreas) {
        var type = geoMap.geo.defaultLayer.layerGeojson.type;
        if (type !== 'FeatureCollection') {
          backgroundLayerData = geoMap.geo.defaultLayer.layerGeojson;
        } else {
          backgroundLayerData = dataProcessor.getMapFeatures('geojson');
        }
      } else {
        backgroundLayerData = dataProcessor.getUserMapFeatures('geojson');
      }

      geoMap.geo.renderedLayer = backgroundLayerData;
      // setup the default layer with the data
      geoMap.setupLayerSettings(backgroundLayerData);
    };

    /**
     *
     */
    GeoMap.prototype.setupZScale = function () {
      var geoMap = this,
        dataProcessor = geoMap.dataObject;

      if (dataProcessor.hasZaxis) {
        geoMap.zscale = geoMap.scales[0].create();
      }
    };

    GeoMap.prototype.renderGraticule = function () {
      var geoMap = this,
        graticuleConfig = geoMap.systemConf.map.graticule || {},
        graticuleEnabled = graticuleConfig.show === true,
        extraLayers = geoMap.geo.extraLayers;

      if (graticuleEnabled) {
        if (geoMap.updating && extraLayers.graticule) {
          extraLayers.graticule.update();
        } else {
          var graticule = d3_geoGraticule();
          extraLayers.graticule = geoMap.addLayer(graticule(), graticuleConfig, 'graticule', 'extra');
        }
      } else if (defined(extraLayers.graticule)) {
        extraLayers.graticule.destroy();
        extraLayers.graticule = null;
      }
    };

    GeoMap.prototype.renderGlobe = function () {
      var geoMap = this,
        mapConfig = geoMap.systemConf.map,
        projection = mapConfig.projection || {},
        enabledGlobe = projection.name === 'geoOrthographic' && !defined(mapConfig.globe.show),
        extraLayers = geoMap.geo.extraLayers;

      // temp globe outer border
      if (enabledGlobe || mapConfig.globe.show) {
        if (geoMap.updating && extraLayers.globe) {
          extraLayers.globe.update();
        } else {
          extraLayers.globe = geoMap.addLayer(
          {
            type: 'Sphere'
          },
          mapConfig.globe,
          'sphere',
          'extra');

        }
      } else if (defined(extraLayers.globe)) {
        extraLayers.globe.destroy();
        extraLayers.globe = null;
      }
    };

    /**
     *
     */
    GeoMap.prototype.renderMapLayer = function () {
      var geoMap = this,
        systemConfig = geoMap.systemConf,
        dataProcessor = geoMap.dataObject,
        userMapConfig = systemConfig.map,
        remainingAreas = dataProcessor.userUnmatchedMapFeatures.values();

      //if the map does not contain heat map render the map as background layer
      if (!dataProcessor.hasHeatmap) {
        // var backgroundLayer = MapDataProcessor.helpers.arrayToGeojson(dataProcessor.userMapFeatures.values());
        var defaultLayer = geoMap.geo.defaultLayer.layerGeojson,
          backgroundLayerFeatures;

        if (defaultLayer.type !== 'FeatureCollection') {
          backgroundLayerFeatures = defaultLayer;
        } else {
          backgroundLayerFeatures = dataProcessor.userMapFeatures.values();
        }
        if (backgroundLayerFeatures.length || backgroundLayerFeatures.type) {
          geoMap.geo.extraLayers.backgroundLayer = geoMap.addLayer(
          backgroundLayerFeatures,
          userMapConfig,
          'background-layer',
          'extra',
          userMapConfig.useMeshOutline);

        }
      }

      // fix all area
      if (geoMap.updating && geoMap.geo.extraLayers.allAreas && !geoMap.flushed) {
        geoMap.geo.extraLayers.allAreas.update(remainingAreas);
      } else if (userMapConfig.allAreas) {
        if (!dataProcessor.userUnmatchedMapFeatures.empty()) {
          geoMap.geo.extraLayers.allAreas = geoMap.addLayer(
          remainingAreas,
          userMapConfig,
          'all-areas-layer',
          'extra',
          userMapConfig.useMeshOutline);

        }
      }
    };

    GeoMap.prototype.renderLabels = function () {
      var geoMap = this;
      geoMap.geo.geoLabels = new GeoLabels(geoMap);
    };

    /**
     *
     */
    GeoMap.prototype.handleEvent = function () {
      var geoMap = this,
        geoConfig = geoMap.geo;

      if ((!geoMap.updating || !geoMap.eventHandler) && geoMap.dataObject.totalDataCount) {
        geoMap.createEventGroups();

        // var eventHandler = (geoMap.eventHandler = events.mouseevents(
        //     geoMap,
        //     geoMap.tooltip.element,
        //     geoMap.systemConf,
        //     geoMap.plotarea,
        //     geoMap.dataset,
        //     null,
        //     null,
        //     null,
        //     null,
        //     geoMap.eventWrap,
        //     geoMap.seriesColor
        // ));
        var trackerGroup = createElement('g', '.trackerGroup', [1], geoMap.eventWrap).attr('pointer-events', 'all'),
          trackerElement = createElement('rect', '.eventhandler', [1], trackerGroup);

        var eventHandler = geoMap.eventHandler = new ZC_MapEvents(geoMap, trackerGroup);

        geoMap.eventHandler.trackerGroup = trackerGroup;
        geoMap.eventHandler.trackerElement = trackerElement;

        eventHandler.init();

        eventHandler.mapEvents = new zmaps.mapEvents(geoMap);

        initTooltip(geoMap);
        // this.eventHandler.handlers = handlers;
        // attachevents(trackerGroup, moveHandlers, null, options, 'chart');
        // attachevents(trackerGroup, clickHandlers, null, options, 'chartmove');
        // attachevents(trackerGroup, {}, touchHandlers, options);
        // trigger init
        // eventHandler.initializeListener();

        geoConfig.eventLayer = eventHandler.trackerElement.styles({
          'pointer-events': 'visible'
        });
      } else if (geoMap.eventHandler) ;else {
        return false;
      }

      // define a cache for event params holder
      geoMap.eventHandler.mapEvents.cache = d3_map();

      // drawBorderBox(geoMap.eventHandler.trackerElement, getPlotBoundingRect(geoMap));
      geoMap.positionEventTrackerElement();

      if (geoMap.behaviouralEvents) {
        geoMap.behaviouralEvents.update();
      } else {
        geoMap.behaviouralEvents = new BehaviouralEvents(geoMap);
      }

      geoMap.handleLegendEvents(); // Legend events
    };

    /**
     *
     */
    GeoMap.prototype.clearMap = function () {
      var geoMap = this;
      //clear the canvas before rendering canvas series

      GeoUtils.clearContext(geoMap.geo.featureLayerExtra);
      GeoUtils.clearContext(geoMap.geo.featureSeriesLayer);
      GeoUtils.clearContext(geoMap.geo.geoLabelLayer);
      GeoUtils.clearContext(geoMap.geo.pointLayer);
      GeoUtils.clearContext(geoMap.geo.pointLabelLayer);

      if (defined(geoMap.eventHandler)) {
        geoMap.eventHandler.mapEvents.clearHighlightedPoints();
      }
    };

    /**
     * Map data process initializer.
     *
     * @param baseSystemConf
     */
    GeoMap.prototype.processUserData = function (baseSystemConf) {
      var geoMap = this,
        series,
        systemConfig = geoMap.systemConf = mergeJSON$1(baseSystemConf, geoMap.userdata, true, true),
        userMapConfig = systemConfig.map,
        // get the layer data since we need to map before rendering
        geoLayerData = geoMap.getLayerData(userMapConfig.scope, userMapConfig.layerName);

      var _chartSpecGetter = Registry.getComponent('dataSplicer');
      if (geoMap.userdata.viewParser || geoMap.userdata._viewParser) {
        var _viewParser = Registry.getComponent('viewParser');
        geoMap.viewFlow = new _viewParser(geoMap.userdata.viewParser || geoMap.userdata, geoMap.userdata);
        _chartSpecGetter = Registry.getComponent('dataSplicer4ViewParser');
        geoMap.parserConfig = geoMap.viewFlow.init();
      }

      geoMap.dataSplicer = new _chartSpecGetter(geoMap.userdata, geoMap.systemConf, geoMap);

      // the first thing to do is call the state change after getting the system config
      if (!geoMap.updating) {
        stateChangeListener(geoMap, geoMap.systemConf.canvas.events, 'chart', 'init');
      }

      series = getPropVal(systemConfig, 'seriesdata') || {};
      geoMap.seriesdata = series.chartdata || [];

      // set the default layer
      var defaultLayer = geoMap.geo.defaultLayer = {
        layerGeojson: GeoMap.getGeoJSON(geoLayerData, userMapConfig.layerName),
        layerOriginal: geoLayerData
      };

      if (defaultLayer.layerGeojson) {
        geoMap.hasGeoLayer = true;
        geoMap.dataset = new MapDataSet(geoMap);
        geoMap.dataObject = new MapDataProcessor(geoMap);
        geoMap.hasSeriesPoints = geoMap.dataObject.totalDataCount > 0;
        geoMap.nochartdata = !geoMap.hasSeriesPoints && geoMap.emptyMapLayer;
      } else {
        geoMap.hasGeoLayer = false;
        geoMap.nochartdata = true;
      }
    };

    GeoMap.prototype.addRemoveSeries = function () {
      var geoMap = this,
        eventHandler = geoMap.eventHandler;

      // set updating true for in root level so that every function knows
      geoMap.updating = true;

      geoMap.clearMap();

      // re initialize the procesor;
      geoMap.dataObject.initialize();

      geoMap.updatePlotareaProp();
      geoMap.drawPlotareaClippath();

      geoMap.repaintChart();
    };

    /**
     *
     */
    GeoMap.prototype.repaintChart = function () {
      var geoMap = this;

      // repaint the background layers
      geoMap.repaintGeoLayer();

      //update all series
      geoMap.eventHandler.mapEvents.cache.clear();
      geoMap.eventHandler.oldInfo = null;
      geoMap.plot.renderer.draw();
    };

    /**
     *
     */
    GeoMap.prototype.repaintGeoLayer = function () {
      var geoMap = this;
      each(geoMap.geo.extraLayers, function (layer) {return layer && layer.update();}); //#ZC1828
      geoMap.geo.customLayers.each(function (layer) {return layer && layer.update();}); // #ZC1828
      geoMap.geo.geoLabels.update(true);
    };

    /**
     *
     * @param point
     * @param {number|*} scale
     */
    GeoMap.prototype.zoomToPoint = function (point, scale) {
      this.__enableZoom();

      var geoMap = this,
        zoomInstance = this.behaviouralEvents.eventManager.behaviours.PLOT_ZOOM.instance,
        position = geoMap.renderer[point.seriesIndex].getZoomPosition(point);

      ZoomToPosition(position, scale, zoomInstance);
    };

    /**
     * TODO animation should be in plotoptions level
     * A very basic animation
     */
    GeoMap.prototype.animate = function () {
      var geoMap = this,
        mapConfig = geoMap.systemConf.map,
        animationConf = mapConfig.animation,
        selection = geoMap.animateSelection;

      if (selection && !geoMap.updating) {
        selection.
        transition().
        duration(animationConf.duration).
        ease(d3_ease(animationConf.easingType)).
        on('start', function () {
          selection.style('opacity', 0);
        }).
        on('end', function () {
          geoMap.chartRendered = true;
        }).
        attrTween('tween', function () {
          return function (t) {
            selection.style('opacity', t);
            return t;
          };
        });
      } else {
        geoMap.chartRendered = true;
      }
    };

    maps.GeoMap = GeoMap;

    //map-events.js

    /**
     *
     * @param {GeoMap} geoMap
     * @constructor
     */
    function MapEvents(geoMap) {
      this.geoMap = geoMap;
      this.initialize();
    }

    /**
     *
     * @param geoMap
     * @param coordinates
     * @return {*}
     */
    MapEvents.fixMouseCoordinates = function (geoMap, coordinates) {
      if (!coordinates) {
        return {
          x: null,
          y: null
        };
      }

      return {
        x: coordinates[0],
        y: coordinates[1]
      };
    };

    /**
     *
     * @param dataPoint
     * @return {{seriesPos: *, itemPos: *, subseriespos: *, data: *}}
     */
    MapEvents.fixEventArguments = function (dataPoint) {
      return {
        seriesPos: dataPoint.seriesIndex,
        itemPos: dataPoint.itemIndex,
        subseriespos: dataPoint.subSeriesIndex,
        data: dataPoint
      };
    };

    MapEvents.prototype.initialize = function () {
      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        mapConfig = geoMap.geo,
        utils_map = mapEvents.utils = mapConfig.utils,
        userMapConfig = geoMap.systemConf.map;

      mapEvents.eventConfig = pick(geoMap.systemConf.map.events, {});
      mapEvents.outerGeoBounds = utils_map.geoPath.bounds(mapConfig.defaultLayer.layerGeojson);

      var highlightElementParent = createElement('g', '.zcMapClipHighlight', [1], geoMap.staticPaneSVG, ':first-child').attr(
      'clip-path', "url(".concat(
      geoMap.defsLocation, "#highlight_group_clip_").concat(geoMap.id));


      mapEvents.highlightElement = createElement('g', '.map-highlight', [1], highlightElementParent).attr(
      'transform', "translate(".concat(
      geoMap.plotarea.left, ",").concat(geoMap.plotarea.top, ")"));


      // to save timers
      mapEvents.timers = {};

      mapEvents.highlightCache = {};
      mapEvents.outLine = mapEvents.getOutLine();
    };

    /**
     *
     * @param position
     * @param point
     * @param event
     * @param pointInfo
     * @param isSamePoint
     */
    MapEvents.prototype.showTooltip = function (position, point, event, pointInfo, isSamePoint) {
      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        XY = { x: 0, y: 0 },
        tooltipPosition,
        helpers,
        isOrdinal = true,
        seriesIndex = pointInfo.point.seriesIndex,
        chartType = geoMap.chartTypes[seriesIndex].value,
        plotOptions = geoMap.renderer[seriesIndex].plotOptions;

      if (pointInfo.type === 'feature' || !isSamePoint) {
        if (pointInfo.type === 'point') {
          isOrdinal = false;
          XY = geoMap.dataObject.getXYPoint(point);
        }

        tooltipPosition = getTooltipPosition(
        getEventObject(event),
        position,
        XY.x,
        XY.y,
        geoMap,
        point,
        false,
        false,
        {},
        isOrdinal,
        false,
        false);

        helpers = tooltipPosition.helpers;

        // if (chartType === $ZC.charttypes.geobubble || chartType === $ZC.charttypes.geobubble)

        if (isBubbleChartType$1(chartType)) {
          tooltipPosition.distance = geoMap.dataObject.getXYvalue(false, false, null, null, null, point, 'z') / 2;
        } else if (pointInfo.type === 'point' && true) {
          tooltipPosition.distance = (plotOptions.marker.size - 1) * 10;
        }

        helpers.itempos = point.itemIndex;
        helpers.subseriespos = point.subSeriesIndex;
        helpers.seriesindex = point.seriesIndex;

        geoMap.eventHandler.tooltipElement.show(geoMap, tooltipPosition, null, true, tooltipPosition.helpers);
      }
    };

    /**
     *
     */
    MapEvents.prototype.hideTooltip = function (immediate) {
      var mapEvents = this,
        delay = mapEvents.geoMap.systemConf.tooltip.hideDelay,
        tooltip = mapEvents.geoMap.eventHandler.tooltipElement;

      if (immediate) {
        tooltip.hide(tooltip.element);
      } else {
        clearTimeout(mapEvents.timers.tooltipDelay);
        mapEvents.timers.tooltipDelay = setTimeout(function () {
          tooltip.hide(tooltip.element);
        }, pick(delay, 150));
      }
    };

    /**
     *
     * @param {GeoPoint|LatLong|[number,number]} latLong
     */
    MapEvents.prototype.getPoint = function (latLong) {
      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        point = null,
        xy;

      if (latLong instanceof GeoPoint) {
        xy = latLong.toArray();
        latLong = latLong.toLatLong(mapEvents.geoMap).toArray();
      } else if (latLong instanceof LatLong) {
        xy = latLong.toXY(geoMap);
        latLong = latLong.toArray();
      }

      //check if the mouse is inside the actual map bounds
      var insideMapBound = mapEvents.outLine.some(function (outline) {
        return d3_polygonContains(outline, xy);
      });
      if (insideMapBound) {
        geoMap.rendererArrangedReveresd.some(function (series) {
          // check if event is available for the current series
          if (!geoMap.eventHandler.eventDisabled(series.series) && series.getPoint) {
            return point = series.getPoint(latLong, xy, series.index);
          }
        });
      }

      return point;
    };

    MapEvents.prototype.getPointsByIndex = function (seriesIndex, legendFilterIndex) {
      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        points = [];

      if (defined(legendFilterIndex)) {
        var flattenPoints = geoMap.dataObject.flattenPoints.get('geoheatmap');
        points = legend_helpers.filterSelectionByColor(flattenPoints, true, legendFilterIndex, geoMap);
      } else if (defined(seriesIndex)) {
        geoMap.seriesdata[seriesIndex].data.forEach(function (subPoint) {
          points = points.concat(subPoint);
        });
      }

      return points;
    };

    /**
     *
     * @param seriesIndex
     * @param color
     * @param type
     * @param from
     * @return {{fillColor}}
     */
    MapEvents.prototype.getHighlightEffect = function (seriesIndex, color, type, from) {
      var geoMap = this.geoMap,
        highlightEffect = geoMap.legendHighlight.getLegendHighlightEffect(seriesIndex, type, from),
        highlightStyle = {
          fillColor: TRANSPARENT
        };

      if (highlightEffect !== NONE) {
        if (geoMap.fixIE) {
          color = 'transparent';
        }

        highlightStyle = geoMap.legendHighlight.getEffect(
        highlightEffect,
        'area',
        color,
        {
          fill: TRANSPARENT,
          stroke: color
        },
        0,
        from,
        null,
        getChartTypeByIndex(geoMap, '0_0', seriesIndex).name);


        // #ZC2361
        highlightStyle = _objectSpread(_objectSpread({}, highlightStyle), {}, { strokeWidth: pick(highlightStyle.strokeWidth, 2), fillColor: highlightStyle.fill });
      }

      return highlightStyle;
    };

    /**
     *
     * @param points
     * @param type
     * @param styles
     */
    MapEvents.prototype.highlightPoints = function (points, type, styles) {
      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        scatterWrap = geoMap.eventWrap.selectAll('#zcscatterhighlight'),
        featureWrap = geoMap.staticPaneSVG.selectAll('g.map-highlight');
      clearHighlightContext(geoMap);
      switch (type) {
        case 'feature':{
            scatterWrap.attr('visibility', 'hidden');
            featureWrap.attr('visibility', 'visible');
            mapEvents.highlightGeoFeature(points, styles);
            break;
          }
        case 'point':{
            scatterWrap.attr('visibility', 'visible');
            featureWrap.attr('visibility', 'hidden');

            // remove existing point
            scatterWrap.selectAll('*').remove();
            scatterWrap.attr('visibility', 'visible');

            var seriesIndex = points.seriesIndex,
              subSeriesIndex = points.subSeriesIndex,
              itemIndex = points.itemIndex,
              chartType = geoMap.chartTypes[seriesIndex],
              xy = geoMap.dataObject.getXYPoint(points),
              plotOptions = geoMap.seriesdata[seriesIndex].plotoptions,
              commonPlotOptions = geoMap.systemConf.chart.plot.plotoptions[chartType.name],
              currentWrap = appendEle(scatterWrap, 'g', [1], '.', 'class', "highlight".concat(seriesIndex)),
              renderer = chartType.name == 'geobubblepie' ? geoMap.renderer[geoMap.bubblePieRendererIndex] : geoMap.renderer[seriesIndex],
              highlighter = renderer.chartRenderer.getHighlighter(geoMap),
              defaultH = highlighter._defaultH();
            points._x = xy.x;
            points._y = xy.y;

            points._size = renderer.chartRenderer.getSymbolSize(points);
            defaultH[0].path.call(highlighter, points, defaultH[0]);
            // geoMap.eventHandler.hoverScatter(
            //     currentWrap,
            //     chartType.value,
            //     plotOptions,
            //     commonPlotOptions,
            //     xy.x,
            //     xy.y,
            //     null,
            //     null,
            //     null,
            //     geoMap.seriesdata,
            //     subSeriesIndex,
            //     seriesIndex,
            //     itemIndex,
            //     false,
            //     null,
            //     false
            // );
          }}

    };

    /**
     *
     * @param points
     * @param styles
     */
    MapEvents.prototype.highlightGeoFeature = function (points, styles) {
      var mapEvents = this,
        geoMap = mapEvents.geoMap;

      mapEvents.highlightLayer = new MapLayer(points, geoMap.geo.highlightUtils, mapEvents.highlightElement, styles, geoMap);
    };

    /**
     *
     */
    MapEvents.prototype.clearHighlightedPoints = function () {
      this.geoMap.staticPaneSVG.selectAll('g#zcscatterhighlight, g.map-highlight').attr('visibility', 'hidden');
    };

    /**
     *
     * @return {d3.transform}
     */
    MapEvents.prototype.getTransform = function () {
      return d3_zoomTransform(this.geoMap.geo.eventLayer.node());
    };

    /**
     *
     * @param coordinates
     * @param type
     * @param event
     */
    MapEvents.prototype.handleEvent = function (coordinates, type, event) {
      // fix the coordinates
      coordinates = MapEvents.fixMouseCoordinates(this.geoMap, coordinates);
      event = event || d3_event();

      //***************************************************//

      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        geoPoint = new GeoPoint(coordinates.x, coordinates.y),
        point = mapEvents.getPoint(geoPoint),
        tooltipEnabled = geoMap.systemConf.tooltip.enabled !== false, // show by default
        actualEventType = pick(geoMap.zcEventType, type),
        oldPoint = geoMap.eventHandler.oldInfo,
        isSamePoint = !(!oldPoint || oldPoint.point !== (point && point.point));

      if (type === 'mouseout') {
        // get the point for mouse out
        point = geoMap.eventHandler.oldInfo;
      } else if (
      // mouseout if previously it had points and then second time no point is available.
      defined(geoMap.eventHandler.oldInfo) && !defined(point) ||
      // mouseout on doubletap or if the same point is being tapped twice.
      (actualEventType === 'doubletap' || actualEventType === 'tap' && isSamePoint) && type !== 'mouseout')
      {
        return geoMap.eventHandler.mapEvents.handleEvent(null, 'mouseout', geoMap.eventHandler.targetEvent);
        // return geoMap.eventHandler.mouseOut();
      }

      // if no point return
      if (!defined(point)) {
        return;
      }

      var dataPoint = point.point,
        seriesIndex = dataPoint.seriesIndex,
        mapSeries = geoMap.renderer[seriesIndex],
        plotOptions = mapSeries.plotOptions,
        customUserCallback = getEventConf(null, plotOptions, geoMap, actualEventType),
        eventHelpers = geoMap.eventHandler,
        immediateMouseOut = false,
        actionType = type,
        isTouchDevice = $Browser.isTouchDevice,
        defaultEventHash = {
          mousemove: 'handleMouseMove',
          click: 'handleMouseClick',
          mouseout: 'handleMouseOut'
        };

      // we are showing point on tap for touch devices
      if (isTouchDevice) {
        immediateMouseOut = true;
        // changing the actionType to mousemove for default action
        if (type === 'click') {
          assignTouchEventLog(actualEventType, geoMap);
          actionType = 'mousemove';
        }
      }

      // invoke the user custom function
      if (defined(customUserCallback)) {
        var action = triggerUserCallback(customUserCallback, point, event, null, geoMap);
        invokeFunction(action.callback, geoMap.eventHandler.targetEvent, action.args, geoMap);
      }

      /**
       * Handle default events here for all the event types (mouse & touch)
       */
      if (eventHelpers.eventManager.isDefaultAllowed(customUserCallback, event)) {
        if (defined(mapEvents[defaultEventHash[actionType]])) {
          mapEvents[defaultEventHash[actionType]](point, isSamePoint);
        }
      }

      // handle the mouse move
      if (actionType === 'mousemove') {
        // tooltip show of enabled
        if (tooltipEnabled) {
          clearTimeout(mapEvents.timers.tooltipDelay);
          mapEvents.showTooltip(coordinates, dataPoint, event, point, isSamePoint);
        }

        //add the cursor only once for a particular point
        if (!isSamePoint) {
          showCursor_C.call(
          geoMap.eventHandler.eventManager,
          coordinates,
          { nearest: dataPoint },
          getEventConf(null, mapSeries.plotOptions, geoMap, 'cursor'));

          // geoMap.eventHandler.addCursor(getEventConf(null, mapSeries.plotOptions, geoMap, 'cursor'));
          // save the point
          geoMap.eventHandler.eventManager.selectionManager.nearest = dataPoint;
          geoMap.eventHandler.oldInfo = point;

          geoMap.eventHandler.oldInfo.nearestPoint = MapEvents.fixEventArguments(dataPoint);
        }

        geoMap.eventHandler.reverseLegendHighlight.highlight(dataPoint);
        geoMap.eventHandler.unselectedHighlight.highlight(dataPoint);
      }
      // handle the mouse out
      else if (actionType === 'mouseout') {
        // hide show of enabled
        if (tooltipEnabled) {
          mapEvents.hideTooltip(immediateMouseOut);
        }

        // hide the cursor
        // geoMap.eventHandler.hideCursor();
        hideCursor_C.call(geoMap.eventHandler.eventManager);
        //ZC1434
        geoMap.eventHandler.reverseLegendHighlight.reset();
        geoMap.eventHandler.oldInfo = null; // clear it
      }
    };

    MapEvents.prototype.getOutLine = function () {
      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        outLinePath = document.createElementNS(d3_namespace('svg').space, 'path'),
        tempPath = d3_select(outLinePath).
        datum({
          type: 'Sphere'
        }).
        attr('d', geoMap.geo.highlightUtils.geoPath),
        outline = tempPath.attr('d');

      return outline.
      split('M').
      slice(1).
      map(function (segment) {
        segment = segment.slice(0, segment.length - 1);
        return segment.split('L').map(function (value) {
          return value.
          trim().
          split(/[,\s]/).
          map(function (value1) {
            return parseInt(value1);
          });
        });
      });
    };

    /**
     *
     * @param points
     * @return {d3.quadtree}
     */
    MapEvents.prototype.getTreeDiagram = function (points) {
      var mapEvents = this,
        geoMap = mapEvents.geoMap;

      return d3_quadtree().
      x(function (d) {
        return geoMap.dataObject.getXYPoint(d).x;
      }).
      y(function (d) {
        return geoMap.dataObject.getXYPoint(d).y;
      }).
      extent([
      [0, 0],
      [geoMap.plotarea.width, geoMap.plotarea.height]]).

      addAll(points);
    };

    /**
     *
     * @type {{getHighlightStyle: MapEvents.helpers.getHighlightStyle, handleMouseClick: MapEvents.helpers.handleMouseClick, handleMouseMove: MapEvents.helpers.handleMouseMove, handleMouseOut: MapEvents.helpers.handleMouseOut}}
     */
    MapEvents.prototype.handleMouseMove = function (pointInfo, isSamePoint) {
      var mapEvents = this,
        geoMap = mapEvents.geoMap,
        point = pointInfo.point,
        seriesIndex = point.seriesIndex;

      if (!isSamePoint) {
        var fillColor = getRawColor(geoMap, seriesIndex, point),
          highlightStyle = mapEvents.getHighlightEffect(seriesIndex, fillColor, 'selectedSeries', 'plot');

        if (pointInfo.type === 'feature') {
          point = pointInfo.feature;
        }
        mapEvents.highlightPoints(point, pointInfo.type, highlightStyle);
      }
    };

    MapEvents.prototype.handleMouseOut = function (point) {
      var mapEvents = this,
        geoMap = this.geoMap;

      mapEvents.clearHighlightedPoints();
      hideCursor_C.call(geoMap.eventHandler.eventManager);
    };

    MapEvents.prototype.handleMouseClick = function (point) {
      this.geoMap.eventHandler.mapEvents.hideTooltip(true);
    };

    zmaps.mapEvents = MapEvents;

    function GeoHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    var proto$k = GeoHighlighter.prototype;

    proto$k.data = function (point) {
      var chart = this.chart;
      // return function() {
      if (!chart.cache.data[point._key]) {
        chart.cache.data[point._key] = {};
      }
      var cache = chart.cache.data[point._key];
      if (!defined(cache._x)) {
        var transPoint = chart.dataObject.getXYPoint(point);
        cache._x = point._x = cache._x || transPoint.x;
        cache._y = point._y = cache._y || transPoint.y;
        if (chart.dataObject.hasZaxis) {
          cache._size = point._size = cache._size || chart.dataObject.getZFromPoint(point);
        }
        point._visible = true;
        cache._point = point;
      }
      // };
      return point;
    };

    //MapSeries.js

    /**
     *
     * @param {Object} series
     * @param {GeoMap} geoMap
     * @param {number} index
     * @constructor
     */
    function MapSeries(series, geoMap, index) {
      this.series = series;
      this.geoMap = geoMap;
      this.index = index;

      this.initialize();
    }

    /**
     *
     * @param geoMap
     * @param chartName
     * @return {*}
     */
    MapSeries.getPlotOptions = function (geoMap, chartName) {
      return getPropVal(geoMap.systemConf, "chart.plot.plotoptions.".concat(chartName));
    };

    MapSeries.prototype.initialize = function () {
      var mapSeries = this,
        geoMap = mapSeries.geoMap,
        chart = geoMap.chartTypes[mapSeries.index],
        gradientDimension = gradient_helpers.getDimension(geoMap, mapSeries.index);

      geoMap.context = pick(geoMap.geo.pointLayer, geoMap.geo.featureLayer);
      mapSeries.isCanvasMode = geoMap.geo.isCanvasMode;

      mapSeries.plotOptions = mergeJSON$1(MapSeries.getPlotOptions(geoMap, chart.name), pick(mapSeries.series.plotoptions, {}), true);
      mapSeries.fillColor = getFillColor(geoMap, mapSeries.index, null, gradientDimension, null, mapSeries.renderingMode);
      mapSeries.strokeColor = getStrokeColor(geoMap, mapSeries.index, gradientDimension);

      this.getHighlighter();
      return mapSeries;
    };

    /**
     *
     */
    MapSeries.prototype.update = function () {
      this.render(true);
    };

    MapSeries.prototype.getHighlighter = function () {
      this.highlighter = new GeoHighlighter(this.geoMap, this);
    };

    /**
     * This is used as a interface for zoom position
     */var
    ZoomPosition = /*#__PURE__*/function () {
      /**
       *
       * @param {string} type ex: bound, rect, point, rotate
       * @param {[[number, number], [number, number]]|[number, number]} point
       */
      function ZoomPosition(type, point) {_classCallCheck(this, ZoomPosition);
        this.type = type;
        this[type] = point;
      }_createClass(ZoomPosition, [{ key: "getPosition", value:

        function getPosition() {
          return this[this.type];
        } }]);return ZoomPosition;}();


    /**
     *
     * @param series
     * @param geoMap
     * @param index
     * @constructor
     */
    function GeoScatterSeries(series, geoMap, index) {
      MapSeries.call(this, series, geoMap, index);
    }

    // inherit from MapSeries
    inherit(GeoScatterSeries, MapSeries);
    maps.GeoMap.SeriesTypes.set('geoscatter', GeoScatterSeries);

    /**
     *
     */
    GeoScatterSeries.prototype.render = function () {
      var scatterSeries = this,
        geoMap = scatterSeries.geoMap;
      geoMap.plot.renderer.triggerChartRendering(scatterSeries);
    };

    /**
     *
     * @param point
     * @return {ZoomPosition}
     */
    GeoScatterSeries.prototype.getZoomPosition = function (point) {
      var geoMap = this.geoMap,
        transform = geoMap.behaviouralEvents.eventManager.behaviours.PLOT_ZOOM.instance.getTransform();

      return new ZoomPosition('point', transform.invert(geoMap.dataObject.getXYPoint(point).toArray()));
    };

    /**
     *
     * @param series
     * @param geoMap
     * @param index
     * @constructor
     */
    function GeoBubbleSeries(series, geoMap, index) {
      GeoScatterSeries.call(this, series, geoMap, index);
    }

    // inherit from MapSeries
    inherit(GeoBubbleSeries, GeoScatterSeries);

    // add HeatMapSeries to global holder
    maps.GeoMap.SeriesTypes.set('geobubble', GeoBubbleSeries);

    /**
     *
     * @param latLong
     * @param mousePosition
     * @param skipColorRangeCheck
     * @return {*}
     */
    GeoBubbleSeries.prototype.getPoint = function (latLong, mousePosition, skipColorRangeCheck) {
      var series = this,
        geoMap = series.geoMap,
        dataObject = geoMap.dataObject,
        chartName = geoMap.chartTypes[series.index].name,
        flattenPoints = dataObject.flattenPoints.get(chartName);

      if (!flattenPoints) {
        return null;
      }

      var enclosed = getGeoEnclosedPoints(flattenPoints, 'geobubble', mousePosition, 'QUADTREE', geoMap);

      var point = bubbleSelection(enclosed, { x: mousePosition[0], y: mousePosition[1] }, geoMap, 'bubble');

      if (point) {
        if (skipColorRangeCheck || isDataActive(point, geoMap)) {
          return {
            type: 'point',
            point: point
          };
        }
      }

      return;
    };

    /**
     *
     * @param series
     * @param geoMap
     * @param index
     * @constructor
     */
    function GeoBubblePieSeries(series, geoMap, index) {
      GeoBubbleSeries.call(this, series, geoMap, index);
    }

    // inherit from MapSeries
    inherit(GeoBubblePieSeries, GeoBubbleSeries);

    // add HeatMapSeries to global holder
    maps.GeoMap.SeriesTypes.set('geobubblepie', GeoBubblePieSeries);

    /**
     *
     * @param latLong
     * @param mousePosition
     * @return {*}
     */
    GeoBubblePieSeries.prototype.getPoint = function (latLong, mousePosition) {
      var bubblePieSeries = this,
        geoMap = bubblePieSeries.geoMap,
        dataObject = geoMap.dataObject,
        chartName = geoMap.chartTypes[bubblePieSeries.index].name,
        flattenPoints = dataObject.flattenPoints.get(chartName),
        enclosed = getGeoEnclosedPoints(flattenPoints, 'geobubblepie', mousePosition, 'QUADTREE', geoMap);

      if (enclosed) {
        var point = bubblePieSelection(enclosed, { x: mousePosition[0], y: mousePosition[1] }, geoMap, 'bubblepie');
        if (point && isDataActive(point, geoMap)) {
          return {
            type: 'point',
            point: point
          };
        }
      }
      return null;
    };

    defaultTheme.geoheatmap = function () {
      return {
        animation: {
          enabled: false
        },
        datalabels: {
          showAs: 'geo',
          fontWeight: 'bold',
          strokeColor: 'contrast',
          strokeWidth: 1.5,
          textOverlap: 'hidden'
        },
        gradients: {
          //linear | radial | none
          options: {
            linear: {
              y2: 100
            },
            radial: {
              radius: 100,
              gradientUnits: 'objectBoundingBox'
            }
          }
        }
      };
    };

    //heatmap-series.js
    /**
     *
     * @param series
     * @param geoMap
     * @param index
     * @constructor
     */
    function GeoHeatMapSeries(series, geoMap, index) {
      this.renderingMode = geoMap.systemConf.map.renderingMode;
      MapSeries.call(this, series, geoMap, index);
    }

    // inherit from MapSeries
    inherit(GeoHeatMapSeries, MapSeries);

    // add HeatMapSeries to global holder
    maps.GeoMap.SeriesTypes.set('geoheatmap', GeoHeatMapSeries);

    /**
     *
     * @param reset
     */
    GeoHeatMapSeries.prototype.render = function (reset) {
      var mapSeries = this.initialize(),
        geoMap = mapSeries.geoMap,
        NULL = null,
        mapFeatures = geoMap.dataObject.getUserMapFeatures(),
        plotOptions = mapSeries.plotOptions,
        gradient = plotOptions.gradients,
        defaultMapConfig = geoMap.systemConf.map,
        gradientEnabled = d3_set(['radial', 'linear']).has(gradient.type);

      mapSeries.features = [];
      mapSeries.seriesdataAfterUpdate = [];

      if (!mapSeries.series.disabled) {
        each(mapSeries.series.data, function (points, index) {
          points = geoMap.dataObject.updateSeriesdatabyCategories(d3_values(points));
          mapSeries.seriesdataAfterUpdate[index] = points;

          each(points, function (point, i) {
            var key = mapSeries.geoMap.dataset.getGeo(point);
            if (mapFeatures.has(key)) {
              var currentMapFeature = mapFeatures.get(key),
                gradientDimension = NULL;

              if (gradientEnabled) {
                var bbox_geo = GeoUtils.getFeatureGradientBBox(
                currentMapFeature,
                gradient.type,
                mapSeries.geoMap.geo.utils.geoPath);

                gradientDimension = [bbox_geo.width, bbox_geo.height];
                currentMapFeature.transform = {
                  x: bbox_geo.x,
                  y: bbox_geo.y
                };
              }

              /**
               * set style in each feature
               *
               * @type {{fillColor: *, strokeColor: *, strokeWidth: *, strokeStyle: *}}
               */
              currentMapFeature.styles = {
                fillColor: mapSeries.fillColor(
                mapSeries.index,
                point,
                NULL,
                NULL,
                mapSeries.plotOptions.fillOpacity,
                gradientDimension),

                strokeColor: mapSeries.strokeColor(
                mapSeries.index,
                point,
                pick(plotOptions.strokeColor, defaultMapConfig.strokeColor),
                NULL,
                plotOptions.strokeOpacity,
                i),

                strokeWidth: plotOptions.strokeWidth,
                strokeStyle: plotOptions.strokeStyle,
                fillOpacity: pick(plotOptions.fillOpacity, 1),
                strokeOpacity: pick(plotOptions.strokeOpacity, 1)
              };

              mapSeries.features.push(currentMapFeature);
            }
          });
        });
      }

      if (reset) {
        mapSeries.mapLayer.update(mapSeries.features);
      } else {
        mapSeries.mapLayer = mapSeries.geoMap.addLayer(
        mapSeries.features,
        NULL, "series-".concat(
        mapSeries.index),
        'series',
        defaultMapConfig.useMeshOutline);

      }

      if (labelRenderer) {
        geoMap.extraParams.labelQueue.push({
          renderer: mapSeries,
          charttype: 'scatter',
          chartObj: geoMap,
          args: [mapSeries.series, mapSeries.index]
        });
      }

      geoMap.timerObj[geoMap.timerObj.length] = mapSeries.renderedTimer = setTimeout(function () {
        mapSeries.chartRendered = true;
      }, 17);
    };

    GeoHeatMapSeries.prototype.commonRendererProp = function () {
      return this.geoMap.rendererConf[this.index];
    };

    /**
     *
     * @param point
     * @return {ZoomPosition}
     */
    GeoHeatMapSeries.prototype.getZoomPosition = function (point) {
      var geoMap = this.geoMap,
        transform = geoMap.behaviouralEvents.eventManager.behaviours.PLOT_ZOOM.instance.getTransform();

      if (geoMap.geo.isGlobeMap) {
        return new ZoomPosition('rotate', geoMap.dataObject.getLatLonPoint(point));
      } else {
        return new ZoomPosition(
        'bound',
        geoMap.geo.utils.geoPath.bounds(geoMap.dataObject.getFeatureByPoint(point)).map(function (b0) {return transform.invert(b0);}));

      }
    };

    /**
     *
     * @param latLong
     * @return {*}
     */
    GeoHeatMapSeries.prototype.getPoint = function (latLong, xy, seriesIndex) {
      var series = this,
        mapFeatures = series.features,
        geoMap = series.geoMap,
        dataObject = geoMap.dataObject,
        feature = arrayFind(mapFeatures, function (feature) {
          return d3_geoContains(feature, latLong);
        });

      if (feature) {
        var points = dataObject.userDataHashed.get(feature.properties[dataObject.joinByKey]),
          len = points.length,
          point;

        while (len--) {
          // #ZC2358 $pointSeriesIndex
          var pointSeriesIndex = points[len].seriesIndex;
          if (pointSeriesIndex === seriesIndex && !geoMap.seriesdata[pointSeriesIndex].disabled) {
            point = points[len];
            break;
          }
        }

        if (!geoMap.hasColorScale || geoMap.hasColorScale && isWithinColorRange(geoMap.dataset.getClr(point), geoMap)) {
          return {
            type: 'feature',
            feature: feature,
            point: point
          };
        }
      }
      return null;
    };

    /**
     *
     * @param {array} latLong
     * @param {array} XY
     * @return {*}
     */
    GeoScatterSeries.prototype.getPoint = function (latLong, XY) {
      var series = this,
        geoMap = series.geoMap,
        plotArea = geoMap.plotarea,
        dataObject = geoMap.dataObject,
        chartName = geoMap.chartTypes[series.index].name,
        flattenPoints = dataObject.flattenPoints.get(chartName),
        plotOptions = series.plotOptions,
        markerSizeFactor = 10,
        mouseX = XY[0],
        mouseY = XY[1];

      // ZC2358
      if (!isArray$1(flattenPoints)) {
        return;
      }
      // if the symbol is location type. add half of the size/2
      if (LOCATION_MARKERS.has(plotOptions.marker.symbol)) {
        mouseY += plotOptions.marker.size * markerSizeFactor / 2;
      }

      var point = getGeoEnclosedPoints(flattenPoints, 'geoscatter', [mouseX, mouseY], 'QUADTREE', geoMap);

      if (
      point &&
      // #ZC1805
      pointInRectangle(point._x, point._y, {
        x: 0,
        y: 0,
        width: plotArea.width,
        height: plotArea.height
      }))
      {
        if (!geoMap.hasColorScale || geoMap.hasColorScale && isDataActive(point, geoMap)) {
          return {
            type: 'point',
            point: point
          };
        }
      }
      return null;
    };

    //$Id$

    function getLineLayout(rp, serData, shiftInfo, yrangePos, paneid) {
      var chartObj = rp.chartObj,
        xscale = rp.xscale,
        yscale = rp.yscale,
        stacked = rp.stacked,
        index = rp.datasetIndex,
        axisrotated = rp.axisrotated,
        commonPlotOptions = rp.commonPlotOptions,
        yaxiscolumnorder = rp.yaxiscolumnorder,
        dataset = rp.dataset,
        systemconf = chartObj.systemConf,
        dataObject = chartObj.dataObject,
        yReversed = systemconf.chart.axes.yaxis[yaxiscolumnorder].reversed,
        plotoptions = (chartObj.seriesdata[index] || chartObj.seriesdata[0]).plotoptions,
        gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions),
        interpolation = $Browser.FIREFOX && serData.length == 1 ? 'linearClosed' : gvp('mode'), //Firefox fails to render path marker if 'd' has only 'M(x) (y)' ZC509
        layout;

      if (dataObject.isPolarAxisCategory) {
        layout = d3_lineRadial().
        defined(function (d, j) {
          return !d.isDummy;
        }).
        radius(function (d, j) {
          var adjustFactor = 0.1; // #ZC717 -> if path contains 'L0,0L0,0L0,0Z'
          var r = stacked ?
          yscale(d.y + d.y0) :
          yscale(dataset.getY(d, yaxiscolumnorder)) + (yscale.bandwidth != null ? yscale.bandwidth() / 2 : 0);
          return mathMax(r, yscale.range()[yReversed && !stacked ? yscale.domain().length - 1 : 0] + adjustFactor);
        }).
        angle(function (d, j) {
          return xscale(dataset.getX(d));
        }).
        curve(d3_curves(interpolation, axisrotated));
      } else {
        var cType = getChartTypeByIndex(chartObj, paneid, index),
          dataProcessorHelpers = DataProcessor.helpers,
          isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
          isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder);

        layout = d3_line().
        defined(function (d, j) {
          var nullData = !isCatNullY(dataset.getY(d, yaxiscolumnorder)) && !isCatNullX(dataset.getX(d));
          if (cType.value === charttype.stkdarea) {
            if (d.isDummy && d.isPrevDummy && d.isNextDummy) {
              // to remove stacked area with dummy data added - remove stroke line join
              return false;
            }
            return true;
          }
          return !d.isDummy && nullData;
        }).
        x(function (d, j) {
          var x = dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'x', null, yrangePos);
          if (shiftInfo != null) {
            var transX = Math.abs(
            dataObject.getXYvalue(
            axisrotated,
            stacked,
            chartObj.renderer[index].oldXscale,
            yscale,
            yaxiscolumnorder,
            serData[0],
            'x',
            null,
            yrangePos) -
            dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, serData[0], 'x', null, yrangePos));

            x = x + transX;
          }
          return x;
        }).
        y(function (d, j) {
          return chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'y', null, yrangePos);
        }).
        curve(d3_curves(interpolation, axisrotated, commonPlotOptions.tension));
      }
      return layout;
    }

    //$Id$

    canvas_plot_renderer.line = function () {
      var commonRendererProp,
        shiftInfo,
        yrangePos,
        scatter = canvas_plot_renderer.scatter();

      function chart(context, series, pattern, filterIndex) {
        var rp = commonRendererProp.params,
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          yscale = rp.yscale,
          index = rp.datasetIndex,
          legendOrder = rp.legendOrderIndex,
          rendererIndex = rp.rendererIndex,
          axisrotated = rp.axisrotated,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          labelQueue = rp.labelQueue,
          yaxiscolumnorder = rp.yaxiscolumnorder;

        var currentdata = series;
        currentdata = chartObj.dataObject.categoryHierarchy ? series[index] : chartObj.seriesdata[index];
        var plotoptions = currentdata.plotoptions;
        var gvp = commonRendererProp.params.gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions),
          xReversed = chartObj.systemConf.chart.axes.xaxis.reversed,
          gradientDim = gradient_helpers.getDimension(chartObj, index),
          canvasarea = chartObj.canvasarea;
        var paneid = "".concat(currentdata.row, "_").concat(currentdata.column);
        var tempChart = getChartTypeByIndex(chartObj, paneid, index),
          chartTypeNumeric = tempChart.value;
        var dashStyle = gvp('dashStyle'),
          strokeWidth = validateNullVal(gvp('strokeWidth'), 2),
          strokeOpacity = gvp('strokeOpacity'),
          strokeColor = getStrokeColor(chartObj, legendOrder, paneid, gradientDim, rp),
          markeroptions = commonRendererProp.params.markerOptions = plotoptions ?
          mergeJSON$1(commonPlotOptions.marker, plotoptions.marker, true) :
          commonPlotOptions.marker,
          hoverOptions = commonRendererProp.params.hoverOptions =
          plotoptions && plotoptions.hoveroptions ?
          mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
          commonPlotOptions.hoveroptions;

        var strokeLineCap = getLineCap(gvp('lineCap'), dashStyle),
          strokeDashArray = getDashArray(dashStyle, strokeWidth),
          markerEnabled =
          datacount_based_intelligence(chartObj, 'marker') &&
          dimension_based_intelligence(chartObj, 'marker', mathMin(canvasarea.width, canvasarea.height)) ?
          markeroptions.enabled :
          false;

        var datatypeX = chartObj.dataset.getDataType('x'),
          datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
          xCategories = datatypeX == ORDINAL_DATATYPE ? xscale.domain() : null,
          yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null;

        if (defined(pattern)) {
          context.lineWidth = pick(pattern['stroke-width'], strokeWidth);

          if (defined(filterIndex)) {
            markerEnabled = true;
            strokeOpacity = 0.00000001;
          }
        } else {
          context.lineWidth = strokeWidth;
        }
        if (!currentdata.disabled) {
          chart.seriesdataAfterUpdate = [];
          context.save();
          currentdata.data.forEach(function (d, i) {
            context.beginPath();
            var serData;
            if (datatypeX == ORDINAL_DATATYPE || datatypeY == ORDINAL_DATATYPE) {
              serData = chartObj.dataObject.updateSeriesdatabyCategories(d3_values(d), xCategories, yCategories, yaxiscolumnorder);
            } else {
              serData = d;
            }
            if (chartObj.renderVisiblePointsOnly) {
              serData = DataProcessor.helpers.filterPointsInViewport(chartObj, serData, 'line', 'x', index);
            }

            chart.seriesdataAfterUpdate[i] = serData;
            getLineLayout(rp, serData, shiftInfo, yrangePos, paneid).context(context)(serData);

            if (strokeDashArray.length && _typeof(strokeDashArray) === 'object' && defined(context.setLineDash)) {
              context.setLineDash(strokeDashArray);
              context.lineCap = strokeLineCap;
            }
            context.strokeStyle = strokeColor(legendOrder, NULL$1, gvp('strokeColor') || color, NULL$1, strokeOpacity, i);
            context.stroke();
          });
          context.restore();

          if (markerEnabled) {
            scatter.commonRendererProp(commonRendererProp).shiftInfo(shiftInfo);
            scatter.chartRendered = false;
            scatter(context, series, pattern, filterIndex);
          }
        }
        var markerSize = 0;
        if (!markerEnabled) {
          markerSize = markerEnabled ? (markeroptions.size || strokeWidth) * 0.5 * 10 + strokeWidth / 2 : 0;
          if (chartObj.dataObject.markerSize[tempChart.name]) {
            chartObj.dataObject.markerSize[tempChart.name].add(markerSize);
          }

          labelQueue.push({
            renderer: chart,
            charttype: 'scatter',
            chartObj: chartObj,
            rendererIndex: rendererIndex,
            paneid: paneid,
            args: [currentdata, index, markerSize]
          });
        }

        chart.getSymbolSize =
        scatter.getSymbolSize ||
        function () {
          return markerSize;
        };
        chart.chartRendered = true;
        return chart;
      }
      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          chart.highlighter = new LineHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };
      chart.commonRendererProp = function (_) {
        return !arguments.length ? commonRendererProp : (commonRendererProp = _) && chart;
      };
      chart.shiftInfo = function (_) {
        return !arguments.length ? shiftInfo : (shiftInfo = _) && chart;
      };
      return chart;
    };

    defaultTheme.line = function () {
      return {
        mode: 'linear', //linear,stepBefore,stepAfter,cardinal
        strokeWidth: 2,
        outerPadding: 0.02,
        stacked: {
          enabled: false,
          showAs: 'values' //values,percent
        },
        marker: {
          enabled: true,
          innerStrokeWidth: 2,
          outerFillColor: 'transparent',
          outerStrokeColor: 'transparent',
          useSVGMarkers: true
        },
        hoveroptions: {
          innerStrokeWidth: 2,
          outerFillOpacity: 0.5,
          outerStrokeOpacity: 0.1
        },
        datalabels: {
          showAs: 'y' //x,y,percent
        },
        animation: {
          type: 'strokeTween', //strokeTween,horiPathTween,vertPathTween,pointbypoint,pointTween
          marquee: {
            enabled: false,
            duration: 300
          },
          blink: {
            enabled: false,
            type: 'twinkle', //twinkle | fade
            duration: 800
          }
        },
        gradients: {
          // linear || none
          options: {
            linear: {
              x2: 10,
              spreadMethod: 'reflect' // pad || repeat || reflect
            }
          }
        }
      };
    };

    //$Id$

    /**
     *
     * @type {chart} line renderer.
     */
    svg_plot_renderer.line = function () {
      var commonRendererProp, xscale, yscale, index, dataset, axisrotated, yaxiscolumnorder, color;
      var line = [],
        scatter = svg_plot_renderer.scatter();
      var series,
        redraw = false,
        path,
        strokeDashArray,
        marqueeEnabled,
        marqueeDuration,
        marker;
      var stacked, labelQueue, commonPlotOptions, systemconf, hasNegValue, chartObj;
      var shiftInfo, yrangePos;
      var transitionDuration, animationType;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          yscale = rp.yscale,
          stacked = rp.stacked,
          index = rp.datasetIndex,
          axisrotated = rp.axisrotated,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          labelQueue = rp.labelQueue,
          hasNegValue = rp.hasNegValue,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset,
          systemconf = chartObj.systemConf;

          var renderingOrder = rp.renderingOrderIndex,
            legendOrder = rp.legendOrderIndex,
            rendererIndex = rp.rendererIndex,
            shapescale = rp.shapescale;

          var defsLocation = chartObj.defsLocation;

          var currentdata = data[index];
          var data_bind = { data: currentdata, index: renderingOrder };
          var plotoptions = currentdata.plotoptions;
          var currentseriesdata = currentdata.data;
          var paneid = "".concat(currentdata.row, "_").concat(currentdata.column);
          var tempChart = getChartTypeByIndex(chartObj, paneid, index),
            cType = tempChart.name,
            chartTypeNumeric = tempChart.value;
          var gvp = commonRendererProp.params.gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions),
            isRangeChart = cType == 'arearange',
            isPolar = chartObj.dataObject.isPolarAxisCategory,
            gradientDim = gradient_helpers.getDimension(chartObj, index),
            canvasarea = chartObj.canvasarea;
          var interpolation = gvp('mode'),
            dashStyle = gvp('dashStyle'),
            strokeWidth = validateNullVal(gvp('strokeWidth'), 2),
            strokeOpacity = gvp('strokeOpacity'),
            strokeColor = getStrokeColor(chartObj, index, paneid, gradientDim, rp),
            hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
            markeroptions = commonRendererProp.params.markerOptions =
            plotoptions && plotoptions.marker ?
            mergeJSON$1(commonPlotOptions.marker, plotoptions.marker, true) :
            commonPlotOptions.marker,
            hoverOptions = commonRendererProp.params.hoverOptions =
            plotoptions && plotoptions.hoveroptions ?
            mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
            commonPlotOptions.hoveroptions;

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, cType);
          var isAnimationEnable = animationOptions.enabled,
            easingType = animationOptions.easingType;
          transitionDuration = animationOptions.duration;
          animationType = animationOptions.type;
          animationType = animationType == VERTPATHTWEENALL_ANIMATION ? VERTPATHTWEEN_ANIMATION : animationType;

          var blinkConf =
          plotoptions && plotoptions.animation && plotoptions.animation.blink ?
          mergeJSON$1(commonPlotOptions.animation.blink, plotoptions.animation.blink, true) :
          commonPlotOptions.animation.blink;
          var race_syncTrans = chartObj.racing && chartObj.racing.syncTransition;
          var markerEnabled =
            hasColorScale || (
            datacount_based_intelligence(chartObj, 'marker') &&
            dimension_based_intelligence(chartObj, 'marker', mathMin(canvasarea.width, canvasarea.height)) ?
            markeroptions.enabled :
            false),
            strokeLineCap = getLineCap(gvp('lineCap'), dashStyle),
            callScatterRenderer =
            $Browser.IE ||
            $Browser.SAFARI ||
            interpolation == 'stepBefore' ||
            interpolation == 'stepAfter' ||
            interpolation == 'step-before' ||
            interpolation == 'step-after' ||
            rp.thresholdType ||
            hasColorScale ||
            shapescale ||
            $Browser.FIREFOX && blinkConf.enabled ||
            markeroptions.useSVGMarkers === false; // IE & SAFARI don't support marker updation. So, render the scatter chart instead of using marker.;
          strokeDashArray = getDashArray(dashStyle, strokeWidth);

          var marqueeOptions =
          plotoptions && plotoptions.animation && plotoptions.animation.marquee ?
          mergeJSON$1(commonPlotOptions.animation.marquee, plotoptions.animation.marquee, true) :
          commonPlotOptions.animation.marquee;
          marqueeEnabled = marqueeOptions.enabled;
          marqueeDuration = marqueeOptions.duration;

          var datatypeX = chartObj.dataset.getDataType('x'),
            datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
            xCategories = datatypeX == ORDINAL_DATATYPE ? xscale.domain() : null,
            yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
            categories =
            datatypeX == ORDINAL_DATATYPE && !defined(chartObj.dataObject.hierarchical) ?
            xCategories :
            chartObj.dataObject.getCategories('x');

          var yReversed = systemconf.chart.axes.yaxis[yaxiscolumnorder].reversed;
          if (datatypeX != ORDINAL_DATATYPE && categories.length == 0 && isAnimationEnable && animationType == POINTTWEEN_ANIMATION) {
            categories = chartObj.dataObject.findXCategories();
          }

          chart.seriesdataAfterUpdate = [];
          currentseriesdata.forEach(function (d, i) {
            var serData;
            if (datatypeX == ORDINAL_DATATYPE || datatypeY == ORDINAL_DATATYPE) {
              serData = chartObj.dataObject.updateSeriesdatabyCategories(d3_values(d), xCategories, yCategories, yaxiscolumnorder);
            } else {
              serData = d;
            }

            chart.seriesdataAfterUpdate[i] = serData;
            line[i] = getLineLayout(rp, serData, shiftInfo, yrangePos, paneid);
          });

          var container = d3_select(this);
          chart.update = function () {
            container.transition().call(chart);
          };
          var dynamicPosition = rp.dynamicSeriesPosition;
          if (dynamicPosition === undefined) {
            dynamicPosition = index;
          }
          series = appendEle(container, 'g', [data_bind], '.', 'class', "lineseries_".concat(dynamicPosition));
          series.node().index = index;
          if (isRangeChart) {
            series = appendEle(series, 'g', [data_bind], '.', 'class', "rangePos_".concat(yrangePos));
          }

          var markerID,
            mSize = isPolar ?
            {
              inner: 0.32,
              outer: 0.56
            } :
            {
              inner: 0.4,
              outer: 0.7
            };
          if (markerEnabled && !callScatterRenderer) {
            markeroptions.color = currentdata.color || getRawColor(chartObj, legendOrder, currentdata, index, paneid, rendererIndex);
            markerID = generateIdByPropValue(markeroptions, 'marker') + generateIdByPropValue(blinkConf, 'blink');
            marker = addSVGmarker(
            series,
            markerID,
            markeroptions,
            {
              color: markeroptions.color,
              symbolSize: mSize,
              strokeWidth: strokeWidth
            },
            chartObj);

            delete markeroptions.color;
          }

          if (markerEnabled && !callScatterRenderer) {
            blinkSVGsymbols(marker.selectAll('.outer,.inner'), blinkConf, chartObj);
          }

          if (markerEnabled && callScatterRenderer) {
            scatter.
            commonRendererProp(commonRendererProp).
            shiftInfo(shiftInfo).
            yrangePos(yrangePos);
            scatter.chartRendered = false;

            container.call(scatter);
          } else {
            container.selectAll("g.scatterseries_".concat(dynamicPosition)).remove();
          }

          currentseriesdata.forEach(function (d, i) {
            var ishideable = currentdata.disabled;

            // render the visible points only
            if (chartObj.renderVisiblePointsOnly) {
              chart.seriesdataAfterUpdate[i] = DataProcessor.helpers.filterPointsInViewport(
              chartObj,
              chart.seriesdataAfterUpdate[i],
              'line',
              'x',
              index);

            }
            var serData = chart.seriesdataAfterUpdate[i];
            if (chartObj.systemConf.chart.axes.xaxis.reversed) {
              serData = serData.slice(0).reverse();
            }
            var baseData = serData;

            var basedataShift,
              dummyDataLength = 0;

            var subseries = appendEle(
            series,
            'g',
            function (d) {
              return ishideable ? [] : [d];
            },
            '.',
            'class', "subseries_".concat(
            i));


            path = subseries.selectAll('path.line').data(function (d) {
              return ishideable ? [] : [d];
            });
            if (isAnimationEnable && animationType != STROKETWEEN_ANIMATION) {
              if (animationType == POINTTWEEN_ANIMATION) {
                //get baseData for starting animation
                baseData =
                serData.map(function (d, i) {
                  return Object.create(serData[0]);
                });
              } else {
                var idx = animationType == HORIPATHTWEEN_ANIMATION ? dataset.xidx : dataset.yidx(yaxiscolumnorder);
                var scaleObj = animationType == HORIPATHTWEEN_ANIMATION ? xscale : yscale;
                var baseIdx = isPolar && yReversed && !stacked ? scaleObj.domain().length - 1 : 0;
                baseData = serData.map(function (d, i) {
                  var s = Object.create(d);
                  if (d.isDummy) {
                    dummyDataLength++;
                  }
                  if (stacked && animationType != HORIPATHTWEEN_ANIMATION) {
                    s.y0 = 0;
                    s.y =
                    !isPolar && hasNegValue != null && scaleObj(hasNegValue) != null ?
                    mathMax(hasNegValue, scaleObj.domain()[0]) :
                    scaleObj.domain()[0];
                  } else {
                    if (isRangeChart && animationType == VERTPATHTWEEN_ANIMATION) {
                      var yArr = new Array(2);
                      var y0 = chartObj.dataset.getY(d, yaxiscolumnorder, 0);
                      yArr[0] = y0;
                      yArr[1] =
                      s[idx] == null ?
                      null :
                      hasNegValue != null && scaleObj(hasNegValue) != null ?
                      mathMax(hasNegValue, y0) :
                      y0;
                      s[idx] = yArr;
                    } else {
                      s[idx] =
                      s[idx] == null ?
                      null :
                      !isPolar && hasNegValue != null && scaleObj(hasNegValue) != null ?
                      mathMax(hasNegValue, scaleObj.domain()[0]) :
                      scaleObj.domain()[baseIdx];
                    }
                  }
                  return s;
                });
              }
              basedataShift = d3_values(baseData);
            }

            if (shiftInfo != null) {
              if (redraw) {
                var clipX = xscale(serData[0][0]) + (xscale.bandwidth != null ? xscale.bandwidth() / 2 : 0);
                var clipWid =
                chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                serData[serData.length - 1],
                'x',
                null,
                yrangePos) -

                chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                serData[0],
                'x',
                null,
                yrangePos);


                var properties = {
                    name: 'rect',
                    id: chartObj.id,
                    x: clipX,
                    y: 0,
                    width: clipWid,
                    height: chartObj.plotarea.height
                  },
                  args = {
                    chartObj: chartObj
                  };
                var clipID = effects.get(effects.svg_clips, 'rect', properties, args);
                series.attr('clip-path', "url(".concat(defsLocation, "#").concat(clipID, ")"));
              }
            }

            var pathEnter = path.
            enter().
            append('path').
            attr('class', 'line').
            datum(baseData, function (d) {
              return dataset.getX(d);
            }).
            attr('d', line[i]).
            style('stroke', currentdata.color || color).
            style('fill', NONE).
            style('stroke-width', strokeWidth).
            style('stroke-opacity', strokeOpacity == null || strokeOpacity === '' ? 1 : strokeOpacity);

            if (isAnimationEnable) {
              if (animationType == POINTBYPOINT_ANIMATION || animationType == POINTTWEEN_ANIMATION) {
                interTween(
                baseData,
                basedataShift,
                serData,
                categories,
                animationType,
                easingType,
                transitionDuration,
                rp,
                function (d) {
                  return {
                    d: line[i](d)
                  };
                },
                pathEnter);

              } else if (animationType == STROKETWEEN_ANIMATION) {
                strokeTween(pathEnter, easingType, transitionDuration);
              } else {
                var isEmpty = !serData.length || serData.length == 1 && !serData[0].length;
                isEmpty = stacked ? serData.length == dummyDataLength : isEmpty;
                if (isEmpty) {
                  pathEnter.attr('d', function (d) {
                    return line[i]([]);
                  });
                } else {
                  if (race_syncTrans) {
                    pathEnter.
                    transition(race_syncTrans).
                    attrTween('d', pathTween);
                  } else {
                    pathEnter.
                    transition().
                    duration(transitionDuration).
                    ease(easingType).
                    attrTween('d', pathTween);
                  }
                }
              }
            }

            var pathUpdate = pathEnter.
            merge(path).
            datum(serData, function (d) {
              return dataset.getX(d);
            }).
            attrs({
              id: "line_".concat(index),
              'stroke-dasharray': strokeDashArray
            }).
            styles({
              'stroke-linecap': strokeLineCap,
              'stroke-width': strokeWidth,
              'stroke-opacity': validateNullVal(strokeOpacity, 1),
              fill: NONE,
              stroke: strokeColor(index, NULL$1, gvp('strokeColor') || color, NULL$1, strokeOpacity, i)
            });

            var dataUpdate = serData;

            if (shiftInfo != null) {
              var transX =
              shiftInfo != null ?
              Math.abs(
              chartObj.dataObject.getXYvalue(
              axisrotated,
              stacked,
              chart.oldXscale,
              yscale,
              yaxiscolumnorder,
              serData[0],
              'x',
              null,
              yrangePos) -

              chartObj.dataObject.getXYvalue(
              axisrotated,
              stacked,
              xscale,
              yscale,
              yaxiscolumnorder,
              serData[0],
              'x',
              null,
              yrangePos)) :


              null;
              path.datum(dataUpdate).
              attr('d', line[i]).
              transition().
              duration(transitionDuration).
              ease(easingType).
              attr('transform', function () {
                return transX == null ? null : "translate(-".concat(transX, ",0)");
              });

              resetDashProp(path);
            } else if (pathEnter.node() == null) {
              if (race_syncTrans) {
                path.datum(dataUpdate).
                attr('transform', null).
                transition(race_syncTrans).
                attr('d', line[i]);

                /*
                 * Reset stroke-dasharray & stroke-dashoffset
                 * If animation.type = "strokeTween" & calling redraw before the animation completes
                 */
                resetDashProp(path);
              } else {
                path.datum(dataUpdate).
                attr('transform', null).
                transition()
                // .delay(((isAreaChart && ((animationType != POINTTWEEN_ANIMATION) || (animationType == POINTTWEEN_ANIMATION && redraw != false && currentdata.disabled != false))) ? 0 : transitionDuration))
                .duration(transitionDuration).
                ease(easingType).
                attr('d', line[i]);

                /*
                 * Reset stroke-dasharray & stroke-dashoffset
                 * If animation.type = "strokeTween" & calling redraw before the animation completes
                 */
                resetDashProp(path);
              }
            }
            var mID = markerEnabled && !callScatterRenderer ? "url(".concat(defsLocation, "#").concat(markerID, ")") : NULL$1,
              markerPosition = markeroptions.position,
              markerProperties = markerPosition ?
              {
                'marker-start': markerPosition.indexOf(START_ALIGN) > -1 ? mID : NULL$1,
                'marker-mid': markerPosition.indexOf(MIDDLE_ALIGN) > -1 ? mID : NULL$1,
                'marker-end': markerPosition.indexOf(END_ALIGN) > -1 ? mID : NULL$1
              } :
              {
                marker: mID
              };

            pathUpdate.styles(markerProperties);
            setOpacityForTickFilterElements(pathUpdate, chartObj, 'line');
            if (chartObj.dataObject.hierarchical) {
              pathUpdate.attr('levelbycolumn', function (d, i) {
                return d[0] && d[0].levelByColumn;
              });
              if (chartObj.dataObject.pivot) {
                pathUpdate.attr('levelbyrow', function (d, i) {
                  return d[0] && d[0].levelByRow;
                });
              }
            }

            pathEnter.exit().remove();

            function pathTween() {
              var interpolate = d3_interpolate(line[i](baseData), line[i](serData));
              return function (t) {
                return interpolate(t);
              };
            }
          });

          var markerSize = 0;
          if (!(callScatterRenderer && markerEnabled)) {
            markerSize = markerEnabled ? (markeroptions.size || strokeWidth) * 0.5 * 10 + strokeWidth / 2 : 0; //common 0.5 sizefactor for scatter, line, threshold
            labelQueue.push({
              renderer: chart,
              charttype: 'scatter',
              chartObj: chartObj,
              rendererIndex: rendererIndex,
              paneid: paneid,
              args: [currentdata, index, markerSize, yrangePos]
            });
            //Initiated in dataprocessor
            if (chartObj.dataObject.markerSize[cType]) {
              chartObj.dataObject.markerSize[cType].add(markerSize);
            }
          }

          chart.getSymbolSize =
          scatter.getSymbolSize ||
          function () {
            return markerSize;
          };
        });
        var chartInstance = commonRendererProp.params.chartObj;
        chartInstance.timerObj[chartInstance.timerObj.length] = chart.renderedTimer = setTimeout(
        function () {
          if (marqueeEnabled) {
            applyMarquee(series.selectAll("#line_".concat(index)), marqueeDuration, strokeDashArray, chart);
          }
          chart.chartRendered = true;
          redraw = true;
        },
        !redraw ? transitionDuration + 20 : 2 * transitionDuration + 20);


        chart.oldXscale = xscale;
        return chart;
      }

      //chart.prototype = new $ZC.renderer();
      function strokeTween(path, easingType, duration) {
        path.styles({
          'stroke-dasharray': function strokeDasharray() {
            return "".concat(this.getTotalLength(), " ").concat(this.getTotalLength());
          },
          'stroke-dashoffset': function strokeDashoffset() {
            return this.getTotalLength();
          }
        }).
        transition().
        duration(duration).
        ease(easingType).
        style('stroke-dashoffset', 0).
        on('end', function () {
          resetDashProp(d3_select(this));
        });
      }

      function resetDashProp(path) {
        path.styles({
          'stroke-dasharray': strokeDashArray,
          'stroke-dashoffset': null
        });
      }
      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          chart.highlighter = new LineHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };

      chart.yrangePos = function (_) {
        if (!arguments.length) {
          return yrangePos;
        }
        yrangePos = _;
        return chart;
      };
      return chart;
    };

    //$Id$

    function HierarchyDataProcessor(data, dataSet, chartInstance) {
      this.data = data;
      this.dataset = dataSet;
      this.chartObj = chartInstance;

      this.globalChartType = null;
      this.processedseriesData = chartInstance.seriesdata;

      this.initialize();
    }

    HierarchyDataProcessor.prototype.flattenData = DataProcessor.prototype.flattenData;
    HierarchyDataProcessor.prototype.getFlattenedSeriesData = DataProcessor.prototype.getFlattenedSeriesData;
    HierarchyDataProcessor.prototype.removeFlattenData = DataProcessor.prototype.removeFlattenData;

    HierarchyDataProcessor.prototype.initialize = function (state) {
      var processor = this,
        data = processor.data,
        dataset = processor.dataset,
        chartObj = processor.chartObj,
        processedseriesData = processor.processedseriesData,
        globalChartType = processor.globalChartType = data.seriesdata && data.seriesdata.type,
        helpers = DataProcessor.helpers;

      dataset.seriesTypes = d3_set();
      processor.totalnoofdatas = 0;
      processor.isNonAxisMultiSeriesCategory = true;
      processor.isHierarchy = true;
      processor.hasHierarchyData = chartObj.preProcessor.hasHierarchyData;
      processor.seriesExtermes = [[]];
      processor.annotation = [];

      chartObj.cache.data = {};
      chartObj.cache.search = {};
      chartObj.cache.customPoints = {};
      chartObj.cache.correction = {};

      function processHierachyData(parent) {
        parent.forEach(function (d, i) {
          if (isArray$1(d[0])) {
            processHierachyData(d);
          } else {
            var seriesIndex = +d.level.split('_')[0],
              currentdata = data.seriesdata.chartdata[seriesIndex],
              yaxiscolumnorder = helpers.getParsedYAxisOrder(currentdata.yaxiscolumnorder);

            if (!currentdata.disabled) {
              var yExtremes = d3_extent([d], function (d) {
                return dataset.getY(d, yaxiscolumnorder);
              });

              processor.seriesExtermes[0].push(yExtremes);
              processor.totalnoofdatas++;
            }
            saveAnnotation$3(d, chartObj, processor.annotation, seriesIndex);
          }
        });
      }

      if (processedseriesData && isArray$1(processedseriesData)) {
        setLevel(processedseriesData);
        processHierachyData(processedseriesData);
        processedseriesData.forEach(function (d, i) {
          var cType = helpers.getChartType(d.type || globalChartType, NUMERIC_DATATYPE);
          processor.singleSourceEvent = processor.singleSourceEvent || arrayIncludes(chartcategory.singleSourceEvent, cType);
          dataset.seriesTypes.add(cType);
        });
        // findSubFunction(processor, processedseriesData);
      }
    };

    // Data adapter
    var HierarchyDataAdapter = /*#__PURE__*/function () {
      function HierarchyDataAdapter(data, processor) {_classCallCheck(this, HierarchyDataAdapter);
        if (data && isArray$1(data)) {
          this.data = this.convert(data, processor);
          setLevel(this.data);
        } else {
          this.data = data;
        }
      }_createClass(HierarchyDataAdapter, [{ key: "convert", value:

        function convert(data, processor) {
          return dataToArray(data, processor);
        } }, { key: "getData", value:

        function getData() {
          return this.data;
        } }]);return HierarchyDataAdapter;}();


    function dataToArray(obj, processor) {
      return obj.map(function (d) {
        var arr;
        if (d.data && d.data[0] && isArray$1(d.data[0])) {
          arr = processor.hierarchical && processor.hierarchical.facetRendering ? simpleClone(d.data) : d.data; // Pivot hierarchy chart - on redraw throwing max call stack error
          var leafColors = d.leafColors;
          if (leafColors) {
            arr.forEach(function (d, i) {return d.color = leafColors[i % leafColors.length];});
          }
        } else if (d.data) {
          processor.hasHierarchyData = true;
          arr = dataToArray(d.data, processor);
        } else {
          arr = d;
        }

        for (var attr in d) {
          if (d.hasOwnProperty(attr) && attr !== 'data' && arr.constructor == Array || arr.constructor == Object) {
            arr[attr] = d[attr];
          }
        }

        return arr;
      });
    }

    function setLevel(node) {var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      node.forEach(function (d, i) {
        d.level = level != -1 ? "".concat(level, "_").concat(i) : "".concat(i);

        if (isArray$1(d[0])) {
          setLevel(d, d.level);
        }
      });
    }

    function saveAnnotation$3(curdata, chart, arr, seriesIndex) {
      var config = chart.systemConf.notes || {},
        dataIndex = config.dataIndex;

      if (isUndefined(dataIndex)) {
        return;
      }

      var data = curdata.data || curdata;
      if (data[dataIndex]) {
        arr.push({ data: curdata, subSeriesIndex: 0, itemIndex: 0, seriesIndex: seriesIndex });
      }
    }

    // Helper functions
    function getChildrenCount(dt, count) {
      if (!count) {
        count = 0;
      }

      dt.forEach(function (d) {
        if (isArray$1(d[0])) {
          count = getChildrenCount(d, count);
        } else {
          count++;
        }
      });
      return count;
    }

    Registry.setComponent('hierarchyDataProcessor', HierarchyDataProcessor);
    Registry.setComponent('hierarchyDataAdapter', HierarchyDataAdapter);

    defaultTheme.packedbubble = function () {
      return {
        fillOpacity: 0.2,
        outerPadding: 5,
        animation: {
          type: 'sizing' //sizing | fade | fadeAll
        },
        datalabels: {
          showAs: 'y' //x,y,percent //MODULARIZE
        }
      };
    };

    //$Id$

    var annotation$4 = Registry.getComponent('annotation');
    /**
     *
     * @returns {chart} packedbubble renderer.
     */
    svg_plot_renderer.packedbubble = function () {
      var pack = d3_pack(),
        isredraw = false,
        commonRendererProp,
        bubbleGroup,
        path,
        chartObj,
        commonPlotOptions,
        mode,
        seriesGroup = [],
        zchighlighterPosition,
        highlightGroup,
        highlightEle,
        multiColoring,
        valueFunction,
        includeDisabledSeries;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj;
          var color = rp.color,
            notesArray = rp.notesArray,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            dataset = rp.dataset,
            systemconf = chartObj.systemConf,
            labelQueue = rp.labelQueue,
            bound = rp.bound,_rp$rendererIndex8 = rp.rendererIndex,rendererIndex = _rp$rendererIndex8 === void 0 ? 0 : _rp$rendererIndex8;

          commonPlotOptions = rp.commonPlotOptions;
          var paneid = isFacet(chartObj) && "".concat(data[0].row, "_").concat(data[0].column),
            fillColor = [],
            strokeColor = [];

          var cloneddata = data.filter(function (d, i) {
              var rendererConf = chartObj.rendererConf[rendererIndex + i];
              d.seriesIndex = i;
              seriesGroup[i] = [];
              fillColor[i] = chart.fillColorFunc = getFillColor(chartObj, i, paneid, null, null, null, null, rendererConf.params);
              strokeColor[i] = getStrokeColor(chartObj, i, paneid, null, rendererConf.params);
              return !d.disabled;
            }),
            chartWidth = bound.width,
            chartHeight = bound.height,
            isSingleSeries = cloneddata.length === 1,
            isPatternPalleteEnabled = legend_helpers.hasPatternPallete(chartObj) || chartObj.patternPallete,
            notesOptions = chartObj.systemConf.notes,
            notesEnabled = notesOptions && notesOptions.enabled === true && notesOptions.plotValues;
          mode = commonPlotOptions.mode;
          multiColoring = isMultiColoring(commonPlotOptions, chartObj);

          var NegativeAsAbsolute = commonPlotOptions.showAsNegative === 'absolute',
            interPadding = +commonPlotOptions.interPadding || 0,
            outerPadding = +commonPlotOptions.outerPadding || 0,
            diameter = mathMin(chartWidth, chartHeight) - outerPadding;

          zchighlighterPosition = [
          chartObj.plotarea.left + (chartWidth - diameter) / 2 + rp.bound.x,
          chartObj.plotarea.top + (chartHeight - diameter) / 2 + rp.bound.y];

          valueFunction = function valueFunction(d) {
            if (!includeDisabledSeries && isDisabled(data, d)) {
              return 0;
            }
            var y = dataset.getY(d, yaxiscolumnorder) || 0;
            if (y < 0) {
              return NegativeAsAbsolute ? mathAbs(y) : 0;
            }
            return y;
          };

          var plotLevelOptions = function plotLevelOptions(d) {return d.depth && data[getSeriesPos(d)].plotoptions;},
            isEventEnabled = function isEventEnabled(d) {
              var plotOptions = plotLevelOptions(d);
              return validateNullVal(getEventConf(plotOptions, commonPlotOptions, chartObj, 'enabled'), true);
            },
            cursor = function cursor(d) {
              var plotOptions = plotLevelOptions(d);
              return isEventEnabled(d) ? getEventConf(plotOptions, commonPlotOptions, chartObj, 'cursor') || POINTER : NULL$1;
            };

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, null, chartObj, PACKEDBUBBLE_CHARTNAME);
          var isAnimationEnable = animationOptions.enabled,
            animationType = animationOptions.type,
            easingType = animationOptions.easingType,
            transitionDuration = isredraw ? isAnimationEnable ? 200 : 0 : animationOptions.duration;

          //Transition variables
          var initial_transform = function initial_transform(d) {
              var transform = d3_select(this).attr('transform');
              return transform != null ? transform : "translate(".concat(diameter / 2, ",").concat(diameter / 2, ")");
            },
            final_transform = function final_transform(d) {
              return "translate(".concat(d.x, ",").concat(d.y, ")");
            },
            initial_r = function initial_r(d) {
              var r = d3_select(this).attr('r');
              return r != null ? r : 0;
            },
            final_r = function final_r(d) {
              return d.r;
            },
            final_fillOpacity = function final_fillOpacity(d, i) {
              return commonPlotOptions.fillOpacity;
            },
            final_strokeOpacity = function final_strokeOpacity(d, i) {
              return commonPlotOptions.strokeOpacity;
            },
            isFade = !isredraw && (animationType === FADE_ANIMATION || animationType === FADEALL_ANIMATION);

          //Initializing pack layout
          pack.size([diameter, diameter]).padding(interPadding);

          bubbleGroup = appendEle(selection, 'g', [1], '.', 'class', 'hierarchychart');
          bubbleGroup.attr('transform', "translate(".concat((chartWidth - diameter) / 2, ",").concat((chartHeight - diameter) / 2, ")"));
          path = appendEle(bubbleGroup, CIRCLE_ELEMENT, getPackNodeDescendants(data, true));

          path.attrs({
            "class": function _class(d) {return "zc_packedbubble series_".concat(getSeriesPos(d));}
          }).style('visibility', function (d) {
            return isDisabled(data, d) ? 'hidden' : null;
          });

          path = path.filter(function (d) {
            return !isDisabled(data, d);
          });
          var packedData = getPackNodeDescendants(cloneddata);
          chart.total = packedData[0].value;
          path = path.data(packedData);

          path.attrs({
            transform: isFade ? final_transform : initial_transform,
            r: isFade ? final_r : initial_r
          }).styles({
            fill: function fill(d, i) {
              var seriesIndex = getSeriesPos(d);

              d.index = i;
              d.data.paneid = paneid;
              //Test_654.json
              d.r = d.r || 0;
              d.x = d.x || 0;
              d.y = d.y || 0;

              if (isFacet(chartObj)) {
                d.data._parent = d.parent;
              } else {
                d.data.parent = d.parent;
              }

              if (notesEnabled) {
                d.data.x = d.x;
                d.data.y = d.y;
              }

              if (!d.children && d.parent) {
                // Test_655.json
                seriesGroup[seriesIndex].push(d);
              }

              if (!d.depth) {
                d.arcColor = mode == 'flat' || multiColoring || isSingleSeries ? NONE : 'grey';
              } else if (mode !== 'flat' && d.depth === 1 && multiColoring) {
                d.arcColor = 'grey';
              } else {
                d.arcColor = isFacet(chartObj) ?
                getRawColor(chartObj, multiColoring ? getItemPos(d) : seriesIndex, d.data, seriesIndex, paneid) :
                color[(multiColoring ? getItemPos(d) : seriesIndex) % color.length];
              }

              var baseClr = getBaseClr(d);
              return d.fillColor =
              !d.depth && isPatternPalleteEnabled || baseClr === NONE ?
              NONE :
              fillColor[seriesIndex || 0](multiColoring ? getItemPos(d) : seriesIndex, d.data, null, baseClr);
            },
            'fill-opacity': isFade ? 0 : final_fillOpacity,
            'stroke-opacity': isFade ? 0 : final_strokeOpacity,
            stroke: function stroke(d) {
              var seriesIndex = getSeriesPos(d);

              if (d.arcColor === NONE) {
                return NONE;
              } else if (commonPlotOptions.strokeColor) {
                return commonPlotOptions.strokeColor;
              } else if (d.children) {
                return d.arcColor;
              } else {
                return strokeColor[seriesIndex || 0](multiColoring ? getItemPos(d) : seriesIndex, d.data);
              }
            },
            'stroke-width': function strokeWidth(d) {
              return commonPlotOptions.strokeWidth;
            },
            cursor: cursor,
            'pointer-events': function pointerEvents(d) {return isEventEnabled(d) && !d.children ? null : NONE;}
          });

          //Animation
          var total = path.size(),
            dur = !isredraw && animationType === FADE_ANIMATION ? transitionDuration / total : transitionDuration,
            del = animationType === FADE_ANIMATION ? dur : 0;

          path.transition().
          delay(function (d, i) {
            return isredraw ? 0 : i * del;
          }).
          duration(dur).
          ease(isredraw ? d3_ease_linear : easingType).
          attrs({
            transform: final_transform,
            r: final_r
          }).
          styles({
            'fill-opacity': final_fillOpacity,
            'stroke-opacity': final_strokeOpacity
          });

          setPivotAttributes(path, chartObj, 'packedbubble');
          setOpacityForTickFilterElements(path, chartObj, 'packedbubble');

          //Events
          setPointerEvents(chartObj, path, function (d) {return !isEventEnabled(d);}, paneid);
          if (!chartObj.cache.search) {
            chartObj.cache.search = {};
          }
          var mousemove = function mousemove(d, i) {
              var args = getEventArgs(d, i);
              chartObj.eventHandler.handlers.mousemove.call(chartObj.eventHandler, args);
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = paneid;
            },
            mouseout = function mouseout(d, i) {
              var args = getEventArgs(d, i);
              args.point = d.data;
              chartObj.eventHandler.handlers.mouseout.call(chartObj.eventHandler, args, getSeriesPos(d));
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = null;
            },
            click = function click(d, i) {
              var args = getEventArgs(d, i);
              chartObj.eventHandler.handlers.click.call(chartObj.eventHandler, args, d, getSeriesPos(d), getItemPos(d), chart);
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = paneid;
            },
            dblclick = function dblclick(d, i) {
              if (!chart.chartRendered) {
                return;
              }
              var dt = !annotation$4._empty ?
              generateDataForAnnotation(d.data, data.length > 1 ? data[getSeriesPos(d)].seriesname : null) :
              d.data;
              var coordinates = [d.x, d.y];
              coordinates = [coordinates[0] + (chartWidth - diameter) / 2, coordinates[1] + (chartHeight - diameter) / 2];
              var args = getEventArgs(d, i);
              args.coordinate = coordinates;
              args.basedOn = 'plot';
              args.data = dt;
              args.point = d.data;
              chartObj.eventHandler.handlers.doubleclick.call(chartObj.eventHandler, args, getSeriesPos(d), d);
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = paneid;
            },
            eventAttacherOptions = {
              target: 'plot',
              touchleave: true,
              chartObj: chartObj
            };
          var mouseHandlers = {
              mousemove: mousemove,
              mouseout: mouseout,
              click: click,
              dblclick: dblclick
            },
            touchHandlers = {
              singletouchmove: mousemove,
              touchend: mouseout,
              tap: click,
              dbltap: dblclick
            };
          attachevents(
          path.filter(function (d) {
            return !d.children;
          }),
          mouseHandlers,
          touchHandlers,
          eventAttacherOptions);


          chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
            //Annotation preprocessing
            if (!annotation$4._empty) {
              data.forEach(function (series, i) {
                notesArray = annotation$4.preprocessAnnotations(
                data,
                i,
                function (dt, k, j) {
                  var c = [dt.x, dt.y];
                  return [c[0] + (chartWidth - diameter) / 2, c[1] + (chartHeight - diameter) / 2];
                },
                notesArray,
                chartObj,
                rp);

              });
            }

            if (labelRenderer) {
              var transform = [(chartWidth - diameter) / 2, (chartHeight - diameter) / 2],
                totalFunc = function totalFunc(d, showAs) {
                  if (showAs === PERCENT_SHOWAS) {
                    return chart.total;
                  } else {
                    return d.parent.value;
                  }
                };

              data.forEach(function (d, i) {
                var _currentRenderer = chartObj.renderer[isFacet(chartObj) ? rendererIndex + i : 0],
                  _currentRendererIndex = isFacet(chartObj) ? rendererIndex + i : i,
                  paneid = isFacet(chartObj) ? "".concat(d.row, "_").concat(d.column) : i;

                labelQueue.push({
                  renderer: _currentRenderer,
                  charttype: 'hierarchy',
                  chartObj: chartObj,
                  rendererIndex: _currentRendererIndex,
                  paneid: paneid,
                  args: [data[i], i, null, null, totalFunc, seriesGroup[i], transform]
                });
              });
            }

            isredraw = true;
            chart.chartRendered = true;
          }, transitionDuration + 17);

          function getEventArgs(d, i) {
            var ev = getEventObject(d3_event()),
              seriesIndex = getSeriesPos(d),
              subSeriesIndex = 0,
              itemIndex = getItemPos(d);
            return {
              renderer: chart,
              seriesIndex: seriesIndex,
              subSeriesIndex: subSeriesIndex,
              itemIndex: itemIndex,
              paneid: paneid,
              rendererIndex: rendererIndex,
              coordinates: [ev.pageX, ev.pageY],
              element: this,
              data: d,
              selected: d.selected,
              _key: "ZC_".concat(chartObj.id, "_").concat(seriesIndex, "_").concat(subSeriesIndex, "_").concat(itemIndex)
            };
          }
        });
        return chart;
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.defaultMouseOverFunc = function (d, seriesPos, itemPos, paneid) {
        createHighlightElement();
        var refElement = d3_select(path.nodes()[d.index]);
        var refElementPosition = getSvgTransform(refElement).translate;
        var highlightEffect = chartObj.legendHighlight.getLegendHighlightEffect(seriesPos, 'selectedSeries', 'plot', paneid);
        var currentColor = getRawColor(chartObj, multiColoring ? itemPos : seriesPos, d.data, seriesPos, paneid);

        highlightGroup.style('opacity', null);
        highlightEle.
        attrs({
          transform: "translate(".concat(zchighlighterPosition[0] + refElementPosition[0], ",").concat(zchighlighterPosition[1] +
          refElementPosition[1], ")"),
          d: getSVGsymbol('circle')(+refElement.attr('r') * 2)
        }).
        styles(
        chartObj.legendHighlight.getEffect(
        highlightEffect,
        PACKEDBUBBLE_CHARTNAME,
        HIGHLIGHT_EFFECT_REGEX.test(highlightEffect) ? currentColor : TRANSPARENT,
        { fill: TRANSPARENT, stroke: currentColor },
        multiColoring ? itemPos : seriesPos,
        'plot'));


      };

      chart.defaultMouseOutFunc = function (d, i) {
        createHighlightElement(); //Touch device -> tap on a data, then tap a legend item. Mouseout should be called and legend tap action also will get executed.

        highlightGroup.style('opacity', 0);
      };

      function createHighlightElement() {
        if (highlightGroup) {
          return;
        }

        var g = chartObj.staticPaneSVG.selectAll('g#zchierarchyhighlight');
        if (!g.empty()) {
          //#ZC1756
          highlightGroup = g;
          highlightEle = appendEle(highlightGroup, PATH_ELEMENT, [1]);
        }
      }

      function getNodes(root) {
        var leafNodes = [];

        function recurse(node, prevID) {
          var child = getChildren(node);
          if (child) {
            child.forEach(function (c, i) {
              var ID = defined(prevID) ? "".concat(prevID, "_").concat(i) : "".concat(c.seriesIndex);
              parseID(c, ID);
              recurse(c, ID);
            });
          } else {
            parseID(node, prevID);
            if (mode == 'flat') {
              leafNodes.push(node);
            }
          }
        }

        function parseID(node, ID) {
          var indices = ID.split(/_/);
          node.seriesPos = +indices[0];
          node.itemPos = +indices[indices.length - 1];
        }

        recurse(root);
        return mode == 'flat' ? leafNodes : root;
      }

      function getChildren(node) {
        var depth = node.level && node.level.split('_').length;
        if (!chartObj.dataObject.hasHierarchyData && depth == 1 && node.length < 2 && node[0] && isArray$1(node[0][0])) {
          return node[0];
        } else if (isArray$1(node[0])) {
          if (isArray$1(node[0][0])) {
            return node;
          } else {
            return node.filter(function (d) {
              return isArray$1(d[0]) || valueFunction(d) > 0; //Test_761.json
            });
          }
        } else {
          return null;
        }
      }

      function getSeriesPos(d) {
        var level = d.level || d.data && d.data.level;
        if (level) {
          return +level.split('_')[0];
        }
      }

      function getItemPos(d) {
        return d.data.itemPos;
      }

      function getBaseClr(d, rendererColor) {
        return d.children ? d.arcColor : rendererColor;
      }

      function isDisabled(seriesData, d) {
        var seriesIndex = getSeriesPos(d);
        return defined(seriesIndex) && seriesData[seriesIndex].disabled;
      }

      function getPackNodeDescendants(data, include) {
        includeDisabledSeries = include;
        var order = commonPlotOptions.order || d3_ascending;
        if (typeof order === 'string') {
          order = getPropVal(window, order);
        }

        var root = d3_hierarchy(getNodes(data), getChildren).
        sum(valueFunction).
        sort(order);

        pack(root);
        return root.descendants();
      }

      return chart;
    };

    defaultTheme.pyramid = function () {
      return {
        threeDimension: true,
        strokeColor: 'black',
        strokeWidth: null,
        strokeOpacity: 0.5,
        fillOpacity: 0.8,
        gradients: {
          // linear || none
          options: {
            linear: {
              x2: 50,
              spreadMethod: 'reflect', // pad || repeat || reflect
              colorGamma: [0.8, 0]
            }
          }
        },
        datalabels: {
          showAs: 'y', //x,y,percent
          type: 'singleside', // singleside || doubleside || strokeddoubleside
          padding: 10,
          relativeX: true,
          line: {
            strokeColor: 'grey',
            strokeWidth: 0.3
          },
          innerLabel: {
            show: false,
            showAs: 'percent' //x,y,percent
          }
        },
        animation: {
          type: 'vertical' //vertical || verticalAll
        }
      };
    };

    //$Id$

    var annotation$5 = Registry.getComponent('annotation');
    /**
     *
     * @returns {chart} pyramid renderer.
     */
    svg_plot_renderer.pyramid = function () {
      var MAXWIDTH_DATALABELS = 0.3;
      var cfg = {};
      var animationType;
      var commonRendererProp,
        dataset,
        yaxiscolumnorder,
        isredraw = false;
      var chartWidth, chartHeight, commonPlotOptions, systemconf, notesArray, isPatternPalleteEnabled, defsLocation;
      var height1,
        total,
        b,
        h,
        side1,
        side2,
        side3,
        side4,
        hScale,
        color,
        heightArray,
        chartObj,
        pyramidGroup,
        gradientDim,
        pyramidsections,
        dataLength,
        data_backup,
        datalabelPadding,
        customPlotarea,
        fillColor = [];

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          notesArray = rp.notesArray,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset;
          systemconf = chartObj.systemConf;
          var labelQueue = rp.labelQueue,
            bound = rp.bound,rendererIndex = rp.rendererIndex,
            seriesData = isFacet(chartObj) && hasColorColumnInNonAxis(chartObj) ? data : data[0],
            paneid = isFacet(chartObj) ? "".concat(seriesData.row, "_").concat(seriesData.column) : null;

          defsLocation = chartObj.defsLocation;

          var plotarea = _objectSpread(_objectSpread({}, bound), customPlotarea);
          chartWidth = plotarea.width;
          chartHeight = plotarea.height;
          var minD = mathMin(chartWidth, chartHeight);

          datalabelPadding = commonPlotOptions.datalabels.padding;
          var showlabel = chartObj.datalabels.moduleExists && isDatalabelEnabled(commonPlotOptions.datalabels, chartObj);
          if (showlabel) {
            /*
             *If chart width is lesser than height, datalabels are hidden as default padding is 10 and there is no space to show datalabels.
             * So 30% of the width is allocated for datalabels and the default padding will be changed to 5
             */
            var minDatalabelsWidth = chartWidth * MAXWIDTH_DATALABELS,
              availableDatalabelsWidth = chartWidth - minD;
            if (availableDatalabelsWidth < minDatalabelsWidth) {
              datalabelPadding = cfg.datalabelPadding = 5;
              minD -= mathMax(minDatalabelsWidth - availableDatalabelsWidth, 0);
            }
          }
          cfg.width = minD;
          cfg.height = minD * 4 / 5;

          var plotoptions = data[0].plotoptions,
            gvp = utils.getValueOfPlotOptions(plotoptions, commonPlotOptions);
          isPatternPalleteEnabled = systemconf.legend.imagePallete || legend_helpers.hasPatternPallete(chartObj);

          var strokeWidth = gvp('strokeWidth'),
            strokeOpacity = gvp('strokeOpacity'),
            threeDimension = gvp('threeDimension'),
            fillOpacity = gvp('fillOpacity');

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, PYRAMID_CHARTNAME);
          var isAnimationEnable = animationOptions.enabled,
            easingType = animationOptions.easingType,
            transitionDuration = isredraw ? isAnimationEnable ? 200 : 0 : animationOptions.duration;
          animationType = animationOptions.type;

          var eventDisabled = validateNullVal(getEventConf(plotoptions, commonPlotOptions, chartObj, 'enabled'), true) == false;
          var cursor = eventDisabled ? null : getEventConf(plotoptions, commonPlotOptions, chartObj, 'cursor') || 'pointer';

          var transX = chartWidth / 2 - cfg.width / 2,
            transY = chartHeight / 2 - cfg.height / 2,
            translation = hasColorColumnInNonAxis(chartObj) ?
            [transX + plotarea.translate[0], transY + plotarea.translate[1]] :
            [transX, transY];
          chartObj.plotarea.centerX = transX, chartObj.plotarea.centerY = transY;
          var container = d3_select(this);
          pyramidGroup = appendEle(container, 'g', [data], '.', 'class', 'pyramidgroup');
          pyramidGroup.attr('transform', "translate(".concat(transX, ",").concat(transY, ")")).style('cursor', cursor);
          data_backup = data = hasColorColumnInNonAxis(chartObj) ? data : data[0].data[0];
          dataLength = data.length;
          heightArray = [];
          height1 = cfg.height;
          b = cfg.width, h = threeDimension ? cfg.height / 6 : 0;
          var theta = 25;
          var x = mathSQRT(mathPow(h / mathSin(theta * mathPI / 180), 2) - mathPow(h, 2));
          b = b - x;
          side1 = d3_scaleLinear().
          range([(b + x) / 2, 0]).
          domain([0, height1]);
          side2 = d3_scaleLinear().
          range([(b + x) / 2, b]).
          domain([0, height1]);
          side3 = d3_scaleLinear().
          range([(b + x) / 2, b + x]).
          domain([0, height1]);
          side4 = d3_scaleLinear().
          range([(b + x) / 2, x]).
          domain([0, height1]);
          hScale = d3_scaleLinear().
          range([0, h]).
          domain([0, height1 - h / 2]);
          gradientDim = [cfg.width, cfg.height];
          chart.fillColorFunc = getFillColor(chartObj, 0, paneid, gradientDim);
          var strokeColor = getStrokeColor(chartObj, 0, paneid);

          if (isFacet(chartObj)) {
            data.forEach(function (d, i) {
              var itemIndex = dataLength - 1 - i;
              fillColor[itemIndex] = getFillColor(chartObj, itemIndex, paneid);
            });
          } else {
            fillColor[0] = chart.fillColorFunc;
          }

          var noofNonZeroData = 0;
          chart.total = total = data.reduce(function (prev, cur) {
            return prev + (isDisabled(cur) ? 0 : (noofNonZeroData++, mathAbs(dataset.getY(cur, yaxiscolumnorder) || 0)));
          }, 0);

          var previous = 0;
          data.forEach(function (d, i) {
            d._acutalData = function () {return data[dataLength - 1 - i];};
            heightArray.push({
              height:
              (previous + (isDisabled(d) ? 0 : mathAbs(dataset.getY(d, yaxiscolumnorder)))) / total * (height1 - h / 2) || 0,
              previousHeight: previous / total * (height1 - h / 2) || 0
            });
            previous += isDisabled(d) ? 0 : mathAbs(dataset.getY(d, yaxiscolumnorder));
          });
          pyramidsections = appendEle(pyramidGroup, 'g', data, '.', 'class', 'pyramidsection');
          pyramidsections.
          attr('id', function (d, i) {
            return "section_".concat(dataLength - 1 - i);
          }).
          styles({
            stroke: function stroke(d, i) {
              if (isFacet(chartObj)) {
                return getStrokeColor(chartObj, dataLength - 1 - i, paneid)(
                dataLength - 1 - i,
                data[dataLength - 1 - i],
                commonPlotOptions.strokeColor);

              }

              return strokeColor(dataLength - 1 - i, data[dataLength - 1 - i], commonPlotOptions.strokeColor);
            },
            'stroke-opacity': strokeOpacity,
            'stroke-width': strokeWidth,
            'fill-opacity': fillOpacity,
            fill: function fill(d, i) {
              if (isFacet(chartObj)) {
                return fillColor[dataLength - 1 - i](dataLength - 1 - i, data[dataLength - 1 - i]);
              }

              return fillColor[0](dataLength - 1 - i, data[dataLength - 1 - i]);
            }
          }).
          each(function (d, i) {
            var currentGroup = d3_select(this);
            var pyramid = appendEle(currentGroup, PATH_ELEMENT, [d, d, d, d]);
            pyramid.attr('class', "section_".concat(dataLength - 1 - i)); //For touch events, class will help to get index
          });

          setPivotAttributes(pyramidsections, chartObj);
          setOpacityForTickFilterElements(pyramidsections, chartObj, 'pyramid');

          setPointerEvents(chartObj, pyramidsections, eventDisabled, paneid);
          if (!chartObj.cache.search) {
            chartObj.cache.search = {};
          }
          if (!eventDisabled) {
            var mousemove = function mousemove(d, j) {
                var ele = this.parentNode;
                var i = pInt(
                d3_select(ele).
                attr('id').
                replace(/section_/gi, ''));

                var args = getEventArgs(ele, i);
                chartObj.eventHandler.handlers.mousemove.call(chartObj.eventHandler, args);
                updateSelectionOnDatapoint(data[i], args);
                chartObj.cache.search.lastPane = paneid;
              },
              mouseout = function mouseout(d, j) {
                var ele = this.parentNode;
                var i = pInt(
                d3_select(ele).
                attr('id').
                replace(/section_/gi, ''));

                var args = getEventArgs(d, i);
                chartObj.eventHandler.handlers.mouseout.call(chartObj.eventHandler, args, i);
                updateSelectionOnDatapoint(data[i], args);
                chartObj.cache.search.lastPane = null;
              },
              click = function click() {
                var ele = this.parentNode;
                var i = pInt(
                d3_select(ele).
                attr('id').
                replace(/section_/gi, ''));

                var args = getEventArgs(ele, i);
                chartObj.eventHandler.handlers.click.call(chartObj.eventHandler, args, chart, 0, i, data[i]);
                updateSelectionOnDatapoint(data[i], args);
                chartObj.cache.search.lastPane = paneid;
              },
              dblclick = function dblclick(d, j) {
                var ele = this.parentNode;
                var i = pInt(
                d3_select(ele).
                attr('id').
                replace(/section_/gi, ''));

                var dt = !annotation$5._empty ? generateDataForAnnotation(data[i], null) : data[i];
                var height = heightArray[i].previousHeight;
                var coordinates = [
                side1(height + hScale(height) / 2) + (chartWidth / 2 - cfg.width / 2),
                hScale(height) / 2 + height + (chartHeight / 2 - cfg.height / 2)];

                var args = getEventArgs(ele, i);
                args.coordinate = coordinates;
                args.basedOn = 'plot';
                args.data = dt;
                chartObj.eventHandler.handlers.doubleclick.call(chartObj.eventHandler, args, i, d);
                updateSelectionOnDatapoint(data[i], args);
                chartObj.cache.search.lastPane = paneid;
              },
              eventAttacherOptions = {
                target: 'plot',
                touchleave: true,
                chartObj: chartObj
              };
            var mouseHandlers = {
                mousemove: mousemove,
                mouseout: mouseout,
                click: click,
                dblclick: dblclick
              },
              touchHandlers = {
                singletouchmove: mousemove,
                touchend: mouseout,
                tap: click,
                dbltap: dblclick
              };
            attachevents(pyramidsections.selectAll(PATH_ELEMENT), mouseHandlers, touchHandlers, eventAttacherOptions);
          }
          var prev = 0;
          pyramidsections.each(function (d, i) {
            var pyramid = pyramidGroup.selectAll("#section_".concat(i)).selectAll(PATH_ELEMENT);
            if (isredraw) {
              pyramid.
              transition().
              duration(transitionDuration).
              ease(d3_ease_linear).
              attr('d', function (d, j) {
                return getPath(i, j);
              });
            } else {
              var yVal = dataset.getY(d, yaxiscolumnorder);
              var dur =
              animationType == VERTICAL_ANIMATION ?
              (isDisabled(d) || !yVal ? 0 : mathAbs(yVal)) / total * transitionDuration :
              transitionDuration;
              prev += isDisabled(d) || !yVal ? 0 : mathAbs(yVal);
              var del = animationType == VERTICAL_ANIMATION ? (total - prev) / total * transitionDuration : 0;
              if (chartObj.systemConf.chart.plot.morph.enabled && chartObj.oldSeriesInfo != undefined) {
                var morph_Obj = new zcMorph({ sampling: chartObj.systemConf.chart.plot.morph.samplingDistance });
                var oldseriesData = chartObj.oldSeriesInfo.get(0);
                var oldseriesIndex = oldseriesData.seriesIndex;
                var oldseriesColor = oldseriesData.color;
                var offsetValue = getOffsetValue(chartObj, oldseriesIndex);
                var individualElementTransform = oldseriesData.transformationInfo;
                transitionDuration = chartObj.systemConf.chart.plot.morph.duration;

                var height = heightArray[i].height;
                var previous = heightArray[i].previousHeight;

                var finalPath = "M".concat(side1(previous + hScale(previous) / 2), " ").concat(hScale(previous) / 2 + previous, " L").concat(side2(
                previous + hScale(previous) / 2), " ").concat(
                hScale(previous) / 2 + previous, " L").concat(side3(previous + hScale(previous) / 2), " ").concat(-hScale(previous) / 2 +
                previous, " L").concat(side3(height + hScale(height) / 2), " ").concat(-hScale(height) / 2 + height, " L").concat(side2(
                height + hScale(height) / 2), " ").concat(
                hScale(height) / 2 + height, " L").concat(side1(height + hScale(height) / 2), " ").concat(hScale(height) / 2 + height);

                var line = d3_line();

                var fromPath = chartObj.oldSeriesInfo.get(oldseriesIndex).pathData[i];
                var fromPathAttribute = fromPath.getAttribute('d');
                fromPath.setAttribute('d', finalPath);
                var toPath = fromPath.cloneNode();
                fromPath.setAttribute('d', fromPathAttribute);
                var interpolated = morph_Obj.interpolate(
                {
                  path: fromPath,
                  xOffset: offsetValue.x + individualElementTransform[i].x,
                  yOffset: offsetValue.y + individualElementTransform[i].y
                },
                { path: toPath, xOffset: 0, yOffset: 0 });


                pyramid.each(function (d, j) {
                  if (j === 0) {
                    var pyramidSection = pyramidGroup.selectAll("#section_".concat(i));
                    pyramidSection.
                    style('fill', function () {
                      return oldseriesColor[i];
                    }).
                    transition().
                    duration(transitionDuration).
                    ease(easingType).
                    style('fill', function () {
                      return getRawColor(chartObj, i, d.data, oldseriesIndex, null);
                    });
                    d3_select(this).
                    transition().
                    duration(transitionDuration).
                    ease(easingType).
                    attrTween('d', function (d, i) {
                      return function (t) {
                        return line(
                        interpolated.map(function (p) {
                          return p(t);
                        }));

                      };
                    }).
                    on('end', function (d, j) {
                      if (chartObj.oldSeriesInfo) {
                        delete chartObj.oldSeriesInfo;
                      }
                      if (j === 0) {
                        pyramid.each(function (d, j) {
                          d3_select(this).attr('d', getPath(i, j));
                        });
                        pyramidSection.style('fill', function () {
                          if (isFacet(chartObj)) {
                            return fillColor[i](i, data[i]);
                          }
                          return fillColor[0](i, data[i]);
                        });
                      }
                    });
                  }
                });
              } else {
                pyramid.
                transition().
                duration(dur).
                delay(del).
                ease(easingType).
                attrTween('d', function (dt, j) {
                  return tween(d, i, j);
                });
              }
            }
          });
          hideDisabledElements();

          chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
            if (labelRenderer) {
              var args = [
              chartObj.seriesdata,
              0,
              data,
              noofNonZeroData,
              0,
              total,
              cfg,
              calculatePointsForLabelPlacement(data),
              chart.subSeriesIndex || 0,
              translation];

              labelQueue.push({
                renderer: chart,
                charttype: FUNNEL_CHARTNAME,
                chartObj: chartObj,
                args: args,
                rendererIndex: rendererIndex,
                paneid: paneid
              });
              labelQueue.push({
                renderer: chart,
                charttype: 'funnelInnerLabels',
                chartObj: chartObj,
                args: args,
                rendererIndex: rendererIndex,
                paneid: paneid
              });
            }

            //Annotation preprocessing
            if (!annotation$5._empty) {
              notesArray = annotation$5.preprocessAnnotations(
              chartObj.seriesdata,
              0,
              function (dt, k, j) {
                var height = heightArray[j].previousHeight;
                return [
                side1(height + hScale(height) / 2) + (chartWidth / 2 - cfg.width / 2),
                hScale(height) / 2 + height + (chartHeight / 2 - cfg.height / 2)];

              },
              notesArray,
              chartObj,
              rp);

            }

            isredraw = true;
            chart.chartRendered = true;

            if (hasColorColumnInNonAxis(chartObj)) {
              chartObj.renderer[rendererIndex].endFunctions();
            }
          }, transitionDuration + 10);

          function getEventArgs(ele, i) {
            var ev = getEventObject(d3_event());
            return {
              renderer: chart,
              seriesIndex: hasColorColumnInNonAxis(chartObj) ? i : 0,
              subSeriesIndex: 0,
              itemIndex: i,
              paneid: paneid,
              rendererIndex: rendererIndex,
              color: color[i % color.length],
              coordinates: [ev.pageX, ev.pageY],
              element: ele,
              data: data[i],
              selected: data[i].selected,
              _key: "ZC_".concat(chartObj.id, "_0_0_").concat(i)
            };
          }

          function hideDisabledElements() {
            if (!isFacet(chartObj)) {
              return;
            }

            var dur = !isredraw ? 0 : transitionDuration;
            pyramidsections.each(function (d, i) {
              var hide = d.dummy || !dataset.getY(d, yaxiscolumnorder);
              var t = hide ? dur : 0;
              if (t) {
                setTimeout(function () {
                  hideSection(i, hide);
                }, t);
              } else {
                hideSection(i, hide);
              }
            });
          }

          function hideSection(i, hide) {
            var display = hide ? 'none' : null;

            pyramidGroup.selectAll("#section_".concat(i)).style('display', display);
          }
        });
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.plotarea = function (_) {
        //Bubble Pie chart will give you the plotarea
        if (!arguments.length) {
          return customPlotarea;
        }
        customPlotarea = _;
        return chart;
      };

      chart.defaultMouseOverFunc = function (d, seriesPos, itemPos) {
        //Reset previous pane mouseover
        // if(chartObj.dataObject.pivot){
        //     var allPyramidSection = chartObj.wrap.selectAll('path.pyramidsection');
        //     if(isPatternPalleteEnabled){
        //         allPyramidSection.style('opacity', null);
        //     }else{
        //         allPyramidSection.selectAll('path').style('fill', (d,i)=>{
        //             return fillColor[0](dataLength - 1 - i, data_backup[dataLength - 1 - i], null);
        //         });
        //     }
        //
        // }

        if (isPatternPalleteEnabled) {
          pyramidsections.style('opacity', function (d, i) {
            return dataLength - 1 - i == itemPos ? null : 0.2;
          });
        } else {
          pyramidsections.style('fill', function (d, i) {
            return (isFacet(chartObj) ?
            fillColor[dataLength - 1 - i] :
            fillColor[0])(dataLength - 1 - i, data_backup[dataLength - 1 - i], dataLength - 1 - i == itemPos ? 0.5 : null);
          });
        }
      };
      chart.defaultMouseOutFunc = function (d, i) {
        if (isPatternPalleteEnabled) {
          pyramidsections.style('opacity', null);
        } else {
          pyramidsections.style('fill', function (d, i) {
            return (isFacet(chartObj) ?
            fillColor[dataLength - 1 - i] :
            fillColor[0])(dataLength - 1 - i, data_backup[dataLength - 1 - i]);
          });
        }
      };

      function constructSide1(height, previous) {
        return "M".concat(side1(height + hScale(height) / 2), " ").concat(hScale(height) / 2 + height, " L").concat(side2(height + hScale(height) / 2), " ").concat(hScale(
        height) /

        2 +
        height, " L").concat(side2(previous + hScale(previous) / 2), " ").concat(hScale(previous) / 2 + previous, " L").concat(side1(
        previous + hScale(previous) / 2), " ").concat(
        hScale(previous) / 2 + previous, " L").concat(side1(height + hScale(height) / 2), " ").concat(hScale(height) / 2 + height);
      }

      function constructSide2(height, previous) {
        return "M".concat(side2(height + hScale(height) / 2), " ").concat(hScale(height) / 2 + height, " L").concat(side3(height + hScale(height) / 2), " ").concat(-hScale(
        height) /

        2 +
        height, " L").concat(side3(previous + hScale(previous) / 2), " ").concat(-hScale(previous) / 2 + previous, " L").concat(side2(
        previous + hScale(previous) / 2), " ").concat(
        hScale(previous) / 2 + previous, " L").concat(side2(height + hScale(height) / 2), " ").concat(hScale(height) / 2 + height);
      }

      function constructSide3(height, previous) {
        return "M".concat(side3(height + hScale(height) / 2), " ").concat(-hScale(height) / 2 + height, " L").concat(side4(height + hScale(height) / 2), " ").concat(-hScale(
        height) /

        2 +
        height, " L").concat(side4(previous + hScale(previous) / 2), " ").concat(-hScale(previous) / 2 + previous, " L").concat(side3(
        previous + hScale(previous) / 2), " ").concat(
        -hScale(previous) / 2 + previous, " L").concat(side3(height + hScale(height) / 2), " ").concat(-hScale(height) / 2 + height);
      }

      function constructSide4(height, previous) {
        return "M".concat(side4(height + hScale(height) / 2), " ").concat(-hScale(height) / 2 + height, " L").concat(side1(height + hScale(height) / 2), " ").concat(hScale(
        height) /

        2 +
        height, " L").concat(side1(previous + hScale(previous) / 2), " ").concat(hScale(previous) / 2 + previous, " L").concat(side4(
        previous + hScale(previous) / 2), " ").concat(
        -hScale(previous) / 2 + previous, " L").concat(side4(height + hScale(height) / 2), " ").concat(-hScale(height) / 2 + height);
      }

      function getPath(i, j, base) {
        var height = heightArray[i].height;
        var baseHgt = base == 'down' ? height : heightArray[i].previousHeight;
        switch (j) {
          case 0:
            return constructSide3(height, baseHgt);
          case 1:
            return constructSide4(height, baseHgt);
          case 2:
            return constructSide1(height, baseHgt);
          case 3:
            return constructSide2(height, baseHgt);}

      }

      function tween(d, i, j) {
        var interpolate = d3_interpolate(getPath(animationType == VERTICAL_ANIMATION ? i : dataLength - 1, j, 'down'), getPath(i, j));
        return function (t) {
          return interpolate(t);
        };
      }

      function calculatePointsForLabelPlacement(data) {
        var trape = [];
        data.forEach(function (d, i) {
          var idx = data.length - 1 - i;
          var height = heightArray[idx].height,
            previous = heightArray[idx].previousHeight;
          var midHeight = (height + previous) / 2;
          var bottom_right = {
              x: side3(height + hScale(height) / 2),
              y: -hScale(height) / 2 + height
            },
            top_right = {
              x: side3(previous + hScale(previous) / 2),
              y: -hScale(previous) / 2 + previous
            },
            bottom_left = {
              x: side1(height + hScale(height) / 2),
              y: hScale(height) / 2 + height
            },
            top_left = {
              x: side1(previous + hScale(previous) / 2),
              y: hScale(previous) / 2 + previous
            };
          var rightX = (bottom_right.x + top_right.x) / 2,
            rightY = (bottom_right.y + top_right.y) / 2,
            leftX = (bottom_left.x + top_left.x) / 2,
            leftY = (bottom_left.y + top_left.y) / 2,
            midX = (side1(midHeight + hScale(midHeight) / 2) + side2(midHeight + hScale(midHeight) / 2)) / 2;

          trape.push({
            rightx: rightX + datalabelPadding,
            leftx: leftX - datalabelPadding,
            y: rightY,
            y0: height + hScale(height) / 2,
            midX: midX,
            leftY: leftY
          });
        });
        return trape;
      }

      function isDisabled(d) {
        return d.disabled || d.dummy;
      }

      return chart;
    };

    //$Id$

    canvas_plot_renderer.scatter = function () {
      var shiftInfo,
        commonRendererProp,
        yrangePos,
        dataProcessorHelpers = DataProcessor.helpers;

      function chart(context, _s, pattern, filterIndex) {var encode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'clr';
        var rp = commonRendererProp.params,
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          yscale = rp.yscale,
          stacked = rp.stacked,
          index = rp.datasetIndex,
          legendOrder = rp.legendOrderIndex,
          rendererIndex = rp.rendererIndex,
          axisrotated = rp.axisrotated,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          labelQueue = rp.labelQueue,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset,
          threshold = rp.threshold,
          shapescale = rp.shapescale,
          seriesData = chartObj.dataObject.categoryHierarchy ? _s[index] : chartObj.seriesdata[index];

        var plotoptions = seriesData.plotoptions || {},
          cpOptions = plotoptions ? mergeJSON$1(commonPlotOptions, plotoptions, true) : commonPlotOptions,
          currentseriesdata = seriesData.data,
          paneid = "".concat(seriesData.row, "_").concat(seriesData.column),
          temp = getChartTypeByIndex(chartObj, paneid, index),
          cType = temp.value,
          chartName = temp.name,
          scatterOrBubble = isScatterChartType(cType),
          isBubbleChart = chartcategory.bubble.has(cType),
          isPolar = chartObj.dataObject.isPolarAxisCategory,
          legend_data = chartObj.systemConf.legend;

        var markerOptions = commonRendererProp.params.markerOptions =
        plotoptions && plotoptions.marker ? mergeJSON$1(commonPlotOptions.marker, plotoptions.marker, true) : commonPlotOptions.marker;

        var hoverOptions = commonRendererProp.params.hoverOptions =
          plotoptions && plotoptions.hoveroptions ?
          mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
          commonPlotOptions.hoveroptions,
          symboltype = markerOptions.symbol || 'circle',
          symbolsize = markerOptions.size,
          imageUrl = markerOptions.imageUrl,
          multiColoring = scatterOrBubble && isMultiColoring(cpOptions, chartObj),
          patternPallete = legend_data.patternPallete,
          hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj);

        if (!scatterOrBubble) {
          if (isUndefined(symbolsize)) {
            symbolsize = pick(cpOptions.strokeWidth, 2);
          }

          if (!imageUrl) {
            symbolsize *= isPolar ? 0.56 : 0.7;
          }

          color = pick(seriesData.color, color);
        } else {
          symbolsize = pick(symbolsize, 1);
        }

        var _color = isFacet(chartObj) ? getRawColor(chartObj, legendOrder, seriesData, legendOrder, paneid) : color,
          outerSize = symbolsize * 5,
          outerFillOpacity = markerOptions.outerFillOpacity,
          outerStrokeOpacity = markerOptions.outerStrokeOpacity,
          innerFillOpacity = markerOptions.innerFillOpacity,
          innerStrokeOpacity = markerOptions.innerStrokeOpacity,
          outerStrokeWidth = pick(markerOptions.outerStrokeWidth, 1),
          innerStrokeWidth = pick(markerOptions.innerStrokeWidth, 1),
          outerStrokeColor = pick(markerOptions.outerStrokeColor, _color),
          innerStrokeColor = pick(markerOptions.innerStrokeColor, _color),
          outerFillColor = pick(markerOptions.outerFillColor, _color),
          innerFillColor = pick(markerOptions.innerFillColor, _color),
          outerDashArray = getDashArray(markerOptions.outerDashStyle, outerStrokeWidth),
          innerDashArray = getDashArray(markerOptions.innerDashStyle, innerStrokeWidth),
          outerStrokeLineCap = getLineCap(markerOptions.outerLineCap, markerOptions.outerDashStyle),
          innerStrokeLineCap = getLineCap(markerOptions.innerLineCap, markerOptions.innerDashStyle),
          markerPosition = markerOptions.position;

        if (defined(pattern)) {
          outerStrokeWidth = pick(pattern['stroke-width'], outerStrokeWidth);

          if (defined(filterIndex) && !(outerStrokeOpacity && d3_rgb(outerStrokeColor).opacity)) {
            innerStrokeWidth = pick(pattern['stroke-width'], innerStrokeWidth);
          }
        }

        if (defined(outerFillOpacity) && outerFillColor) {
          outerFillColor = rgba_canvas(outerFillColor, outerFillOpacity);
        }
        if (defined(outerStrokeOpacity) && outerStrokeColor) {
          outerStrokeColor = rgba_canvas(outerStrokeColor, outerStrokeOpacity);
        }
        if (defined(innerFillOpacity) && innerFillColor) {
          innerFillColor = rgba_canvas(innerFillColor, innerFillOpacity);
        }
        if (defined(innerStrokeOpacity) && innerStrokeColor) {
          innerStrokeColor = rgba_canvas(innerStrokeColor, innerStrokeOpacity);
        }

        function getSymbolSize(d) {
          if (isPolar && (!d || d.isDummy)) {
            return 0;
          } else if (
          !isPolar &&
          cType !== cType.stkdarea && (
          isCatNullX(dataset.getX(d)) || isCatNullY(dataset.getY(d, yaxiscolumnorder))))
          {
            return 0;
          } else if (!isPolar && cType == cType.stkdarea && (!d || d.isDummy)) {
            return 0;
          } else {
            return isBubbleChart ?
            chartObj.dataObject.getXYvalue(
            axisrotated,
            stacked,
            xscale,
            yscale,
            yaxiscolumnorder,
            d,
            'z',
            chartObj.zscale,
            yrangePos) :

            outerSize * 2;
          }
        }

        function getSymbolBBox(d) {
          var size = getSymbolSize(d) / 2;
          if (size > 0 && (symboltype == 'line' || symboltype == 'vertical-line')) {
            if (symboltype == 'line') {
              return {
                width: size,
                height: strokeWidth || 1
              };
            } else if (symboltype == 'vertical-line') {
              return {
                width: strokeWidth || 1,
                height: size
              };
            }
          } else {
            return null;
          }
        }
        function getSegments(d) {
          var size = getSymbolSize(d);
          if (symboltype == 'line' || symboltype == 'vertical-line') {
            var _data = d._data();
            var symbolSegment = getSegmentsForSymbol(symboltype, size, _data._x, _data._y);
            if (symboltype == 'line' || symboltype == 'vertical-line') {
              return [symbolSegment];
            } else {
              return symbolSegment;
            }
          }
        }
        if (scatterOrBubble) {
          chart.highlighter = isBubbleChart ? new BubbleHighlighter(chartObj, chart) : new ScatterHighlighter(chartObj, chart);
        }
        //Assign renderer functions
        chart.getSymbolSize = getSymbolSize;
        chart.getSymbolBBox = getSymbolBBox;
        chart.getSegments = getSegments;

        // don't use cache in case of bubble, multicolor and colorOverlay.
        var useCache =
          !defined(threshold) &&
          !multiColoring && (
          chartName === 'scatter' || chartName === 'line' || chartName === 'area') &&
          !patternPallete &&
          !imageUrl &&
          !hasColorScale &&
          !shapescale,
          cache;

        var fillColor = chart.fillColorFunc = getFillColor(chartObj, legendOrder, paneid, null, !scatterOrBubble),
          strokeColor = getStrokeColor(chartObj, legendOrder, paneid),
          innerFillColorFunc = getFillColor(chartObj, legendOrder, paneid, null, true);

        if (useCache) {
          fillStyle = chart.fillColorFunc(
          legendOrder,
          seriesData,
          null,
          outerFillColor,
          null,
          scatterOrBubble ? [outerSize, outerSize] : null,
          false);

          cache = canvas_plot_renderer.scatter.getCache(
          symboltype,
          outerSize,
          outerStrokeColor,
          outerStrokeWidth,
          fillStyle,
          innerStrokeColor,
          innerStrokeWidth,
          innerFillColor,
          markerOptions);

          var adjust = cache.adjustPosition,
            cacheCanvas = cache.canvas,
            drawWidth = cache.width;
        }

        if (!seriesData.disabled) {
          var datatypeX = chartObj.dataset.getDataType('x'),
            datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
            isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
            isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder),
            xCategories = datatypeX == ORDINAL_DATATYPE ? xscale.domain() : null,
            yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
            categories =
            datatypeX == ORDINAL_DATATYPE && xscale.domain != null && !defined(chartObj.dataObject.hierarchical) ?
            xCategories :
            chartObj.dataObject.getCategories('x'),
            fillStyle,
            strokeStyle;
          //Initiated in dataprocessor
          if (chartObj.dataObject.markerSize[chartName]) {
            var mSize = symboltype == 'line' || symboltype == 'vertical-line' ? strokeWidth || 1 : outerSize * 2;
            chartObj.dataObject.markerSize[chartName].add(mSize);
          }

          chart.seriesdataAfterUpdate = [];

          currentseriesdata.forEach(function (data, j) {
            var dataUpdate;
            if (datatypeX == ORDINAL_DATATYPE || datatypeY == ORDINAL_DATATYPE) {
              dataUpdate = chartObj.dataObject.updateSeriesdatabyCategories(
              d3_values(data),
              xCategories,
              yCategories,
              yaxiscolumnorder);

            } else {
              dataUpdate = data;
            }

            if (chartObj.renderVisiblePointsOnly) {
              var filterAxisType = chartName === 'scatter' || chartName === 'bubble' ? 'xy' : 'x';
              dataUpdate = DataProcessor.helpers.filterPointsInViewport(chartObj, dataUpdate, chartName, filterAxisType, index);
            }

            chart.seriesdataAfterUpdate[j] = dataUpdate;

            if (hasColorScale && defined(pattern) && encode === 'clr') {
              dataUpdate = legend_helpers.filterSelectionByColor(dataUpdate, true, filterIndex, chartObj);
            }

            if (isBubbleChart && defined(pattern) && encode === 'z') {
              dataUpdate = legend_helpers.filterSelectionByColor(dataUpdate, true, filterIndex, chartObj, 'z');
            }

            dataUpdate.forEach(function (d, i) {
              var itemIndex = encode === 'z' ? pick(d.sortedItemIndex, i) : i,
                outerStrokeStyle,
                position = i === 0 ? START_ALIGN : i === dataUpdate.length - 1 ? END_ALIGN : MIDDLE_ALIGN;

              if (
              !(
              !isPolar &&
              cType !== charttype.stkdarea && (
              !d || d.isDummy || isCatNullX(dataset.getX(d)) || isCatNullY(dataset.getY(d, yaxiscolumnorder)))))

              {
                // to remove stacked area with dummy data added
                if (!isPolar && cType == charttype.stkdarea && (!d || d.isDummy)) {
                  return;
                }
                if (markerPosition && markerPosition.indexOf(position) <= -1) {
                  return;
                }

                var x = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'x'),
                  y = chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'y'),
                  size = getSymbolSize(d) / 2,
                  shape = shapescale ? shapescale(d[dataset.shapeidx]) : symboltype;

                if (useCache) {
                  // using cache image
                  context.beginPath();
                  var centered = size + outerStrokeWidth / 2 + adjust;
                  context.drawImage(cacheCanvas, x - centered, y - centered, drawWidth - 1, drawWidth - 1);
                  context.closePath();
                } else {
                  // outer circle
                  if (outerFillColor || outerStrokeColor) {
                    outerStrokeStyle = strokeColor(
                    multiColoring ? itemIndex : legendOrder,
                    d,
                    chartObj.imagePallete ? null : markerOptions.outerStrokeColor,
                    NULL$1,
                    outerStrokeOpacity);

                    var drawScatterFunction = function drawScatterFunction(context, fillStyle, imageDimension) {
                      canvas_plot_renderer.scatter.drawPath(
                      shape,
                      context,
                      x,
                      y,
                      size,
                      outerStrokeWidth,
                      outerStrokeStyle,
                      fillStyle,
                      outerDashArray,
                      outerStrokeLineCap,
                      imageUrl,
                      imageDimension,
                      outerFillOpacity);

                    };

                    if (imageUrl) {
                      var options = {
                        x: x,
                        y: y,
                        width: size * 2,
                        height: size * 2,
                        context: context,
                        name: imageUrl,
                        repeatMode: 'no-repeat'
                      };
                      effects.canvas_patterns.imageFill(options, drawScatterFunction);
                    } else if (chartObj.imagePallete) {
                      var options = {
                        x: x,
                        y: y,
                        context: context,
                        name: chartObj.imagePallete[multiColoring ? itemIndex : legendOrder]
                      };
                      effects.canvas_patterns.imageFill(options, drawScatterFunction);
                    } else {
                      var fillStyle = chart.fillColorFunc(
                      multiColoring ? itemIndex : legendOrder,
                      d,
                      null,
                      markerOptions.outerFillColor,
                      outerFillOpacity,
                      scatterOrBubble ? [size, size] : null,
                      false);

                      drawScatterFunction(context, fillStyle);
                    }
                  }

                  // inner circle
                  var innerMarker = true;
                  if (
                  imageUrl ||
                  innerStrokeWidth === 0 && (innerFillOpacity === 0 || markerOptions.innerFillColor === 'transparent'))
                  {
                    innerMarker = false;
                  }
                  // TODO gradients need to check since no such condition in svg renderer
                  // if (!(isBubbleChart && cpOptions.gradients.type && cpOptions.gradients.type !== NONE) && !imageUrl && (innerFillColor || innerStrokeColor)) {
                  if (innerMarker) {
                    fillStyle = innerFillColorFunc(
                    multiColoring ? itemIndex : legendOrder,
                    d,
                    null,
                    markerOptions.innerFillColor,
                    innerFillOpacity,
                    null,
                    false);

                    strokeStyle = rgba_canvas(
                    strokeColor(
                    multiColoring ? itemIndex : legendOrder,
                    d,
                    chartObj.imagePallete ? null : markerOptions.innerStrokeColor),

                    innerStrokeOpacity);

                    canvas_plot_renderer.scatter.drawPath(
                    shape,
                    context,
                    x,
                    y,
                    size / 2,
                    innerStrokeWidth,
                    strokeStyle,
                    fillStyle,
                    innerDashArray,
                    innerStrokeLineCap,
                    null,
                    null,
                    null,
                    'inner');

                  }
                }
              }
            });
          });
        }

        if (defined(labelRenderer)) {
          var markerSize;
          if (scatterOrBubble) {
            markerSize = outerSize * 2 + markerOptions.outerStrokeWidth;
          } else {
            var strokeWidth = pick(cpOptions.strokeWidth, 2);
            markerSize = pick(markerOptions.size, strokeWidth) * outerSize + strokeWidth / 2;
          }
          labelQueue.push({
            renderer: chart,
            charttype: 'scatter',
            chartObj: chartObj,
            rendererIndex: rendererIndex,
            paneid: paneid,
            args: [seriesData, legendOrder, markerSize, yrangePos]
          });
        }
        chart.chartRendered = true;
        return chart;
      }

      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          var isBubbleChart = chartcategory.bubble.has(getChartTypeByIndex(chartObj, null, index).value);
          chart.highlighter = isBubbleChart ? new BubbleHighlighter(chartObj, chart) : new ScatterHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };

      chart.yrangePos = function (_) {
        if (!arguments.length) {
          return yrangePos;
        }
        yrangePos = _;
        return chart;
      };

      return chart;
    };

    /**
     * @param {String} symbol
     * @param {CanvasRenderingContext2D} context
     * @param {Number} x
     * @param {Number} y
     * @param {Number} size
     * @param {Number} strokeWidth
     * @param {String} strokeColor
     * @param {String} fillColor
     */

    canvas_plot_renderer.scatter.drawPath = function (
    symbol,
    context,
    x,
    y,
    size,
    strokeWidth,
    strokeColor,
    fillColor,
    strokeDashArray,
    strokeLineCap,
    imageUrl,
    imageDimension,
    opacity,
    side)
    {
      context.save();
      context.translate(x, y);
      context.beginPath();
      context.lineWidth = strokeWidth;
      context.strokeStyle = strokeColor;

      if (symbol === 'circle') {
        context.arc(0, 0, size, 0, mathPI * 2);
      } else {
        var path = getSVGsymbol(symbol)(size * 2, null, null, side);
        canvasUtils.drawPath(context, path);
      }

      if (imageUrl) {
        // For marker with imageUrl
        context.globalAlpha = opacity; //Set outerFillOpacity for imageUrl
        context.translate(-size + imageDimension.x, -size + imageDimension.y);
      }

      context.fillStyle = fillColor;
      if (fillColor) {
        context.fill();
      }

      if (imageUrl) {
        context.globalAlpha = 1; //Reset outerFillOpacity for imageUrl
      }

      if (strokeDashArray && strokeDashArray.length && _typeof(strokeDashArray) === 'object' && defined(context.setLineDash)) {
        context.setLineDash(strokeDashArray);
        context.lineCap = strokeLineCap;
      }

      if (strokeWidth && strokeColor) {
        context.stroke();
      }
      context.closePath();
      context.restore();
    };

    /**
     * osc, osw, ofc, isc, isw, ifc - params
     * o - outer
     * i - inner
     * s - stroke
     * f - fill
     * c - color
     * w - width
     * ----
     * @param {String} symbol
     * @param {Number} outerSize
     * @param {String} osc
     * @param {Number} osw
     * @param {String} ofc
     * @param {String} isc
     * @param {Number} isw
     * @param {String} ifc
     */

    canvas_plot_renderer.scatter.getCache = function (symbol, outerSize, osc, osw, ofc, isc, isw, ifc, markerOptions) {
      var adjustPosition = 10, // to remove the sharp edge
        scaleRatio = DEVICE_PIXEL_RATIO * 1.5,
        cacheCanvas = document.createElement('canvas'),
        tempPos = (outerSize + osw / 2) * scaleRatio + adjustPosition / 2,
        cache = cacheCanvas.getContext('2d'),
        canvasDimension = (outerSize * 2 + osw + adjustPosition) * scaleRatio,
        width = canvasDimension / scaleRatio;
      cacheCanvas.height = cacheCanvas.width = canvasDimension;
      // outer symbol
      this.drawPath(
      symbol,
      cache,
      tempPos,
      tempPos,
      outerSize * scaleRatio,
      osw * scaleRatio,
      osc,
      ofc,
      getDashArray(markerOptions.outerDashStyle, osw, scaleRatio),
      getLineCap(markerOptions.outerLineCap, markerOptions.outerDashStyle));

      // inner symbol
      this.drawPath(
      symbol,
      cache,
      tempPos,
      tempPos,
      outerSize / 2 * scaleRatio,
      isw * scaleRatio,
      isc,
      ifc,
      getDashArray(markerOptions.innerDashStyle, isw, scaleRatio),
      getLineCap(markerOptions.innerLineCap, markerOptions.innerDashStyle),
      null,
      null,
      null,
      'inner');


      return {
        canvas: cache.canvas,
        width: width,
        adjustPosition: adjustPosition / 2 / scaleRatio
      };
    };

    defaultTheme.scatter = function (chartType) {
      var options = {
        outerPadding: 0.02,
        multiColoring: false,
        marker: {
          size: 1,
          innerFillColor: 'white',
          innerStrokeColor: 'white',
          innerStrokeWidth: 0,
          innerStrokeOpacity: 1,
          outerFillColor: 'white',
          outerStrokeOpacity: 1,
          outerStrokeWidth: 2
        },
        hoveroptions: {
          innerStrokeOpacity: 1,
          outerFillColor: 'white',
          outerStrokeWidth: 2
        },
        datalabels: {
          showAs: 'y' //x,y,percent
        },
        animation: {
          type: 'allseries' //onebyone || seriesbyseries || allseries || fade || fadeAll
        },
        gradients: {
          // radial || linear || none
          options: {
            linear: {
              y2: 100,
              gradientUnits: 'userSpaceOnUse', //objectBoundingBox || userSpaceOnUse
              colorGamma: [2, 0]
            },
            radial: {
              radius: 90,
              colorGamma: [2, 0]
            }
          }
        }
      };

      if (chartType === 'geoscatter') {
        // marker.innerStrokeWidth = marker.innerFillOpacity = hoverOptions.innerFillOpacity = hoverOptions.innerStrokeWidth = 0;

        options.animation.type = 'sizing';
        options.datalabels.showAs = 'geo';
        options.datalabels.orient = 'bottom';
        options.datalabels.textOverlap = 'hidden';
      }

      return options;
    };

    //$Id$

    /**
     *
     * @returns {chart} scatter, bubble renderer.
     */
    svg_plot_renderer.scatter = function () {
      var chartObj,
        xscale,
        yscale,
        index,
        yaxiscolumnorder,
        color,
        stacked,
        dataset,
        axisrotated,
        labelQueue,
        commonPlotOptions,
        systemconf,
        hasNegValue,
        redraw = false,
        transitionDuration;
      var shiftInfo,
        commonRendererProp,
        yrangePos,
        dataProcessorHelpers = DataProcessor.helpers;
      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj,
          xscale = rp.xscale,
          yscale = rp.yscale,
          stacked = rp.stacked,
          index = rp.datasetIndex,
          axisrotated = rp.axisrotated,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          labelQueue = rp.labelQueue,
          hasNegValue = rp.hasNegValue,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset,
          systemconf = chartObj.systemConf;

          var renderingOrder = rp.renderingOrderIndex,
            legendOrder = rp.legendOrderIndex,
            rendererIndex = rp.rendererIndex,
            shapescale = rp.shapescale;

          var defsLocation = chartObj.defsLocation;

          var xReversed = systemconf.chart.axes.xaxis.reversed,
            yReversed = systemconf.chart.axes.yaxis[yaxiscolumnorder].reversed;

          var container = d3_select(this);
          chart.update = function () {
            container.transition().call(chart);
          };
          var currentdata = data[index];
          var data_bind = { data: currentdata, index: renderingOrder };
          var plotoptions = currentdata.plotoptions;

          var currentseriesdata = currentdata.data;
          var paneid = "".concat(currentdata.row, "_").concat(currentdata.column);

          var cType_Obj = getChartTypeByIndex(chartObj, paneid, index),
            cType = cType_Obj.value,
            chartName = cType_Obj.name;

          var isBubbleChart = chartcategory.bubble.has(cType),
            scatterOrBubble = isScatterChartType(cType),
            isPolar = chartObj.dataObject.isPolarAxisCategory;
          var dynamicPosition = rp.dynamicSeriesPosition;
          if (dynamicPosition === undefined) {
            dynamicPosition = index;
          }
          var series = appendEle(container, 'g', [data_bind], '.', 'class', "scatterseries_".concat(dynamicPosition));
          if (chartName === 'arearange') {
            series = appendEle(series, 'g', [data_bind], '.', 'class', "rangePos_".concat(yrangePos));
          }

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, chartName);
          var isAnimationEnable = animationOptions.enabled,
            easingType = animationOptions.easingType,
            animationType = animationOptions.type;
          transitionDuration = animationOptions.duration;

          var markerOptions = commonRendererProp.params.markerOptions =
          plotoptions && plotoptions.marker ?
          mergeJSON$1(commonPlotOptions.marker, plotoptions.marker, true) :
          commonPlotOptions.marker;

          var hoverOptions = commonRendererProp.params.hoverOptions =
          plotoptions && plotoptions.hoveroptions ?
          mergeJSON$1(commonPlotOptions.hoveroptions, plotoptions.hoveroptions, true) :
          commonPlotOptions.hoveroptions;
          var symboltype = markerOptions.symbol,
            symbolsize = markerOptions.size,
            imageUrl = markerOptions.imageUrl,
            markerPosition = markerOptions.position;
          var race_syncTrans = chartObj.racing && chartObj.racing.syncTransition;
          if (!scatterOrBubble) {
            if (isUndefined(symbolsize)) {
              symbolsize =
              (plotoptions ?
              utils.getValueOfPlotOptions(plotoptions, commonPlotOptions)('strokeWidth') :
              commonPlotOptions.strokeWidth) || 2;
            }

            if (!imageUrl) {
              symbolsize *= isPolar ? 0.56 : 0.7;
            }

            animationType =
            animationType == VERTPATHTWEEN_ANIMATION || animationType == VERTPATHTWEENALL_ANIMATION ?
            VERTICALALL_ANIMATION :
            animationType;
            animationType = animationType == HORIPATHTWEEN_ANIMATION ? HORIZONTALALL_ANIMATION : animationType;
            color = currentdata.color;
          } else {
            symbolsize = validateNullVal(symbolsize, 1);
            animationType = animationType == FADEALL_ANIMATION ? FADE_ANIMATION : animationType;
          }

          var symbolpath = getSVGsymbol(symboltype, symbolsize),
            _symbolPath = function _symbolPath(d) {return shapescale ? getSVGsymbol(shapescale(d.data[dataset.shapeidx]), symbolsize) : symbolpath;},
            multiColoring = scatterOrBubble ? isMultiColoring(commonPlotOptions, chartObj) : false,
            outersize = symbolsize * 10,
            initial_outerFillOpacity = animationType == FADE_ANIMATION ? 0 : markerOptions.outerFillOpacity,
            initial_outerStrokeOpacity = animationType == FADE_ANIMATION ? 0 : markerOptions.outerStrokeOpacity,
            initial_innerFillOpacity = animationType == FADE_ANIMATION ? 0 : markerOptions.innerFillOpacity,
            initial_innerStrokeOpacity = animationType == FADE_ANIMATION ? 0 : markerOptions.innerStrokeOpacity,
            imageConf = {
              name: markerOptions.imageUrl
            },
            outerDashArray = getDashArray(markerOptions.outerDashStyle, markerOptions.outerStrokeWidth),
            innerDashArray = getDashArray(markerOptions.innerDashStyle, markerOptions.innerStrokeWidth),
            outerStrokeLineCap = getLineCap(markerOptions.outerLineCap, markerOptions.outerDashStyle),
            innerStrokeLineCap = getLineCap(markerOptions.innerLineCap, markerOptions.innerDashStyle),
            hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
            visibility = hasColorScale && markerOptions.enabled === false ? 'hidden' : NULL$1;

          var fillColor = chart.fillColorFunc = getFillColor(chartObj, index, paneid, null, scatterOrBubble ? null : true, null, null, rp),
            strokeColor = getStrokeColor(chartObj, index, paneid, null, rp);

          //Initiated in dataprocessor
          if (chartObj.dataObject.markerSize[chartName]) {
            var mSize = symboltype == 'line' || symboltype == 'vertical-line' ? strokeWidth || 1 : outersize;
            chartObj.dataObject.markerSize[chartName].add(mSize);
          }

          chart.seriesdataAfterUpdate = [];
          var datatypeX = chartObj.dataset.getDataType('x'),
            datatypeY = chartObj.dataset.getDataType('y', yaxiscolumnorder),
            isCatNullX = dataProcessorHelpers.isCatNull(dataset, 'x'),
            isCatNullY = dataProcessorHelpers.isCatNull(dataset, 'y', yaxiscolumnorder),
            xCategories = datatypeX == ORDINAL_DATATYPE ? xscale.domain() : null,
            yCategories = datatypeY == ORDINAL_DATATYPE ? yscale.domain() : null,
            categories =
            datatypeX == ORDINAL_DATATYPE && xscale.domain != null && !defined(chartObj.dataObject.hierarchical) ?
            xCategories :
            chartObj.dataObject.getCategories('x');

          currentseriesdata.forEach(function (d, i) {
            var dataUpdate;
            if (datatypeX == ORDINAL_DATATYPE || datatypeY == ORDINAL_DATATYPE) {
              dataUpdate = chartObj.dataObject.updateSeriesdatabyCategories(d3_values(d), xCategories, yCategories, yaxiscolumnorder);
            } else {
              dataUpdate = d;
            }

            if (chartObj.renderVisiblePointsOnly) {
              dataUpdate = DataProcessor.helpers.filterPointsInViewport(chartObj, dataUpdate, 'scatter', 'xy', index);
            }

            chart.seriesdataAfterUpdate[i] = dataUpdate;
            var ishideable = currentdata.disabled;
            var serData, baseData, basedataShift;

            if (animationType == POINTBYPOINT_ANIMATION || animationType == POINTTWEEN_ANIMATION) {
              serData = dataUpdate;
              if (xReversed) {
                serData = serData.slice(0).reverse();
              }
              baseData = serData;
              if (animationType == POINTTWEEN_ANIMATION) {
                baseData = serData.map(function (d, i) {
                  return Object.create(serData[0]);
                });
              } else if (animationType == POINTBYPOINT_ANIMATION) {
                var baseIdx = isPolar && yReversed && !stacked ? yscale.domain().length - 1 : 0;
                baseData = serData.map(function (d, i) {
                  var s = Object.create(d);
                  var baseY =
                  !isPolar && hasNegValue != null && yscale(hasNegValue) != null ?
                  mathMax(hasNegValue, yscale.domain()[0]) :
                  yscale.domain()[baseIdx];
                  if (stacked) {
                    s.y0 = 0;
                    s.y = baseY;
                  }
                  s[dataset.yidx(yaxiscolumnorder)] = baseY;
                  return s;
                });
              }
              basedataShift = d3_values(baseData);
            }

            var subseries = appendEle(
            series,
            'g',
            function (d) {
              return ishideable ? [] : [dataUpdate];
            },
            '.',
            'class', "subseries_".concat(
            i));

            var dataKeyFunc = function dataKeyFunc(d) {
              return d;
            };
            var scatter = subseries.
            selectAll('g.scatter').
            data(dataKeyFunc).
            attr('class', 'scatter');
            // appendEle(subseries, "g", dataKeyFunc, ".", "class", "scatter", null)
            var scatterEnter = scatter.
            enter().
            append('g').
            attr('class', 'scatter');
            var noScatters = scatterEnter.size();
            var duration = animationType != ONEBYONE_ANIMATION ? transitionDuration : transitionDuration / noScatters,
              pathData = function pathData(d, i) {
                if (isPolar && (!d || d.isDummy)) {
                  return [];
                } else if (
                !isPolar &&
                cType !== charttype.stkdarea && (
                !d || d.isDummy || isCatNullX(dataset.getX(d)) || isCatNullY(dataset.getY(d, yaxiscolumnorder))))
                {
                  return [];
                } else if (!isPolar && cType == charttype.stkdarea && (!d || d.isDummy)) {
                  // to remove stacked area with dummy data added
                  return [];
                } else {
                  return [
                  {
                    color: multiColoring ? chartObj.seriesColor[i % chartObj.seriesColor.length] : color,
                    index: multiColoring ? i : legendOrder,
                    data: d
                  }];

                }
              };
            //console.log(isAnimationEnable);
            if (chartObj.systemConf.chart.plot.morph.enabled && chartObj.oldSeriesInfo) {
              scatterEnter.attr('transform', function (d) {
                return "translate(".concat(chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'x',
                null,
                yrangePos), ",").concat(
                chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'y', null, yrangePos), ")");
              });
            } else if (isAnimationEnable) {
              if (animationType == POINTBYPOINT_ANIMATION || animationType == POINTTWEEN_ANIMATION) {
                interTween(
                baseData,
                basedataShift,
                serData,
                categories,
                animationType,
                easingType,
                transitionDuration,
                rp,
                function (d) {
                  return {
                    transform: function transform(dt, i) {
                      return "translate(".concat(getInitialX(d[i]), ",").concat(getInitialY(d[i]), ")");
                    }
                  };
                },
                scatterEnter,
                'scatter');

              } else {
                var initTransition = scatterEnter.
                transition().
                delay(function (d, i) {
                  return animationType == ONEBYONE_ANIMATION ? i * duration : 0;
                }).
                duration(duration).
                ease(easingType);
                if (race_syncTrans) {
                  initTransition = race_syncTrans;
                }
                scatterEnter.
                attr('transform', function (d, i) {
                  if (race_syncTrans) {
                    var xValue = chartObj.dataObject.getXYvalue(
                    axisrotated,
                    stacked,
                    xscale,
                    yscale,
                    yaxiscolumnorder,
                    d,
                    'x',
                    null,
                    yrangePos);

                    var yValue = chartObj.dataObject.getXYvalue(
                    axisrotated,
                    stacked,
                    xscale,
                    yscale,
                    yaxiscolumnorder,
                    d,
                    'y',
                    null,
                    yrangePos);

                    return "translate(".concat(xValue, ",").concat(yValue, ")");

                  }
                  return "translate(".concat(getInitialX(
                  d), ",").concat(
                  getInitialY(d), ")").concat(imageUrl && animationType === SIZING_ANIMATION ? ' scale(0)' : '');
                }).
                transition(initTransition).
                attr('transform', function (d) {
                  return "translate(".concat(chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  d,
                  'x',
                  null,
                  yrangePos), ",").concat(
                  chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'y', null, yrangePos), ")");
                });
                // scatterEnter = scatterEnter.merge(scatter)
              }
            }
            var scatterUpdate = scatterEnter.merge(scatter);
            // if(scatterEnter.node() == null || !isAnimationEnable){ //doubt : Why scatterEnter.node() == null?

            var outermarkerEnter = appendEle(scatterUpdate, 'path', pathData, '.', 'class', 'outer');
            if (!redraw) {
              outermarkerEnter.styles({
                'fill-opacity': initial_outerFillOpacity,
                'stroke-opacity': initial_outerStrokeOpacity,
                visibility: visibility
              });
            }

            /**
             *
             * removing inner marker if
             * 1. defined image marker or
             * 2. innerStrokeWidth is 0 and if it is not visible.
             */
            var innerPathData = pathData;
            if (
            imageUrl ||
            markerOptions.innerStrokeWidth === 0 && (
            markerOptions.innerFillOpacity === 0 || markerOptions.innerFillColor === 'transparent'))
            {
              innerPathData = [];
            }

            var innermarkerpath = appendEle(scatterUpdate, 'path', innerPathData, '.', 'class', 'inner');
            innermarkerpath.styles({
              'fill-opacity': initial_innerFillOpacity,
              'stroke-opacity': initial_innerStrokeOpacity,
              visibility: visibility
            });

            if (redraw && imageUrl) {
              scatterUpdate.attr('transform', function (d) {
                var transform = d3_select(this).attr('transform'),
                  previousSize = d3_select(this).attr('size'),
                  size = getSymbolSize(d);
                if (transform) {
                  return "".concat(transform, " scale(").concat(previousSize / size, ")");
                }
              });
            }

            if (race_syncTrans) {
              //updating position
              scatterUpdate.
              transition(race_syncTrans).
              attr('transform', function (d) {
                return "translate(".concat(chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'x',
                null,
                yrangePos), ",").concat(
                chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'y', null, yrangePos), ")");
              }).
              styles({
                transition: 'opacity ease .2s'
              });
            } else {
              scatterUpdate.
              style('visibility', function (d, i) {
                if (!markerPosition) {
                  return NULL$1;
                }

                var position = i === 0 ? START_ALIGN : i === dataUpdate.length - 1 ? END_ALIGN : MIDDLE_ALIGN;
                return markerPosition.indexOf(position) > -1 ? NULL$1 : 'hidden';
              }).

              transition().
              delay(function (d, i) {
                return (animationType == POINTBYPOINT_ANIMATION || animationType == POINTTWEEN_ANIMATION) &&
                scatterEnter.node() != null ?
                transitionDuration :
                animationType == ONEBYONE_ANIMATION ?
                i * duration :
                0;
              }).
              duration(duration).
              ease(easingType).
              attr('transform', function (d) {
                return "translate(".concat(chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'x',
                null,
                yrangePos), ",").concat(
                chartObj.dataObject.getXYvalue(axisrotated, stacked, xscale, yscale, yaxiscolumnorder, d, 'y', null, yrangePos), ")");
              }).
              styles({
                transition: 'opacity ease .2s'
              });
            }

            setOpacityForTickFilterElements(scatterUpdate, chartObj, 'scatter');

            if (chartObj.dataObject.hierarchical) {
              scatterUpdate.attr('levelbycolumn', function (d, i) {
                return d.levelByColumn;
              });
              if (chartObj.dataObject.pivot) {
                scatterUpdate.attr('levelbyrow', function (d, i) {
                  return d.levelByRow;
                });
              }
            }

            // }

            var pathDuration = animationType === SIZINGRANDOM_ANIMATION ? transitionDuration * 2 / 5 : duration,
              pathDelay =
              animationType === SIZINGRANDOM_ANIMATION ?
              function () {
                return mathRandom() * (transitionDuration * 3 / 5);
              } :
              0;
            function updatePath(scatterUpdate, className) {
              var dashArray, strokeLineCap;
              if (className === 'outer') {
                dashArray = outerDashArray;
                strokeLineCap = outerStrokeLineCap;
              } else {
                dashArray = innerDashArray;
                strokeLineCap = innerStrokeLineCap;
              }
              return scatterUpdate.
              selectAll("path.".concat(className)).
              attr('d', function (d, i) {
                var previousSize = d3_select(this.parentNode).attr('size'),
                  symbolSize = getSymbolSize(d.data);
                var size = imageUrl ? symbolSize : previousSize;
                var s =
                previousSize != null ?
                size :
                (animationType == SIZING_ANIMATION || animationType === SIZINGRANDOM_ANIMATION) && !imageUrl ?
                0 :
                symbolSize;
                if (className === 'outer') {
                  return _symbolPath(d)(s);
                } else {
                  return _symbolPath(d)(s / 2, null, null, 'inner');
                }
              }).
              styles({
                'stroke-width': markerOptions["".concat(className, "StrokeWidth")],
                fill: function fill(d, i) {
                  var symbolSize = getSymbolSize(d.data);
                  var radius;
                  if (className === 'outer') {
                    if (imageUrl) {
                      imageConf.width = imageConf.height = parseFloat(symbolSize);
                      imageConf.x = imageConf.y = -parseFloat(symbolSize) / 2;
                      return "url(".concat(defsLocation, "#").concat(effects.get(effects.svg_patterns, 'imageFill', imageConf, {
                        chartObj: chartObj
                      }), ")");
                    }
                    radius = symbolSize / 2;
                  } else {
                    radius = symbolSize / 4;
                  }

                  return fillColor(
                  d.index,
                  d.data,
                  null,
                  markerOptions["".concat(className, "FillColor")],
                  null,
                  scatterOrBubble ? [radius, radius] : null);

                },
                stroke: function stroke(d, i) {
                  return strokeColor(d.index, d.data, markerOptions["".concat(className, "StrokeColor")]);
                },
                'stroke-dasharray': dashArray,
                'stroke-linecap': strokeLineCap,
                visibility: visibility
              });
            }
            if (chartObj.systemConf.chart.plot.morph.enabled && chartObj.oldSeriesInfo) {
              var morph_Obj = new zcMorph({ sampling: chartObj.systemConf.chart.plot.morph.samplingDistance });
              var oldseriesData = chartObj.oldSeriesInfo.get(index);
              var oldseriesIndex = oldseriesData.seriesIndex;
              var oldseriesColor = oldseriesData.color;
              var offsetValue = getOffsetValue(chartObj, oldseriesIndex);
              var multicoloring = isMultiColoring(commonPlotOptions, chartObj);
              var individualElementTransform = oldseriesData.transformationInfo;
              var morphDuration = chartObj.systemConf.chart.plot.morph.duration;

              var interpolated = {};
              var line = d3_line();

              scatterUpdate.each(function (d, i) {
                var xValue = chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'x',
                null,
                yrangePos);

                var yValue = chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'y',
                null,
                yrangePos);


                var fromPath = chartObj.oldSeriesInfo.get(oldseriesIndex).pathData[i];
                var fromPathAttribute = fromPath.getAttribute('d');
                fromPath.setAttribute('d', symbolpath(getSymbolSize(d)));
                var toPath = fromPath.cloneNode();
                fromPath.setAttribute('d', fromPathAttribute);
                interpolated[i] = morph_Obj.interpolate(
                {
                  path: fromPath,
                  xOffset: -xValue + offsetValue.x + individualElementTransform[i].x,
                  yOffset: -yValue + offsetValue.y + individualElementTransform[i].y
                },
                { path: toPath, xOffset: 0, yOffset: 0 });

              });

              scatterUpdate.each(function (d, i) {
                d3_select(this).
                selectAll('path.outer').
                style('fill', function () {
                  return oldseriesColor[i];
                }).
                transition().
                duration(morphDuration).
                ease(easingType).
                style('fill', function () {
                  if (multicoloring) {
                    return getRawColor(chartObj, i, d, oldseriesIndex, null, rendererIndex);
                  } else {
                    return getRawColor(chartObj, 0, d, oldseriesIndex, null, rendererIndex);
                  }
                }).
                attrTween('d', function () {
                  var interpolator = interpolated[i];
                  return function (t) {
                    return line(
                    interpolator.map(function (p) {
                      return p(t);
                    }));

                  };
                }).
                on('end', function () {
                  if (chartObj.oldSeriesInfo) {
                    delete chartObj.oldSeriesInfo;
                  }
                  if (i === chartObj.seriesdata[index].data[0].length - 1) {
                    updatePath(scatterUpdate, 'outer');
                    updatePath(scatterUpdate, 'inner');
                  }
                });
              });
            } else {
              var outermarkerpathUpdate = updatePath(scatterUpdate, 'outer');
              var innermarkerpathUpdate = updatePath(scatterUpdate, 'inner');
              outermarkerpathUpdate.
              transition().
              delay(pathDelay).
              duration(pathDuration).
              ease(easingType).
              attr('d', function (d) {
                return _symbolPath(d)(getSymbolSize(d.data));
              }).
              styles({
                'fill-opacity': markerOptions.outerFillOpacity,
                'stroke-opacity': markerOptions.outerStrokeOpacity
              });
              innermarkerpathUpdate.
              transition().
              delay(pathDelay).
              duration(pathDuration).
              ease(easingType).
              attr('d', function (d) {
                return _symbolPath(d)(getSymbolSize(d.data) / 2, null, null, 'inner');
              }).
              styles({
                'fill-opacity': markerOptions.innerFillOpacity,
                'stroke-opacity': markerOptions.innerStrokeOpacity
              });
            }

            var blinkConf =
            (plotoptions && plotoptions.animation && plotoptions.animation.blink ?
            mergeJSON$1(commonPlotOptions.animation.blink, plotoptions.animation.blink, true) :
            commonPlotOptions.animation.blink) || {};

            blinkSVGsymbols(scatterUpdate.selectAll('.outer,.inner'), blinkConf, chartObj);

            scatterUpdate.attr('size', function (d) {
              return getSymbolSize(d);
            }); //Saving the size, makes redraw animation cool
            if (race_syncTrans) {
              scatter.
              exit().
              transition(race_syncTrans).
              remove();
            } else {
              scatter.exit().remove();
            }

            function getInitialX(d) {
              switch (animationType) {
                case VERTICALALL_ANIMATION:
                  var baseX =
                  hasNegValue != null && yscale(hasNegValue) != null ?
                  yscale(mathMax(hasNegValue, yscale.domain()[0])) :
                  yscale.origRange[0];
                  return axisrotated ?
                  baseX :
                  chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  d,
                  'x',
                  null,
                  yrangePos);

                case HORIZONTALALL_ANIMATION:
                  var baseX =
                  (hasNegValue != null && xscale(hasNegValue) != null ?
                  xscale(mathMax(hasNegValue, xscale.domain()[0])) :
                  xscale.origRange[0]) + (xscale.bandwidth != null ? xscale.bandwidth() / 2 : 0);
                  return axisrotated ?
                  chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  d,
                  'x',
                  null,
                  yrangePos) :

                  baseX;
                case FADE_ANIMATION:
                case SIZING_ANIMATION:
                case SIZINGRANDOM_ANIMATION:
                case POINTTWEEN_ANIMATION:
                case POINTBYPOINT_ANIMATION:
                case STROKETWEEN_ANIMATION:
                  return chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  d,
                  'x',
                  null,
                  yrangePos);

                default:
                  var range = (axisrotated ? yscale : xscale).origRange;
                  var pos = axisrotated && yReversed || !axisrotated && xReversed ? range.length - 1 : 0;
                  return range[pos];}

            }

            function getInitialY(d) {
              switch (animationType) {
                case VERTICALALL_ANIMATION:
                  var baseY =
                  hasNegValue != null && yscale(hasNegValue) != null ?
                  yscale(mathMax(hasNegValue, yscale.domain()[0])) :
                  yscale.origRange[0];
                  return axisrotated ?
                  chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  d,
                  'y',
                  null,
                  yrangePos) :

                  baseY;
                case HORIZONTALALL_ANIMATION:
                  var baseX =
                  (hasNegValue != null && xscale(hasNegValue) != null ?
                  xscale(mathMax(hasNegValue, xscale.domain()[0])) :
                  xscale.origRange[0]) + (xscale.bandwidth != null ? xscale.bandwidth() / 2 : 0);
                  return axisrotated ?
                  baseX :
                  chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  d,
                  'y',
                  null,
                  yrangePos);

                case FADE_ANIMATION:
                case SIZING_ANIMATION:
                case SIZINGRANDOM_ANIMATION:
                case POINTTWEEN_ANIMATION:
                case POINTBYPOINT_ANIMATION:
                case STROKETWEEN_ANIMATION:
                  return chartObj.dataObject.getXYvalue(
                  axisrotated,
                  stacked,
                  xscale,
                  yscale,
                  yaxiscolumnorder,
                  d,
                  'y',
                  null,
                  yrangePos);

                default:
                  var range = (axisrotated ? xscale : yscale).origRange;
                  var pos = axisrotated && xReversed || !axisrotated && yReversed ? range.length - 1 : 0;
                  return range[pos];}

            }

            function getSymbolSize(d) {
              if (isPolar && (!d || d.isDummy)) {
                return 0;
              } else if (
              !isPolar &&
              cType !== charttype.stkdarea && (
              isCatNullX(dataset.getX(d)) || isCatNullY(dataset.getY(d, yaxiscolumnorder))))
              {
                return 0;
              } else {
                return isBubbleChart ?
                chartObj.dataObject.getXYvalue(
                axisrotated,
                stacked,
                xscale,
                yscale,
                yaxiscolumnorder,
                d,
                'z',
                chartObj.zscale,
                yrangePos) :

                outersize;
              }
            }
            function getSymbolBBox(d) {
              var size = getSymbolSize(d);
              if (size > 0 && (symboltype == 'line' || symboltype == 'vertical-line')) {
                if (symboltype == 'line') {
                  return {
                    width: size,
                    height: strokeWidth || 1
                  };
                } else if (symboltype == 'vertical-line') {
                  return {
                    height: strokeWidth || 1,
                    width: size
                  };
                }
              } else {
                return null;
              }
            }
            //currently segments available only for line, vertical-line, whiskers symbol alone
            //for line - there is single segment
            //for whisker it is array of multiple line segments
            function getSegments(d) {
              var size = getSymbolSize(d);
              if (symboltype == 'line' || symboltype == 'vertical-line') {
                var _data = d._data();
                var symbolSegment = getSegmentsForSymbol(symboltype, size, _data._x, _data._y);
                if (symboltype == 'line' || symboltype == 'vertical-line') {
                  return [symbolSegment];
                } else {
                  return symbolSegment;
                }
              }
            }

            //Assign renderer functions
            chart.getSymbolSize = getSymbolSize;
            chart.getSymbolBBox = getSymbolBBox;
            chart.getSegments = getSegments;
          });
          if (scatterOrBubble) {
            chart.highlighter = isBubbleChart ? new BubbleHighlighter(chartObj, chart) : new ScatterHighlighter(chartObj, chart);
          }

          if (labelRenderer != null) {
            var markerSize;
            if (scatterOrBubble || isBubbleChart) {
              markerSize = outersize + markerOptions.outerStrokeWidth;
            } else {
              var strokeWidth = validateNullVal(utils.getValueOfPlotOptions(plotoptions, commonPlotOptions)('strokeWidth'), 2);
              markerSize = (markerOptions.size || strokeWidth) * outersize * 0.5 + strokeWidth / 2;
            }
            labelQueue.push({
              renderer: chart,
              charttype: 'scatter',
              chartObj: chartObj,
              rendererIndex: rendererIndex,
              paneid: paneid,
              args: [currentdata, index, markerSize, yrangePos]
            });
          }

          var chartInstance = commonRendererProp.params.chartObj;
          chartInstance.timerObj[chartInstance.timerObj.length] = chart.renderedTimer = setTimeout(function () {
            redraw = true;
            chart.chartRendered = true;
          }, transitionDuration);
        });
        return chart;
      }
      chart.getHighlighter = function (chartObj, index) {
        if (!chart.highlighter) {
          var isBubbleChart = chartcategory.bubble.has(getChartTypeByIndex(chartObj, null, index).value);
          chart.highlighter = isBubbleChart ? new BubbleHighlighter(chartObj, chart) : new ScatterHighlighter(chartObj, chart);
        }
        return chart.highlighter;
      };
      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      chart.shiftInfo = function (_) {
        if (!arguments.length) {
          return shiftInfo;
        }
        shiftInfo = _;
        return chart;
      };

      chart.yrangePos = function (_) {
        if (!arguments.length) {
          return yrangePos;
        }
        yrangePos = _;
        return chart;
      };
      return chart;
    };

    defaultTheme.bubble = function () {
      return {
        outerPadding: 0.02,
        multiColoring: false,
        marker: {
          innerFillOpacity: 0,
          innerStrokeWidth: 0,
          innerStrokeOpacity: 0,
          outerFillOpacity: 0.4,
          outerStrokeOpacity: 1
        },
        hoveroptions: {
          innerFillColor: 'transparent',
          innerStrokeColor: 'transparent',
          innerStrokeOpacity: 1,
          innerStrokeWidth: 0,
          outerFillOpacity: 0.3,
          outerStrokeOpacity: 0.5
        },
        datalabels: {
          showAs: 'y' //x,y,z,percent
        },
        animation: {
          type: 'sizing' //sizing || onebyone || seriesbyseries || allseries || fade || fadeAll || verticalAll
        },
        gradients: {
          // radial || linear || none
          options: {
            linear: {
              y2: 100,
              gradientUnits: 'userSpaceOnUse', //objectBoundingBox || userSpaceOnUse
              colorGamma: [1.5, 0]
            },
            radial: {
              radius: 90,
              colorGamma: [1.5, 0]
            }
          }
        }
      };
    };

    defaultTheme.sunburst = function () {
      return {
        strokeColor: 'white',
        innerRadius: 30,
        outerPadding: 20,
        animation: {
          type: 'fan' //fan, inner, wheel
        },
        datalabels: {
          showAs: 'y', //x,y,percent
          type: 'circular', // circular || doubleside
          padding: 10,
          line: {
            strokeColor: 'grey',
            strokeWidth: 0.3
          },
          innerLabel: {
            show: false,
            showAs: 'splitpercent', //x,y,percent
            parentLabel: {}
          }
        }
      };
    };

    //$Id$

    var annotation$6 = Registry.getComponent('annotation');
    /**
     *
     * @returns {chart} sunburst renderer.
     */
    /*
     * PENDING:
     * Annotation for parent arcs. Legend filter
     * Annotation for hierarchy data
     */
    svg_plot_renderer.sunburst = function () {
      var commonRendererProp,
        xscale,
        yscale,
        arc,
        radius,
        dataset,
        redraw = false,
        arcLabel,
        systemconf,
        oldData,
        yaxiscolumnorder;
      var chartwidth, chartheight, color, chartObj, notesArray, path, pathGroup, commonPlotOptions;
      var start,
        end,
        innerrad,
        rad,
        highlightGroup,
        highlightEle,
        highlightHierarchy,
        maxDepth,
        valueFunction,
        nodes,
        stratifiedIndices = {};

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj,
          commonPlotOptions = rp.commonPlotOptions,
          color = rp.color,
          notesArray = rp.notesArray,
          yaxiscolumnorder = rp.yaxiscolumnorder,
          dataset = rp.dataset;
          systemconf = chartObj.systemConf;
          var labelQueue = rp.labelQueue,bound = rp.bound,rendererIndex = rp.rendererIndex;

          chartwidth = bound.width, chartheight = bound.height;
          var paneid = isFacet(chartObj) ? "".concat(data[0].row, "_").concat(data[0].column) : null;
          var gvpFn = utils.getValueOfPlotOptions,
            dataLabels = commonPlotOptions.datalabels,
            outerPadding = +commonPlotOptions.outerPadding || 0,
            NegativeAsAbsolute = commonPlotOptions.showAsNegative === 'absolute',
            finalDisplay = function finalDisplay(d) {
              var hidden = isDisabled(data, d) || start(d) === end(d) || !d.value; // if disabled or value = 0 | null
              return hidden ? NONE : NULL$1;
            },
            initialDisplay = function initialDisplay(d) {
              var prevDisplay = d3_select(this).style('display'),
                curDisplay = finalDisplay(d);
              return !redraw || prevDisplay === NONE && curDisplay === NONE ? curDisplay : NULL$1;
            },
            padding;
          highlightGroup = null;
          maxDepth = 0;
          nodes = [];

          var showlabel = chartObj.datalabels.moduleExists && isDatalabelEnabled(dataLabels, chartObj);
          var boundBoxPadding =
          showlabel && isBoundBoxEnabled(dataLabels, chartObj) ?
          getBoundBoxPadding(dataLabels, chartObj) + getBoundBoxStrokeWidth(dataLabels, chartObj) :
          0;
          highlightHierarchy = commonPlotOptions.events && commonPlotOptions.events.highlightHierarchy;

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, null, chartObj, SUNBURST_CHARTNAME);
          var isAnimationEnable = animationOptions.enabled,
            animationType = animationOptions.type,
            easingType = animationOptions.easingType,
            transitionDuration = redraw ? isAnimationEnable ? 200 : 0 : animationOptions.duration,
            transitionEnd = function transitionEnd() {
              d3_select(this).style('display', finalDisplay);
            };

          radius = mathMin(chartwidth, chartheight) / 2 - outerPadding - 2 * boundBoxPadding;
          var innerRadius = mathMin(mathMax(0, perToPx(commonPlotOptions.innerRadius, radius)), perToPx('95%', radius)),
            fillColor = [],
            strokeColor = [];

          start = function start(d) {
            return mathMax(0, mathMin(2 * mathPI, xscale(d.x0)));
          },
          end = function end(d) {
            return mathMax(0, mathMin(2 * mathPI, xscale(d.x1)));
          },
          innerrad = function innerrad(d) {
            return yscale(d.y0) + padding / 2;
          };
          rad = function rad(scaleObj, extra) {
            extra = extra || 0;
            return function (d) {
              return yscale(d.y1) + extra - padding / 2;
            };
          };
          valueFunction = function valueFunction(d) {
            if (isDisabled(data, d)) {
              return 0;
            }
            var y = dataset.getY(d, yaxiscolumnorder) || 0;
            if (y < 0) {
              return NegativeAsAbsolute ? mathAbs(y) : 0;
            }
            return y;
          };

          arc = d3_arc() //#ZC814 - d3.svg.arc has issue in this
          .startAngle(start).
          endAngle(end).
          innerRadius(innerrad).
          outerRadius(rad(yscale));

          arcLabel = d3_arc() //#ZC814 - d3.svg.arc has issue in this
          .startAngle(start).
          endAngle(end).
          innerRadius(innerrad).
          outerRadius(rad(yscale));

          pathGroup = appendEle(selection, 'g', [data], '.', 'class', 'hierarchychart');
          pathGroup.attr('transform', "translate(".concat(chartwidth / 2, ",").concat(chartheight / 2, ")"));

          oldData = [];
          pathGroup.selectAll(PATH_ELEMENT).each(function (d) {
            oldData.push({
              x0: d.x0,
              x1: d.x1
            });
          });
          var packedData = getPartitionNodeDescendants(data);
          chart.total = packedData[0].value;
          path = appendEle(pathGroup, PATH_ELEMENT, packedData);
          cancelAnimation(path);

          var colorLighter = [],
            leafNodes = [],
            seriesWiseNodes = [];
          data.forEach(function (d, i) {
            fillColor[i] = chart.fillColorFunc = getFillColor(chartObj, i, paneid, [radius, radius]);
            strokeColor[i] = getStrokeColor(chartObj, i, paneid);

            leafNodes[i] = [[]];
            leafNodes[i].disabled = d.disabled;
            leafNodes[i].plotoptions = d.plotoptions;
            seriesWiseNodes[i] = [];
            seriesWiseNodes[i].disabled = d.disabled;
            seriesWiseNodes[i].plotoptions = d.plotoptions;
            var nonRGBAColor = getColorByIndex(chartObj, i, paneid);
            colorLighter[i] = d3_scaleLinear().
            domain([0, getChildrenCount(d)]).
            range([nonRGBAColor, getColorCopy(nonRGBAColor, 1.5, 'brighter')]);
          });

          var plotLevelOptions = function plotLevelOptions(d) {return d.depth && seriesWiseNodes[getSeriesIndex(d)].plotoptions;},
            isEventEnabled = function isEventEnabled(d) {
              var plotOptions = plotLevelOptions(d);
              return validateNullVal(getEventConf(plotOptions, commonPlotOptions, chartObj, 'enabled'), true);
            },
            cursor = function cursor(d) {
              var plotOptions = plotLevelOptions(d);
              return isEventEnabled(d) ? getEventConf(plotOptions, commonPlotOptions, chartObj, 'cursor') || POINTER : NULL$1;
            };

          path.attr('class', function (d) {
            return getLevel(d) != null ? "zc_sunburst series_".concat(getSeriesIndex(d)) : 'zc_sunburst';
          }).
          attr('id', function (d) {
            return "arcPath_".concat(getLevel(d));
          }).
          each(function (d, i) {
            d.index = i;
            var seriesIndex = getSeriesIndex(d),
              level = getLevel(d);
            maxDepth = mathMax(maxDepth, d.depth);
            d.data._seriesIndex = seriesIndex;
            d.data.paneid = paneid;
            if (!d.depth) {
              d.data.arcColor = TRANSPARENT;
            } else {
              if (d.data.color) {
                d.data.arcColor = d.data.color;
              } else {
                var plotoptions = data[seriesIndex].plotoptions;
                var chClr =
                plotoptions != null ?
                gvpFn(plotoptions, commonPlotOptions)('childrenColors') :
                commonPlotOptions.childrenColors;
                if (!d.children && chClr != null) {
                  d.data.arcColor = chClr[stratifiedIndices[level] % chClr.length];
                } else {
                  var c = colorLighter[seriesIndex](stratifiedIndices[level]);
                  d.data.arcColor = c;
                }
              }

              if (!d.children) {
                leafNodes[seriesIndex][0].push(d);
              }

              seriesWiseNodes[seriesIndex].push(d);
              nodes[level] = d;
            }
          });

          xscale = d3_scaleLinear().range([0, 2 * mathPI]);
          yscale = d3_scaleLinear().
          range([innerRadius, radius]).
          domain([packedData[0].y1, 1]);
          padding = mathMin(mathMax(0, perToPx(commonPlotOptions.padding, radius, 0)), (radius - innerRadius) * 0.9 / maxDepth);

          path.style('display', initialDisplay).
          transition().
          duration(transitionDuration).
          ease(redraw ? d3_ease_linear : easingType).
          attrTween(
          'd',
          redraw || animationType === FAN_ANIMATION ? fanTween : animationType === WHEEL_ANIMATION ? wheelTween : innerTween).

          on('end', transitionEnd);

          path.styles({
            fill: function fill(d) {
              var seriesIndex = getSeriesIndex(d);

              return d.fillColor = fillColor[seriesIndex || 0](seriesIndex, d.data);
            },
            stroke: function stroke(d) {
              var seriesIndex = getSeriesIndex(d);

              if (!d.depth) {
                return 'white';
              } else if (commonPlotOptions.strokeColor) {
                return commonPlotOptions.strokeColor;
              } else {
                return strokeColor[seriesIndex || 0](seriesIndex, d.data);
              }
            },
            'stroke-opacity': function strokeOpacity(d) {
              return d.depth ? gvpFn(data[getSeriesIndex(d)].plotoptions, commonPlotOptions)('strokeOpacity') : 1;
            },
            'fill-opacity': function fillOpacity(d) {
              return d.depth ? gvpFn(data[getSeriesIndex(d)].plotoptions, commonPlotOptions)('fillOpacity') : 0;
            },
            'stroke-width': function strokeWidth(d) {
              return d.depth ? gvpFn(data[getSeriesIndex(d)].plotoptions, commonPlotOptions)('strokeWidth') : 0;
            },
            cursor: cursor,
            'pointer-events': function pointerEvents(d) {return d.depth && isEventEnabled(d) ? null : 'none';}
          });

          setPivotAttributes(path, chartObj, 'sunburst');
          setOpacityForTickFilterElements(path, chartObj, 'sunburst');

          setPointerEvents(chartObj, path, function (d) {return !isEventEnabled(d);}, paneid);
          if (!chartObj.cache.search) {
            chartObj.cache.search = {};
          }
          var mousemove = function mousemove(d, i) {
              var args = getEventArgs(d, i);
              chartObj.eventHandler.handlers.mousemove.call(chartObj.eventHandler, args);
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = paneid;
            },
            mouseout = function mouseout(d, i) {
              var args = getEventArgs(d, i);
              chartObj.eventHandler.handlers.mouseout.call(chartObj.eventHandler, args);
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = null;
            },
            click = function click(d, i) {
              var args = getEventArgs(d, i);
              chartObj.eventHandler.handlers.click.call(chartObj.eventHandler, args);
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = paneid;
              //clickFunc(path,d);     //default click function
            },
            dblclick = function dblclick(d, i) {
              if (!chart.chartRendered) {
                return;
              }
              var dt =
              d.children == null ?
              !annotation$6._empty ?
              generateDataForAnnotation(d, data.length > 1 ? d.parent.data.seriesname : null) :
              d :
              [d.data.seriesname, d.value];
              var coordinates = arcLabel.centroid(d);
              coordinates = [coordinates[0] + chartwidth / 2, coordinates[1] + chartheight / 2];
              var args = getEventArgs(d, i);
              args.coordinate = coordinates;
              args.basedOn = 'plot';
              args.data = dt;
              chartObj.eventHandler.handlers.doubleclick.call(chartObj.eventHandler, args, getSeriesIndex(d), d);
              updateSelectionOnDatapoint(d, args);
              chartObj.cache.search.lastPane = paneid;
            },
            eventAttacherOptions = {
              target: 'plot',
              touchleave: true,
              chartObj: chartObj
            };
          var mouseHandlers = {
              mousemove: mousemove,
              mouseout: mouseout,
              click: click,
              dblclick: dblclick
            },
            touchHandlers = {
              singletouchmove: mousemove,
              touchend: mouseout,
              tap: click,
              dbltap: dblclick
            };
          attachevents(
          path.filter(function (d) {return d.depth && isEventEnabled(d);}),
          mouseHandlers,
          touchHandlers,
          eventAttacherOptions);


          chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
            if (labelRenderer != null) {
              var outline = d3_arc().
              startAngle(start).
              endAngle(end).
              innerRadius(rad(yscale)).
              outerRadius(rad(yscale));

              var datalabelsPadding = commonPlotOptions.datalabels.padding + boundBoxPadding;
              var outlineWithPad = d3_arc().
              startAngle(start).
              endAngle(end).
              innerRadius(rad(yscale, datalabelsPadding)).
              outerRadius(rad(yscale, datalabelsPadding));

              data.forEach(function (d, i) {
                var _currentRenderer = chartObj.renderer[isFacet(chartObj) ? rendererIndex + i : 0],
                  _currentRendererIndex = isFacet(chartObj) ? rendererIndex + i : i,
                  _paneid = isFacet(chartObj) ? "".concat(d.row, "_").concat(d.column) : i;

                var getArguments = function getArguments(nodes, isParent) {
                  return [
                  leafNodes,
                  i,
                  nodes,
                  radius,
                  function (d, showAs) {
                    if (showAs === PERCENT_SHOWAS) {
                      return chart.total;
                    } else {
                      var node = chart.getProcessedNode(d);
                      return node.parent.value;
                    }
                  },
                  outlineWithPad,
                  outline,
                  arcLabel,
                  [chartwidth / 2, chartheight / 2],
                  isParent];

                };

                labelQueue.push({
                  renderer: _currentRenderer,
                  chartObj: chartObj,
                  charttype: PIE_CHARTNAME,
                  rendererIndex: _currentRendererIndex,
                  paneid: _paneid,
                  args: getArguments(seriesWiseNodes[i])
                });
                labelQueue.push({
                  renderer: _currentRenderer,
                  chartObj: chartObj,
                  charttype: 'pieInnerLabels',
                  rendererIndex: _currentRendererIndex,
                  paneid: _paneid,
                  args: getArguments(leafNodes[i][0])
                });
                labelQueue.push({
                  renderer: _currentRenderer,
                  chartObj: chartObj,
                  charttype: 'pieInnerLabels',
                  rendererIndex: _currentRendererIndex,
                  paneid: _paneid,
                  args: getArguments(
                  seriesWiseNodes[i].filter(function (d) {
                    return d.children;
                  }),
                  true)

                });
              });
            }

            //Annotation preprocessing
            if (!annotation$6._empty) {
              data.forEach(function (series, i) {
                notesArray = annotation$6.preprocessAnnotations(
                data,
                i,
                function (dt, k, j) {
                  var node = chart.getProcessedNode(dt);
                  var c = arcLabel.centroid(node);
                  return [c[0] + chartwidth / 2, c[1] + chartheight / 2];
                },
                notesArray,
                chartObj,
                rp);

              });
            }

            redraw = true;
            chart.chartRendered = true;
          }, transitionDuration + 1000 / 60);

          function getEventArgs(d, i) {
            var ev = getEventObject(d3_event()),
              level = getLevel(d);
            return {
              renderer: chart,
              seriesIndex: getSeriesIndex(d),
              // "subseriesPos": 0,
              // "itemPos": d.itemPos,
              paneid: paneid,
              rendererIndex: rendererIndex,
              coordinates: [ev.pageX, ev.pageY],
              element: this,
              data: d.data,
              level: level,
              selected: d.selected,
              _key: "ZC_".concat(chartObj.id, "_").concat(level)
            };
          }
        });
        return chart;
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      chart.defaultMouseOverFunc = function (d, seriesPos, itemPos, paneid) {
        createHighlightElement();
        var highlightEffect = chartObj.legendHighlight.getLegendHighlightEffect(seriesPos, 'selectedSeries', 'plot', paneid),
          elementIds = getHierarchyElementIds(getLevel(d));

        if (highlightEffect !== NONE) {
          highlightGroup.style('opacity', null);

          var zchighlighterPosition = [commonRendererProp.params.bound.x, commonRendererProp.params.bound.y];

          var refElements = pathGroup.selectAll(elementIds.join()).nodes();
          highlightEle.each(function (d, i) {
            var ele = d3_select(this);
            if (refElements[i]) {
              var refEle = d3_select(refElements[i]),
                arcColor = getRawColor(chartObj, seriesPos, refEle.datum(), seriesPos, paneid);
              ele.attr('d', refEle.attr('d')).styles(
              chartObj.legendHighlight.getEffect(
              highlightEffect,
              SUNBURST_CHARTNAME,
              HIGHLIGHT_EFFECT_REGEX.test(highlightEffect) ? arcColor : TRANSPARENT,
              { fill: TRANSPARENT, stroke: arcColor },
              seriesPos,
              'plot'));


              ele.attr('transform', "translate(".concat(zchighlighterPosition[0], ",").concat(zchighlighterPosition[1], ")"));
            } else {
              ele.attr('d', null);
            }
          });
        }
      };
      chart.defaultMouseOutFunc = function (d, i) {
        createHighlightElement(); //Touch device -> tap on a data, then tap a legend item. Mouseout should be called and legend tap action also will get executed.

        highlightGroup.style('opacity', 0);
      };
      chart.getProcessedNode = function (d) {
        return nodes[getLevel(d)];
      };

      // function Tween(d, tweentype) {
      //     var xd = d3_interpolate(xscale.domain(), [d.x, d.x + d.dx]),
      //         yd = d3_interpolate(yscale.domain(), [d.y, 1]),
      //         yr = d3_interpolate(yscale.range(), [d.y ? 20 : 0, radius]);
      //     if (tweentype == "arc") {
      //         return function(d, i) {
      //             return i ?

      //                 function(t) {
      //                     return arcLabel(d);
      //                 } :
      //                 function(t) {
      //                     xscale.domain(xd(t));
      //                     yscale.domain(yd(t)).range(yr(t));
      //                     return arcLabel(d);
      //                 };
      //         };
      //     } else {
      //         return function(d, i) {
      //             return i ?

      //                 function(t) {
      //                     return "translate(" + arcLabel.centroid(d) + ")";
      //                 } :
      //                 function(t) {
      //                     xscale.domain(xd(t));
      //                     yscale.domain(yd(t)).range(yr(t));
      //                     return "translate(" + arcLabel.centroid(d) + ")";
      //                 };
      //         };
      //     }
      // }

      function createHighlightElement() {
        if (highlightGroup) {
          return;
        }

        var g = chartObj.staticPaneSVG.selectAll('g#zchierarchyhighlight');
        if (!g.empty()) {
          //#ZC1756
          highlightGroup = g;
          highlightGroup.attr(
          'transform', "translate(".concat(
          chartObj.plotarea.left + chartwidth / 2, ",").concat(chartObj.plotarea.top + chartheight / 2, ")"));

          highlightEle = appendEle(highlightGroup, PATH_ELEMENT, d3_range(highlightHierarchy ? maxDepth : 1));
        }
      }

      function fanTween(d, i) {
        var startAngle = d3_interpolate(redraw && oldData[i] ? start(oldData[i]) : 0, start(d));
        var endAngle = d3_interpolate(redraw && oldData[i] ? end(oldData[i]) : 0, end(d));
        return function (t) {
          arc.startAngle(startAngle(t)).endAngle(endAngle(t));
          return arc(d);
        };
      }

      function innerTween(d) {
        var inner = d3_interpolate(0, innerrad(d));
        var outer = d3_interpolate(0, rad(yscale)(d));
        return function (t) {
          arc.innerRadius(inner(t)).outerRadius(outer(t));
          return arc(d);
        };
      }

      function wheelTween(d) {
        var endAngle = d3_interpolate(start(d), end(d));
        return function (t) {
          arc.endAngle(endAngle(t));
          return arc(d);
        };
      }

      // function clickFunc(path, d) {
      //     path.transition()
      //         .duration(250)
      //         .attrTween("d", Tween(d, "arc"));
      //     // text.style("visibility", function(e) {return isParentOf(d, e) ? null : "hidden";})
      //     //  .transition()
      //     //  .duration(250)
      //     //  .attrTween("transform",Tween(d,"label"))
      //     //  .style("fill-opacity", function(e) { return isParentOf(d, e) ? 1 : 1e-6; });
      // }

      // function getDomainMax(parentElement) {
      //     return parentElement.children.length;
      // }

      // function isParentOf(p, c) {
      //     if (p === c) {
      //         return true;
      //     }
      //     if (p.children) {
      //         return p.children.some(function(d) {
      //             return isParentOf(d, c);
      //         });
      //     }
      //     return false;
      // }

      function getSeriesIndex(d) {
        var level = getLevel(d);
        if (level) {
          return +level.split('_')[0];
        }
      }

      function getHierarchyElementIds(id) {
        var hierarchyIds = [];
        var currentId = "".concat(PATH_ELEMENT, "#arcPath");

        if (highlightHierarchy) {
          var levels = id.split('_');

          levels.forEach(function (d) {
            currentId = "".concat(currentId, "_").concat(d);
            hierarchyIds.push(currentId);
          });
        } else {
          hierarchyIds.push("".concat(currentId, "_").concat(id));
        }

        return hierarchyIds;
      }

      function getLevel(d) {
        return d.level || d.data && d.data.level;
      }

      function isDisabled(data, d) {
        var seriesIndex = getSeriesIndex(d);
        return defined(seriesIndex) && data[seriesIndex].disabled;
      }

      var childrenCount;
      function getChildren(node) {
        var level = getLevel(node),
          depth = level && level.split('_').length;
        stratifiedIndices[level] = depth === 1 ? childrenCount = 0 : childrenCount;

        if (!chartObj.dataObject.hasHierarchyData && depth == 1 && node.length < 2 && node[0] && isArray$1(node[0][0])) {
          return node[0];
        } else if (isArray$1(node[0])) {
          return node;
        } else {
          childrenCount++;
          return null;
        }
      }

      function getPartitionNodeDescendants(data) {
        var partition = d3_partition();
        var root = d3_hierarchy(data, getChildren).
        sum(valueFunction).
        sort(d3_ascending);

        partition(root);
        return root.descendants();
      }

      return chart;
    };

    /*
     Doubts:
     1) Whether sharedseries will be applicable?
     Pending:
     1) Hierarchy data. (e.g): treemap-01
     2) scroll treemap
     */
    function TreemapHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    inherit(TreemapHighlighter, BarHighlighter);
    var proto$l = TreemapHighlighter.prototype;

    proto$l.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('nonaxis').call(this, this.chart);
    };

    proto$l.translateContext = function (point) {
      var chart = this.chart,
        renderer = getRenderer(point, chart, this.renderer),
        dimension = renderer.layout.dimension,
        bound = renderer.commonRendererProp().bound(),
        plotArea = chart.plotarea;

      return [plotArea.left + dimension.x + bound.x, plotArea.top + dimension.y + bound.y];
    };

    proto$l.data = function (point) {
      var chart = this.chart,
        renderer = getRenderer(point, chart, this.renderer),
        layout = renderer.layout,
        dimension = layout.dimension,
        bound = renderer.commonRendererProp().bound();

      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }

        var cache = chart.cache.data[point._key];
        var node = renderer.getProcessedNode(point);
        var tileBound = treemapUtils.getTileBound(layout, node);

        cache._x = point._x = cache._x || tileBound.x + dimension.x + bound.x + tileBound.width / 2;
        cache._y = point._y = cache._y || tileBound.y + dimension.y + bound.y + tileBound.height / 2;
        cache._width = point._width = cache._width || tileBound.width;
        cache._height = point._height = cache._height || tileBound.height;
        point._centric = true;
        cache._size = point._size =
        2 * euclideanDistance({ x: point._x, y: point._y }, { x: point._x - tileBound.width / 2, y: point._y - tileBound.height / 2 });
        cache._uid = point._uid = chart.dataset.getX(point);
        cache._visible = point._visible = isPointVisible(chart, point);
        cache._point = point;

        return point;
      };
    };

    proto$l.options = function (point) {
      var chart = this.chart,
        renderer = getRenderer(point, chart, this.renderer),
        layout = renderer.layout,
        rp = renderer.commonRendererProp().params,
        dimension = layout.dimension,
        seriesIndex = point.seriesIndex,
        tileBound = getTileBound(renderer, point),
        borderRadius = getBorderRadius(rp.commonPlotOptions.borderRadius),
        multiColoring = isMultiColoring(rp.commonPlotOptions, chart),
        rawColor = getRawColor(chart, multiColoring ? point.itemIndex : seriesIndex, point, seriesIndex);

      if (chart.plot.renderer.mode === 'canvas') {
        //#ZC1193
        borderRadius = checkRadiusWithinBoundary(borderRadius, tileBound.width, tileBound.height, true);
      }

      return {
        radius: borderRadius,
        color: rawColor,
        strokeColor: TRANSPARENT,
        fillColor: function () {
          var func = getFillColor(chart, seriesIndex, null, [dimension.width, dimension.height], null, 'svg');
          return func(seriesIndex, point, null, null, null, [tileBound.width, tileBound.height]);
        }()
      };
    };

    proto$l.path = function (point, model) {
      var self = this,
        context = model.context.call(self),
        translate = model.translate.call(self, point),
        chart = this.chart,
        renderer = getRenderer(point, chart, this.renderer),
        rp = renderer.commonRendererProp().params,
        //
        tileBound = getTileBound(renderer, point),
        path = roundedRect(tileBound.x, tileBound.y, tileBound.width, tileBound.height, getBorderRadius(rp.commonPlotOptions.borderRadius));

      context.style('display', '').style('opacity', null);

      var groupContext = createElement('g', ".treemap-highlight".concat(point.paneid).concat(point.seriesIndex).concat(point.subSeriesIndex), [point], context);
      groupContext.attr('transform', "translate(".concat(translate[0], ",").concat(translate[1], ")"));

      var pathContext = createElement('path', ".treemap-highlight", [point], groupContext).attr('d', path);
      return pathContext;
    };

    function getRenderer(point, chart, renderer) {
      return point ? chart.renderer[getRendererIndex(point, chart)] : renderer;
    }

    function getTileBound(renderer, point) {
      var node = renderer.getProcessedNode(point),
        layout = renderer.layout;
      return treemapUtils.getTileBound(layout, node);
    }

    //$Id$

    var treemapLayout = function treemapLayout(commonRendererProp, data) {
      var self = this;
      self.data = data;
      var rp = self.rp = commonRendererProp.params,
        bound = rp.bound;

      self.chartObj = rp.chartObj;
      self.commonRendererProp = commonRendererProp;
      self.dimension = rendererBoundUtils.getAvailableBound(bound, rp.commonPlotOptions);

      self.createScale();
      self.layout = self.getLayout();
      self.processData();
    };

    treemapLayout.prototype.createScale = function () {
      var dimension = this.dimension;
      //x scale
      var xScale = d3_scaleLinear().
      domain([0, dimension.width]).
      range([0, dimension.width]);

      // y sclae
      var yScale = d3_scaleLinear().
      domain([0, dimension.height]).
      range([0, dimension.height]);

      this.xScale = xScale;
      this.yScale = yScale;
    };

    treemapLayout.prototype.getLayout = function () {
      var self = this,
        dimension = self.dimension,
        commonPlotOptions = this.rp.commonPlotOptions,
        parentOptions = commonPlotOptions.parent,
        padding = parseShortHandValue(commonPlotOptions.padding),
        mode = commonPlotOptions.mode;

      return d3_treemap().
      size([dimension.width, dimension.height]).
      tile(d3_tiles(mode)).
      round(true).
      paddingInner(function (d) {
        //padding between children
        if (d.value) {
          return (d.children[0] && d.children[0].children ? parentOptions : commonPlotOptions).interPadding || 0;
        } else {
          return 0;
        }
      }).
      paddingTop(function (d) {
        return d.depth && d.value ? padding.top : 0;
      }).
      paddingBottom(function (d) {
        return d.depth && d.value ? padding.bottom : 0;
      }).
      paddingLeft(function (d) {
        return d.depth && d.value ? padding.left : 0;
      }).
      paddingRight(function (d) {
        return d.depth && d.value ? padding.right : 0;
      });
    };

    treemapLayout.prototype.getValue = function (d) {
      var self = this,
        chartObj = self.chartObj,
        rp = self.rp,
        curSeriesData = getCurrentSeriesData(self, d),
        yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(curSeriesData.yaxiscolumnorder),
        y = chartObj.dataset.getY(d, yaxiscolumnorder) || 0,
        negativeAsAbsolute = rp.commonPlotOptions.negativeAs === 'absolute';

      if (treemapUtils.isDisabled(curSeriesData, d)) {
        return 0;
      }

      if (y < 0) {
        return negativeAsAbsolute ? mathAbs(y) : 0;
      }
      return y;
    };

    treemapLayout.prototype.getChildren = function (node) {
      var level = treemapUtils.getLevel(node),
        depth = level && level.split('_').length;

      if (!this.chartObj.dataObject.hasHierarchyData && depth == 1 && node.length < 2 && node[0] && isArray$1(node[0][0])) {
        return node[0];
      } else if (isArray$1(node[0])) {
        return node;
      } else {
        return NULL$1;
      }
    };

    treemapLayout.prototype.processData = function () {
      var self = this,
        data = self.data,
        chartObj = self.chartObj,
        commonRendererProp = self.commonRendererProp,
        dimension = self.dimension,
        rp = self.rp,
        commonPlotOptions = rp.commonPlotOptions,
        color = rp.color,_rp$rendererIndex9 =
        rp.rendererIndex,rendererIndex = _rp$rendererIndex9 === void 0 ? 0 : _rp$rendererIndex9,
        colorScheme = commonPlotOptions.colorScheme || 'solid',

        previousSiblingsCounter = 0,
        previousSiblingsCount = {},
        colorLighter = [],
        childColorIndex = [],
        seriesWiseNodes = [],
        leafNodes = [],
        nodes = [],
        fillColor = [],
        strokeColor = [],
        root = d3_hierarchy(data, function (d) {
          return self.getChildren(d);
        }).sum(function (d) {
          return self.getValue(d);
        }),

        processedData = self.layout(root).descendants(),
        paneid = "".concat(data[0].row, "_").concat(data[0].column);

      data.forEach(function (d, i) {
        var rendererConf = chartObj.rendererConf[rendererIndex + i];
        var nonRGBAColor = getRawColor(chartObj, i, null, i, paneid);

        fillColor[i] = getFillColor(chartObj, i, paneid, [dimension.width, dimension.height], null, null, null, rendererConf.params);
        strokeColor[i] = getStrokeColor(chartObj, i, paneid, null, rendererConf.params);

        childColorIndex[i] = 0;
        seriesWiseNodes[i] = [];
        seriesWiseNodes[i].disabled = d.disabled;
        seriesWiseNodes[i].plotoptions = d.plotoptions;
        colorLighter[i] = d3_scaleLinear().
        domain([0, getChildrenCount(d)]).
        range([
        nonRGBAColor,
        getColorCopy(nonRGBAColor, colorScheme === 'solid' ? 0 : colorScheme === 'shades' ? -1 : 1, 'brighter', d3_hsl)]);

      });

      processedData.forEach(function (d, i) {
        var level = treemapUtils.getLevel(d),
          seriesIndex = treemapUtils.getSeriesIndex(d),
          itemIndex = treemapUtils.getItemIndex(d),
          curSeriesData = getCurrentSeriesData(self, d);

        d.index = i;
        d.data.paneid = paneid;
        if (d.depth) {
          if (d.data.color) {
            d.data.arcColor = d.data.color;
          } else {
            var c = isMultiColoring(commonPlotOptions, chartObj) ?
            color[itemIndex % color.length] :
            colorLighter[seriesIndex](childColorIndex[seriesIndex]);
            d.data.arcColor = c;
          }
          nodes[level] = d;
        }

        if (!d.children) {
          if (!leafNodes[seriesIndex]) {
            leafNodes[seriesIndex] = [];
          }
          leafNodes[seriesIndex].push(d);
          childColorIndex[seriesIndex]++;
        } else {
          d.data.arcColor = treemapUtils.getParentColor(commonRendererProp, d, paneid);
        }

        if (d.depth) {
          seriesWiseNodes[seriesIndex].push(d);
        }

        if (!treemapUtils.isDisabled(curSeriesData, d)) {
          previousSiblingsCount[level] = previousSiblingsCounter++;
        }
      });

      chartObj.renderer[0].fillColorFunc = fillColor[0];

      self.processedData = processedData;
      self.previousSiblingsCount = previousSiblingsCount;
      self.seriesWiseNodes = seriesWiseNodes;
      self.leafNodes = leafNodes;
      self.nodes = nodes;
      self.fillColor = fillColor;
      self.strokeColor = strokeColor;
    };

    function getCurrentSeriesData(layoutObj, d) {
      var data = layoutObj.data,
        chartObj = layoutObj.chartObj,
        seriesIndex = treemapUtils.getSeriesIndex(d) || 0;

      return isFacet(chartObj) ? data[seriesIndex].node : chartObj.seriesdata[seriesIndex];
    }

    //$Id$

    var annotation$7 = Registry.getComponent('annotation');
    canvas_plot_renderer.treemap = function () {
      var commonRendererProp,
        getLevel = treemapUtils.getLevel,
        getSeriesIndex = treemapUtils.getSeriesIndex,
        getItemIndex = treemapUtils.getItemIndex,
        layoutObj;

      function chart(context, seriesdata, effect, filterIndex, encode, _index) {
        var rp = commonRendererProp.params,
          chartObj = rp.chartObj,
          commonPlotOptions = rp.commonPlotOptions,
          notesArray = rp.notesArray,
          labelQueue = rp.labelQueue,
          rendererIndex = rp.rendererIndex;

        chart.layout = layoutObj = isHighlight ?
        layoutObj :
        new treemapLayout(commonRendererProp, isFacet(chartObj) || chartObj.isAxisedHierarchyChart ? seriesdata : chartObj.seriesdata);
        var hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
          multiColoring = isMultiColoring(commonPlotOptions, chartObj),
          borderRadius = getBorderRadius(commonPlotOptions.borderRadius),
          parentOptions = commonPlotOptions.parent,
          dimension = layoutObj.dimension,
          leafNodes = layoutObj.leafNodes,
          seriesWiseNodes = layoutObj.seriesWiseNodes,
          processedData = layoutObj.processedData,
          fillColor = layoutObj.fillColor,
          isHighlight = context.canvas.className === 'highlight-canvas';

        context.save();
        context.translate(dimension.x, dimension.y);
        chart.total = processedData[0].value;

        if (isHighlight) {
          var index = _index;
          processedData = processedData.filter(function (d) {
            return getSeriesIndex(d) === index && !(hasColorScale && d.children);
          });

          if (hasColorScale) {
            processedData = legend_helpers.filterSelectionByColor(processedData, true, filterIndex, chartObj);
          }
        }

        processedData.forEach(function (d, i) {
          var seriesIndex = getSeriesIndex(d),
            itemIndex = getItemIndex(d),
            tileBound = treemapUtils.getTileBound(layoutObj, d),
            x = tileBound.x,
            y = tileBound.y,
            w = tileBound.width,
            h = tileBound.height,
            customStrokeColor = (d.children ? parentOptions.strokeColor : NULL$1) || commonPlotOptions.strokeColor,
            strokeClr;

          if (!d.depth) {
            strokeClr = TRANSPARENT;
          } else if (
          isHighlight &&
          isUndefined(effect) &&
          chartObj.legendHighlight.getLegendHighlightEffect(index, 'selectedSeries', d.data.paneid) !== NONE)
          {
            strokeClr = 'black';
          } else if (customStrokeColor) {
            strokeClr = customStrokeColor;
          } else if (d.children) {
            strokeClr = d.data.arcColor;
          }

          var drawCell = function drawCell(context, fillStyle) {
            context.save();
            context.translate(x + w / 2, y + h / 2);
            context.beginPath();
            context.lineWidth = (d.children ? parentOptions.strokeWidth : NULL$1) || commonPlotOptions.strokeWidth;
            context.strokeStyle = rgba_canvas(
            strokeClr,
            (d.children ? parentOptions.strokeOpacity : NULL$1) || commonPlotOptions.strokeOpacity);

            context.fillStyle = fillStyle;

            canvasUtils.roundedRect(context, -w / 2, -h / 2, w, h, borderRadius);
            context.fill();
            context.stroke();
            context.closePath();
            context.restore();
          };

          if (chartObj.imagePallete && isWithinColorRange(chartObj.dataset.getClr(d), chartObj) && d.depth) {
            effects.canvas_patterns.imageFill(
            { x: x, y: y, context: context, name: getRawColor(chartObj, multiColoring ? itemIndex : seriesIndex, d, seriesIndex) },
            drawCell);

          } else {
            var fillStyle;
            if (defined(effect)) {
              fillStyle = effect;
            } else if (!d.children) {
              fillStyle = fillColor[seriesIndex](seriesIndex, d.data, NULL$1, NULL$1, commonPlotOptions.fillOpacity, [w, h]);
            } else {
              fillStyle = rgba_canvas(d.data.arcColor, parentOptions.fillOpacity);
            }
            drawCell(context, fillStyle);
          }
        });

        context.restore();

        if (labelRenderer) {
          var transform = [dimension.x, dimension.y];
          var totalFunc = function totalFunc(d, showAs) {
            if (showAs === PERCENT_SHOWAS) {
              return chart.total;
            } else {
              var node = chart.getProcessedNode(d);
              return node.parent.value;
            }
          };
          seriesdata.forEach(function (d, i) {
            var _currentRendererIndex = isFacet(chartObj) ? rendererIndex + i : i,
              paneid = isFacet(chartObj) ? "".concat(d.row, "_").concat(d.column) : i;

            labelQueue.push({
              renderer: chart,
              charttype: 'hierarchy',
              chartObj: chartObj,
              rendererIndex: _currentRendererIndex,
              paneid: paneid,
              args: [seriesWiseNodes[i], i, NULL$1, NULL$1, totalFunc, leafNodes[i], transform]
            });

            labelQueue.push({
              renderer: chart,
              charttype: 'hierarchy',
              chartObj: chartObj,
              rendererIndex: _currentRendererIndex,
              paneid: paneid,
              args: [seriesWiseNodes[i], i, NULL$1, NULL$1, totalFunc, [seriesWiseNodes[i][0]], transform, true]
            });
          });
        }

        //Annotation preprocessing
        if (!annotation$7._empty && !isHighlight) {
          chartObj.seriesdata.forEach(function (series, i) {
            notesArray = annotation$7.preprocessAnnotations(
            chartObj.seriesdata,
            i,
            function (dt, k, j) {
              var node = chart.getProcessedNode(dt);
              var tileBound = treemapUtils.getTileBound(layoutObj, node);
              return [tileBound.x + dimension.x, tileBound.y + dimension.y];
            },
            notesArray,
            chartObj,
            rp);

          });
        }

        chart.chartRendered = true;
        return chart;
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.getProcessedNode = function (d) {
        return layoutObj.nodes[getLevel(d)];
      };

      chart.getHighlighter = function (chartObj, index) {
        return chart.highlighter = new TreemapHighlighter(chartObj, chart);
      };
      return chart;
    };

    defaultTheme.treemap = function () {
      return {
        outerPadding: 5,
        strokeColor: 'rgba(255,255,255,0.7)',
        animation: {
          type: 'fadeOneByOne'
        },
        axis: {
          "enabled": false
        },
        datalabels: {
          showAs: 'y',
          vAlign: 'bottom',
          hAlign: 'left'
        },
        gradients: {
          //linear | radial | none
          options: {
            linear: {
              y2: 100,
              x2: 100,
              colorGamma: [0.5, 0]
            },
            radial: {
              radius: 100
            }
          }
        },
        parent: {
          strokeOpacity: 0,
          datalabels: {
            position: 'inset',
            vAlign: 'center',
            hAlign: 'center',
            showAs: 'y',
            show: false
          },
          events: {}
        }
      };
    };

    //$Id$

    var annotation$8 = Registry.getComponent('annotation');
    /**
     *
     * @returns {chart} treemap renderer.
     */

    /* PENDING:
     * Annotation for hierarchy data
     */
    svg_plot_renderer.treemap = function () {
      var isredraw = false,
        commonRendererProp,
        treemapGroup,
        path,
        chartObj,
        commonPlotOptions,
        // clickedItem,
        // xScale,
        // yScale,

        getLevel = treemapUtils.getLevel,
        getSeriesIndex = treemapUtils.getSeriesIndex,
        // getItemIndex = treemapUtils.getItemIndex,

        layoutObj,
        dimension,
        nodes,
        leafNodes,
        seriesWiseNodes;

      function chart(selection) {
        selection.each(function (data) {
          //renderer config values
          var rp = commonRendererProp.params;
          chartObj = rp.chartObj;
          commonPlotOptions = rp.commonPlotOptions;
          var notesArray = rp.notesArray,
            systemconf = chartObj.systemConf,
            labelQueue = rp.labelQueue,
            rendererIndex = rp.rendererIndex;

          chart.layout = layoutObj = new treemapLayout(commonRendererProp, data);
          dimension = layoutObj.dimension;
          nodes = layoutObj.nodes;
          leafNodes = layoutObj.leafNodes;
          seriesWiseNodes = layoutObj.seriesWiseNodes;

          var strokeWidth = commonPlotOptions.strokeWidth,
            strokeOpacity = commonPlotOptions.strokeOpacity,
            fillOpacity = commonPlotOptions.fillOpacity,
            fillColor = layoutObj.fillColor,
            strokeColor = layoutObj.strokeColor,
            borderRadius = getBorderRadius(commonPlotOptions.borderRadius),
            transform = [dimension.x, dimension.y];

          //Animation variables
          var animationOptions = getAnimationConf(commonPlotOptions, NULL$1, chartObj, 'treemap');
          var isAnimationEnable = animationOptions.enabled,
            animationType = animationOptions.type,
            easingType = isredraw ? d3_ease_linear : animationOptions.easingType,
            transitionDuration = isredraw ? isAnimationEnable ? 200 : 0 : animationOptions.duration,
            dataCount = chartObj.dataObject.totalnoofdatas,
            duration = isredraw ?
            transitionDuration :
            animationType === FADEONEBYONE_ANIMATION ?
            transitionDuration / dataCount :
            transitionDuration,
            delay = isredraw ?
            0 :
            animationType === FADEONEBYONE_ANIMATION ?
            function (d) {
              return layoutObj.previousSiblingsCount[getLevel(d)] * (transitionDuration / dataCount);
            } :
            animationType === FADERANDOM_ANIMATION ?
            function () {
              return mathRandom() * dataCount * (transitionDuration / dataCount);
            } :
            0,
            initialOpacity =
            animationType === FADEALL_ANIMATION ||
            animationType === FADERANDOM_ANIMATION ||
            animationType === FADEONEBYONE_ANIMATION ?
            0 :
            NULL$1;

          var cursor = commonPlotOptions.events ?
            commonPlotOptions.events.cursor || POINTER :
            systemconf.chart.plot.events.cursor || POINTER,
            parentOptions = commonPlotOptions.parent,
            parentCursor = parentOptions.events.cursor;

          treemapGroup = appendEle(selection, 'g', [data], '.', 'class', 'hierarchychart');
          treemapGroup.attr('transform', "translate(".concat(dimension.x, ",").concat(dimension.y, ")")).styles({
            'stroke-width': strokeWidth,
            'stroke-opacity': strokeOpacity,
            'fill-opacity': fillOpacity,
            cursor: cursor
          });

          var processedData = layoutObj.processedData;
          chart.total = processedData[0].value;
          path = appendEle(treemapGroup, PATH_ELEMENT, processedData);
          if (!chart.total) {
            path.remove();
          }

          path.styles({
            fill: function fill(d) {
              if (!d.children) {
                var tileBound = treemapUtils.getTileBound(layoutObj, d),
                  seriesIndex = getSeriesIndex(d);

                return d.fillColor = fillColor[seriesIndex](seriesIndex, d.data, NULL$1, NULL$1, NULL$1, [
                tileBound.width,
                tileBound.height]);

              } else {
                return d.fillColor = d.data.arcColor;
              }
            },
            stroke: function stroke(d) {
              var customStrokeColor = (d.children ? parentOptions.strokeColor : NULL$1) || commonPlotOptions.strokeColor,
                seriesIndex = getSeriesIndex(d);

              if (!d.depth) {
                return TRANSPARENT;
              } else if (customStrokeColor) {
                return customStrokeColor;
              } else if (d.children) {
                return d.data.arcColor;
              } else {
                return strokeColor[seriesIndex](seriesIndex, d.data);
              }
            },
            visibility: function visibility(d) {
              return d.value ? NULL$1 : 'hidden';
            }
          }).
          attr('class', function (d) {
            if (defined(getLevel(d))) {
              return "zc_treemap series_".concat(getSeriesIndex(d)).concat(d.children ? ' zchierarchyparent' : '');
            }
            return 'zc_treemap';
          }).
          attr('id', function (d) {return "tree_".concat(getLevel(d));});

          var parentNodes = treemapGroup.selectAll("".concat(PATH_ELEMENT, ".zchierarchyparent"));
          parentNodes.styles({
            'stroke-width': parentOptions.strokeWidth,
            'stroke-opacity': parentOptions.strokeOpacity,
            'fill-opacity': parentOptions.fillOpacity,
            cursor: parentCursor
          });

          if (!isredraw) {
            path.attr('transform', function (d) {
              var tileBound = treemapUtils.getTileBound(layoutObj, d),
                tX = tileBound.x + tileBound.width / 2,
                tY = tileBound.y + tileBound.height / 2;

              if (animationType === RANDOMOUT_ANIMATION) {
                tX = dimension.width / 2;
                tY = dimension.height / 2;
              } else if (animationType === HORIZONTALALL_ANIMATION) {
                tX = tileBound.width / 2;
              } else if (animationType === VERTICALALL_ANIMATION) {
                tY = tileBound.height / 2;
              }

              return "translate(".concat(tX, ",").concat(tY, ")");
            }).
            attr('d', function (d) {
              var tileBound = treemapUtils.getTileBound(layoutObj, d),
                x = -tileBound.width / 2,
                y = -tileBound.height / 2,
                w = tileBound.width,
                h = tileBound.height;

              if (animationType === HORIZONTALALL_ANIMATION) {
                w = 0;
              } else if (animationType === VERTICALALL_ANIMATION) {
                h = 0;
              }

              return roundedRect(x, y, w, h, borderRadius);
            }).
            style('opacity', initialOpacity);
          }

          setPivotAttributes(path, chartObj, 'treemap');
          setOpacityForTickFilterElements(path, chartObj, 'treemap');

          path.transition().
          duration(duration).
          delay(delay).
          ease(easingType).
          attr('transform', function (d) {
            var tileBound = treemapUtils.getTileBound(layoutObj, d);
            return "translate(".concat(tileBound.x + tileBound.width / 2, ",").concat(tileBound.y + tileBound.height / 2, ")");
          }).
          attr('d', function (d) {
            var tileBound = treemapUtils.getTileBound(layoutObj, d);
            return roundedRect(-tileBound.width / 2, -tileBound.height / 2, tileBound.width, tileBound.height, borderRadius);
          }).
          style(
          'opacity',
          isFacet(chartObj) ?
          function () {
            return d3_select(this).attr('filtered-opacity') || 1;
          } :
          NULL$1);


          chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
            if (labelRenderer) {
              var totalFunc = function totalFunc(d, showAs) {
                if (showAs === PERCENT_SHOWAS) {
                  return chart.total;
                } else {
                  var node = chart.getProcessedNode(d);
                  return node.parent.value;
                }
              };

              data.forEach(function (d, i) {
                var _currentRenderer = chartObj.renderer[isFacet(chartObj) || chartObj.isAxisedHierarchyChart ? rendererIndex + i : 0],
                  _currentRendererIndex = isFacet(chartObj) ? rendererIndex + i : i,
                  paneid = isFacet(chartObj) ? "".concat(d.row, "_").concat(d.column) : i;

                labelQueue.push({
                  renderer: _currentRenderer,
                  charttype: 'hierarchy',
                  chartObj: chartObj,
                  rendererIndex: _currentRendererIndex,
                  paneid: paneid,
                  args: [seriesWiseNodes[i], i, NULL$1, NULL$1, totalFunc, leafNodes[i], transform]
                });

                labelQueue.push({
                  renderer: _currentRenderer,
                  charttype: 'hierarchy',
                  chartObj: chartObj,
                  rendererIndex: _currentRendererIndex,
                  paneid: paneid,
                  args: [seriesWiseNodes[i], i, NULL$1, NULL$1, totalFunc, [seriesWiseNodes[i][0]], transform, true]
                });
              });
            }

            //Annotation preprocessing
            if (!annotation$8._empty) {
              data.forEach(function (series, i) {
                notesArray = annotation$8.preprocessAnnotations(
                data,
                i,
                function (dt, k, j) {
                  var node = chart.getProcessedNode(dt);
                  var tileBound = treemapUtils.getTileBound(layoutObj, node);
                  return [tileBound.x + dimension.x, tileBound.y + dimension.y];
                },
                notesArray,
                chartObj,
                rp);

              });
            }

            isredraw = true;
            chart.chartRendered = true;
          }, transitionDuration + 17 + (delay ? dataCount * 4 : 0));
        });
        return chart;
      }
      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      // chart.defaultClickFunc = function(d) {
      // 	var rp = commonRendererProp.params;
      // 	if (clickedItem === getLevel(d)) {
      // 		xScale.domain([0, dimension.width]);
      // 		yScale.domain([0, dimension.height]);
      // 		clickedItem = NULL;
      // 	} else {
      // 		xScale.domain([d.x0, d.x1]);
      // 		yScale.domain([d.y0, d.y1]);
      // 		clickedItem = getLevel(d);
      // 	}
      // 	chart.defaultMouseOutFunc();
      // 	$ZC.labelRenderer.drawLabelsFromQueue(rp.labelQueue, rp.labelArray, chartObj);
      // 	path
      // 	.transition()
      // 	.ease(d3_ease_linear)
      // 	.attr("d", function(d) {
      // 		var tileBound = treemapUtils.getTileBound(chartObj, d);
      // 		return roundedRect(tileBound.x, tileBound.y, tileBound.width, tileBound.height, borderRadius)
      // 	});
      // }
      chart.getProcessedNode = function (d) {
        return layoutObj.nodes[getLevel(d)];
      };

      chart.getHighlighter = function (chartObj, index) {
        return chart.highlighter = new TreemapHighlighter(chartObj, chart);
      };

      return chart;
    };

    //$Id$

    function addMarkerPointer(group, data, comparatorData, comparisonConfig, config) {
      var chartObj = config.chart,
        isAnimationEnable = config.animationOptions.enabled,
        axisrotated = config.axisrotated,
        renderer = config.renderer,
        seriesindex = config.seriesindex,
        barSize = axisrotated ?
        renderer.getParamValue('height', data[0], seriesindex, null, renderer.commonOption) :
        renderer.getParamValue('width', data[0], seriesindex, null, renderer.commonOption),
        mSize = mathMin(barSize / 10, 1),
        markerPosition = getMarkerCoordinates(comparatorData),
        symbolSize = {
          inner: 0,
          outer: 1
        },
        symbolType = axisrotated ? 'triangle-left' : 'triangle-down';
      var markerG = appendEle(group, 'g', comparisonConfig.enabled ? [1] : [], '.', 'class', 'zcmarkerPointers');

      var marker = appendEle(markerG, 'g', markerPosition, '.', 'class', 'markers', null, function (d, i) {
        // #ZC2049
        return comparatorData[i] && comparatorData[i].y;
      });

      marker.each(function (d, j) {
        var m = d3_select(this);
        m.attrs({
          transform: function transform(d) {
            return "translate(".concat(d[0], ",").concat(d[1], ")");
          }
        }).
        style('opacity', 0).
        transition().
        duration(isAnimationEnable ? config.animationOptions.duration : 0).
        style('opacity', 1);
        addSVGmarker(
        m,
        null,
        {
          size: mSize,
          symbol: symbolType,
          outerFillOpacity: comparisonConfig.strokeOpacity,
          outerStrokeOpacity: comparisonConfig.strokeOpacity,
          outerStrokeWidth: 0
        },
        {
          symbolSize: symbolSize,
          color: comparisonConfig.strokeColor || 'black'
        },
        chartObj);

      });
    }

    function getMarkerCoordinates(comparatorData) {
      var positions = comparatorData.map(function (d, i) {
        return comparatorData[i][3];
      });
      return positions;
    }

    //$Id$

    renderer_helpers.getWaterfallCategoriesConfig = function (plotOptions, commonPlotOptions) {
      var cascadedCat =
        plotOptions && plotOptions.cascadeCategories ?
        mergeJSON$1(commonPlotOptions.cascadeCategories, plotOptions.cascadeCategories, true) :
        commonPlotOptions.cascadeCategories,
        risingCat =
        plotOptions && plotOptions.risingCategories ?
        mergeJSON$1(commonPlotOptions.risingCategories, plotOptions.risingCategories, true) :
        commonPlotOptions.risingCategories,
        fallingCat =
        plotOptions && plotOptions.fallingCategories ?
        mergeJSON$1(commonPlotOptions.fallingCategories, plotOptions.fallingCategories, true) :
        commonPlotOptions.fallingCategories;

      return { cascaded: cascadedCat, rising: risingCat, falling: fallingCat };
    };

    colorscale_helpers.getWaterfallColor = function (data, config, defaultColor) {
      if (data.isCascaded) {
        return config.cascaded.color || defaultColor;
      } else if (data.isPositive) {
        return config.rising.color || defaultColor;
      } else {
        return config.falling.color || defaultColor;
      }
    };

    //$Id$

    svg_plot_renderer.waterfallHelpers = function () {};
    svg_plot_renderer.waterfallHelpers.drawComparisonLine = function (group, data, config) {
      var chartObj = config.chart,
        points = data,
        comparatorData = getDataForComparison(points, config),
        plotoptions = config.plotoptions,
        commonPlotOptions = config.commonPlotOptions,
        animationOptions = getAnimationConf(commonPlotOptions, plotoptions, chartObj, 'waterfall'),
        isAnimationEnable = animationOptions.enabled,
        comparisonConfig =
        plotoptions && plotoptions.comparisonLine ?
        mergeJSON$1(commonPlotOptions.comparisonLine, plotoptions.comparisonLine, true) :
        commonPlotOptions.comparisonLine;
      config.animationOptions = animationOptions;

      var d3Line = d3_line().
      x(function (d, i) {
        return d[0];
      }).
      y(function (d, i) {
        return d[1];
      });
      var lineG = appendEle(group, 'g', comparisonConfig.enabled ? [1] : [], '.', 'class', 'zccomparisonLines');
      var line = appendEle(lineG, 'path', comparatorData, '.', 'class', 'lines', null, function (d) {
        return d.y;
      });

      line.attr('d', function (d, i) {
        return d3Line(d);
      }).
      styles({
        fill: 'none',
        stroke: comparisonConfig.strokeColor || 'black',
        'stroke-width': comparisonConfig.strokeWidth || 1,
        'stroke-dasharray': getDashArray(comparisonConfig.dashStyle, comparisonConfig.strokeWidth || 1),
        'stroke-opacity': 0
      }).
      transition().
      duration(isAnimationEnable ? animationOptions.duration : 0).
      styles({
        'stroke-opacity': comparisonConfig.strokeOpacity || 1
      });
      addMarkerPointer(group, data, comparatorData, comparisonConfig, config);
      addText(group, comparatorData, comparisonConfig, config);
    };

    function addText(group, points, comparisonConfig, config) {
      var chartObj = config.chart,
        systemConf = chartObj.systemConf,
        axisrotated = config.axisrotated,
        isAnimationEnable = config.animationOptions.enabled,
        padding = 10,
        labelConfig = comparisonConfig.label || {},
        labelPos = labelConfig.labelPos,
        labelSize = utils.getVal(getValByPriority([labelConfig, systemConf.chart, systemConf.canvas, $ZCG], 'fontSize')),
        labelFixedPos = labelPos == 'fixedTop' ? axisrotated ? chartObj.plotarea.width : labelSize : null;
      var defaultFormatConf = {
        format: {
          decimalPlaces: '2',
          signEnabled: true,
          suffix: '%'
        }
      };
      var labelG = appendEle(group, 'g', comparisonConfig.enabled ? [1] : [], '.', 'class', 'zccomparisonLabels');
      var label = appendEle(labelG, 'text', points, '.', 'class', 'labels', null, function (d) {
        return d.y;
      });
      label.
      attrs({
        x: function x(d, i) {
          return axisrotated ? labelFixedPos || d[1][0] + padding : d[0][0] + (d[2][0] - d[0][0]) / 2;
        },
        y: function y(d, i) {
          return axisrotated ? d[1][1] + (d[2][1] - d[1][1]) / 2 : labelFixedPos || d[1][1] - 10;
        }
      }).
      text(function (d, i) {
        return getFormattedValue(defaultFormatConf, d.y, NUMERIC_DATATYPE, chartObj);
      }).
      styles({
        'text-anchor': axisrotated ? labelPos == 'fixedTop' ? 'end' : 'start' : 'middle',
        opacity: 0
      }).
      transition().
      duration(isAnimationEnable ? config.animationOptions.duration : 0).
      styles({
        opacity: 1
      });
      applyFont(labelG, [labelConfig, systemConf.chart, systemConf.canvas, $ZCG]);
    }
    function getDataForComparison(points, config) {
      var chartObj = config.chart,
        renderer = config.renderer,
        dataset = chartObj.dataset,
        seriesindex = config.seriesindex,
        yaxiscolumnorder = config.yaxiscolumnorder,
        stacked = config.stacked,
        processedStackedData = chartObj.dataObject.waterfall.layout._keys,
        isCatNullY = DataProcessor.helpers.isCatNull(dataset, 'y', yaxiscolumnorder),
        count = points.length - 1,
        barSize = config.axisrotated ?
        renderer.getParamValue('height', points[0], seriesindex, null, renderer.commonOption) :
        renderer.getParamValue('width', points[0], seriesindex, null, renderer.commonOption),
        mSize = mathMin(barSize / 10, 1) * 10,
        stackExtent = config.chart.dataObject.stackedChart ? config.chart.dataObject.waterfall.stackExtent[0] : null,
        cascadedPoints = getCascadedData(points),
        cascadeCounter = 0,
        comparatorPathData = [];

      points.map(function (d, i) {
        var point_now = points[i];

        if (point_now.isCascaded && points[i + 1]) {
          var cascaded_next = getNextCascadedPoint(points, i + 1, config);
          if (cascaded_next) {
            var intermediateMaxPt = cascaded_next.maxPt,
              f = getTransValue(point_now, 'x', config, stackExtent),
              intermediate_x = getTransValue(intermediateMaxPt, 'x', config, stackExtent),
              intermediate_y = getTransValue(intermediateMaxPt, 'y', config, stackExtent),
              point_now_x = getTransValue(point_now, 'x', config, stackExtent),
              point_now_y = getTransValue(point_now, 'y', config, stackExtent),
              point_now_width = getTransValue(point_now, 'width', config, stackExtent),
              point_now_height = getTransValue(point_now, 'height', config, stackExtent),
              point_now_unshared = point_now.index == 0 || point_now.index == points.length - 1,
              point_next = cascaded_next.point,
              point_next_x = getTransValue(point_next, 'x', config, stackExtent),
              point_next_y = getTransValue(point_next, 'y', config, stackExtent),
              point_next_width = getTransValue(point_next, 'width', config, stackExtent),
              point_next_height = getTransValue(point_next, 'height', config, stackExtent),
              point_next_unshared = point_next.index == 0 || point_next.index == points.length - 1,
              movingSteps = getStepCoordinates(
              {
                x: point_now_x,
                y: point_now_y,
                width: point_now_width,
                height: point_now_height,
                unshared: point_now_unshared
              },
              {
                x: point_next_x,
                y: point_next_y,
                width: point_next_width,
                height: point_next_height,
                unshared: point_next_unshared
              },
              {
                x: intermediate_x,
                y: intermediate_y
              },
              mSize,
              config);

            if (stacked) {
              var point_now_stkd = processedStackedData[point_now.index],
                point_next_stkd = processedStackedData[point_next.index];
              movingSteps.y =
              (point_next_stkd.stackedValue - point_now_stkd.stackedValue) /
              mathMax(point_now_stkd.stackedValue, point_next_stkd.stackedValue) *
              100;
            } else {
              movingSteps.y = (point_next.y - point_now.y) / point_now.y * 100;
            }

            point_next.percent = movingSteps.y;
            if (cascadeCounter == 0 && i != 0) {
              var initY = renderer.getParamValue('y', points[0], seriesindex, null, renderer.commonOption);
              point_now.percent = (point_now.y - points[0].y) / point_now.y * 100;
            }
            comparatorPathData.push(movingSteps);
          }
          cascadeCounter++;
        }
      });
      return comparatorPathData;
    }

    function getStepCoordinates(source, target, intermediate, mSize, config) {
      var axisrotated = config.axisrotated,
        stacked = config.chart.dataObject.stacked,
        datalabelPadding = config.chart.dataObject.waterfall.datalabelPadding,
        tinyAdjustmentPadding = 30,
        x_target = mathMax(intermediate.x, stacked ? target.x : target.x + target.width), //TODO comment
        y_target = mathMin(intermediate.y, target.y),
        width_source = source.unshared ? source.width / 2 : source.width / 2 + source.width / 4,
        width_target = target.unshared ? target.width / 2 : target.width / 4,
        height_source = source.unshared ? source.height / 2 : source.height / 4,
        height_target = target.unshared ? target.height / 2 : target.height / 2 + target.height / 4,
        step_1,
        step_2,
        step_3,
        step_4;

      if (axisrotated) {
        step_1 = [source.x + source.width + datalabelPadding, source.y + height_source],
        step_2 = [x_target + datalabelPadding + tinyAdjustmentPadding, source.y + height_source],
        step_3 = [x_target + datalabelPadding + tinyAdjustmentPadding, target.y + height_target],
        step_4 = [target.x + target.width + datalabelPadding, target.y + height_target];
      } else {
        step_1 = [source.x + width_source, source.y - datalabelPadding],
        step_2 = [source.x + width_source, y_target - datalabelPadding - tinyAdjustmentPadding],
        step_3 = [target.x + width_target, y_target - datalabelPadding - tinyAdjustmentPadding],
        step_4 = [target.x + width_target, target.y - datalabelPadding];
      }

      var moves = [step_1, step_2, step_3, step_4];
      return moves;
    }

    function getNextCascadedPoint(points, index, config) {
      var point_now = points[index],
        stackExtent = config.chart.dataObject.stackedChart ? config.chart.dataObject.waterfall.stackExtent[0] : null,
        maxY = 0,
        maxPoint = point_now;
      if (!point_now) {
        return;
      }
      while (!point_now.isCascaded) {
        var point_now_y = getY(point_now, stackExtent);
        if (point_now_y > maxY) {
          maxPoint = point_now;
          maxY = point_now_y;
        }
        point_now = points[++index];
        if (!point_now) {
          return;
        }
      }
      return { point: point_now, maxPt: maxPoint };
    }
    function getCascadedData(points) {
      var cascadedPoints = points.filter(function (d, i) {
        return d.isCascaded;
      });
      return cascadedPoints;
    }

    function getY(point, stackExtent) {
      if (stackExtent) {
        return getStackExtentValue(point, stackExtent);
      }
      return point.y + point.y0;
    }

    function getStackExtentValue(point, stackExtentList) {
      /*
       extent[0] = category index (for same category there may be two set of values, one for positive, one for negative)
       extent[1] = Display value
       extent[2] = cumulative screen value
      */

      var itemPos = point.index,
        stackExtent_now = stackExtentList.filter(function (d, i) {
          return d[0] == itemPos;
        }), // returns positive and negative list for the current category
        curEntry = stackExtent_now[0]; //Take only the first position of the list;
      // Always 0th position contains positive Details, 1st position contains negative info
      if (!curEntry || !curEntry.length) {
        return 0;
      }
      var actualDisplayVal = curEntry[1],
        actualExtentVal = curEntry[2],
        overallCumulativeVal = isPositive(actualDisplayVal) ? actualExtentVal : actualExtentVal + mathAbs(actualDisplayVal);

      return overallCumulativeVal;
    }
    //TODO COMMENT all params clearly
    function getTransValue(point, type, config, stackExtent) {
      var renderer = config.renderer,
        axisrotated = config.axisrotated,
        seriesindex = config.seriesindex;

      if (stackExtent) {
        if (axisrotated && type == 'width') {
          return 0;
        }
        var actualExtent = getStackExtentValue(point, stackExtent);
        return axisrotated && type == 'x' || !axisrotated && type == 'y' ?
        renderer.commonOption.yscale(actualExtent) :
        renderer.getParamValue(type, point, seriesindex, null, renderer.commonOption);
      } else {
        return renderer.getParamValue(type, point, seriesindex, null, renderer.commonOption);
      }
    }

    function getPreCalculatedLabelSize(chartObj, data) {
      var commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions.waterfall,
        axisrotated = chartObj.axes.rotated,
        systemconf = chartObj.systemConf,
        labelSize = 0,
        padding = 10,
        element = appendEle(chartObj.staticPaneSVG.selectAll('g.labelholder'), 'text', [1], '.', 'class', 'dummyText');
      chartObj.seriesdata.forEach(function (d, i) {
        if (d.plotoptions || !labelSize) {
          var plotoptions = d.plotoptions,
            comparisonConfig =
            plotoptions && plotoptions.comparisonLine ?
            mergeJSON$1(commonPlotOptions.comparisonLine, plotoptions.comparisonLine, true) :
            commonPlotOptions.comparisonLine,
            labelConfig = comparisonConfig.label;
          element.text('800%').style('fill', 'none');
          applyFont(element, [labelConfig, systemconf.chart, systemconf.canvas, $ZCG]);
          var clientRect = bbox(element.node());
          labelSize = mathMax(axisrotated ? clientRect.width : clientRect.height, labelSize);
        }
      });
      element.remove();
      return labelSize + padding;
    }

    function checkComparisonLineEnabled(chartObj, index) {
      var data = chartObj.dataObject.getEncode('y', index).seriesData,
        commonPlotOptions = chartObj.systemConf.chart.plot.plotoptions.waterfall;

      var enabled = data.some(function (series) {
        var plotoptions = series.plotoptions,
          comparisonConfig =
          plotoptions && plotoptions.comparisonLine ?
          mergeJSON$1(commonPlotOptions.comparisonLine, plotoptions.comparisonLine, true) :
          commonPlotOptions.comparisonLine;

        return comparisonConfig.enabled;
      });
      return enabled;
    }

    var _waterfallComparisonLine = svg_plot_renderer.waterfallHelpers.drawComparisonLine;

    //waterfall-layout.js

    /**
     * @param  {Array} data          [description]
     * @param  {Function} keyAccessor   [description]
     * @param  {Function} valueAccessor [description]
     */
    var WaterfallLayout = function WaterfallLayout(data) {
      extend(WaterfallLayout.prototype, StackLayout.prototype);

      var base = this._base = 0;
      this._stack = false;
      this._extent = [base, base];
      this._data = [];
      this._rows = {};
      this._keys = {};
      this._sum = base;

      if (data) {
        this.add.apply(this, arguments);
      }
    };

    var proto$m = WaterfallLayout.prototype;

    /**
     * Converts and adds the data to the layout[description]
     * @param  {Array} data          [description]
     * @param  {Function} keyAccessor   [description]
     * @param  {Function} valueAccessor [description]
     */
    proto$m.add = function (data, index, keyAccessor, valueAccessor, intermediateAccessor) {
      /*
          keys - categories
          rows - series
          lastRunningSum - running y0 for the previous category added
          in this layout (for stack)
          previousSum - local y0 to be used for stacking the values
          now - current key data to be processed
       */
      var L = this,
        stack = L._stack,
        keys = L._keys,
        rows = L._rows,
        extent = L._extent,
        base = L._base,
        lastRunningSum = L._sum,
        previousSum = base,
        total = base,
        now = keys[index];
      keys[index] = now = {};
      now.runningTotal = [NULL$1, NULL$1];
      now.absoluteTotal = [base, base];

      data.forEach(function (d, i) {
        /*
               key - Actual category
             */
        var key = keyAccessor(d),
          /*
              value - value for that category
           */
          value = valueAccessor(d) || base,
          /*
              To check whether data need to be cascaded and render.
           */
          intermediate = intermediateAccessor(d),
          sign = +(value >= base),
          /*
              For stack, data iterated for each category with respect to different series
              Hence for stack, index passed in main function will be category position
              and i passed in local function will be series index and vice versa for
              normal charts
          */

          keyIdx = stack ? index : i,
          rowIdx = stack ? i : index,
          /*
              Chained stack total for all the categories
              - saved separately for positive & negative
           */
          runningTotal = keys[index].runningTotal,
          /*
              Absolute total considered only for this particular category
              - saved separately for positive & negative
           */
          absoluteTotal = keys[index].absoluteTotal;

        /**
         *For intermediate category, base value (y0) should be zero and
         * actual value (y) should be previousSum. If first category
         * is intermediate, then y value should be the user given value.
         *
         * For stack intermediate category, value was calculated from the saved
         * row wise stacked values
         *
         * previousSum - gives overall chained stack value for the successive categories
         *
         * lastRunningSum - gives simple stack value for the last drawn key or cat
         */
        if (intermediate) {
          value = value || rows[rowIdx] || previousSum;
          sign = +(value >= base);
          previousSum = lastRunningSum = base;
          rows[rowIdx] = base;
          /*
          set value to the respective datapoint
          */
          valueAccessor(d, value);
        }

        /*
        For stack mode, base value (y0) for the first series should be lastNetSum
        and for the successive series, it should take previousSum
         Also we need to update rows - To generate value for intermediate category
        Need to update keys with signIndex - To get separate previousSum for positive
        and negative.
        */

        if (stack) {
          previousSum = runningTotal[sign] || lastRunningSum || base;

          runningTotal[sign] = previousSum + value;
          absoluteTotal[sign] += value;
          rows[rowIdx] = (rows[rowIdx] || base) + value;
          total += value;
        }

        /*
        Save y0 - previous running sum for that category
            y - actual current value
            index - to render the chart based on this index. May have same category multiple
            times.
        */

        d.y0 = previousSum;
        d.y = value;
        d.index = keyIdx;
        d.isPositive = sign;
        d.isCascaded = intermediate;

        /*
        Save cumulative sum value (used as previous sum value)
        */
        previousSum = previousSum + value;

        /*
        Find extent
        */
        extent = d3_extent([].concat(_toConsumableArray(extent), [previousSum, base]));
      });

      L._extent = extent;
      L._data = L._data.concat(data);
      L._sum = now.runningTotal[+(total > base)];
    };

    /**
     * Set the stack mode
     *
     */
    proto$m.stack = function (_) {
      this._stack = _;
    };

    //$Id$

    DataProcessor.prototype.processDataForWaterFall = function () {
      var processor = this,
        dataset = processor.dataset,
        data = processor.data,
        chartObj = processor.chartObj,
        dataObject = chartObj.dataObject,
        processedseriesData = processor.processedseriesData,
        seriesLength = processedseriesData.length,
        xCategories = dataObject.getCategories('x'),
        xCategoriesLength = xCategories.length,
        stacked = processor.isstacked('waterfall'),
        cascaded_dataindex = validateNullVal(data.chart.plot.plotoptions.waterfall.cascadeCategories.dataindex, 2),
        yaxiscolumnorder,
        allYValues = [];
      processor.waterfall = {};

      var xAccessor = function xAccessor(d) {
        return dataset.getActualX(d);
      };
      var yAccessor = function yAccessor(d, value) {
        if (value) {
          d[dataset.yidx(yaxiscolumnorder)] = value;
        }
        return dataset.getY(d, yaxiscolumnorder);
      };
      var intermediateAccessor = function intermediateAccessor(d) {
        return d[cascaded_dataindex];
      };

      var layout = new WaterfallLayout();

      if (stacked) {
        layout.stack(true);
        var baseValue = 0,
          stackExtent = [];

        for (var i = 0; i < xCategoriesLength; i++) {
          var currentCategory = xCategories[i];
          var data = [];
          for (var j = 0; j < seriesLength; j++) {
            var d = processedseriesData[j],
              ishideable = d.disabled,
              currentseriesdata = d.data,
              subgroupLength = currentseriesdata.length;
            yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(d.yaxiscolumnorder);
            if (!ishideable) {
              for (var k = 0; k < subgroupLength; k++) {
                var subgroup = currentseriesdata[k],
                  xCat = dataset.getActualX(subgroup[i]);
                if (xCat == currentCategory) {
                  if (!subgroup[i].dummy) {
                    data.push(subgroup[i]);
                  }
                } else {
                  var dummy = [];
                  dummy[dataset.xidx] = currentCategory;
                  dummy.dummy = true;
                  subgroup.splice(i, 0, dummy);
                }
              }
            }
          }

          var y0 = layout._sum || 0;
          if (data.length) {
            layout.add(data, i, xAccessor, yAccessor, intermediateAccessor);

            /*
                Construct stack data for the categories. Used for connector lines
             */
            var key = layout._keys[i];

            key.index = i;
            key.stackedValue = d3_sum(key.absoluteTotal);
            key.isPositive = +(key.stackedValue > baseValue);
            key.isCascaded = intermediateAccessor(data[0]);
            key.y = key.absoluteTotal[key.isPositive];
            key.y0 = key.isCascaded ? baseValue : y0; //y0 will be the running sum of the previous category

            /*
                Construct stack extent values. Used for label render
             */

            for (var j = key.absoluteTotal.length - 1; j >= 0; j--) {
              if (key.absoluteTotal[j]) {
                stackExtent.push([i, key.absoluteTotal[j], key.runningTotal[j]]);
              }
            }
          }

          /*
              extent for finding domain of axis
           */
          allYValues = layout._extent;
        }

        //stack Extent
        processor.waterfall.stackExtent = []; //TODO: hack
        var stackEncode = processor.getEncode('stack');

        each(stackEncode, function (stackData, i) {
          // var stackExtent = updateStackExtent(d3.range(xCategories.length), grossPositiveSum, grossNegativeSum,netPositiveSum,netNegativeSum);
          processor.waterfall.stackExtent[i] = stackExtent;
          stackData.layout.getAllExtents = function () {return stackExtent;}; //Override
        });
      } else {
        processedseriesData.forEach(function (d, i) {
          var currentseriesdata = d.data;
          yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(d.yaxiscolumnorder);

          currentseriesdata.forEach(function (subgroup, j) {
            xCategories.forEach(function (cat, k) {
              var currentCategory = cat;
              var data = subgroup[k],
                xCat = data ? dataset.getActualX(data).toString() : null;

              if (xCat !== currentCategory.toString()) {
                var dummy = [];
                dummy[dataset.xidx] = currentCategory;
                dummy.dummy = true;
                subgroup.splice(k, 0, dummy);
                return;
              }
            });
            layout.add(subgroup, i, xAccessor, yAccessor, intermediateAccessor);
            allYValues = layout._extent;
          });
        });
      }
      chartObj.dataObject.waterfall.layout = layout;
      var minMaxY = d3_extent(allYValues);
      return minMaxY;
    };

    DataProcessor.prototype.getCorrectionForWaterfall = function (domain, type, index, chartObj, hasLabelCorrection) {
      var isComparisonEnabled = checkComparisonLineEnabled(chartObj, index);
      hasLabelCorrection = chartObj.datalabels.hasFixedPosition ? false : hasLabelCorrection;
      var handleOverlap = chartObj.systemConf.chart.plot.datalabels.handleOverlapping,
        needLabelAdjustment = chartObj.datalabels.isStackedLabels || chartObj.datalabels.hasFixedPosition || !handleOverlap,
        datalabelExtraPadding = hasLabelCorrection ? needLabelAdjustment ? 10 : 0 : 10;
      chartObj.dataObject.waterfall.datalabelPadding = hasLabelCorrection ?
      chartObj.cache.correction['label-y-0'][1] + datalabelExtraPadding :
      datalabelExtraPadding;
      domain = resetNegativeDomain(domain);
      var domainDiff = domain[1] - domain[0],
        orient = chartObj.axes.y.orient,
        rangeDiff = chartObj.plotarea[orient == 'left' ? 'height' : 'width'],
        totalAdjustment = 5,
        correction = domainDiff / (rangeDiff - totalAdjustment) * totalAdjustment,
        correction_comp;
      if (isComparisonEnabled) {
        var labelSize = getPreCalculatedLabelSize(chartObj),
          adjustY = 30;
        totalAdjustment += labelSize + adjustY + datalabelExtraPadding;
        correction_comp = domainDiff / (rangeDiff - totalAdjustment) * totalAdjustment;
      }

      domain[1] += isComparisonEnabled ? correction_comp : correction;
      domain[0] -= chartObj.dataObject.waterfall.hasNegativeCascaded ? correction : 0;

      return domain;
    };

    function resetNegativeDomain(domain) {
      if (domain[1] < 0) {
        domain[1] = 0;
      }
      return domain;
    }

    var _waterfallProcessor = DataProcessor.prototype.processDataForWaterFall;

    defaultTheme.waterfall = function () {
      return {
        outerPadding: 0.04,
        fillOpacity: 0.9,
        maxBandWidth: 200,
        multiColoring: false,
        border: {
          show: false,
          size: null,
          style: 'solid',
          radius: 0,
          color: null
        },
        stacked: {
          enabled: false,
          showAs: 'values' //values,percent
        },
        connector: {},
        comparisonLine: {},
        cascadeCategories: {
          dataindex: 2
        },
        risingCategories: {},
        fallingCategories: {},
        datalabels: {
          showAs: 'y', //x,y,percent
          stackLabels: {
            show: false,
            showAs: 'y' //y,percent
          }
        },
        animation: {
          type: 'verticalAll' //verticalAll || vertical
        },
        gradients: {
          //linear || none
          options: {
            linear: {
              y2: 50
            }
          }
        }
      };
    };

    //$Id$

    svg_plot_renderer.waterfallHelpers.drawConnectorLines = function (group, data, config, mode) {
      var chartObj = config.chart,
        dataset = chartObj.dataset,
        axisrotated = config.axisrotated,
        stacked = config.stacked,
        xscale = config.xscale,
        yscale = config.yscale,
        yaxiscolumnorder = config.yaxiscolumnorder,
        renderer = config.renderer,
        seriesindex = config.seriesindex,
        points = stacked ? chartObj.dataObject.waterfall.layout._keys : data,
        yaxisReversed = chartObj.systemConf.chart.axes.yaxis[yaxiscolumnorder || 0].reversed,
        xAxisReversed = chartObj.systemConf.chart.axes.xaxis.reversed,
        plotoptions = config.plotoptions,
        commonPlotOptions = config.commonPlotOptions,
        connectorConfig =
        plotoptions && plotoptions.connector ?
        mergeJSON$1(commonPlotOptions.connector, plotoptions.connector, true) :
        commonPlotOptions.connector,
        connectorData = connectorConfig.enabled ? getPointToPointConnectData(points, config) : [];

      var d3Line = d3_line().
      x(function (d, i) {
        var x = renderer.getParamValue('x', d, seriesindex, null, renderer.commonOption),
          width = renderer.getParamValue('width', d, seriesindex, null, renderer.commonOption),
          isSrc = xAxisReversed ? i == 1 : i == 0;
        return getTransLinkPoints(x, width, d, 'x', isSrc, axisrotated);
      }).
      y(function (d, i) {
        var y = renderer.getParamValue('y', d, seriesindex, null, renderer.commonOption),
          height = renderer.getParamValue('height', d, seriesindex, null, renderer.commonOption);
        return getTransLinkPoints(y, height, d, 'y', i == 0, axisrotated);
      });
      var line = appendEle(group, 'path', connectorData, '.', 'class', 'zcconnectorLine', null, function (d) {
        return dataset.getX(d);
      });

      line.attr('d', function (d, i) {
        return d3Line(d);
      }).
      styles({
        fill: 'none',
        stroke: connectorConfig.strokeColor || 'black',
        'stroke-width': connectorConfig.strokeWidth || 1,
        'stroke-dasharray': getDashArray(connectorConfig.dashStyle, connectorConfig.strokeWidth || 1),
        'stroke-opacity': 0
      }).
      transition().
      duration(1000).
      styles({
        'stroke-opacity': connectorConfig.strokeOpacity || 1
      });
    };
    function getTransLinkPoints(x0, x1, data, type, isSourcePoint, axisrotated, stacked) {
      if (type == 'x') {
        if (axisrotated) {
          if (isSourcePoint || data.isCascaded) {
            return data.isPositive ? x0 + x1 : x0;
          } else {
            return data.isPositive ? x0 : x0 + x1;
          }
        } else {
          return isSourcePoint ? x0 + x1 : x0;
        }
      } else {
        if (axisrotated) {
          return isSourcePoint ? x0 : x0 + x1;
        } else {
          if (isSourcePoint || data.isCascaded) {
            return data.isPositive ? x0 : x0 + x1;
          } else {
            return data.isPositive ? x0 + x1 : x0;
          }
        }
      }
    }

    function getPointToPointConnectData(points, config) {
      var chartObj = config.chart,
        dataset = chartObj.dataset,
        yaxiscolumnorder = config.yaxiscolumnorder,
        stacked = config.stacked,
        isCatNullY = DataProcessor.helpers.isCatNull(dataset, 'y', yaxiscolumnorder),
        yAccessor = getConnectorY,
        keys = Object.keys(points),
        count = keys.length - 1,
        connectorDataPoints = [];

      for (var i = 0; i < count; i++) {
        var point_now = points[keys[i]],
          point_after = points[keys[i + 1]],
          point_now_y = yAccessor(point_now, yaxiscolumnorder),
          point_next_y = yAccessor(point_after, yaxiscolumnorder),
          point_now_undefined = isCatNullY(point_now_y),
          point_next_undefined = isCatNullY(point_next_y);
        if (point_now_undefined) {
          connectorDataPoints.push([]);
        } else if (point_next_undefined) {
          var temp = i + 2,
            point_subsequent = points[temp],
            point_subsequent_y = point_subsequent && yAccessor(point_subsequent, yaxiscolumnorder),
            point_subsequent_defined = !isCatNullY(point_subsequent_y);
          while (temp < count && !point_subsequent_defined) {
            temp++;
            point_subsequent = points[temp];
            point_subsequent_y = point_subsequent && yAccessor(point_subsequent, yaxiscolumnorder),
            point_subsequent_defined = !isCatNullY(point_subsequent_y);
          }
          if (point_subsequent_defined) {
            connectorDataPoints.push([point_now, point_subsequent]);
          }
        } else {
          connectorDataPoints.push([point_now, point_after]);
        }
      }

      return connectorDataPoints;
    }

    function getConnectorY(point) {
      return point.y;
    }

    var _waterfallConnectorLine = svg_plot_renderer.waterfallHelpers.drawConnectorLines;

    //

    function fontRangeParser(encodeType, index, config, chart) {
      var dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType, index),
        ranges = config.ranges,userSizes = config.sizes,
        bound = rendererBoundUtils.getAvailableBound(chart.plotarea, config),
        rangeOperators = {};

      if (userSizes) {
        rangeOperators.userRanges = {
          size: userSizes,
          plotBound: bound,
          callbackArgs: [chart, bound]
        };
        return rangeOperators;
      }

      rangeOperators.baseSize = {
        config: config,
        size: ['2%', '20%'],
        plotBound: bound,
        callbackArgs: [chart, bound]
      };

      if (ranges || dataType === ORDINAL_DATATYPE) {
        rangeOperators.mapDiscreteDomainToRange = { ranges: ranges };
      } else {
        rangeOperators.mapContinuousDomainToRange = {};
      }

      return rangeOperators;
    }

    //

    function fontScaleParser(encodeType) {var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var chart = arguments.length > 2 ? arguments[2] : undefined;var config = arguments.length > 3 ? arguments[3] : undefined;
      var dataSet = chart.dataset,
        dataType = dataSet.getDataType(encodeType, index),
        columnInfo = dataSet.getColumn(encodeType, index);

      var parser = {
        type: dataType,
        dataType: dataType,
        scaleType: dataType === ORDINAL_DATATYPE ? '_ordinal' : dataType,
        field: columnInfo,
        reverse: config.reversed,
        clamp: true,
        data: [],
        domain: {
          operators: ScaleRegistry.get('size.domainParser')(encodeType, index, config, chart),
          evaluator: ScaleRegistry.get('size.evalDomain')
        },
        range: {
          operators: fontRangeParser(encodeType, index, config, chart),
          evaluator: ScaleRegistry.get('size.evalRange')
        }
      };

      return parser;
    }
    ScaleRegistry.add('wordcloud.font.parser', fontScaleParser);

    //$Id$

    // https://github.com/timdream/wordcloud2.js/blob/gh-pages/API.md
    var TRUE = true,
      FALSE = false,
      maxCanvasSize = $Browser.CHROME || $Browser.FIREFOX ? 32000 : $Browser.IE && $Browser.isTouchDevice ? 4000 : 8000,
      createCanvas = function createCanvas() {
        return document.createElement('canvas');
      },
      createContext = function createContext(canvas) {
        return canvas.getContext('2d');
      },
      isTspan = function isTspan(node) {
        return node.nodeName === TSPAN_ELEMENT;
      };

    var WordCloud = function WordCloud(data, config) {
      var plotWidth = config.width,
        plotHeight = config.height,
        textOverflow = config.textOverflow,
        textOverlap = config.textOverlap,
        mask = config.mask,
        invert = config.invert || FALSE,
        fontScale = config.fontScale,
        maxWidth = defined(config.maxWidth) ? perToPx(config.maxWidth, plotWidth) : NULL$1,
        _fontFamily = config.fontFamily,
        _fontStyle = config.fontStyle,
        _fontWeight = config.fontWeight,
        _fontSize = config.fontSize,
        _content = config.content,
        _rotation = config.rotation,
        patternSvg = config.container,
        maxSizeFactor = config.maxSizeFactor,
        pointsAtRadius = [],
        g = mathMin(8, mathMax(4, mathRound(16 * mathMin(plotWidth, plotHeight) / 1024))),
        grid = [],
        rotationCollection = [],
        outside = [0, 0],
        meta,
        maskImageData,
        areaOfMask,
        imageDataX,
        imageDataY,
        imageTotalWidth,
        imageTotalHeight,
        currentRowHeight,
        canvasCount,
        textImageData,
        drawnData,
        calculatedPosition,
        canvasMeta,
        drawnBound,_ref21 =
        config.preCalculation || {},_ref21$singleNode = _ref21.singleNode,singleNode = _ref21$singleNode === void 0 ? true : _ref21$singleNode,_ref21$timeOut = _ref21.timeOut,timeOut = _ref21$timeOut === void 0 ? 0 : _ref21$timeOut,adjust = _ref21.adjust,
        breathNInvoke = !singleNode ? function (func) {return setTimeout(func, timeOut);} : function (func) {return func();},

        dummyText = function () {
          if (singleNode) {
            return appendEle(patternSvg, TEXT_ELEMENT, [1], '.', 'class', 'dummyText');
          } else {
            return appendEle(patternSvg, TEXT_ELEMENT, data, '.', 'class', 'dummyWord').attr('id', function (d, i) {return 'dummyWord_' + i;});
          }
        }(),
        getDummyText = function getDummyText(i) {return singleNode ? dummyText : patternSvg.selectAll('text#dummyWord_' + i);},

        ngx = mathCeil(plotWidth / g),
        ngy = mathCeil(plotHeight / g),
        fx = mathMin(1, ngx / ngy),
        fy = mathMin(1, ngy / ngx),
        center = (center = config.origin) ? [center[0] / g, center[1] / g] : [ngx / 2, ngy / 2],
        maxRadius = mathFloor(mathSQRT(ngx * ngx + ngy * ngy)),
        noOfPointAtRadius = data.length < 100 ? 8 : 1,

        getPointsAtRadius = function getPointsAtRadius(radius) {
          if (pointsAtRadius[radius]) {
            return pointsAtRadius[radius];
          }

          var T = radius * noOfPointAtRadius, // Look for these number of points on each radius
            t = T,
            points = []; // Getting all the points at this radius

          if (radius === 0) {
            points.push([center[0], center[1] + outside[1], 0]);
          }

          while (t--) {
            // distort the radius to put the cloud in shape
            var theta = t / T * 2 * mathPI;

            // Push [x, y, t]; t is used solely for getTextColor()
            points.push([center[0] + radius * mathCos(-theta) * fx, center[1] + outside[1] + radius * mathSin(-theta) * fy, theta]);
          }

          return pointsAtRadius[radius] = points;
        },
        getCanvas = function getCanvas(d) {
          var canvas = createCanvas();
          canvas.setAttribute('width', d.width);
          canvas.setAttribute('height', d.height);
          d.context = createContext(canvas);
        },
        getContext = function getContext(arg) {
          var index = arg.constructor === Object ? arg.canvasIndex : arg;
          return canvasMeta[index].context;
        },
        readImageData = function readImageData(d, i) {
          textImageData[i] = getContext(i).getImageData(0, 0, d.width, d.height).data; // Get the pixels of all the words
        },
        getWordPadding = function getWordPadding(d) {
          return config.strokeWidth(d) + config.padding(d);
        },
        drawText = function drawText(d, info) {
          // XXX: We cannot because textBaseline = 'top' here because
          // Firefox and Chrome uses different default line-height for canvas.
          // Please read https://bugzil.la/737852#c6.
          // Here, we use textBaseline = 'middle' and draw the text at exactly
          // 0.5 * fontSize lower.
          var fontSize = info.size,
            globalFont = getFont(d),
            bb = info.bb,
            nodeList = info.nodeList,
            dy = wordCloudUtils.getDy(nodeList),
            x = 0,
            y = 0,
            context = getContext(info);

          context.strokeStyle = '#000';
          context.lineWidth = getWordPadding(d);
          context.lineJoin = 'bevel'; // ZC1459 // add this too context.miterLimit=2;
          context.fillStyle = '#000';

          if (nodeList.contentType === 'html') {
            context.textAlign = CENTER_ALIGN;
            nodeList.forEach(function (a) {
              var userStyle = a.style,
                font,
                fSize;

              if (userStyle.length) {
                font = getUserFontValue(applyFont(NULL$1, [getFontStyles(d)]), userStyle);
                fSize = parseFloat(userStyle['font-size']);
              }

              x = a.dx || 0;
              y = (a.dy || 0) * fontSize + fontSize * dy - (wordCloudUtils.isMultiLine(nodeList) ? bb.height / 2 : 0);

              context.font = font || globalFont;
              context.strokeText(a.text, x, y);
              context.fillText(a.text, x, y);
            });
          } else {
            y = fontSize * dy;
            context.textAlign = CENTER_ALIGN;
            context.font = globalFont;
            context.strokeText(nodeList.innerSVG, x, y);
            context.fillText(nodeList.innerSVG, x, y);
          }
        },
        getFontStyles = function getFontStyles(d) {
          return {
            fontStyle: _fontStyle(d),
            fontWeight: _fontWeight(d),
            fontSize: _fontSize(d),
            fontFamily: _fontFamily(d)
          };
        },
        getFont = function getFont(d) {
          return "".concat(_fontStyle(d), " ") + "normal" + " ".concat(_fontWeight(d), " ").concat(_fontSize(d).toString(10)).concat(PX, " ").concat(_fontFamily(d));
        },
        sortByFontSizeAccesor = function sortByFontSizeAccesor(a, b) {
          return _fontSize(b) - _fontSize(a);
        },
        sortByContentAccesor = function sortByContentAccesor(a, b) {
          return _content(b).value.length - _content(a).value.length;
        },
        updateBound = function updateBound(bound, start, end) {
          bound[0] = mathMin(bound[0], start[0]);
          bound[1] = mathMin(bound[1], start[1]);
          bound[2] = mathMax(bound[2], end[0]);
          bound[3] = mathMax(bound[3], end[1]);
        },
        getOccupiedArrayNBound = function getOccupiedArrayNBound(info) {
          // Read the pixels and save the information to the occupied array
          var cgw = info.gw,
            cgh = info.gh,
            cx = info.canvasBound[0],
            cy = info.canvasBound[1],
            canvasIndex = info.canvasIndex,
            width = canvasMeta[canvasIndex].width,
            imageData = textImageData[canvasIndex],
            occupied = [],
            bound = [cgw / 2, cgh / 2, cgw / 2, cgh / 2],
            gx = cgw,
            gy,
            x,
            y;

          while (gx--) {
            gy = cgh;
            while (gy--) {
              y = g;
              singleGridLoop: {
                while (y--) {
                  x = g;
                  while (x--) {
                    if (imageData[((gy * g + y + cy) * width + (gx * g + x + cx)) * 4 + 3]) {
                      occupied.push([gx, gy]);
                      updateBound(bound, [gx, gy], [gx, gy]);
                      break singleGridLoop;
                    }
                  }
                }
              }
            }
          }

          return {
            occupied: occupied,
            bound: bound
          };
        },
        wordOverflow = function wordOverflow(ele, d, deg, customWidth) {
          var textNode = ele.node(),
            nodes = textNode.childElementCount ?
            ele.
            selectAll('*').
            filter(function () {
              return isTspan(this) && !this.childElementCount;
            }).
            nodes() :
            [textNode],
            degree_360 = radianToDegree(deg) % 360,
            degree_90 = degree_360 > 90 ? 180 - degree_360 : degree_360;

          ele.attr('dy', '1em').attr('transform', "rotate(".concat(degree_90, " 0 0)"));

          var overflowPattern = textOverflow === 'ellipsis' ? '..' : '',
            overflowPatternLength = overflowPattern.length,
            textNode_bb = getDefaultBoundingClientRect(textNode),
            padding = config.padding(d),
            w = (defined(customWidth) ? customWidth : plotWidth) - padding - (adjust ? g : 0), // ZC1459: consider padding
            h = plotHeight - padding,
            available = {
              left: textNode_bb.left,
              top: textNode_bb.top,
              right: textNode_bb.left + w,
              bottom: textNode_bb.top + h,
              width: w,
              height: h
            },
            getTextBound_wordcloud = function getTextBound_wordcloud(node) {
              var clientRect = isTspan(node) ? getTspanBoundingClientRect : getDefaultBoundingClientRect,
                bb = clientRect(node, 1);

              if (isTspan(node)) {
                availableWidth = available.width - mathMax(0, bb.left - available.left) - mathMax(0, available.right - bb.right);
                availableHeight = available.height - mathMax(0, bb.top - available.top) - mathMax(0, available.bottom - bb.bottom);
              }

              return {
                width: bb.width,
                height: bb.height
              };
            },
            overflowLength,
            croppedTextLength,
            availableWidth,
            availableHeight,
            textBound;

          nodes.forEach(function (node) {
            availableWidth = w;
            availableHeight = h;
            textBound = getTextBound_wordcloud(node);

            if (textBound.width - availableWidth > 1) {
              // Test_941.json, Test_942.json
              overflowLength = (textBound.width - availableWidth) / textBound.width;
              croppedTextLength = mathCeil((1 - overflowLength) * node.textContent.length);
              node.textContent = node.textContent.substring(0, croppedTextLength - overflowPatternLength) + overflowPattern;
              textBound = getTextBound_wordcloud(node);
            }

            if (textBound.height - availableHeight > 1) {
              overflowLength = (textBound.height - availableHeight) / textBound.height;
              croppedTextLength = mathCeil((1 - overflowLength) * node.textContent.length);
              node.textContent = node.textContent.substring(0, croppedTextLength - overflowPatternLength) + overflowPattern;
              textBound = getTextBound_wordcloud(node);
            }

            if (textBound.width - availableWidth > 1 || textBound.height - availableHeight > 1) {
              naiveEllipsis(node, node, node.textContent, textBound.width, textBound.height, textBound, overflowPattern);
            }

            if (node.textContent === overflowPattern) {
              node.textContent = '';
            }
          });
        },
        drawWordsInSvg = function drawWordsInSvg(d, i, customFontSize) {
          var content = _content(d),
            innerSVG = content.value,
            contentType = content.type,
            rotateDeg = rotationCollection[i],
            textEle = getDummyText(i);

          textEle[contentType](innerSVG);
          applyFont(textEle, [getFontStyles(d)]);
          if (customFontSize) {
            textEle.style('font-size', customFontSize + PX);
          }
          if (wordCloudUtils.isMultiLine(content)) {
            translateTspan(textEle, 0);
          }

          if (!customFontSize && textOverflow !== 'none') {
            if (maxWidth) {
              wordOverflow(textEle, d, 0, maxWidth); //Have to enhance
            }
            wordOverflow(textEle, d, rotateDeg);
          }

          textEle.
          attr('text-anchor', MIDDLE_ALIGN).
          attr('dy', "".concat(wordCloudUtils.getDy(content), "em")).
          attr('transform', "rotate(".concat(radianToDegree(rotateDeg), " 0 0)"));
        },
        getTextInfo = function getTextInfo(d, i) {
          var fontSize = _fontSize(d),
            content = _content(d),
            padding = getWordPadding(d),
            contentType = content.type,
            rotateDeg = rotationCollection[i],
            nodeList = [];

          var textEle = getDummyText(i),
            bb = bbox(textEle.node()),
            boxWidth = bb.width + padding,
            boxHeight = bb.height + padding,
            // Calculate the actual dimension of the canvas, considering the rotation.
            cgh = mathCeil((boxWidth * mathAbs(mathSin(rotateDeg)) + boxHeight * mathAbs(mathCos(rotateDeg))) / g),
            cgw = mathCeil((boxWidth * mathAbs(mathCos(rotateDeg)) + boxHeight * mathAbs(mathSin(rotateDeg))) / g),
            width = cgw * g,
            height = cgh * g;

          nodeList.innerSVG = textEle[contentType]().trim(); // Why trim? If text has trailing spaces, wordcloud will overlap
          nodeList.contentType = contentType;
          nodeList.format = content.format;
          if (contentType === 'html') {
            var tspanInfo = getTspanBound(textEle, fontSize);
            Array.prototype.push.apply(nodeList, tspanInfo);
          }

          // Return information needed to create the text on the real canvas
          var info = {
            gw: cgw,
            gh: cgh,
            width: boxWidth,
            height: boxHeight,
            size: fontSize,
            rotation: rotateDeg,
            nodeList: nodeList,
            bb: bb // insteadof bb.height, can we use boxheight?????????
          };

          if (imageDataX + width > maxCanvasSize) {
            imageDataX = 0;
            imageDataY = imageDataY + currentRowHeight;
            currentRowHeight = 0;
          }

          if (imageDataY + height > maxCanvasSize) {
            canvasMeta[++canvasCount] = { width: 1, height: 1 };
            imageDataX = imageDataY = currentRowHeight = 0;
          }

          info.canvasBound = [imageDataX, imageDataY, width, height];
          info.canvasIndex = canvasCount;

          imageDataX += width;
          currentRowHeight = mathMax(currentRowHeight, height);
          canvasMeta[canvasCount].width = mathMax(canvasMeta[canvasCount].width, imageDataX);
          canvasMeta[canvasCount].height = imageDataY + currentRowHeight;

          return info;
        },
        drawWordsInCanvas = function drawWordsInCanvas(d, i) {
          var info = meta[i];
          if (!info) {
            return;
          }

          var context = getContext(info),
            canvasBound = info.canvasBound;
          context.save();
          context.translate(canvasBound[0] + canvasBound[2] / 2, canvasBound[1] + canvasBound[3] / 2);
          context.rotate(info.rotation);

          if (config.boundBox) {
            context.fillRect(-info.width / 2, -info.height / 2, info.width, info.height);
          } else {
            drawText(d, info);
          }

          context.restore();
        },
        isWithin = function isWithin(x, y) {
          return x >= ngx || y >= ngy || x < 0 || y < 0;
        },

        canFitText = function canFitText(gx, gy, occupied) {
          // Go through the occupied points,
          // return false if the space is not available.

          return !occupied.some(function (d) {
            var px = gx + d[0],
              py = gy + d[1];

            if (isWithin(px, py) || !grid[px][py]) {
              return TRUE;
            }
          });
        },

        createGrid = function createGrid() {
          var gx = ngx,
            gy,
            x,
            y;

          while (gx--) {
            grid[gx] = [];
            gy = ngy;
            while (gy--) {
              if (!mask) {
                grid[gx][gy] = TRUE;
              } else {
                grid[gx][gy] = !invert;
                y = g;
                singleGridLoop: while (y--) {
                  x = g;
                  while (x--) {
                    if (!maskImageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + 3]) {
                      grid[gx][gy] = invert;
                      break singleGridLoop;
                    }
                  }
                }
              }
            }
          }
        },


        updateGrid = function updateGrid(position, info) {
          info.occupied.forEach(function (d) {
            var px = position[0] + d[0],
              py = position[1] + d[1];

            if (!isWithin(px, py)) {
              grid[px][py] = FALSE;
            }
          });
        },
        tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy) {
          var info = this,
            gx = mathFloor(gxy[0] - info.gw / 2),
            gy = mathFloor(gxy[1] - info.gh / 2 + outside[1]);

          // If we cannot fit the text at this position, return false
          // and go to the next position.
          if (!canFitText(gx, gy, info.occupied)) {
            return FALSE;
          }

          calculatedPosition = [gx, gy];
          updateGrid(calculatedPosition, info); // Mark the spaces on the grid as filled

          return TRUE; // Return true so some() will stop and also return true.
        },



        putWord = function putWord(item, i) {
          var info = meta[i];
          item.layout = NULL$1;

          // not getting the info means we shouldn't be drawing this one.
          if (!info) {
            return FALSE;
          }

          var obj = getOccupiedArrayNBound(info);
          info.occupied = obj.occupied;
          var bound = info.bound = obj.bound;

          // skip the loop if we have already know the bounding box of
          // word is larger than the canvas.
          if (bound[2] - bound[0] + 1 > ngx || bound[3] - bound[1] + 1 > ngy) {
            return FALSE;
          }

          // Determine the position to put the text by
          // start looking for the nearest points
          var r = maxRadius + 1;var _loop7 = function _loop7()

          {
            points = getPointsAtRadius(maxRadius - r);

            // Try to fit the words by looking at each point.
            // array.some() will stop and return true
            // when putWordAtPoint() returns true.
            // If all the points returns false, array.some() returns false.
            drawn = points.some(tryToPutWordAtPoint, info);

            if (drawn) {
              x = calculatedPosition[0],
              y = calculatedPosition[1],
              bound = info.bound;

              var polygon = [];
              info.occupied.forEach(function (o) {
                if (o[0] && o[1]) {
                  polygon.push([o[0] * g, o[1] * g]);
                }
              });

              item.layout = {
                x: (x + info.gw / 2) * g,
                y: (y + info.gh / 2) * g,
                width: info.width,
                height: info.height,
                rotation: info.rotation,
                size: info.size,
                nodeList: info.nodeList,
                bb: info.bb,
                tightBound: {
                  x: bound[0] * g,
                  y: bound[1] * g,
                  width: (bound[2] - bound[0] + 1) * g,
                  height: (bound[3] - bound[1] + 1) * g
                },
                polygon: polygon
              };

              updateBound(drawnBound, [x * g, y * g], [(x + info.gw) * g, (y + info.gh) * g]);return { v:
                TRUE };
            }
          };while (r--) {var points, drawn, x, y, bound;var _ret = _loop7();if (_typeof(_ret) === "object") return _ret.v;}
          // we tried all distances but text won't fit, return false
          return FALSE;
        },
        precalculate = function precalculate() {
          var availablePlotArea = maskImageData ? areaOfMask : geometryUtils.areaOfEllipse(plotWidth / 2, plotHeight / 2),
            sum = 0,
            outWidth = 0,
            outHeight = 0,
            maxBoxWidth = 0,
            maxBoxHeight = 0,
            percent,
            fontArea = 0,
            range = fontScale.range(),
            domain = fontScale.domain(),
            maxFontSize = range[range.length - 1],
            _fonts = {};
          rotationCollection = data.map(_rotation);

          var writeFunc = function writeFunc(d, i) {
              var fontSize = _fontSize(d),
                contentType = _content(d).type,
                customFontSize = contentType === 'html' ? fontSize : 10;

              _fonts[fontSize] = fontSize;
              drawWordsInSvg(d, i, customFontSize);
            },
            readFunc = function readFunc(d, i) {
              var fontSize = _fontSize(d),
                padding = getWordPadding(d),
                contentType = _content(d).type,
                customFontSize = contentType === 'html' ? fontSize : 10,
                fontRatio = fontSize / customFontSize,
                deg = rotationCollection[i]; // ZC3305

              var textEle = getDummyText(i),
                bb = bbox(textEle.node()),
                boxWidth = bb.width + padding,
                boxHeight = bb.height + padding,
                area = boxWidth * boxHeight,
                scaledWidth = boxWidth * fontRatio * mathAbs(mathCos(deg)) + boxHeight * fontRatio * mathAbs(mathSin(deg)),
                scaledHeight = boxWidth * fontRatio * mathAbs(mathSin(deg)) + boxHeight * fontRatio * mathAbs(mathCos(deg));

              maxBoxWidth = mathMax(maxBoxWidth, scaledWidth);
              maxBoxHeight = mathMax(maxBoxHeight, scaledHeight);
              outHeight = mathMax(outHeight, scaledHeight - plotHeight);
              outWidth = mathMax(outWidth, scaledWidth - plotWidth);
              sum += area * mathPow(fontRatio, 2);
              fontArea += area * mathPow(fontRatio, 2) / (fontSize / maxFontSize);
            };

          if (singleNode) {
            data.forEach(function (d, i) {
              writeFunc(d, i);
              readFunc(d, i);
            });
          } else {
            data.forEach(writeFunc);
            data.forEach(readFunc);
          }

          if ((outWidth || outHeight) && sum < availablePlotArea) {
            var outWidthPercent = outWidth ? outWidth / plotWidth : 0,
              outHeightPercent = outHeight ? outHeight / plotHeight : 0;

            percent = mathMax(outWidthPercent, outHeightPercent);
            percent = 1 - mathMin(percent, pick(maxSizeFactor, 0.2));
          } else {
            var factor = mathMin(
            mathSQRT(availablePlotArea / sum),
            plotWidth / maxBoxWidth,
            plotHeight / maxBoxHeight,
            mathSQRT(availablePlotArea / fontArea));
            // ZC2859, FEATURES_BAR_13
            percent = factor * (config.boundBox ? 0.5 : 1);
            percent = mathMax(percent, pick(maxSizeFactor, 0.4));
          }

          var minFontSize = 3,
            uniqueFontSizes = objectValues(_fonts),
            r0 = pick(
            config.size.min,
            mathMax(uniqueFontSizes.length === 1 && uniqueFontSizes[0] === range[0] ? range[0] * percent : range[0], minFontSize)),

            r1 = pick(config.size.max, mathMax(range[range.length - 1] * percent, r0 + 2)),
            tempScalePoint = d3_scalePoint();

          tempScalePoint.domain(domain).range([r0, r1]);
          fontScale.range(domain.map(tempScalePoint));
        },
        updatPixelByColor = function updatPixelByColor(imageData, i, rgb) {
          if (rgb) {
            imageData[i] = rgb.r;
            imageData[i + 1] = rgb.g;
            imageData[i + 2] = rgb.b;
            imageData[i + 3] = mathMax(1, mathFloor(rgb.opacity * 255));
          }
        },
        operations = function operations() {
          imageDataX = imageDataY = canvasCount = imageTotalWidth = imageTotalHeight = currentRowHeight = 0;
          canvasMeta = [{ width: 1, height: 1 }];
          textImageData = [];
          drawnBound = [plotWidth / 2, plotHeight / 2, plotWidth / 2, plotHeight / 2];

          precalculate();
          createGrid();
          if (singleNode) {
            meta = data.map(function (d, i) {
              drawWordsInSvg(d, i);
              return getTextInfo(d, i);
            });
            canvasMeta.forEach(getCanvas);
            data.forEach(drawWordsInCanvas);
            canvasMeta.forEach(readImageData);
            drawnData = data.filter(putWord);
            atEnd();
          } else {
            data.forEach(function (d, i) {return drawWordsInSvg(d, i);});
            breathNInvoke(function () {
              meta = data.map(getTextInfo);
              breathNInvoke(function () {
                canvasMeta.forEach(getCanvas);
                data.forEach(drawWordsInCanvas);
                canvasMeta.forEach(readImageData);

                breathNInvoke(function () {
                  drawnData = data.filter(putWord);
                  if (drawnData.length < data.length && adjust) {
                    breathNInvoke(drawAgain);
                  }
                  breathNInvoke(atEnd);
                });
              });
            });
          }
        },
        findScaleFactor = function findScaleFactor() {
          if (config.boundBox) {
            var scaleFactor = mathMin(drawnBound[0] - 0, drawnBound[1] - 0, plotWidth - drawnBound[2], plotHeight - drawnBound[3]);
            return mathMin(plotWidth, plotHeight) / (mathMin(plotWidth, plotHeight) - scaleFactor);
          }

          var scale = d3_scaleLinear(),
            l = scale.domain([plotWidth / 2, drawnBound[0]])(0),
            t = scale.domain([plotHeight / 2, drawnBound[1]])(0),
            r = scale.domain([plotWidth / 2, drawnBound[2]])(plotWidth),
            b = scale.domain([plotHeight / 2, drawnBound[3]])(plotHeight);
          return mathMin(l, t, r, b);
        },
        drawAgain = function drawAgain() {
          // ZC3032
          outside[1] = mathMax(0, (plotHeight - drawnBound[3]) / g);

          if (!outside[1]) {
            return;
          }
          drawnBound = [plotWidth / 2, plotHeight / 2, plotWidth / 2, plotHeight / 2];
          pointsAtRadius = [];
          grid = [];
          createGrid();
          drawnData = data.filter(putWord);
        },
        atEnd = function atEnd() {
          var scaleFactor = maskImageData || defined(config.size.min) && defined(config.size.max) ? 1 : findScaleFactor();
          config.onload({ mask: maskCanvas, scaleFactor: scaleFactor });
          dummyText.remove();
          maskImageData = NULL$1;
        },
        draw = function draw() {
          data.sort(sortByFontSizeAccesor);
          if (adjust && data.length && _content(data[0]).type !== 'html') {
            data.sort(function (a, b) {return _fontSize(a) === _fontSize(b) ? sortByContentAccesor(a, b) : 1;});
          }
          breathNInvoke(operations);
        },
        drawOnMask = function drawOnMask() {
          var imageData = maskContext.getImageData(0, 0, w, h),
            maskBackgroundColor = config.maskBackground,
            rgb = maskBackgroundColor && maskBackgroundColor !== 'inherit' && d3_rgb(maskBackgroundColor);
          maskImageData = imageData.data;
          areaOfMask = 0;

          for (var i = 0; i < maskImageData.length; i += 4) {
            if (maskImageData[i + 3]) {
              areaOfMask++;
              updatPixelByColor(maskImageData, i, rgb);
            }
          }

          if (rgb) {
            maskContext.putImageData(imageData, 0, 0);
          }

          draw();
        };

      // All set, start the drawing
      if (!mask) {
        draw();
      } else {
        var maskCanvas = createCanvas(),
          w = ngx * g,
          h = ngy * g;

        maskCanvas.width = w;
        maskCanvas.height = h;
        var maskContext = createContext(maskCanvas);

        var drawOnShape = function drawOnShape(_mask) {
          var size = mathMin(w, h),
            bound = _mask._name === 'rect' ? [w, h] : [size, size],
            path = _mask.apply(NULL$1, bound);

          maskContext.translate(w / 2, h / 2);
          maskContext.scale(w / bound[0], h / bound[1]);
          canvasUtils.drawPath(maskContext, path);

          maskContext.fillStyle = '#000';
          maskContext.fill();
          drawOnMask();
        };

        if (typeof mask === 'function') {
          drawOnShape(mask);
        } else {
          var img = new Image();
          img.crossOrigin = 'Anonymous'; // Uncaught DOMException: Failed to execute 'getImageData' on 'CanvasRenderingContext2D': The canvas has been tainted by cross-origin data.
          img.onload = function () {
            maskContext.drawImage(img, 0, 0, w, h);
            drawOnMask();
          };
          img.onerror = function () {
            maskCanvas = NULL$1;
            drawOnShape(getSVGsymbol());
          };

          img.src = mask;
        }
      }
    };

    Registry.setComponent('wordcloud.layout', WordCloud);

    //$Id$

    var wordcloudLayout = function wordcloudLayout(commonRendererProp, data) {
      var rp,
        chartObj,
        commonPlotOptions,
        processedData,
        dimension,
        sum,
        fontScale,
        datalabelOptions,
        GLT,
        _fontFamily3,
        _fontStyle3,
        _fontWeight3,
        yValues,
        hasBoundBox,
        globalRotation,
        globalRotationCount,
        seriesSpecificRotation,
        seriesSpecificRotationCount,
        _getSeriesIndex = wordCloudUtils.getSeriesIndex,
        getValue = function getValue(d) {
          var yaxiscolumnorder = DataProcessor.helpers.getParsedYAxisOrder(data[_getSeriesIndex(d)].yaxiscolumnorder);
          return chartObj.dataset.getY(d, yaxiscolumnorder);
        },
        paneid = "".concat(data[0].row, "_").concat(data[0].column),
        isScalable = true,
        fontData = [],
        processData = function processData() {
          data.forEach(function (series, seriesIndex) {
            var plotOptions = series.plotoptions;
            var gradientOptions =
              plotOptions && plotOptions.gradients ?
              mergeJSON$1(commonPlotOptions.gradients, plotOptions.gradients, true) :
              commonPlotOptions.gradients,
              activeData = [];
            isScalable = isScalable && !arrayIncludes(['linear', 'radial'], gradientOptions.type);

            if (!series.disabled) {
              series.data.forEach(function (subseries, subSeriesIndex) {
                subseries.forEach(function (d, itemIndex) {
                  d.seriesIndex = seriesIndex;
                  d.subSeriesIndex = subSeriesIndex;
                  d.itemIndex = itemIndex;
                  d.layout = NULL$1;
                  d.paneid = paneid;
                  d.level = "".concat(seriesIndex, "_").concat(subSeriesIndex, "_").concat(itemIndex); //Hack because of double click event return wrong seriesIndex, itemIndex

                  var yVal = getValue(d);

                  if (defined(commonPlotOptions.nullAs) || defined(yVal)) {
                    //Omit null|undefined values
                    sum += yVal;
                    yValues.push(yVal);
                    processedData.push(d);
                    activeData.push(d);
                  }
                });
              });
            }
            fontData.push({ data: [activeData] });
            // chartObj.dataObject.saveEncode('y', 0, seriesIndex, { data: [activeData] }); // For font-scale
          });
        },
        setTextProperties = function setTextProperties() {
          var percentFunc = function percentFunc(d, showAs) {
            return showAs === PERCENT_SHOWAS ? sum : fontScale.domain()[1];
          };

          data.forEach(function (series, seriesIndex) {
            var options = getMergedDatalabelOptions(commonPlotOptions, series.plotoptions, chartObj, seriesIndex, paneid);
            var font = applyDatalabelFonts(NULL$1, options, chartObj);

            _fontFamily3.push(font['font-family']);
            _fontStyle3.push(font['font-style']);
            _fontWeight3.push(font['font-weight']);

            datalabelOptions.push(options);
            GLT.push(dataLabelTextContent(chartObj, rp, options, DATALABELS_LABELTYPE, percentFunc, seriesIndex, undefined, paneid));
            hasBoundBox = hasBoundBox || isBoundBoxEnabled(options, chartObj);

            var rotation = series.plotoptions && series.plotoptions.rotation;
            if (defined(rotation)) {
              seriesSpecificRotation[seriesIndex] = !isArray$1(rotation) ? [rotation] : rotation;
              seriesSpecificRotationCount[seriesIndex] = 0;
            }
          });
        },
        getMask = function getMask() {
          var maskOptions = commonPlotOptions.mask,
            htmlEl = !$Browser.IE && !$Browser.PHANTOMJS && maskOptions.htmlEl,
            imageUrl = maskOptions.imageUrl,
            symbol = maskOptions.symbol,
            mask;

          if (htmlEl) {
            mask = "data:image/svg+xml;".concat($Browser.IE ? 'base64' : 'utf8', ",").concat(
            $Browser.IE ? btoa(unescape(encodeURIComponent(htmlEl))) : htmlEl);

          } else if (imageUrl) {
            mask = imageUrl; // "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Heart_font_awesome.svg/1024px-Heart_font_awesome.svg.png", //check with http, relative image
          } else if (symbol) {
            mask = getSVGsymbol(symbol);
            mask._name = symbol;
          }
          return mask;
        },
        drawLayout = function drawLayout(render) {
          var self = this,
            maskOptions = commonPlotOptions.mask,
            dataLabels = commonPlotOptions.datalabels;

          var options = {
            width: dimension.width,
            height: dimension.height,
            rotation: function rotation(d) {
              var seriesIndex = _getSeriesIndex(d),
                degree;

              if (seriesSpecificRotation[seriesIndex]) {
                degree =
                seriesSpecificRotation[seriesIndex][
                seriesSpecificRotationCount[seriesIndex]++ % seriesSpecificRotation[seriesIndex].length];

              } else {
                degree = globalRotation[globalRotationCount++ % globalRotation.length];
              }

              return geometryUtils.degreeToRadian(degree);
            },
            fontSize: function fontSize(d) {
              var value = getValue(d);
              if (defined(commonPlotOptions.nullAs) && isUndefined(value)) {
                var nullAsOptions = {
                  config: commonPlotOptions,
                  scale: fontScale,
                  columnKey: chartObj.dataset.getColumnIdx('y', 0)
                };
                value = convertNull(value, nullAsOptions);
              }

              return defined(value) ? fontScale(value) : 0;
            },
            fontFamily: function fontFamily(d) {
              return _fontFamily3[_getSeriesIndex(d)];
            },
            fontStyle: function fontStyle(d) {
              return _fontStyle3[_getSeriesIndex(d)] || 'normal';
            },
            fontWeight: function fontWeight(d) {
              return _fontWeight3[_getSeriesIndex(d)] || 'normal';
            },
            content: function content(d) {
              var yVal = getValue(d),
                format = GLT[_getSeriesIndex(d)];

              return {
                type: format.contentType,
                value: format(d),
                format: format
              };
            },
            padding: function padding(d) {
              var currentDatalabelOptions = datalabelOptions[_getSeriesIndex(d)],
                padding = validateNullVal(commonPlotOptions.padding, 2),
                boundBoxPadding = 0;

              if (isBoundBoxEnabled(currentDatalabelOptions, chartObj)) {
                boundBoxPadding =
                getBoundBoxPadding(currentDatalabelOptions, chartObj) * 2 +
                getBoundBoxStrokeWidth(currentDatalabelOptions, chartObj);
              }

              return padding + boundBoxPadding;
            },
            strokeWidth: function strokeWidth(d) {
              var plotOptions = data[_getSeriesIndex(d)].plotoptions,
                defaultStrokeWidth =
                plotOptions && defined(plotOptions.strokeWidth) ? plotOptions.strokeWidth : commonPlotOptions.strokeWidth;
              return validateNullVal(defaultStrokeWidth, 1);
            },
            onload: function onload(args) {
              chartObj.hideLoading(chartObj.container);
              chartObj.svg.selectAll('g.zc-wordcloud-dummy').remove();
              self.output = args;
              render();
            },
            origin: NULL$1, //have to work
            mask: getMask(),
            maskBackground: maskOptions.background.color,
            invert: maskOptions.invert,
            textOverflow: dataLabels.textOverflow || 'ellipsis',
            textOverlap: dataLabels.textOverlap || 'adjust', //hidden | adjust
            maxWidth: dataLabels.maxWidth,
            fontScale: fontScale,
            container:
            isObjectPropDefined(dataLabels, 'preCalculation.singleNode', true) === false ?
            createElement('g', '.zc-wordcloud-dummy', [1], chartObj.svg).style('visibility', 'hidden') :
            chartObj.getPatternSvg(),
            size:
            commonPlotOptions.size === 'auto' ?
            {} :
            {
              min: commonPlotOptions.minSize,
              max: commonPlotOptions.maxSize
            },
            boundBox: hasBoundBox,
            maxSizeFactor: commonPlotOptions.maxSizeFactor,
            preCalculation: dataLabels.preCalculation
          };

          //Todo: Safari breathing time
          // setTimeout(function() {
          WordCloud(processedData, options);
          // }, 0); //Safari: for breathing time. without this timeout loader will not be shown. (e.g) wordcloud-10.json
        },
        initVariables = function initVariables() {
          rp = commonRendererProp.params;
          chartObj = rp.chartObj;
          commonPlotOptions = rp.commonPlotOptions;
          dimension = rendererBoundUtils.getAvailableBound(rp.bound, commonPlotOptions);

          sum = 0;
          processedData = [];

          datalabelOptions = [];
          GLT = [];
          _fontFamily3 = [];
          _fontStyle3 = [];
          _fontWeight3 = [];
          yValues = [];

          seriesSpecificRotation = [];
          seriesSpecificRotationCount = [];

          globalRotation = commonPlotOptions.rotation || [0];
          globalRotation = !isArray$1(globalRotation) ? [globalRotation] : globalRotation;
          globalRotationCount = 0;
        },
        createFontScale = function createFontScale() {
          var config = _objectSpread(_objectSpread({}, commonPlotOptions), {}, { _data: fontData }),
            ranges = config.ranges,stops = config.stops,minRange = config.minRange,maxRange = config.maxRange,base = config.base,nullAs = config.nullAs,
            parser = fontScaleParser('y', 0, chartObj, config),
            scaleComponent = new Scale('y', 0, _objectSpread({ ranges: ranges, stops: stops, minRange: minRange, maxRange: maxRange, base: base, nullAs: nullAs }, parser), chartObj); // TODO: check with config
          return scaleComponent.getScale();
        },
        init = function init() {
          initVariables();
          chartObj.showLoading(chartObj.container);
          processData();
          fontScale = createFontScale();
          setTextProperties();
        };

      init();

      return {
        rp: rp,
        processedData: processedData,
        dimension: dimension,
        sum: sum,
        fontScale: fontScale,
        datalabelOptions: datalabelOptions,
        fontFamily: _fontFamily3,
        fontStyle: _fontStyle3,
        fontWeight: _fontWeight3,
        drawLayout: drawLayout,
        hasBoundBox: hasBoundBox,
        data: data,
        isScalable: $Browser.PHANTOMJS && chartObj.plot.renderer.mode !== 'canvas' ? isScalable : true
      };
    };

    //$Id$

    var _wordcloudBoundBoxCanvas = function _wordcloudBoundBoxCanvas(context, d, layoutObj, commonRendererProp) {
      var rp = commonRendererProp.params,
        chartObj = rp.chartObj,
        commonPlotOptions = rp.commonPlotOptions,
        layout = d.layout,
        seriesIndex = wordCloudUtils.getSeriesIndex(d),
        datalabelOptions = layoutObj.datalabelOptions[seriesIndex],
        boundboxOptions = getMergedBoundBoxOptions(datalabelOptions, chartObj),
        strokeWidth = defined(boundboxOptions.strokeWidth) ? +boundboxOptions.strokeWidth : 1,
        strokeDashArray = getDashArray(boundboxOptions.dashStyle, strokeWidth),
        strokeLineCap = getLineCap(boundboxOptions.lineCap, boundboxOptions.dashStyle),
        b = wordCloudUtils.getBoundBoxSize(layout, datalabelOptions, commonPlotOptions, chartObj, layoutObj);

      if (!isBoundBoxEnabled(datalabelOptions, chartObj)) {
        return;
      }

      context.beginPath();
      context.lineWidth = strokeWidth;
      if (isArray$1(strokeDashArray) && strokeDashArray.length && defined(context.setLineDash)) {
        context.setLineDash(strokeDashArray);
        context.lineCap = strokeLineCap;
      }
      context.strokeStyle = rgba_canvas(boundboxOptions.strokeColor || TRANSPARENT, boundboxOptions.strokeOpacity);
      context.fillStyle = rgba_canvas(boundboxOptions.fillColor || '#000', boundboxOptions.fillOpacity);
      canvasUtils.roundedRect(context, b.x, b.y, b.width, b.height, b.r);
      context.stroke();
      context.fill();
      context.closePath();
    };

    //$Id$

    var drawMaskBackgroundInCanvas = function drawMaskBackgroundInCanvas(context, commonPlotOptions, layoutObj, update) {
      var backgroundOptions = commonPlotOptions.mask.background,
        mask = layoutObj.output.mask;

      if (update && mask && backgroundOptions.color) {
        context.globalAlpha = validateNullVal(backgroundOptions.opacity, 1);
        context.drawImage(mask, 0, 0);
        context.globalAlpha = 1;
      }
    };

    /*
     Doubts:
     1) Whether sharedseries will be applicable?
     Pending:
     */
    function WordcloudHighlighter(chart, renderer) {
      this.chart = chart;
      this.renderer = renderer;
    }

    inherit(WordcloudHighlighter, BarHighlighter);
    var proto$n = WordcloudHighlighter.prototype;

    proto$n._defaultH = function () {
      return [
      {
        shape: TEXT_ELEMENT,
        path: this.path,
        data: this.data,
        context: this.renderingContext,
        translate: this.translateContext,
        styles: patternFillEffect
      }];

    };

    proto$n.renderingContext = function () {
      return HIGHLIGHT_CONTEXT.get('nonaxis').call(this, this.chart);
    };

    proto$n.translateContext = function (point) {
      var chart = this.chart,
        renderer = getRenderer$1(point, chart, this.renderer),
        bound = renderer.commonRendererProp().bound(),
        layout = renderer.layout,
        dimension = layout.dimension,
        transformation = wordCloudUtils.getContainerTransformation(layout, dimension),
        translate = transformation.translate,
        plotArea = chart.plotarea;

      return [plotArea.left + translate[0] + bound.x, plotArea.top + translate[1] + bound.y, transformation.scale];
    };

    proto$n.data = function (point) {
      var chart = this.chart,
        renderer = getRenderer$1(point, chart, this.renderer),
        layout = renderer.layout,
        dimension = layout.dimension,
        bound = renderer.commonRendererProp().bound();

      return function () {
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }

        var cache = chart.cache.data[point._key];
        cache._point = point;
        var tileBound = point.layout;

        if (!tileBound) {
          cache._visible = point._visible = false;
          return point;
        }

        var transformation = wordCloudUtils.getContainerTransformation(layout, dimension).translate;
        var scaleFactor = layout.output.scaleFactor;
        var _point$layout = point.layout,x = _point$layout.x,y = _point$layout.y,width = _point$layout.width,height = _point$layout.height,rotation = _point$layout.rotation;
        x *= scaleFactor;
        y *= scaleFactor;
        width *= scaleFactor;
        height *= scaleFactor;

        cache._x = point._x = cache._x || x + transformation[0] + bound.x;
        cache._y = point._y = cache._y || y + transformation[1] + bound.y;
        cache._width = point._width = cache._width || width;
        cache._height = point._height = cache._height || height;
        cache._centric = point._centric = cache._centric || true;
        cache._rotation = point._rotation = cache._rotation || rotation;
        cache._size = point._size =
        2 * euclideanDistance({ x: point._x, y: point._y }, { x: point._x - width / 2, y: point._y - height / 2 });
        cache._uid = point._uid = chart.dataset.getX(point);
        cache._visible = point._visible = isPointVisible(chart, point);

        return point;
      };
    };

    proto$n.options = function (point) {
      var seriesIndex = point.seriesIndex,itemIndex = point.itemIndex,paneid = point.paneid,
        chart = this.chart,
        renderer = getRenderer$1(point, chart, this.renderer),
        rp = renderer.commonRendererProp().params,
        multiColoring = isMultiColoring(rp.commonPlotOptions, chart),
        layout = renderer.layout,
        dimension = layout.dimension,

        scaleFactor = layout.output.scaleFactor,
        fontScaleFactor = layout.isScalable ? 1 : scaleFactor,
        rawColor = getRawColor(chart, multiColoring ? itemIndex : seriesIndex, point, seriesIndex, paneid);

      var textInfo = point.layout,
        isMultiLine = wordCloudUtils.isMultiLine(textInfo),
        highlightX = textInfo.x * fontScaleFactor,
        highlightY = textInfo.y * fontScaleFactor,
        w = dimension.width,
        h = dimension.height,
        _fillColor,
        _strokeColor;

      if (isFacet(chart)) {
        _fillColor = getFillColor(chart, seriesIndex, paneid, { x1: 0, x2: w, y1: 0, y2: h, r: mathMin(w, h) }, NULL$1, 'svg');
        _strokeColor = getStrokeColor(chart, seriesIndex, paneid);
      } else {
        _fillColor = getFillColor(chart, 0, null, { x1: 0, x2: w, y1: 0, y2: h, r: mathMin(w, h) }, NULL$1, 'svg');
        _strokeColor = getStrokeColor(chart, 0);
      }

      return {
        x: highlightX,
        y: highlightY - (isMultiLine ? textInfo.height * fontScaleFactor / 2 : 0),
        dy: wordCloudUtils.getDy(textInfo),
        rotation: [radianToDegree(textInfo.rotation), highlightX, highlightY],
        fontSize: textInfo.size * fontScaleFactor,
        font: layout.datalabelOptions[seriesIndex],
        contentType: textInfo.nodeList.contentType,
        innerSVG: textInfo.nodeList.innerSVG,
        color: rawColor,
        fillColor: _fillColor(multiColoring ? itemIndex : seriesIndex, point),
        strokeColor: _strokeColor(
        multiColoring ? itemIndex : seriesIndex,
        point,
        rp.commonPlotOptions.strokeColor)

      };
    };

    proto$n.path = function (point, model) {
      var self = this,
        context = model.context.call(self),
        translate = model.translate.call(self, point),
        options = this.options(point),
        x = options.x,y = options.y,dy = options.dy,rotation = options.rotation,fontSize = options.fontSize,font = options.font,contentType = options.contentType,innerSVG = options.innerSVG,
        textInfo = point.layout,
        isMultiLine = wordCloudUtils.isMultiLine(textInfo),
        chart = this.chart;

      context.style('display', '').style('opacity', null);

      var groupContext = createElement(
      'g', ".wordcloud-highlight".concat(
      point.paneid).concat(point.seriesIndex).concat(point.subSeriesIndex),
      [point],
      context);

      groupContext.attr('transform', "translate(".concat(translate[0], ",").concat(translate[1], ") scale(").concat(translate[2], ")"));
      var textContext = createElement(TEXT_ELEMENT, ".wordcloud-highlight", [point], groupContext);
      applyDatalabelFonts(textContext, font, chart);
      textContext[contentType](innerSVG);
      textContext.
      attrs({
        x: x,
        y: y,
        dy: "".concat(dy, "em"),
        transform: "rotate(".concat(rotation[0], " ").concat(rotation[1], " ").concat(rotation[2], ")"),
        'text-anchor': MIDDLE_ALIGN
      }).
      styles({
        'font-size': fontSize + PX,
        'paint-order': 'stroke',
        'stroke-linejoin': 'round'
      });

      if (isMultiLine) {
        translateTspan(textContext, textInfo.x);
      }

      return textContext;
    };

    function getRenderer$1(point, chart, renderer) {
      return point ? chart.renderer[getRendererIndex(point, chart)] : renderer;
    }

    //$Id$

    var annotation$9 = Registry.getComponent('annotation');
    canvas_plot_renderer.wordcloud = function () {
      var _getSeriesIndex = wordCloudUtils.getSeriesIndex,
        _getItemIndex = wordCloudUtils.getItemIndex,
        helpers = _canvasDatalabelUtils,
        commonRendererProp;

      function chart(context, seriesdata, effect, filterIndex, encode, _index) {
        var rp = commonRendererProp.params,
          chartObj = rp.chartObj,
          commonPlotOptions = rp.commonPlotOptions,
          notesArray = rp.notesArray,
          renderer = chartObj.renderer[rp.rendererIndex || 0],
          layoutUpate = chartObj.phase !== 'legendFilter-colorScale' && !effect,
          layoutObj = layoutUpate ? new wordcloudLayout(commonRendererProp, seriesdata) : renderer.layout,
          dimension = layoutObj.dimension,
          w = dimension.width,
          h = dimension.height,
          processedData = layoutObj.processedData,
          fillColor = [],
          strokeColor = [],
          hasColorScale = colorscale_helpers.isQuantileColorScale(chartObj),
          multiColoring = isMultiColoring(commonPlotOptions, chartObj),
          highlightStrokeWidth,
          highlightStrokeColor,
          highlightFillColor,
          highlightIndex,
          font = [],
          textShadow = [],
          paneid = isFacet(chartObj) && "".concat(seriesdata[0].row, "_").concat(seriesdata[0].column);

        if (effect) {
          highlightIndex = _index; //isObjectPropDefined(seriesdata, 'data[0][0].seriesIndex', true); //ZC1440
          highlightStrokeWidth = effect['stroke-width'];
          highlightStrokeColor = effect.stroke;
          highlightFillColor = effect.fill;
        }

        chart.total = layoutObj.sum;
        chart.extentY = layoutObj.fontScale.domain();

        layoutObj.data.forEach(function (d, i) {
          fillColor[i] = chart.fillColorFunc = getFillColor(chartObj, i, paneid, {
            x1: 0,
            x2: w,
            y1: 0,
            y2: h,
            r: mathMin(w, h)
          });
          strokeColor[i] = getStrokeColor(chartObj, i, paneid);
        });

        if (layoutUpate) {
          layoutObj.drawLayout(draw);
          renderer.layout = layoutObj;
        } else {
          draw();
        }
        chart.layout = layoutObj;
        layoutObj.paneid = isFacet(chartObj) ? "".concat(seriesdata[0].row, "_").concat(seriesdata[0].column) : 0;

        function draw() {
          var transformation = wordCloudUtils.getContainerTransformation(layoutObj, dimension);
          var scaleFactor = layoutObj.output.scaleFactor,
            fontScaleFactor = layoutObj.isScalable ? 1 : scaleFactor;

          context.save();
          context.translate(transformation.translate[0], transformation.translate[1]);
          context.scale(transformation.scale, transformation.scale);
          drawMaskBackgroundInCanvas(context, commonPlotOptions, layoutObj, layoutUpate);

          if (defined(highlightIndex)) {
            processedData = processedData.filter(function (d) {
              return _getSeriesIndex(d) === highlightIndex;
            });

            if (hasColorScale) {
              processedData = legend_helpers.filterSelectionByColor(processedData, true, filterIndex, chartObj);
            }
          }

          processedData.forEach(function (d, i) {
            var layout = d.layout;
            if (!layout) {
              return;
            }

            var text = layout.text,
              x = layout.x * fontScaleFactor,
              y = layout.y * fontScaleFactor,
              dy = wordCloudUtils.getDy(layout),
              seriesIndex = _getSeriesIndex(d),
              itemIndex = _getItemIndex(d),
              datalabelOptions = layoutObj.datalabelOptions[seriesIndex],
              plotOptions = (effect ? seriesdata : seriesdata[seriesIndex]).plotoptions || {},
              tX,
              tY;

            font[seriesIndex] = font[seriesIndex] || canvasUtils.getFontStyles(chartObj, datalabelOptions);
            textShadow[seriesIndex] = textShadow[seriesIndex] || helpers.parseTextShadow(datalabelOptions.textShadow);
            var strokeWidth = pick(highlightStrokeWidth, plotOptions.strokeWidth, commonPlotOptions.strokeWidth, 1),
              stroke = pick(
              highlightStrokeColor,
              plotOptions.strokeColor !== UNDEFINED ? plotOptions.strokeColor : commonPlotOptions.strokeColor),

              strokeOpacity = pick(plotOptions.strokeOpacity, commonPlotOptions.strokeOpacity),
              fillOpacity = pick(plotOptions.fillOpacity, commonPlotOptions.fillOpacity),
              gradientOptions = fillColor[seriesIndex].gradientOptions;

            var drawText = function drawText(context, fillStyle) {
              font[seriesIndex]['font-size'] = layout.size * fontScaleFactor + PX;
              context.save();

              if (layout.rotation) {
                context.translate(x, y);
                context.rotate(layout.rotation);
                context.translate(-x, -y);
              }

              if (!effect && wordCloudUtils.hasBoundBox(d)) {
                _wordcloudBoundBoxCanvas(context, d, layoutObj, commonRendererProp);
              }

              helpers.addTextShadow(context, textShadow[seriesIndex]);
              context.font = getUserFontValue(font[seriesIndex]);
              context.textAlign = CENTER_ALIGN;

              if (layout.nodeList.contentType === 'html') {
                layout.nodeList.forEach(function (a) {
                  var userStyle = a.style,
                    content = a.text,
                    userFont,
                    fSize,
                    userFillStyle;

                  if (userStyle.length) {
                    userFont = getUserFontValue(font[seriesIndex], userStyle);
                    fSize = parseFloat(userStyle['font-size']);
                    userFillStyle = userStyle.fill;
                  }

                  tX = x + (a.dx || 0);
                  tY =
                  y +
                  (a.dy || 0) * layout.size * fontScaleFactor +
                  layout.size * fontScaleFactor * dy - (
                  wordCloudUtils.isMultiLine(layout) ? layout.height * fontScaleFactor / 2 : 0);

                  context.font = userFont || getUserFontValue(font[seriesIndex]);
                  context.strokeStyle = strokeColor[seriesIndex](
                  multiColoring ? itemIndex : seriesIndex,
                  d,
                  stroke,
                  NULL$1,
                  commonPlotOptions.strokeOpacity);

                  context.lineWidth = strokeWidth;
                  context.strokeText(content, tX, tY);

                  context.fillStyle = userFillStyle || fillStyle;
                  context.fillText(content, tX, tY);
                });
              } else {
                var content = layout.nodeList.innerSVG;
                tX = x;
                tY = y + layout.size * fontScaleFactor * dy;

                context.strokeStyle = strokeColor[seriesIndex](
                multiColoring ? itemIndex : seriesIndex,
                d,
                stroke,
                NULL$1,
                strokeOpacity);

                context.lineWidth = strokeWidth;
                context.lineJoin = 'round';
                context.strokeText(content, tX, tY);

                context.fillStyle = fillStyle;
                context.fillText(content, tX, tY);
              }

              context.restore();
            };

            var customGradientDimension = NULL$1;
            if (gradientOptions.type === 'linear' && gradientOptions.options[gradientOptions.type].gradientUnits !== 'userSpaceOnUse') {
              customGradientDimension = {
                x1: x - layout.width * fontScaleFactor / 2,
                x2: x + layout.width * fontScaleFactor / 2,
                y1: y - layout.height * fontScaleFactor / 2,
                y2: y + layout.height * fontScaleFactor / 2
              };
            }

            if (chartObj.imagePallete && isWithinColorRange(chartObj.dataset.getClr(d), chartObj)) {
              effects.canvas_patterns.imageFill(
              {
                x: x,
                y: y,
                context: context,
                name: getRawColor(chartObj, multiColoring ? itemIndex : seriesIndex, d, seriesIndex, paneid)
              },
              drawText);

            } else {
              var fillStyle =
              highlightFillColor ||
              fillColor[seriesIndex](
              multiColoring ? itemIndex : seriesIndex,
              d,
              NULL$1,
              NULL$1,
              fillOpacity,
              customGradientDimension);

              drawText(context, fillStyle);
            }
          });
          context.restore();
          //Annotation preprocessing

          if (!annotation$9._empty && !effect) {
            chartObj.seriesdata.forEach(function (series, i) {
              notesArray = annotation$9.preprocessAnnotations(
              chartObj.seriesdata,
              i,
              function (dt, k, j) {
                var layout = dt.layout,
                  x = transformation.translate[0] + (layout.x - layout.width / 2) * scaleFactor,
                  y = transformation.translate[1] + (layout.y - layout.height * wordCloudUtils.getDy(layout)) * scaleFactor;

                return [x, y];
              },
              notesArray,
              chartObj,
              rp);

            });
          }

          chart.chartRendered = true;
        }
        return chart;
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };
      chart.getHighlighter = function (chartObj, index) {
        return chart.highlighter = new WordcloudHighlighter(chartObj, chart);
      };

      return chart;
    };

    defaultTheme.wordcloud = function () {
      return {
        base: 0,
        strokeColor: 'transparent',
        size: 'auto',
        animation: {
          type: 'fadeOneByOne'
        },
        datalabels: {
          showAs: 'x' //x,y,percent
        },
        gradients: {
          options: {
            linear: {
              x2: 100,
              y2: 100,
              colorGamma: [0, 1.5]
            },
            radial: {
              x: 50,
              y: 50,
              radius: 100,
              colorGamma: [1, 0]
            }
          }
        },
        mask: {
          background: {}
        }
      };
    };

    var _wordcloudBoundBoxSvg = function _wordcloudBoundBoxSvg(element, d, layoutObj, commonRendererProp) {
      var rp = commonRendererProp.params,
        chartObj = rp.chartObj,
        commonPlotOptions = rp.commonPlotOptions,
        layout = d.layout,
        seriesIndex = wordCloudUtils.getSeriesIndex(d),
        datalabelOptions = layoutObj.datalabelOptions[seriesIndex],
        boundboxOptions = getMergedBoundBoxOptions(datalabelOptions, chartObj),
        strokeWidth = defined(boundboxOptions.strokeWidth) ? +boundboxOptions.strokeWidth : 1,
        strokeDashArray = getDashArray(boundboxOptions.dashStyle, strokeWidth),
        strokeLineCap = getLineCap(boundboxOptions.lineCap, boundboxOptions.dashStyle),
        b = wordCloudUtils.getBoundBoxSize(layout, datalabelOptions, commonPlotOptions, chartObj, layoutObj),
        scaleFactor = layoutObj.output.scaleFactor,
        fontScaleFactor = layoutObj.isScalable ? 1 : scaleFactor;

      element.
      attrs({
        transform: "rotate(".concat(radianToDegree(layout.rotation), " ").concat(layout.x * fontScaleFactor, " ").concat(layout.y * fontScaleFactor, ")"),
        d: getBoundBoxPathDescription(b.x, b.y, b.width, b.height, b.r, 0, NULL$1, {})
      }).
      styles({
        visibility: isBoundBoxEnabled(datalabelOptions, chartObj) ? NULL$1 : 'hidden',
        fill: boundboxOptions.fillColor, //take series color
        'fill-opacity': boundboxOptions.fillOpacity,
        stroke: boundboxOptions.strokeColor,
        'stroke-opacity': boundboxOptions.strokeOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': strokeDashArray,
        'stroke-linecap': strokeLineCap
      });
    };

    //$Id$

    var drawMaskBackgroundInSvg = function drawMaskBackgroundInSvg(element, commonPlotOptions, layoutObj) {
      var backgroundOptions = commonPlotOptions.mask.background,
        mask = layoutObj.output.mask,
        dimension = layoutObj.dimension,
        maskBackground = createElement('image', '.mask-background', mask && backgroundOptions.color ? [1] : [], element, ':first-child');

      if (!mask) {
        return;
      }

      maskBackground.
      attrs({
        width: dimension.width,
        height: dimension.height,
        'xlink:href': mask.toDataURL()
      }).
      style('opacity', backgroundOptions.opacity);
    };

    //$Id$

    var annotation$a = Registry.getComponent('annotation');
    /**
     *
     * @returns {chart} wordcloud renderer.
     */
    // Neg value
    // bound box
    svg_plot_renderer.wordcloud = function () {
      var isredraw = false,
        commonRendererProp,
        layoutObj,
        _getSeriesIndex = wordCloudUtils.getSeriesIndex,
        _getItemIndex = wordCloudUtils.getItemIndex,
        filterAccessor = function filterAccessor(d) {
          d3_select(this).style('opacity', d.layout ? NULL$1 : 0); //Set opacity:0 to the words that are not visible to improve redraw
          return d.layout;
        };

      function chart(selection) {
        selection.each(function (data) {
          var rp = commonRendererProp.params,
            chartObj = rp.chartObj,
            commonPlotOptions = rp.commonPlotOptions,
            notesArray = rp.notesArray,
            scaleFactor,
            layoutUpate = chartObj.phase !== 'legendFilter-colorScale',
            //Animation variables
            animationOptions = getAnimationConf(commonPlotOptions, NULL$1, chartObj, WORDCLOUD_CHARTNAME),
            isAnimationEnable = animationOptions.enabled,
            animationType = animationOptions.type,
            easingType = isredraw ? d3_ease_linear : animationOptions.easingType,
            transitionDuration = isredraw ? isAnimationEnable ? 200 : 0 : animationOptions.duration,
            dataCount = chartObj.dataObject.totalnoofdatas,
            duration = isredraw ?
            transitionDuration :
            animationType === FADEONEBYONE_ANIMATION || animationType === FADERANDOM_ANIMATION ?
            transitionDuration / dataCount :
            transitionDuration,
            delay = isredraw ?
            0 :
            animationType === FADEONEBYONE_ANIMATION ?
            function (d, i) {
              return i * (transitionDuration / dataCount);
            } :
            animationType === FADERANDOM_ANIMATION ?
            function () {
              return mathRandom() * dataCount * (transitionDuration / dataCount);
            } :
            0,
            initialOpacity =
            animationType === FADEALL_ANIMATION ||
            animationType === FADERANDOM_ANIMATION ||
            animationType === FADEONEBYONE_ANIMATION ?
            0 :
            NULL$1,
            container = appendEle(d3_select(this), 'g', [data], '.', 'class', 'wordcloudgroup'),
            paneid = isFacet(chartObj) && "".concat(data[0].row, "_").concat(data[0].column);

          chart.layout = layoutObj = layoutUpate ? new wordcloudLayout(commonRendererProp, data) : layoutObj; //TODO: on legend brushing need not to create new layout
          var dimension = layoutObj.dimension,
            w = dimension.width,
            h = dimension.height,
            fillColor = [],
            strokeColor = [],
            multiColoring = isMultiColoring(commonPlotOptions, chartObj);

          data.forEach(function (d, i) {
            fillColor[i] = chart.fillColorFunc = getFillColor(chartObj, i, paneid, { x1: 0, x2: w, y1: 0, y2: h, r: mathMin(w, h) });
            strokeColor[i] = getStrokeColor(chartObj, i, paneid);
          });

          chart.total = layoutObj.sum;
          chart.extentY = layoutObj.fontScale.domain(); //percent, maxpercent only. No splitpercent

          if (layoutUpate) {
            layoutObj.drawLayout(draw);
          } else {
            draw();
          }

          function draw() {
            drawMaskBackgroundInSvg(container, commonPlotOptions, layoutObj);
            scaleFactor = layoutObj.output.scaleFactor;
            var transformation = wordCloudUtils.getContainerTransformation(layoutObj, dimension),
              fontScaleFactor = layoutObj.isScalable ? 1 : scaleFactor;

            data.forEach(function (d, i) {
              var plotOptions = chartObj.seriesdata[i].plotoptions;
              var gradientOptions =
              plotOptions && plotOptions.gradients ?
              mergeJSON$1(commonPlotOptions.gradients, plotOptions.gradients, true) :
              commonPlotOptions.gradients;

              fillColor[i] = chart.fillColorFunc = getFillColor(chartObj, i, paneid, {
                x1: 0,
                x2: w,
                y1: 0,
                y2: h,
                r: mathMin(w, h),
                transform:
                !layoutObj.isScalable &&
                gradientOptions.type === 'radial' &&
                gradientOptions.options.radial.gradientUnits !== 'objectBoundingBox' ? "translate(".concat(
                -transformation.translate[0], ", ").concat(-transformation.translate[1], ")") :
                null
              });
              strokeColor[i] = getStrokeColor(chartObj, i);
            });

            container.attrs({
              transform: "translate(".concat(transformation.translate, ") scale(").concat(transformation.scale, ")"),
              'text-anchor': MIDDLE_ALIGN
            });

            var boundBoxGroup = appendEle(container, 'g', [1], '.', 'class', 'boundBoxes'),
              textGroup = appendEle(container, 'g', [1], '.', 'class', 'words');

            var boundBox = appendEle(boundBoxGroup, PATH_ELEMENT, layoutObj.hasBoundBox ? layoutObj.processedData : []);
            boundBox = boundBox.filter(filterAccessor);
            boundBox.each(function (d) {
              if (wordCloudUtils.hasBoundBox(d)) {
                _wordcloudBoundBoxSvg(d3_select(this), d, layoutObj, commonRendererProp);
              }
            });

            var text = appendEle(textGroup, TEXT_ELEMENT, layoutObj.processedData);
            text = text.filter(filterAccessor);
            applyStaticStyle(container, commonPlotOptions);

            text.each(function (d) {
              var ele = d3_select(this),
                seriesIndex = _getSeriesIndex(d),
                itemIndex = _getItemIndex(d),
                layout = d.layout,
                isMultiLine = wordCloudUtils.isMultiLine(layout),
                plotOptions = data[seriesIndex].plotoptions,
                plotLevelStrokeWidth = plotOptions && plotOptions.strokeColor,
                _stroke = strokeColor[seriesIndex](
                multiColoring ? itemIndex : seriesIndex,
                d,
                plotLevelStrokeWidth !== UNDEFINED ? plotLevelStrokeWidth : commonPlotOptions.strokeColor),

                datalabelOptions = layoutObj.datalabelOptions[seriesIndex];

              applyDatalabelFonts(ele, datalabelOptions, chartObj);
              ele[layout.nodeList.contentType](layout.nodeList.innerSVG);

              ele.styles({
                'font-size': layout.size * fontScaleFactor + PX,
                fill: fillColor[seriesIndex](multiColoring ? itemIndex : seriesIndex, d),
                stroke: _stroke,
                filter: NULL$1,
                'stroke-linejoin': 'round'
              }).attrs({
                x: layout.x * fontScaleFactor,
                y: layout.y * fontScaleFactor - (isMultiLine ? layout.height * fontScaleFactor / 2 : 0),
                dy: "".concat(wordCloudUtils.getDy(layout), "em"),
                transform: "rotate(".concat(radianToDegree(layout.rotation), " ").concat(layout.x * fontScaleFactor, " ").concat(layout.y * fontScaleFactor, ")"),
                id: "word_".concat(seriesIndex, "_").concat(d.subSeriesIndex, "_").concat(itemIndex),
                "class": "zc_wordcloud series_".concat(seriesIndex)
              });

              ele.styles(
              applyTextShadow4Firefox(
              _stroke,
              pick(plotOptions && plotOptions.strokeWidth, commonPlotOptions.strokeWidth),
              datalabelOptions.textShadow));



              if (isMultiLine) {
                translateTspan(ele, layout.x * fontScaleFactor);
              }

              if (plotOptions) {
                applyStaticStyle(ele, plotOptions);
              }
            });

            setPivotAttributes(text, chartObj);
            setOpacityForTickFilterElements(text, chartObj, 'wordcloud');

            //Animation
            if (!isredraw) {
              text.style('opacity', initialOpacity).each(function (d) {
                var layout = d.layout,
                  tX,
                  tY;

                if (animationType === SIZING_ANIMATION) {
                  tX = dimension.width / 2;
                  tY = dimension.height / 2;
                } else if (animationType === RANDOMOUT_ANIMATION) {
                  var usedWidth = w / scaleFactor,
                    usedHeight = h / scaleFactor;

                  tX =
                  mathRandom() * (usedWidth - layout.width * fontScaleFactor) -
                  dimension.x +
                  layout.width * fontScaleFactor / 2 +
                  (w - usedWidth) / 2;
                  tY =
                  mathRandom() * (usedHeight - layout.height * fontScaleFactor) -
                  dimension.y +
                  layout.height * fontScaleFactor / 2 +
                  (h - usedHeight) / 2;
                } else {
                  tX = layout.x * fontScaleFactor;
                  tY = layout.y * fontScaleFactor;
                }

                d3_select(this).attrs({
                  x: tX,
                  y: tY - (wordCloudUtils.isMultiLine(layout) ? layout.height * fontScaleFactor / 2 : 0),
                  transform: "rotate(".concat(radianToDegree(layout.rotation), " ").concat(tX, " ").concat(tY, ")")
                });
              });
            }

            text.transition().
            duration(duration).
            delay(delay).
            ease(easingType).
            style(
            'opacity',
            isFacet(chartObj) ?
            function () {
              return d3_select(this).attr('filtered-opacity') || 1;
            } :
            NULL$1).

            attrs({
              x: function x(d) {
                return d.layout.x * fontScaleFactor;
              },
              y: function y(d) {
                var layout = d.layout;
                return (
                  layout.y * fontScaleFactor - (
                  wordCloudUtils.isMultiLine(layout) ? layout.height * fontScaleFactor / 2 : 0));

              },
              transform: function transform(d) {
                var layout = d.layout;
                return "rotate(".concat(radianToDegree(layout.rotation), " ").concat(layout.x * fontScaleFactor, " ").concat(layout.y * fontScaleFactor, ")");
              }
            });

            chartObj.timerObj[chartObj.timerObj.length] = chart.renderedTimer = setTimeout(function () {
              layoutObj.paneid = isFacet(chartObj) ? "".concat(data[0].row, "_").concat(data[0].column) : 0;

              //Annotation preprocessing
              if (!annotation$a._empty) {
                data.forEach(function (series, i) {
                  notesArray = annotation$a.preprocessAnnotations(
                  data,
                  i,
                  function (dt, k, j) {
                    var layout = dt.layout,
                      x = transformation.translate[0] + (layout.x - layout.width / 2) * scaleFactor,
                      y =
                      transformation.translate[1] +
                      (layout.y - layout.height * wordCloudUtils.getDy(layout)) * scaleFactor;

                    return [x, y];
                  },
                  notesArray,
                  chartObj,
                  rp);

                });
              }

              chart.chartRendered = true;
              isredraw = true;
            }, transitionDuration + 1000 / 60);
          }
        });
        return chart;
      }

      chart.commonRendererProp = function (_) {
        if (!arguments.length) {
          return commonRendererProp;
        }
        commonRendererProp = _;
        return chart;
      };

      chart.getHighlighter = function (chartObj, index) {
        return chart.highlighter = new WordcloudHighlighter(chartObj, chart);
      };

      function applyStaticStyle(element, options) {
        element.styles({
          'paint-order': 'stroke',
          'fill-opacity': options.fillOpacity,
          'stroke-width': options.strokeWidth,
          'stroke-opacity': options.strokeOpacity
        });
      }

      return chart;
    };var

    SankeyLayout = /*#__PURE__*/function () {











      /**
       *
       * @param points
       * @param sourceAccessor
       * @param targetAccessor
       * @param weightAccessor
       * @param excludeItems
       */
      function SankeyLayout(points, sourceAccessor, targetAccessor, exitAccessor, weightAccessor) {var excludeItems = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : d3_map();_classCallCheck(this, SankeyLayout);
        var nodes = [],
          links = [],
          linkSet = d3_set(),
          nodeSet = d3_set(),
          allNodes = [],
          allLinks = [];

        points.forEach(function (point) {
          var source = sourceAccessor(point),
            target = targetAccessor(point),
            weight = weightAccessor(point),
            target1 = exitAccessor(point);

          if (SankeyLayout.isValidPoint(source, target, target1, weight)) {
            var sourceNode = { name: "".concat(source), nameOriginal: source, point: point, _type: 'node' },
              targetNode = { name: "".concat(target), nameOriginal: target, point: point, _type: 'node' },
              link = {
                _type: 'link',
                source: "".concat(source),
                target: "".concat(target),
                value: weight,
                exit: !target,
                point: point
              };

            if (!excludeItems.has(source) && !excludeItems.has(target)) {
              links.push(link);
              linkSet.add(source);
              linkSet.add(target);
              nodeSet.add(source);
              nodes.push(sourceNode);
              if (target) {
                nodeSet.add(target);
                nodes.push(targetNode);
              } else {
                link.exit = true;
              }
            } else if (!excludeItems.has(source)) {
              nodeSet.add(source);
              nodes.push(sourceNode);
            } else if (!excludeItems.has(target) && target) {
              nodes.push(targetNode);
              nodeSet.add(target);
            }

            // add to all node sets
            allLinks.push(_objectSpread({}, link));
            allNodes.push(_objectSpread({}, sourceNode));
            if (target) {
              allNodes.push(_objectSpread({}, targetNode));
            }
          }
        });

        // get and set the extent
        var extent = d3_extent(links, function (link) {return link.value;});

        // now find the unique nodes
        nodes = getUnique(nodes, function (d) {return d.name;});
        allNodes = getUnique(allNodes, function (d) {return d.name;});

        nodes.forEach(function (node) {
          // link less node
          if (!linkSet.has(node.name)) {
            // fixedValue a value is required when there is no link
            node.fixedValue = extent[0] || 0.0001;
          }
          node._type = 'node';
        });

        this.extent = extent;
        this.nodeLength = nodes.length;
        this.linkLength = links.length;

        this.graph = { nodes: nodes, links: links };
        this.completeGraph = { nodes: allNodes, links: allLinks };
      }

      /**
       *
       * @param node
       */_createClass(SankeyLayout, [{ key: "getConnectedLinks", value:
        function getConnectedLinks(node) {
          return [].concat(_toConsumableArray(node.sourceLinks), _toConsumableArray(node.targetLinks));
        }

        /**
         *
         * @param link
         * @return {*[]}
         */ }, { key: "getConnectedNodes", value:
        function getConnectedNodes(link) {
          return [link.source, link.target];
        }

        /**
         *
         * @param point
         * @param flatten
         * @return {(*)[]|{nodes: [*, *], links: [*]}}
         */ }, { key: "getAllConnectedPoints", value:
        function getAllConnectedPoints(point, flatten) {
          var layout = this,
            points;

          if (point._type === 'link') {
            if (flatten) {
              points = [].concat(_toConsumableArray(layout.getConnectedNodes(point)), [point]);
            } else {
              points = { nodes: layout.getConnectedNodes(point), links: [point] };
            }
          } else if (point._type === 'node') {
            var sourceLinkNodes = point.sourceLinks.map(function (link) {return link.target;}),
              targetLinkNodes = point.targetLinks.map(function (link) {return link.source;});

            var links = layout.getConnectedLinks(point),
              nodes = getDistinct([].concat(_toConsumableArray(targetLinkNodes), _toConsumableArray(sourceLinkNodes), [point]));

            if (flatten) {
              points = [].concat(_toConsumableArray(links), _toConsumableArray(nodes));
            } else {
              points = { nodes: nodes, links: links };
            }
          }
          return points;
        } }], [{ key: "isValidPoint", value: /**
         *
         * @param source
         * @param target
         * @param weight
         * @return {boolean}
         */function isValidPoint(source, target, target1, weight) {return defined(weight) && weight > 0 && defined(source) && defined(target1) && source !== target;} }]);return SankeyLayout;}(); /**
     *
     * @param array
     * @param accessor
     * @return {[]}
     */function getUnique(array, accessor) {var flags = {},output = [],
        l = array.length,
        i;
      for (i = 0; i < l; i++) {
        var _value2 = accessor(array[i]);
        if (flags[_value2]) {
          continue;
        }
        flags[_value2] = true;
        output.push(array[i]);
      }
      return output;
    }

    Registry.setComponent('sankeyLayout', SankeyLayout);

    defaultTheme.sankey = function () {
      return {
        datalabels: {
          showAs: 'x',
          strokeWidth: 1.5,
          strokeColor: 'contrast',
          fontWeight: 'bold',
          padding: 5
        },
        link: {
          curve: 'bezier',
          fillOpacity: 0.5,
          gradients: {
            show: false,
            options: {
              linear: {}
            }
          },
          exit: {
            enabled: false,
            color: 'red'
          },
          strokeWidth: 0
        },
        node: {
          width: 20,
          padding: 5,
          strokeWidth: 0
        },
        animation: {
          easingType: 'cubic',
          duration: 1000
        },
        hoveroptions: {
          fillOpacity: 1
        },
        showAsNegative: 'absolute'
      };
    };

    /**
     *
     * @return {labels}
     */
    labelRenderer.sankey = function () {
      var MARGIN = 5,
        renderer,
        args;

      function labels(selection, labelHandler) {
        selection.each(function () {
          var _args5 = args,_args6 = _slicedToArray(_args5, 4),currentdata = _args6[0],index = _args6[1],sankeyLayout = _args6[2],sankeySize = _args6[3];

          var _sankeySize = _slicedToArray(sankeySize, 2),chartWidth = _sankeySize[0],chartHeight = _sankeySize[1],
            paneid = labelHandler.paneid,
            rp = renderer.commonRendererProp().params,
            chartObj = rp.chartObj,
            systemconf = chartObj.systemConf,
            commonPlotOptions = rp.commonPlotOptions,
            dataset = rp.dataset,
            yaxiscolumnorder = rp.yaxiscolumnorder,
            labelArray = getLabelArray(rp, paneid),
            chartName = chartObj.chartTypes[0].name,
            dataLabels;

          var translation = '';

          currentdata = currentdata[index];
          var plotoptions = currentdata.plotoptions,
            boundBoxPaddingAlone = 0,
            boundBoxPadding = 0,
            hookWidth = 0,
            boundBoxRadius = 0,
            sankeyNodeOptions = commonPlotOptions.node,sankeyLinkOptions = commonPlotOptions.link;

          // dataLabels = getMergedDatalabelOptions(commonPlotOptions, plotoptions, chartObj, index);
          dataLabels = commonPlotOptions.node.datalabels;

          if (isBoundBoxEnabled(dataLabels, chartObj)) {
            var boundBoxOptions = getMergedBoundBoxOptions(dataLabels, chartObj);
            var hookOptions = getBoundBoxHookConf(boundBoxOptions.hook);
            boundBoxPaddingAlone = getBoundBoxPadding(dataLabels, chartObj);
            boundBoxPadding = boundBoxPaddingAlone + getBoundBoxStrokeWidth(dataLabels, chartObj) + hookOptions.height;
            hookWidth = hookOptions.width;
            boundBoxRadius = boundBoxOptions.radius;
          }

          var padding = dataLabels.padding || 0,
            type = dataLabels.type,
            handleOverlapping = systemconf.chart.plot.datalabels.handleOverlapping === true,
            txtHgt = getFontSizeByHierarchy(dataLabels, chartObj),
            GLT = dataLabelTextContent(chartObj, rp, dataLabels, DATALABELS_LABELTYPE, null, index, undefined, paneid),
            contentType = GLT.contentType || 'text',
            isHTMLContent = contentType === 'html',
            isMultiLine = isHTMLContent && GLT.multiLine,
            showlabel = isDatalabelEnabled(dataLabels, chartObj),
            relativeX = dataLabels.relativeX === true;

          if (!showlabel) {
            return;
          }

          showlabel = showlabel ? type : 'hidden';
          var PathGroupPosition = [0, 0];

          var temp_label = appendEle(chartObj.staticPaneSVG.select('.labelholder'), 'text', [1], '.', 'class', 'temp_label');
          applyDatalabelFonts(temp_label, dataLabels, chartObj, rp.color);
          temp_label.attr('transform', translation).style('opacity', 0);
          var queue = labelHandler.add;

          currentdata.data.forEach(function (d, i) {
            var dataUpdate = sankeyLayout.nodes,
              commonProperties = [];

            var alignedNodes = getAlignedNodes(sankeyLayout.nodes);

            dataUpdate.forEach(function (d, j) {
              var display = true,
                isLeft = true,
                heightToBeAdded = 0,
                bb;

              var nodeWidth = sankeyNodeOptions.width;

              var X,
                ANCHOR,
                Y = d.y0 + (d.y1 - d.y0) / 2,
                DY = isMultiLine ? '0.9em' : '0.3em';

              if (alignedNodes.center.includes(d)) {
                X = d.x0 + nodeWidth / 2;
              } else if (alignedNodes.end.includes(d)) {
                X = d.x0 + nodeWidth / 2;
              } else {
                X = d.x1 - nodeWidth / 2;
              }

              if (isMultiLine || alignedNodes.center.includes(d)) {
                ANCHOR = 'middle';
              } else if (alignedNodes.end.includes(d)) {
                ANCHOR = 'end';
              } else {
                ANCHOR = 'start';
              }

              var text = d.name; //GLT(dt);

              temp_label[contentType](text).attrs({
                x: X,
                y: Y,
                'text-anchor': ANCHOR,
                dy: DY
              });

              if (isMultiLine) {
                translateTspan(temp_label, X);
                var bb = bbox(temp_label.node());
                Y -= bb.height / 2;
                X += bb.width / 2 * -1;
                translateTspan(temp_label, X);
                temp_label.attr('y', Y);
              }

              if (handleOverlapping) {
                {
                  bb = bbox(temp_label.node());
                  heightToBeAdded = getSizeToBeAdded(bb.height, boundBoxPaddingAlone, boundBoxRadius, hookWidth);
                  var DX = -(0 + padding + boundBoxPadding);
                  if (isMultiLine) {
                    DX += bb.width / 2 * -1;
                  }

                  var obj = {
                    id: "lbl".concat(index, "_").concat(i, "_").concat(j),
                    x1: bb.x - boundBoxPadding,
                    x2: bb.x + bb.width + boundBoxPadding,
                    y1: bb.y - MARGIN - boundBoxPadding - heightToBeAdded / 2,
                    isLeft: isLeft,
                    y2: bb.y + bb.height + MARGIN + boundBoxPadding + heightToBeAdded / 2,
                    DX: DX - X,
                    overlap: 'hidden',
                    translateFunction: labelHandler.update
                  };
                  labelArray.push(obj);
                }
              } else {
                bb = bbox(temp_label.node());
                heightToBeAdded = getSizeToBeAdded(bb.height, boundBoxPaddingAlone, boundBoxRadius, hookWidth);
              }

              var coordinate = {
                X: X,
                Y: Y,
                ANCHOR: ANCHOR,
                DY: DY,
                text: text,
                display: display,
                ID: "lbl".concat(index, "_").concat(i, "_").concat(j),
                width: bb.width,
                height: bb.height + heightToBeAdded,
                hookPosition: RIGHT_ALIGN
              };

              if (isHTMLContent) {
                coordinate.isLeft = isLeft;
              }

              commonProperties.push(coordinate);
            });
            // add to drawing queue
            var q = queue(commonProperties, index, i);
            q.properties = {
              type: SANKEY_CHARTNAME,
              dataLabels: dataLabels,
              dataUpdate: dataUpdate,
              showlabel: showlabel,
              rp: rp,
              translation: translation,
              trans: PathGroupPosition,
              txtHgt: txtHgt,
              reverseColor: true,
              onOverlap: function onOverlap() {
              },
              contentType: contentType,
              isMultiLine: isMultiLine
            };

            labelArray.TOP = -PathGroupPosition[1], labelArray.BOTTOM = chartHeight + PathGroupPosition[1];
            labelArray.actualType = SANKEY_CHARTNAME;
          });
        });
      }

      function getAlignedNodes(nodes) {
        var grouped = groupBy(nodes, 'layer');
        var keys = Object.keys(grouped).
        map(parseFloat).
        sort(d3_ascending);

        var startKey = keys.shift();
        var endKey = keys.pop();
        var centerKey = keys;

        var centers = [];
        centerKey.forEach(function (key) {
          centers = [].concat(_toConsumableArray(centers), _toConsumableArray(grouped[key]));
        });

        return {
          start: grouped[startKey],
          center: centers,
          end: grouped[endKey] || []
        };
      }

      labels.renderer = function (_) {
        if (!arguments.length) {
          return renderer;
        }
        renderer = _;
        return labels;
      };
      labels.args = function (_) {
        if (!arguments.length) {
          return args;
        }
        args = _;
        return labels;
      };
      return labels;
    };

    var SankeyLayout$1 = Registry.getComponent('sankeyLayout');

    var _sankeyProcessor = DataProcessor.prototype.processSankeyData = function () {
      var self = this,
        processedSeries = self.processedseriesData,dataSet = self.dataset,
        xIndex = self.dataset.xidx,
        yIndex = self.dataset.yidx(0),
        zIndex = self.dataset.zidx,
        chartInstance = self.chartObj,
        cache = chartInstance.cache,
        updateLegendLayout = chartInstance.phase !== 'legendFilter',
        disabledItems = cache.disabledItems = d3_set(),
        sankeyData = cache.sankey = cache.sankey || {
          legend: [],
          legendItemsMap: d3_map()
        },
        legend = sankeyData.legend,legendItemsMap = sankeyData.legendItemsMap,
        layout;

      if (legend.length) {
        // create a map for faster access
        legend.forEach(function (item) {
          if (item.disabled) {
            disabledItems.add(item[xIndex]);
          }
        });
      }

      if (processedSeries != null && isArray$1(processedSeries)) {
        processedSeries.forEach(function (series, seriesIndex) {
          // first add the chart type
          var _DataProcessor$helper = DataProcessor.helpers.getChartType(null, null, seriesIndex, self.data),name = _DataProcessor$helper.name,type = _DataProcessor$helper.type,
            renderEmptyLink = getPropVal(self.data, "chart.plot.plotoptions.".concat(name, ".link.renderEmpty")),
            negativeAsAbsolute = getPropVal(self.data, "chart.plot.plotoptions.".concat(name, ".showAsNegative")) === 'absolute',
            sankeyLinkOptions = getPropVal(self.data, "chart.plot.plotoptions.".concat(name, ".link")),
            showExitLink = sankeyLinkOptions.exit.enabled;

          dataSet.seriesTypes.add(type);

          // convert the data to 3d if it is not
          if (isArray$1(series.data) && !DataProcessor.helpers.is3D(series.data)) {
            series.data = [series.data];
          }

          // currently for formatting, only x value is supported
          var format = function format(value, type) {
            var column = dataSet.getColumn(type, 0);
            return getFormattedValue(column[column.datatype], value, column.datatype, chartInstance);
          };

          series.data.forEach(function (subSeries, subSeriesIndex) {
            var sourceAccessor = function sourceAccessor(point) {return format(dataSet.getX(point, 0), 'x');},
              targetAccessor = function targetAccessor(point) {return format(dataSet.getY(point, 0), 'y');},
              exitAccessor = function exitAccessor(point) {
                if (showExitLink) {
                  return true;
                } else {
                  return format(dataSet.getY(point, 0), 'y');
                }
              },
              weightAccessor = function weightAccessor(point) {
                var z = dataSet.getZ(point);
                if (z < 0) {
                  return negativeAsAbsolute ? mathAbs(z) : 0;
                }
                return z;
              };

            layout = self.sankeyLayout = new SankeyLayout$1(
            subSeries,
            sourceAccessor,
            targetAccessor,
            exitAccessor,
            weightAccessor,
            disabledItems);


            subSeries.forEach(function (point, itemIndex) {
              if (
              SankeyLayout$1.isValidPoint(sourceAccessor(point), targetAccessor(point), exitAccessor(point), weightAccessor(point)))
              {
                // need in sankey renderer for mapping
                point._key = DataProcessor.helpers.generatePointKey(
                chartInstance.id,
                'pane0_0',
                seriesIndex,
                subSeriesIndex,
                itemIndex);

                point._type = 'link';
                if (!targetAccessor(point)) {
                  point.exit = true;
                }
              }
            });
          });
        });

        if (layout.nodeLength || layout.linkLength) {
          // create a layout calculate the weight of each node
          // we will create a seriesdata with this [xValue, yValue, zValue]
          // it will help with existing flow of legend and datalabel rendering
          var chartWidth, chartHeight;
          if (chartInstance.systemConf.chart.width) {
            chartWidth = invokeFunction(chartInstance.systemConf.chart.width, chartInstance);
          }
          if (chartInstance.systemConf.chart.height) {
            chartHeight = invokeFunction(chartInstance.systemConf.chart.height, chartInstance);
          }
          var dummyLayoutConstructor = getSankeyLayout({ node: { width: 1 }, link: {} }, [
            [0, 0],
            [chartWidth || chartInstance.canvasarea.width, chartHeight || chartInstance.canvasarea.height]]),

            dummyLayout = dummyLayoutConstructor(layout.graph),
            dummyLayoutForLegend = sankeyData.legendSankeyLayout = dummyLayoutConstructor(layout.completeGraph),
            layerCompare = function layerCompare(a, b) {return d3_ascending(a.layer, b.layer);};
          self.sankeyLayout.layout = dummyLayout;

          // sor the nodes based on layer so that the legend renders in order

          dummyLayout.nodes.sort(layerCompare);
          dummyLayoutForLegend.nodes.sort(layerCompare);

          normalizeNodes(dummyLayoutForLegend.nodes, dummyLayout.nodes);
        }

        return sankeyData;
      }

      function normalizeNodes(nodes, pointNodes) {
        var nodesMapped = d3_map(pointNodes, function (n) {return n.name;});

        if (updateLegendLayout) {
          legendItemsMap.clear();
          legend.length = 0;

          nodes.forEach(function (node, i) {
            var pointNode = nodesMapped.get(node.name),
              t0 = [];

            t0[xIndex] = t0[yIndex] = node.nameOriginal;
            t0[zIndex] = node.value;
            t0._type = 'node';
            t0.itemIndex = i;
            t0.seriesIndex = 0;
            t0.disabled = disabledItems.has(node.name);
            legend.push(t0);

            node.point = t0;
            node.index = i;

            if (pointNode) {
              pointNode.index = i;
              pointNode.point = t0;
            }

            legendItemsMap.set(node.name, { index: i, point: t0 });
          });
        } else {
          nodes.forEach(function (node) {
            var _legendItemsMap$get = legendItemsMap.get(node.name),point = _legendItemsMap$get.point,index = _legendItemsMap$get.index,
              pointNode = nodesMapped.get(node.name);

            node.index = index;
            node.point = point;

            if (pointNode) {
              pointNode.index = index;
              pointNode.point = point;
            }

            point.disabled = disabledItems.has(node.name);
          });
        }
      }
    };

    //

    function Markerhighlighter(chart, helpers) {
      this.chart = chart;
      this.helpers = helpers;
    }

    inherit(Markerhighlighter, ScatterHighlighter);

    var proto$o = Markerhighlighter.prototype;
    proto$o.options = function (optionInfo) {
      this.optionsInfo = optionInfo;
    };
    proto$o.data = function () {
      var chart = this.chart,
        helpers = this.helpers;
      return function (p) {
        var point = this;
        if (!chart.cache.data[point._key]) {
          chart.cache.data[point._key] = {};
        }
        var cache = chart.cache.data[point._key];
        cache._x = point._x = helpers.x(point);
        cache._y = point._y = helpers.y(point);
        cache._size = point._size = helpers.options.size;
        cache._visible = point._visible = true;
        return point;
      };
    };
    proto$o.getSegments = function (point) {
      var data = point._data(),
        symbol = this.helpers.highlightOptions.segment || this.helpers.options.shape,
        segment = getSegmentsForSymbol(symbol, data._size, data._x, data._y);
      return [segment];
    };
    proto$o.path = function (point, model) {
      point = point._data && point._data() || point;
      var _options = this.optionsInfo;
      var context = model.context.call(this),
        translate = model.translate.call(this),_point5 =
        point,seriesIndex = _point5.seriesIndex,paneid = _point5.paneid;
      _options.options.strokeWidth = 2;

      context.style('display', '');
      context.attr('transform', "translate(".concat(translate[0], ",").concat(translate[1], ")"));

      var arrowMark = MarkerParser({
          selection: '.outer',
          data: [point],
          config: _objectSpread({
            x: point._x,
            y: point._y },
          _options.options)

        }),
        _conversionLineMark = {
          mark: {
            mark: 'g',
            selector: ".highlight".concat(point.paneid).concat(seriesIndex).concat(point.itemIndex).concat(model.type) || '_',
            data: [point],
            properties: {
              attrs: {
                display: ''
              }
            },
            children: [_objectSpread({},

            arrowMark)]


          }
        };
      renderDom(_conversionLineMark.mark, context);
    };

    Registry.setComponent('events.markerhighlighter', Markerhighlighter);

    function getConversionLineConfig() {
      var defaultFormatConf = {
          format: {
            decimalPlaces: 0,
            suffix: '%'
          }
        },
        config = {
          conversionLine: {
            marker: {
              shape: 'arrow-line',
              fillOpacity: 1,
              strokeOpacity: 1,
              strokeWidth: 1,
              strokeColor: 'grey',
              fillColor: 'none',
              x: function x(d, i, args) {
                return -args.bandGap / 2 + args.addExtraBW;
              },
              y: function y(d, i, args) {
                return 0;
              },
              events: {
                enabled: true

              }
            },
            label: {
              x: function x(d, i, args) {
                return -args.bandGap / 2 + args.addExtraBW;
              },
              y: function y(d, i, args) {
                return args.labelPaddingUnit * 20;
              },
              text: function text(values, i, args) {
                var percentCoversion = values.current / values.base * 100;
                return getFormattedValue(defaultFormatConf, percentCoversion, NUMERIC_DATATYPE);
              }
            }
          }
        };
      return config;
    }

    function getConversionMarkerData(data, userConfig, chart) {
      data = data || chart.seriesdata[0].data[0];
      var defaultConfig = getConversionLineConfig(),
        customConfig = userConfig ? invokeFunction(userConfig) : {},
        config = mergeJSON$1(defaultConfig, customConfig, true),
        conversionLine = config.conversionLine,
        marker = conversionLine.marker,label = conversionLine.label,
        axisRotated = chart.axes.rotated,
        axisReverse = chart.systemConf.chart.axes.xaxis.reversed,
        m = axisRotated ? -1 : -1,
        xScale = chart.axes.x.scale,
        yScale = chart.axes.y.groups[0].scale,
        bandwidth = Math.min(xScale.bandwidth(), xScale.maxBandWidth),
        ordinalRange = getOrdinalRange(xScale),
        diffBand = xScale.domain().length > 1 ? mathAbs(ordinalRange[1] - ordinalRange[0]) + m * bandwidth : 0,
        bandGap = axisRotated && !axisReverse ? -diffBand : diffBand,
        percentSpacing = 35,
        spacing = (percentSpacing / 100 * diffBand).toFixed(2),
        isRangeChart = chart.dataObject.noofBarRangeEnabledSeries > 0,
        range = isRangeChart ? 1 : null,
        userArgs = {
          x: xScale,
          y: yScale,
          bandGap: bandGap,
          bandwidth: bandwidth,
          addExtraBW: axisRotated && !axisReverse ? bandwidth : 0,
          padding: spacing,
          labelPaddingUnit: axisRotated ? 1 : -1,
          isRangeChart: isRangeChart
        },
        angle = axisRotated ? axisReverse ? 90 : -90 : axisReverse ? -180 : 0,
        animationOptions = getAnimationConf(
        chart.renderer[0].commonRendererProp().params.commonPlotOptions,
        chart.seriesdata[0].plotoptions,
        chart,
        'bar'),

        x_getter = chart.dataset.getX,
        y_getter = chart.dataset.getY;

      /*
      COMMON INFO
       */
      var display = function display(d, i) {
        if (axisReverse && !axisRotated) {
          return i == d.length - 1 ? 'none' : 'show';
        } else {
          return i == '0' ? 'none' : 'show';
        }
      };

      /*
      CONVERSION MARKER INFO
       */
      var x = function x(d, i) {
          return axisRotated ? marker.y(chart.dataset.getY(d, 0), i, userArgs) : marker.x(chart.dataset.getX(d), i, userArgs);
        },
        y = function y(d, i) {
          return axisRotated ? marker.x(chart.dataset.getX(d), i, userArgs) : marker.y(chart.dataset.getY(d, 0), i, userArgs);
        },
        options = {
          size: diffBand - 2 * spacing,
          shape: marker.shape,
          fillOpacity: marker.fillOpacity,
          strokeOpacity: marker.strokeOpacity,
          strokeWidth: marker.strokeWidth,
          fillColor: marker.fillColor,
          strokeColor: marker.strokeColor || 'black',
          animation: animationOptions,
          angle: angle
        },
        highlightOptions = {
          segment: axisRotated ? 'line' : 'vertical-line'
        };
      var x_label = function x_label(d, i) {
          return axisRotated ? label.y(chart.dataset.getY(d, 0), i, userArgs) : label.x(chart.dataset.getX(d), i, userArgs);
        },
        y_label = function y_label(d, i) {
          return axisRotated ? label.x(chart.dataset.getX(d), i, userArgs) : label.y(chart.dataset.getY(d, 0), i, userArgs);
        },
        styles = applyFont(null, [label, chart.systemConf.chart, chart.systemConf.canvas, $ZCG]),
        formatter = function formatter(d, conf) {
          var current = chart.dataset.getY(d, 0, range),
            previous = conf.cur == 0 ? current : chart.dataset.getY(data[conf.cur - 1], 0, range),
            base = conf.cur == 0 ? current : chart.dataset.getY(data[0], 0, range);

          return label.text({ current: current, previous: previous, base: base }, conf.cur, userArgs);
        };
      styles['text-anchor'] = axisRotated ? 'start' : 'middle';
      var labelInfo = { x: x_label, y: y_label, formatter: formatter, styles: styles };

      /*
      MARKER EVENTS INFO
       */
      var eventsInfo = {};
      var highlighter = new Markerhighlighter(chart, { x: x, y: y, options: options, highlightOptions: highlightOptions });
      highlighter.options({ options: options });
      if (marker.events.enabled) {
        eventsInfo = {
          config: marker.events,
          highlighter: highlighter,
          tooltipContent: function tooltipContent(d, i) {
            var currentX = chart.dataset.getX(d, 0, range),
              previousX = i == 0 ? currentX : chart.dataset.getX(data[i - 1], 0, range),
              nextX = i == data.length - 1 ? currentX : chart.dataset.getX(data[i + 1], 0, range);

            if (axisReverse) {
              return "".concat(currentX, "->").concat(nextX, ": ").concat(formatter(d, i, data));
            }

            return "".concat(previousX, "->").concat(currentX, ": ").concat(formatter(d, i, data));
          }
        };
      }

      var markerInfo = { x: x, y: y, options: options, eventsInfo: eventsInfo };

      //
      // let id = `cLine`;
      // let eventInfo = {
      //     type: MARKER_COMPONENT,
      //     id,
      //     config: {
      //         [id]: data.map((_d, i) => {
      //             let d = [..._d];
      //             d = defaultHash(d, chart, 0, i, MARKER_COMPONENT);
      //             d._data = highlighter.data();
      //             d._dependents = getConversionLineDependents(d, i, data);
      //             return d;
      //         }),
      //         superKey: 'segment',
      //         componentIndex: 0
      //     }
      // };
      // eventInfo.config[id].disabled = d => false;
      // chart.components = [
      //     {
      //         name: 'conversionLine',
      //         events: eventInfo,
      //         markerH: markerInfo,
      //         highlighter
      //     }
      // ];

      return { markerInfo: markerInfo, labelInfo: labelInfo, display: display };
    }

    function getConversionLineDependents(d, i, data) {
      if (i > 0) {
        return {
          from: data[i - 1],
          to: data[i]
        };
      }
      return null;
    }

    //

    function conversionLineParser(notesConfig) {var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var chartObj = arguments.length > 2 ? arguments[2] : undefined;
      // let { markerInfo, labelInfo, display } = conversionLineH;
      var data = notesConfig.data,
        conversionLineH = chartObj.conversionH,
        _data = chartObj.seriesdata[0].data[0];
      // if (!conversionLineH) {
      chartObj.conversionH = conversionLineH = getConversionMarkerData(null, notesConfig.config, chartObj);
      var eventsInfo = conversionLineH.markerInfo.eventsInfo,
        highlighter = eventsInfo.highlighter,tooltipContent = eventsInfo.tooltipContent;
      // }

      var _conversionLineH = conversionLineH,markerInfo = _conversionLineH.markerInfo,labelInfo = _conversionLineH.labelInfo,display = _conversionLineH.display;
      var arrowMark = MarkerParser({
        selection: '.outer',
        data: [data],
        config: _objectSpread({
          x: function x(d, i) {
            return markerInfo.x(d, i);
          },
          y: function y(d, i) {
            return markerInfo.y(d, i);
          } },
        markerInfo.options),

        event: _objectSpread({
          type: 'zc-marker',
          id: 'cLine',
          superKey: 'segment',
          size: markerInfo.options.size * 10 / 2,
          data: function data(_d, chart, xy, parser) {
            // TODO: work
            var d = _toConsumableArray(_d);
            d = defaultHash(d, chart, _d.seriesIndex, _d.itemIndex, 'zc-marker', _d._key);
            d._dependents = {
              from: _data[parser.conf.prev], // TODO: work
              to: _data[parser.conf.cur]
            };

            d._data = function () {
              var point = highlighter.data().call(this);
              point._x = xy[0] - chart.plotarea.left;
              point._y = xy[1] - chart.plotarea.top;
              return point;
            };
            return d;
          },
          highlighter: highlighter,
          tooltipContent: tooltipContent },
        eventsInfo.config || {})

      });
      var _conversionLineMark = {
        mark: {
          mark: 'g',
          selector: '.conversion-line',
          data: [1],
          properties: {
            attrs: {

              // transform: `translate(${chartObj.plotarea.left},${chartObj.plotarea.top})`
            } },
          children: [_objectSpread({},

          arrowMark),

          {
            name: 'label',
            selector: '.conversion-label',
            mark: 'text',
            data: [data],
            properties: {
              text: function text(d, i) {
                return labelInfo.formatter(d, notesConfig);
              },
              attrs: {
                x: function x(d, i) {return labelInfo.x(d, i);},
                y: function y(d, i) {return labelInfo.y(d, i);},
                dy: labelInfo.dy
              },
              styles: _objectSpread({},
              labelInfo.styles)

            }
          }]

        }
      };
      return _conversionLineMark.mark;
    }
    Registry.setComponent('conversionLineParser', conversionLineParser);

    function conversionLineComponent(data, userConfig, chart) {
      var data_c = data[0].data[0], //chart.seriesdata[0].data[0]
        conversionLineH = getConversionMarkerData(data_c, userConfig, chart),
        marks = conversionLineParser(data_c, conversionLineH, chart),
        eventInfo;

      renderDom(marks.mark, chart.staticPaneSVG.selectAll('g.qualitativeGroupHolder'));

      if (conversionLineH.markerInfo.eventsInfo.config.enabled) {var _config11;
        var id = "cLine",
          highlighter = conversionLineH.markerInfo.eventsInfo.highlighter;
        eventInfo = {
          type: MARKER_COMPONENT,
          id: id,
          config: (_config11 = {}, _defineProperty(_config11,
          id, data_c.map(function (_d, i) {
            var d = _toConsumableArray(_d);
            d = defaultHash(d, chart, 0, i, MARKER_COMPONENT);
            d._data = highlighter.data();
            d._dependents = getConversionLineDependents(d, i, data_c);
            return d;
          })), _defineProperty(_config11, "superKey",
          'segment'), _defineProperty(_config11, "componentIndex",
          0), _config11)

        };
        eventInfo.config[id].disabled = function (d) {return false;};
        chart.components = [
        {
          name: 'conversionLine',
          events: eventInfo,
          markerH: conversionLineH.markerInfo,
          highlighter: highlighter
        }];

      }
    }

    Registry.setComponent('conversionLine', conversionLineComponent);

    /*
     * n - selector name
     * v - selector value
     * p - parser
     */
    function _loopParser(n, v, p) {
      var _s;
      for (var _key in p) {
        if (p.hasOwnProperty(_key)) {
          if (_key === n && p[n] === v) {
            return p;
          }
          var _val = p[_key];
          if (isArray$1(_val)) {
            for (var i = 0; i < _val.length; i++) {
              _s = _loopParser(n, v, _val[i]);
              if (_s) {
                return _s;
              }
            }
          }
        }
      }
    }

    /*
     * n - selector name - name,mark,selector
     * v - selector value
     * parser.select - selects the first object with the given details.
     */
    function select(n, v) {var _this46 = this;
      if (isArray$1(n)) {
        this.selection = [];
        n.map(function (d, i) {
          _this46.selection.push(_loopParser(d, v[i], _this46.parser));
        });
      } else {
        this.selection = _loopParser(n, v, this.parser);
      }

      return this;
    }

    /*
     * n - selector name
     * v - selector value
     * p - parser
     */
    function _loopParser$1(n, v, p) {
      var _s = [];
      for (var _key in p) {
        if (p.hasOwnProperty(_key)) {
          if (_key === n && p[n] === v) {
            _s.push(p);
          }
          var _val = p[_key];
          if (isArray$1(_val)) {
            for (var i = 0; i < _val.length; i++) {
              _s = _s.concat(_loopParser$1(n, v, _val[i]));
            }
          }
        }
      }
      return _s;
    }
    /*
     * n - selector name - name,mark,selector
     * v - selector value
     * parser.selectAll - selects all the objects with the given details.
     */
    function selectAll(n, v) {
      this.selection = _loopParser$1(n, v, this.parser);
      return this;
    }

    /*
     * n - selector name
     * v - selector value
     * p - parser
     * isAll - remove all elements with above details or not(bollean)
     */
    function removeLooper(n, v, p, isAll) {
      for (var _key in p) {
        if (p.hasOwnProperty(_key)) {
          if (_key === n && p[n] === v) {
            return null;
          }
          var _val = p[_key];
          if (isArray$1(_val)) {
            for (var i = 0; i < _val.length; i++) {
              if (removeLooper.call(this, n, v, _val[i]) === null) {
                this.selection = this.selection.concat(_val.splice(i, 1));
                if (isAll) {
                  i--;
                } else {
                  return;
                }
              }
            }
          }
        }
      }
    }
    /*
     * n - selector name - name, mark, selector
     * v - selector value
     * parser.removeAll - everytime it parses the entire parser to remove elements
     * even if selection.removeAll performed, entire parser will be parsed to remove
     */
    function remove(n, v) {var _this47 = this;
      this.selection = [];
      var _n = isArray$1(n) ? n : [n],
        _v = isArray$1(v) ? v : [v],
        _;

      _n.map(function (d, i) {
        _ = removeLooper.call(_this47, d, _v[i], _this47.parser);
      });
      _ === null ? (this.selection.push(this.parser), this.parser = {}) : 'none';

      return this;
    }

    /*
     * n - selector name - name, mark, selector
     * v - selector value
     * parser.removeAll - everytime it parses the entire parser to remove elements
     * even if selection.removeAll performed, entire parser will be parsed to remove
     */
    function removeAll(n, v) {var _this48 = this;
      this.selection = [];
      var _n = isArray$1(n) ? n : [n],
        _v = isArray$1(v) ? v : [v],
        _;

      _n.map(function (d, i) {
        _ = removeLooper.call(_this48, d, _v[i], _this48.parser, true);
      });
      _ === null ? (this.selection.push(this.parser), this.parser = {}) : 'none';

      return this;
    }

    /*
     * e - element to be appended
     * selection.append - appends element to the selection
     */

    function append(e) {
      var s = this.selection,
        _s = isArray$1(s) ? s : [s],
        _e = isArray$1(e) ? e : [e];

      _s.map(function (d, i) {
        _concat(_e, d);
      });
      return this;
    }

    function _concat(_e, _d) {
      _d.children = _d.children ? _d.children.concat(_e) : _e;
    }

    /*
     * e - element to be inserted
     * p - position to be inserted
     * s - selection
     * selection.insert - inserts elements into the selection
     */
    function insert(e, p) {
      var s = this.selection,
        _s = isArray$1(s) ? s : [s],
        _e = isArray$1(e) ? e : [e],
        _p = isArray$1(p) ? p : [p];

      _s.map(function (d, i) {
        _splice(_e, _p, d);
      });
      return this;
    }

    /*
     * _e - element to be insertes.
     * _p - position where _e has to be inserted.
     * s - selection in which insertion occures.
     */

    function _splice(_e, _p, s) {
      _e.map(function (d, i) {
        var c = s.children;
        if (!c) {
          s.children = [_e[i]];
        } else {
          var spliceIdx = !defined(_p[i]) ? c.length : _p[i];
          c.splice(spliceIdx, 0, d);
        }
      });
    }

    /*
     * selection.each - executes the function passed for each selection
     */
    function each$1(callback) {var _this49 = this;
      var s = this.selection;
      var _s = isArray$1(s) ? s : [s];
      s.map(function (d, i) {
        callback.call(_this49, d, i);
      });
    }

    /*
     * n - property name to be chnaged in the selection
     * v - value of the property
     * selection.set - sets the property with the given value in the selection
     */

    function set$1(n, v) {
      var s = this.selection;

      var _s = isArray$1(s) ? s : [s];
      for (var i = 0; i < _s.length; i++) {
        _.call(this, _s[i], n, v);
      }
      return this;
    }
    function _(_s, n, v) {var _this50 = this;
      var _n = isArray$1(n) ? n : [n],
        _v = isArray$1(v) ? v : [v];

      _n.map(function (d, i) {
        var _d = d.split('.');
        setProp.call(_this50, _s, _d, _v[i]);
      });
    }

    /*
     * _o - object in which the property given has to be changed
     * n - property name
     * v - property value
     */

    //this function setPropVal is made used by set,attr,style,config methods
    function setProp(_o, n, v) {
      var i = -1;
      _.call(this, _o);
      function _(_o) {
        i++;
        if (i === n.length - 1) {
          var _n = n[i];
          if (defined(v)) {
            _o[_n] = v;
          }
          if (v === null) {
            delete _o[_n];
            return;
          }
          return;
        }
        _o[n[i]] = _o[n[i]] ? _o[n[i]] : {};
        _.call(this, _o[n[i]]);
      }
    }

    /*
     * n - attribute name to be modified
     * v - attribute value to be assigned
     * s - selection
     * selection.attr - modifies the given attribute with the given value
     */
    function attr(n, v) {
      var s = this.selection;

      var _s = isArray$1(s) ? s : [s];
      for (var i = 0; i < _s.length; i++) {
        _$1.call(this, _s[i], n, v);
      }
      return this;
    }
    function _$1(_s, n, v) {var _this51 = this;
      var p = _s.properties,
        _n = isArray$1(n) ? n : [n],
        _v = isArray$1(v) ? v : [v];

      p = _s.properties = p ? p : {};
      var a = p.attrs;
      a = p.attrs = a ? a : {};

      _n.map(function (d, i) {
        setProp.call(_this51, a, [d], _v[i]);
      });
    }

    /*
     * a - attribute object
     */
    function attrs(a) {
      var s = this.selection;
      if (isArray$1(s)) {
        for (var i = 0; i < s.length; i++) {
          var p = s[i].properties;
          p = s[i].properties = p ? p : {};
          p.attrs = a;
        }
      } else {
        var p = s.properties;
        p = s.properties = p ? p : {};
        p.attrs = a;
      }
      return this;
    }

    /*
     * n - name of the style
     * v - value of the style
     * s - selection
     * selection.style - helps to set the given style to the selection
     */
    function style(n, v) {
      var s = this.selection,
        _s = isArray$1(s) ? s : [s];

      for (var i = 0; i < _s.length; i++) {
        _$2.call(this, _s[i], n, v);
      }
      return this;
    }
    function _$2(_s, n, v) {var _this52 = this;
      var p = _s.properties,
        _n = isArray$1(n) ? n : [n],
        _v = isArray$1(v) ? v : [v];

      p = _s.properties = p ? p : {};
      var s = p.styles;
      s = p.styles = s ? s : {};

      _n.map(function (d, i) {
        setProp.call(_this52, s, [d], _v[i]);
      });
    }

    /*
     * _s - style object
     * selection.styles -assigns the entire _s object directly
     */
    function styles(a) {
      var s = this.selection;
      if (isArray$1(s)) {
        for (var i = 0; i < s.length; i++) {
          var p = s[i].properties;
          p = s[i].properties = p ? p : {};
          p.styles = a;
        }
      } else {
        var p = s.properties;
        p = s.properties = p ? p : {};
        p.styles = a;
      }
      return this;
    }

    /*
     * _d - data
     * _dA - dataAccessor
     * selection.data - changes data in the given selection
     */
    function data(_d, _dA) {
      var s = this.selection;

      var _s = isArray$1(s) ? s : [s];
      for (var i = 0; i < _s.length; i++) {
        _s[i].data = _d;
        _s[i].dataAccessor = _dA;
      }
      return this;
    }

    /*
     * n - property name to be collected fron selection
     * n can be passed in this format also - properties.styles.stroke, so we do split at first
     * selection.get - collects the passed property
     */


    function get$1(n) {
      var s = this.selection;
      var _g = [];
      var _n = isArray$1(n) ? n : [n];
      _n.map(function (d) {
        var _d = d.split('.');
        if (isArray$1(s)) {
          for (var i = 0; i < s.length; i++) {
            _g.push(getPropVal$1(s[i], _d));
          }
        } else {
          _g.push(getPropVal$1(s, _d));
        }
      });
      return _g;
    }

    /*
     * _n - property to be collected
     * _s - selection from which _n will be collected
     */
    function getPropVal$1(_s, _n) {
      var i = 0;
      return _(_s);
      function _(_s) {
        if (i === _n.length - 1) {
          return _s[_n[i]];
        }
        return _(_s[_n[i++]]);
      }
    }

    /*
     * n - attribute name to be modified
     * v - attribute value to be assigned
     * s - selection
     * selection.config - modifies the given config with the given value
     */
    function config(n, v) {
      var s = this.selection;

      var _s = isArray$1(s) ? s : [s];
      for (var i = 0; i < _s.length; i++) {
        _$3.call(this, _s[i], n, v);
      }
      return this;
    }
    function _$3(_s, n, v) {var _this53 = this;
      var c = _s.config,
        _n = isArray$1(n) ? n : [n],
        _v = isArray$1(v) ? v : [v];

      c = _s.config = c ? c : {};
      _n.map(function (d, i) {
        setProp.call(_this53, c, [d], _v[i]);
      });
    }

    function markSelection(parser) {
      this.parser = _objectSpread({}, parser);
    }

    markSelection.prototype.select = select;
    markSelection.prototype.selectAll = selectAll;
    markSelection.prototype.remove = remove;
    markSelection.prototype.removeAll = removeAll;
    markSelection.prototype.append = append;
    markSelection.prototype.insert = insert;
    markSelection.prototype.each = each$1;
    markSelection.prototype.attr = attr;
    markSelection.prototype.attrs = attrs;
    markSelection.prototype.style = style;
    markSelection.prototype.styles = styles;
    markSelection.prototype.data = data;
    markSelection.prototype.get = get$1;
    markSelection.prototype.set = set$1;
    markSelection.prototype.config = config;

    MarksRegistry.add('markSelection', markSelection);

    //versions and chart types

    exports.version = version;
    exports.versionName = versionName;
    exports.d3Version = d3Version;
    exports.chartcategory = chartcategory;
    exports.charttypenames = charttypenames;
    exports.charttype = charttype;
    exports.setTheme = setTheme;
    exports.getTheme = getTheme;
    exports.rename = rename;
    exports.tempCanvasContext = tempCanvasContext;
    exports.scale = scale;
    exports.requireXDataSorting = requireXDataSorting;
    exports.imageFilePath = imageFilePath;
    exports.dataEncoded = dataEncoded;
    exports.setGlobalPropByUserdata = setGlobalPropByUserdata;
    exports.createHelperElements = createHelperElements;
    exports.getComponent = getComponent;
    exports.get = get;
    exports.set = set;
    exports.setComponent = setComponent;
    exports.getDefaultOptions = getDefaultOptions;
    exports.setDefaultOptions = setDefaultOptions;
    exports.setGlobalPatternSVG = setGlobalPatternSVG;
    exports.utils = utils;
    exports.appendElement = appendEle;
    exports.getRawColor = getRawColor;
    exports.CHART_DOMAIN_HELPERS = CHART_DOMAIN_HELPERS;
    exports.charts = charts;
    exports.maps = maps;
    exports.setLegendColorPallete = setLegendColorPallete;
    exports.getLegendColorPallete = getLegendColorPallete;
    exports.setLegendPatternPallete = setLegendPatternPallete;
    exports.getLegendPatternPallete = getLegendPatternPallete;
    exports.setLegendImagePallete = setLegendImagePallete;
    exports.getLegendImagePallete = getLegendImagePallete;
    exports.annotation = annotation;
    exports.BrushD3 = BrushD3;
    exports._legendSizeSliderBrushD3 = BrushD3;
    exports.setCustomBrushHandle = setCustomBrushHandle;
    exports.tickFilterMap = tickFilterMap;
    exports.effects = effects;
    exports.addPattern = addPattern;
    exports.getPattern = getPattern;
    exports.PlotHighlighter = PlotHighlighter;
    exports.setPlotDefaultBehaviour = setPlotDefaultBehaviour;
    exports.getPlotDefaultBehaviour = getPlotDefaultBehaviour;
    exports.getFormattedValue = getFormattedValue;
    exports.generateFormatSpecifier = generateFormatSpecifier;
    exports.setLocale = setLocale;
    exports.legendHighlight = legendHighlight;
    exports.getTooltipPosition = getTooltipPosition;
    exports.mapCollections = mapCollections;
    exports.sankey = Sankey;
    exports.sankeyCenter = center;
    exports.sankeyJustify = justify;
    exports.sankeyLeft = left;
    exports.sankeyRight = right;

    Object.defineProperty(exports, '__esModule', { value: true });

  });});
